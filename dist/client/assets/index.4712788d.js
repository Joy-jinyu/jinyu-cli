function _mergeNamespaces(n2, m2) {
  m2.forEach(function(e3) {
    e3 && typeof e3 !== "string" && !Array.isArray(e3) && Object.keys(e3).forEach(function(k2) {
      if (k2 !== "default" && !(k2 in n2)) {
        var d2 = Object.getOwnPropertyDescriptor(e3, k2);
        Object.defineProperty(n2, k2, d2.get ? d2 : {
          enumerable: true,
          get: function() {
            return e3[k2];
          }
        });
      }
    });
  });
  return Object.freeze(Object.defineProperty(n2, Symbol.toStringTag, { value: "Module" }));
}
var Shape$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get Base() {
    return ShapeBase$3;
  },
  get Circle() {
    return Circle$4;
  },
  get Ellipse() {
    return Ellipse$3;
  },
  get Image() {
    return ImageShape$1;
  },
  get Line() {
    return Line$6;
  },
  get Marker() {
    return Marker$3;
  },
  get Path() {
    return Path$4;
  },
  get Polygon() {
    return Polygon$4;
  },
  get Polyline() {
    return PolyLine$1;
  },
  get Rect() {
    return Rect$4;
  },
  get Text() {
    return Text$3;
  }
}, Symbol.toStringTag, { value: "Module" }));
var Shape = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get Base() {
    return ShapeBase$1;
  },
  get Circle() {
    return Circle$2;
  },
  get Dom() {
    return Dom$1;
  },
  get Ellipse() {
    return Ellipse$1;
  },
  get Image() {
    return Image$2;
  },
  get Line() {
    return Line$4;
  },
  get Marker() {
    return Marker$1;
  },
  get Path() {
    return Path$2;
  },
  get Polygon() {
    return Polygon$2;
  },
  get Polyline() {
    return Polyline$1;
  },
  get Rect() {
    return Rect$2;
  },
  get Text() {
    return Text$1;
  }
}, Symbol.toStringTag, { value: "Module" }));
const p$7 = function polyfill() {
  const relList = document.createElement("link").relList;
  if (relList && relList.supports && relList.supports("modulepreload")) {
    return;
  }
  for (const link of document.querySelectorAll('link[rel="modulepreload"]')) {
    processPreload(link);
  }
  new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type !== "childList") {
        continue;
      }
      for (const node of mutation.addedNodes) {
        if (node.tagName === "LINK" && node.rel === "modulepreload")
          processPreload(node);
      }
    }
  }).observe(document, { childList: true, subtree: true });
  function getFetchOpts(script) {
    const fetchOpts = {};
    if (script.integrity)
      fetchOpts.integrity = script.integrity;
    if (script.referrerpolicy)
      fetchOpts.referrerPolicy = script.referrerpolicy;
    if (script.crossorigin === "use-credentials")
      fetchOpts.credentials = "include";
    else if (script.crossorigin === "anonymous")
      fetchOpts.credentials = "omit";
    else
      fetchOpts.credentials = "same-origin";
    return fetchOpts;
  }
  function processPreload(link) {
    if (link.ep)
      return;
    link.ep = true;
    const fetchOpts = getFetchOpts(link);
    fetch(link.href, fetchOpts);
  }
};
p$7();
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
var reactDom = { exports: {} };
var reactDom_production_min = {};
var react = { exports: {} };
var react_production_min = {};
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty$d = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;
function toObject(val) {
  if (val === null || val === void 0) {
    throw new TypeError("Object.assign cannot be called with null or undefined");
  }
  return Object(val);
}
function shouldUseNative() {
  try {
    if (!Object.assign) {
      return false;
    }
    var test1 = new String("abc");
    test1[5] = "de";
    if (Object.getOwnPropertyNames(test1)[0] === "5") {
      return false;
    }
    var test2 = {};
    for (var i2 = 0; i2 < 10; i2++) {
      test2["_" + String.fromCharCode(i2)] = i2;
    }
    var order2 = Object.getOwnPropertyNames(test2).map(function(n2) {
      return test2[n2];
    });
    if (order2.join("") !== "0123456789") {
      return false;
    }
    var test3 = {};
    "abcdefghijklmnopqrst".split("").forEach(function(letter) {
      test3[letter] = letter;
    });
    if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
      return false;
    }
    return true;
  } catch (err) {
    return false;
  }
}
var objectAssign = shouldUseNative() ? Object.assign : function(target, source) {
  var from;
  var to = toObject(target);
  var symbols;
  for (var s2 = 1; s2 < arguments.length; s2++) {
    from = Object(arguments[s2]);
    for (var key2 in from) {
      if (hasOwnProperty$d.call(from, key2)) {
        to[key2] = from[key2];
      }
    }
    if (getOwnPropertySymbols) {
      symbols = getOwnPropertySymbols(from);
      for (var i2 = 0; i2 < symbols.length; i2++) {
        if (propIsEnumerable.call(from, symbols[i2])) {
          to[symbols[i2]] = from[symbols[i2]];
        }
      }
    }
  }
  return to;
};
/** @license React v17.0.2
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var l$4 = objectAssign, n$6 = 60103, p$6 = 60106;
react_production_min.Fragment = 60107;
react_production_min.StrictMode = 60108;
react_production_min.Profiler = 60114;
var q$6 = 60109, r$5 = 60110, t$5 = 60112;
react_production_min.Suspense = 60113;
var u$4 = 60115, v$4 = 60116;
if ("function" === typeof Symbol && Symbol.for) {
  var w$3 = Symbol.for;
  n$6 = w$3("react.element");
  p$6 = w$3("react.portal");
  react_production_min.Fragment = w$3("react.fragment");
  react_production_min.StrictMode = w$3("react.strict_mode");
  react_production_min.Profiler = w$3("react.profiler");
  q$6 = w$3("react.provider");
  r$5 = w$3("react.context");
  t$5 = w$3("react.forward_ref");
  react_production_min.Suspense = w$3("react.suspense");
  u$4 = w$3("react.memo");
  v$4 = w$3("react.lazy");
}
var x$2 = "function" === typeof Symbol && Symbol.iterator;
function y$3(a2) {
  if (null === a2 || "object" !== typeof a2)
    return null;
  a2 = x$2 && a2[x$2] || a2["@@iterator"];
  return "function" === typeof a2 ? a2 : null;
}
function z$2(a2) {
  for (var b10 = "https://reactjs.org/docs/error-decoder.html?invariant=" + a2, c2 = 1; c2 < arguments.length; c2++)
    b10 += "&args[]=" + encodeURIComponent(arguments[c2]);
  return "Minified React error #" + a2 + "; visit " + b10 + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
}
var A$2 = { isMounted: function() {
  return false;
}, enqueueForceUpdate: function() {
}, enqueueReplaceState: function() {
}, enqueueSetState: function() {
} }, B$2 = {};
function C(a2, b10, c2) {
  this.props = a2;
  this.context = b10;
  this.refs = B$2;
  this.updater = c2 || A$2;
}
C.prototype.isReactComponent = {};
C.prototype.setState = function(a2, b10) {
  if ("object" !== typeof a2 && "function" !== typeof a2 && null != a2)
    throw Error(z$2(85));
  this.updater.enqueueSetState(this, a2, b10, "setState");
};
C.prototype.forceUpdate = function(a2) {
  this.updater.enqueueForceUpdate(this, a2, "forceUpdate");
};
function D$2() {
}
D$2.prototype = C.prototype;
function E$2(a2, b10, c2) {
  this.props = a2;
  this.context = b10;
  this.refs = B$2;
  this.updater = c2 || A$2;
}
var F$2 = E$2.prototype = new D$2();
F$2.constructor = E$2;
l$4(F$2, C.prototype);
F$2.isPureReactComponent = true;
var G$2 = { current: null }, H$2 = Object.prototype.hasOwnProperty, I$2 = { key: true, ref: true, __self: true, __source: true };
function J(a2, b10, c2) {
  var e3, d2 = {}, k2 = null, h2 = null;
  if (null != b10)
    for (e3 in void 0 !== b10.ref && (h2 = b10.ref), void 0 !== b10.key && (k2 = "" + b10.key), b10)
      H$2.call(b10, e3) && !I$2.hasOwnProperty(e3) && (d2[e3] = b10[e3]);
  var g2 = arguments.length - 2;
  if (1 === g2)
    d2.children = c2;
  else if (1 < g2) {
    for (var f2 = Array(g2), m2 = 0; m2 < g2; m2++)
      f2[m2] = arguments[m2 + 2];
    d2.children = f2;
  }
  if (a2 && a2.defaultProps)
    for (e3 in g2 = a2.defaultProps, g2)
      void 0 === d2[e3] && (d2[e3] = g2[e3]);
  return { $$typeof: n$6, type: a2, key: k2, ref: h2, props: d2, _owner: G$2.current };
}
function K(a2, b10) {
  return { $$typeof: n$6, type: a2.type, key: b10, ref: a2.ref, props: a2.props, _owner: a2._owner };
}
function L$1(a2) {
  return "object" === typeof a2 && null !== a2 && a2.$$typeof === n$6;
}
function escape(a2) {
  var b10 = { "=": "=0", ":": "=2" };
  return "$" + a2.replace(/[=:]/g, function(a3) {
    return b10[a3];
  });
}
var M$2 = /\/+/g;
function N$2(a2, b10) {
  return "object" === typeof a2 && null !== a2 && null != a2.key ? escape("" + a2.key) : b10.toString(36);
}
function O$2(a2, b10, c2, e3, d2) {
  var k2 = typeof a2;
  if ("undefined" === k2 || "boolean" === k2)
    a2 = null;
  var h2 = false;
  if (null === a2)
    h2 = true;
  else
    switch (k2) {
      case "string":
      case "number":
        h2 = true;
        break;
      case "object":
        switch (a2.$$typeof) {
          case n$6:
          case p$6:
            h2 = true;
        }
    }
  if (h2)
    return h2 = a2, d2 = d2(h2), a2 = "" === e3 ? "." + N$2(h2, 0) : e3, Array.isArray(d2) ? (c2 = "", null != a2 && (c2 = a2.replace(M$2, "$&/") + "/"), O$2(d2, b10, c2, "", function(a3) {
      return a3;
    })) : null != d2 && (L$1(d2) && (d2 = K(d2, c2 + (!d2.key || h2 && h2.key === d2.key ? "" : ("" + d2.key).replace(M$2, "$&/") + "/") + a2)), b10.push(d2)), 1;
  h2 = 0;
  e3 = "" === e3 ? "." : e3 + ":";
  if (Array.isArray(a2))
    for (var g2 = 0; g2 < a2.length; g2++) {
      k2 = a2[g2];
      var f2 = e3 + N$2(k2, g2);
      h2 += O$2(k2, b10, c2, f2, d2);
    }
  else if (f2 = y$3(a2), "function" === typeof f2)
    for (a2 = f2.call(a2), g2 = 0; !(k2 = a2.next()).done; )
      k2 = k2.value, f2 = e3 + N$2(k2, g2++), h2 += O$2(k2, b10, c2, f2, d2);
  else if ("object" === k2)
    throw b10 = "" + a2, Error(z$2(31, "[object Object]" === b10 ? "object with keys {" + Object.keys(a2).join(", ") + "}" : b10));
  return h2;
}
function P$2(a2, b10, c2) {
  if (null == a2)
    return a2;
  var e3 = [], d2 = 0;
  O$2(a2, e3, "", "", function(a3) {
    return b10.call(c2, a3, d2++);
  });
  return e3;
}
function Q$1(a2) {
  if (-1 === a2._status) {
    var b10 = a2._result;
    b10 = b10();
    a2._status = 0;
    a2._result = b10;
    b10.then(function(b11) {
      0 === a2._status && (b11 = b11.default, a2._status = 1, a2._result = b11);
    }, function(b11) {
      0 === a2._status && (a2._status = 2, a2._result = b11);
    });
  }
  if (1 === a2._status)
    return a2._result;
  throw a2._result;
}
var R$2 = { current: null };
function S$2() {
  var a2 = R$2.current;
  if (null === a2)
    throw Error(z$2(321));
  return a2;
}
var T$1 = { ReactCurrentDispatcher: R$2, ReactCurrentBatchConfig: { transition: 0 }, ReactCurrentOwner: G$2, IsSomeRendererActing: { current: false }, assign: l$4 };
react_production_min.Children = { map: P$2, forEach: function(a2, b10, c2) {
  P$2(a2, function() {
    b10.apply(this, arguments);
  }, c2);
}, count: function(a2) {
  var b10 = 0;
  P$2(a2, function() {
    b10++;
  });
  return b10;
}, toArray: function(a2) {
  return P$2(a2, function(a3) {
    return a3;
  }) || [];
}, only: function(a2) {
  if (!L$1(a2))
    throw Error(z$2(143));
  return a2;
} };
react_production_min.Component = C;
react_production_min.PureComponent = E$2;
react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = T$1;
react_production_min.cloneElement = function(a2, b10, c2) {
  if (null === a2 || void 0 === a2)
    throw Error(z$2(267, a2));
  var e3 = l$4({}, a2.props), d2 = a2.key, k2 = a2.ref, h2 = a2._owner;
  if (null != b10) {
    void 0 !== b10.ref && (k2 = b10.ref, h2 = G$2.current);
    void 0 !== b10.key && (d2 = "" + b10.key);
    if (a2.type && a2.type.defaultProps)
      var g2 = a2.type.defaultProps;
    for (f2 in b10)
      H$2.call(b10, f2) && !I$2.hasOwnProperty(f2) && (e3[f2] = void 0 === b10[f2] && void 0 !== g2 ? g2[f2] : b10[f2]);
  }
  var f2 = arguments.length - 2;
  if (1 === f2)
    e3.children = c2;
  else if (1 < f2) {
    g2 = Array(f2);
    for (var m2 = 0; m2 < f2; m2++)
      g2[m2] = arguments[m2 + 2];
    e3.children = g2;
  }
  return {
    $$typeof: n$6,
    type: a2.type,
    key: d2,
    ref: k2,
    props: e3,
    _owner: h2
  };
};
react_production_min.createContext = function(a2, b10) {
  void 0 === b10 && (b10 = null);
  a2 = { $$typeof: r$5, _calculateChangedBits: b10, _currentValue: a2, _currentValue2: a2, _threadCount: 0, Provider: null, Consumer: null };
  a2.Provider = { $$typeof: q$6, _context: a2 };
  return a2.Consumer = a2;
};
react_production_min.createElement = J;
react_production_min.createFactory = function(a2) {
  var b10 = J.bind(null, a2);
  b10.type = a2;
  return b10;
};
react_production_min.createRef = function() {
  return { current: null };
};
react_production_min.forwardRef = function(a2) {
  return { $$typeof: t$5, render: a2 };
};
react_production_min.isValidElement = L$1;
react_production_min.lazy = function(a2) {
  return { $$typeof: v$4, _payload: { _status: -1, _result: a2 }, _init: Q$1 };
};
react_production_min.memo = function(a2, b10) {
  return { $$typeof: u$4, type: a2, compare: void 0 === b10 ? null : b10 };
};
react_production_min.useCallback = function(a2, b10) {
  return S$2().useCallback(a2, b10);
};
react_production_min.useContext = function(a2, b10) {
  return S$2().useContext(a2, b10);
};
react_production_min.useDebugValue = function() {
};
react_production_min.useEffect = function(a2, b10) {
  return S$2().useEffect(a2, b10);
};
react_production_min.useImperativeHandle = function(a2, b10, c2) {
  return S$2().useImperativeHandle(a2, b10, c2);
};
react_production_min.useLayoutEffect = function(a2, b10) {
  return S$2().useLayoutEffect(a2, b10);
};
react_production_min.useMemo = function(a2, b10) {
  return S$2().useMemo(a2, b10);
};
react_production_min.useReducer = function(a2, b10, c2) {
  return S$2().useReducer(a2, b10, c2);
};
react_production_min.useRef = function(a2) {
  return S$2().useRef(a2);
};
react_production_min.useState = function(a2) {
  return S$2().useState(a2);
};
react_production_min.version = "17.0.2";
{
  react.exports = react_production_min;
}
var React = react.exports;
var React$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  "default": React
}, [react.exports]);
var scheduler = { exports: {} };
var scheduler_production_min = {};
/** @license React v0.20.2
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function(exports) {
  var f2, g2, h2, k2;
  if ("object" === typeof performance && "function" === typeof performance.now) {
    var l2 = performance;
    exports.unstable_now = function() {
      return l2.now();
    };
  } else {
    var p2 = Date, q2 = p2.now();
    exports.unstable_now = function() {
      return p2.now() - q2;
    };
  }
  if ("undefined" === typeof window || "function" !== typeof MessageChannel) {
    var t2 = null, u2 = null, w2 = function() {
      if (null !== t2)
        try {
          var a2 = exports.unstable_now();
          t2(true, a2);
          t2 = null;
        } catch (b10) {
          throw setTimeout(w2, 0), b10;
        }
    };
    f2 = function(a2) {
      null !== t2 ? setTimeout(f2, 0, a2) : (t2 = a2, setTimeout(w2, 0));
    };
    g2 = function(a2, b10) {
      u2 = setTimeout(a2, b10);
    };
    h2 = function() {
      clearTimeout(u2);
    };
    exports.unstable_shouldYield = function() {
      return false;
    };
    k2 = exports.unstable_forceFrameRate = function() {
    };
  } else {
    var x2 = window.setTimeout, y2 = window.clearTimeout;
    if ("undefined" !== typeof console) {
      var z2 = window.cancelAnimationFrame;
      "function" !== typeof window.requestAnimationFrame && console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills");
      "function" !== typeof z2 && console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills");
    }
    var A2 = false, B2 = null, C2 = -1, D2 = 5, E2 = 0;
    exports.unstable_shouldYield = function() {
      return exports.unstable_now() >= E2;
    };
    k2 = function() {
    };
    exports.unstable_forceFrameRate = function(a2) {
      0 > a2 || 125 < a2 ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : D2 = 0 < a2 ? Math.floor(1e3 / a2) : 5;
    };
    var F2 = new MessageChannel(), G2 = F2.port2;
    F2.port1.onmessage = function() {
      if (null !== B2) {
        var a2 = exports.unstable_now();
        E2 = a2 + D2;
        try {
          B2(true, a2) ? G2.postMessage(null) : (A2 = false, B2 = null);
        } catch (b10) {
          throw G2.postMessage(null), b10;
        }
      } else
        A2 = false;
    };
    f2 = function(a2) {
      B2 = a2;
      A2 || (A2 = true, G2.postMessage(null));
    };
    g2 = function(a2, b10) {
      C2 = x2(function() {
        a2(exports.unstable_now());
      }, b10);
    };
    h2 = function() {
      y2(C2);
      C2 = -1;
    };
  }
  function H2(a2, b10) {
    var c2 = a2.length;
    a2.push(b10);
    a:
      for (; ; ) {
        var d2 = c2 - 1 >>> 1, e3 = a2[d2];
        if (void 0 !== e3 && 0 < I2(e3, b10))
          a2[d2] = b10, a2[c2] = e3, c2 = d2;
        else
          break a;
      }
  }
  function J2(a2) {
    a2 = a2[0];
    return void 0 === a2 ? null : a2;
  }
  function K2(a2) {
    var b10 = a2[0];
    if (void 0 !== b10) {
      var c2 = a2.pop();
      if (c2 !== b10) {
        a2[0] = c2;
        a:
          for (var d2 = 0, e3 = a2.length; d2 < e3; ) {
            var m2 = 2 * (d2 + 1) - 1, n2 = a2[m2], v2 = m2 + 1, r2 = a2[v2];
            if (void 0 !== n2 && 0 > I2(n2, c2))
              void 0 !== r2 && 0 > I2(r2, n2) ? (a2[d2] = r2, a2[v2] = c2, d2 = v2) : (a2[d2] = n2, a2[m2] = c2, d2 = m2);
            else if (void 0 !== r2 && 0 > I2(r2, c2))
              a2[d2] = r2, a2[v2] = c2, d2 = v2;
            else
              break a;
          }
      }
      return b10;
    }
    return null;
  }
  function I2(a2, b10) {
    var c2 = a2.sortIndex - b10.sortIndex;
    return 0 !== c2 ? c2 : a2.id - b10.id;
  }
  var L2 = [], M2 = [], N2 = 1, O2 = null, P2 = 3, Q2 = false, R2 = false, S2 = false;
  function T2(a2) {
    for (var b10 = J2(M2); null !== b10; ) {
      if (null === b10.callback)
        K2(M2);
      else if (b10.startTime <= a2)
        K2(M2), b10.sortIndex = b10.expirationTime, H2(L2, b10);
      else
        break;
      b10 = J2(M2);
    }
  }
  function U2(a2) {
    S2 = false;
    T2(a2);
    if (!R2)
      if (null !== J2(L2))
        R2 = true, f2(V2);
      else {
        var b10 = J2(M2);
        null !== b10 && g2(U2, b10.startTime - a2);
      }
  }
  function V2(a2, b10) {
    R2 = false;
    S2 && (S2 = false, h2());
    Q2 = true;
    var c2 = P2;
    try {
      T2(b10);
      for (O2 = J2(L2); null !== O2 && (!(O2.expirationTime > b10) || a2 && !exports.unstable_shouldYield()); ) {
        var d2 = O2.callback;
        if ("function" === typeof d2) {
          O2.callback = null;
          P2 = O2.priorityLevel;
          var e3 = d2(O2.expirationTime <= b10);
          b10 = exports.unstable_now();
          "function" === typeof e3 ? O2.callback = e3 : O2 === J2(L2) && K2(L2);
          T2(b10);
        } else
          K2(L2);
        O2 = J2(L2);
      }
      if (null !== O2)
        var m2 = true;
      else {
        var n2 = J2(M2);
        null !== n2 && g2(U2, n2.startTime - b10);
        m2 = false;
      }
      return m2;
    } finally {
      O2 = null, P2 = c2, Q2 = false;
    }
  }
  var W2 = k2;
  exports.unstable_IdlePriority = 5;
  exports.unstable_ImmediatePriority = 1;
  exports.unstable_LowPriority = 4;
  exports.unstable_NormalPriority = 3;
  exports.unstable_Profiling = null;
  exports.unstable_UserBlockingPriority = 2;
  exports.unstable_cancelCallback = function(a2) {
    a2.callback = null;
  };
  exports.unstable_continueExecution = function() {
    R2 || Q2 || (R2 = true, f2(V2));
  };
  exports.unstable_getCurrentPriorityLevel = function() {
    return P2;
  };
  exports.unstable_getFirstCallbackNode = function() {
    return J2(L2);
  };
  exports.unstable_next = function(a2) {
    switch (P2) {
      case 1:
      case 2:
      case 3:
        var b10 = 3;
        break;
      default:
        b10 = P2;
    }
    var c2 = P2;
    P2 = b10;
    try {
      return a2();
    } finally {
      P2 = c2;
    }
  };
  exports.unstable_pauseExecution = function() {
  };
  exports.unstable_requestPaint = W2;
  exports.unstable_runWithPriority = function(a2, b10) {
    switch (a2) {
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
        break;
      default:
        a2 = 3;
    }
    var c2 = P2;
    P2 = a2;
    try {
      return b10();
    } finally {
      P2 = c2;
    }
  };
  exports.unstable_scheduleCallback = function(a2, b10, c2) {
    var d2 = exports.unstable_now();
    "object" === typeof c2 && null !== c2 ? (c2 = c2.delay, c2 = "number" === typeof c2 && 0 < c2 ? d2 + c2 : d2) : c2 = d2;
    switch (a2) {
      case 1:
        var e3 = -1;
        break;
      case 2:
        e3 = 250;
        break;
      case 5:
        e3 = 1073741823;
        break;
      case 4:
        e3 = 1e4;
        break;
      default:
        e3 = 5e3;
    }
    e3 = c2 + e3;
    a2 = { id: N2++, callback: b10, priorityLevel: a2, startTime: c2, expirationTime: e3, sortIndex: -1 };
    c2 > d2 ? (a2.sortIndex = c2, H2(M2, a2), null === J2(L2) && a2 === J2(M2) && (S2 ? h2() : S2 = true, g2(U2, c2 - d2))) : (a2.sortIndex = e3, H2(L2, a2), R2 || Q2 || (R2 = true, f2(V2)));
    return a2;
  };
  exports.unstable_wrapCallback = function(a2) {
    var b10 = P2;
    return function() {
      var c2 = P2;
      P2 = b10;
      try {
        return a2.apply(this, arguments);
      } finally {
        P2 = c2;
      }
    };
  };
})(scheduler_production_min);
{
  scheduler.exports = scheduler_production_min;
}
/** @license React v17.0.2
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var aa = react.exports, m$5 = objectAssign, r$4 = scheduler.exports;
function y$2(a2) {
  for (var b10 = "https://reactjs.org/docs/error-decoder.html?invariant=" + a2, c2 = 1; c2 < arguments.length; c2++)
    b10 += "&args[]=" + encodeURIComponent(arguments[c2]);
  return "Minified React error #" + a2 + "; visit " + b10 + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
}
if (!aa)
  throw Error(y$2(227));
var ba = /* @__PURE__ */ new Set(), ca = {};
function da(a2, b10) {
  ea(a2, b10);
  ea(a2 + "Capture", b10);
}
function ea(a2, b10) {
  ca[a2] = b10;
  for (a2 = 0; a2 < b10.length; a2++)
    ba.add(b10[a2]);
}
var fa = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), ha = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, ia = Object.prototype.hasOwnProperty, ja = {}, ka = {};
function la(a2) {
  if (ia.call(ka, a2))
    return true;
  if (ia.call(ja, a2))
    return false;
  if (ha.test(a2))
    return ka[a2] = true;
  ja[a2] = true;
  return false;
}
function ma(a2, b10, c2, d2) {
  if (null !== c2 && 0 === c2.type)
    return false;
  switch (typeof b10) {
    case "function":
    case "symbol":
      return true;
    case "boolean":
      if (d2)
        return false;
      if (null !== c2)
        return !c2.acceptsBooleans;
      a2 = a2.toLowerCase().slice(0, 5);
      return "data-" !== a2 && "aria-" !== a2;
    default:
      return false;
  }
}
function na(a2, b10, c2, d2) {
  if (null === b10 || "undefined" === typeof b10 || ma(a2, b10, c2, d2))
    return true;
  if (d2)
    return false;
  if (null !== c2)
    switch (c2.type) {
      case 3:
        return !b10;
      case 4:
        return false === b10;
      case 5:
        return isNaN(b10);
      case 6:
        return isNaN(b10) || 1 > b10;
    }
  return false;
}
function B$1(a2, b10, c2, d2, e3, f2, g2) {
  this.acceptsBooleans = 2 === b10 || 3 === b10 || 4 === b10;
  this.attributeName = d2;
  this.attributeNamespace = e3;
  this.mustUseProperty = c2;
  this.propertyName = a2;
  this.type = b10;
  this.sanitizeURL = f2;
  this.removeEmptyString = g2;
}
var D$1 = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a2) {
  D$1[a2] = new B$1(a2, 0, false, a2, null, false, false);
});
[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a2) {
  var b10 = a2[0];
  D$1[b10] = new B$1(b10, 1, false, a2[1], null, false, false);
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a2) {
  D$1[a2] = new B$1(a2, 2, false, a2.toLowerCase(), null, false, false);
});
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a2) {
  D$1[a2] = new B$1(a2, 2, false, a2, null, false, false);
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a2) {
  D$1[a2] = new B$1(a2, 3, false, a2.toLowerCase(), null, false, false);
});
["checked", "multiple", "muted", "selected"].forEach(function(a2) {
  D$1[a2] = new B$1(a2, 3, true, a2, null, false, false);
});
["capture", "download"].forEach(function(a2) {
  D$1[a2] = new B$1(a2, 4, false, a2, null, false, false);
});
["cols", "rows", "size", "span"].forEach(function(a2) {
  D$1[a2] = new B$1(a2, 6, false, a2, null, false, false);
});
["rowSpan", "start"].forEach(function(a2) {
  D$1[a2] = new B$1(a2, 5, false, a2.toLowerCase(), null, false, false);
});
var oa = /[\-:]([a-z])/g;
function pa(a2) {
  return a2[1].toUpperCase();
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a2) {
  var b10 = a2.replace(
    oa,
    pa
  );
  D$1[b10] = new B$1(b10, 1, false, a2, null, false, false);
});
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a2) {
  var b10 = a2.replace(oa, pa);
  D$1[b10] = new B$1(b10, 1, false, a2, "http://www.w3.org/1999/xlink", false, false);
});
["xml:base", "xml:lang", "xml:space"].forEach(function(a2) {
  var b10 = a2.replace(oa, pa);
  D$1[b10] = new B$1(b10, 1, false, a2, "http://www.w3.org/XML/1998/namespace", false, false);
});
["tabIndex", "crossOrigin"].forEach(function(a2) {
  D$1[a2] = new B$1(a2, 1, false, a2.toLowerCase(), null, false, false);
});
D$1.xlinkHref = new B$1("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
["src", "href", "action", "formAction"].forEach(function(a2) {
  D$1[a2] = new B$1(a2, 1, false, a2.toLowerCase(), null, true, true);
});
function qa(a2, b10, c2, d2) {
  var e3 = D$1.hasOwnProperty(b10) ? D$1[b10] : null;
  var f2 = null !== e3 ? 0 === e3.type : d2 ? false : !(2 < b10.length) || "o" !== b10[0] && "O" !== b10[0] || "n" !== b10[1] && "N" !== b10[1] ? false : true;
  f2 || (na(b10, c2, e3, d2) && (c2 = null), d2 || null === e3 ? la(b10) && (null === c2 ? a2.removeAttribute(b10) : a2.setAttribute(b10, "" + c2)) : e3.mustUseProperty ? a2[e3.propertyName] = null === c2 ? 3 === e3.type ? false : "" : c2 : (b10 = e3.attributeName, d2 = e3.attributeNamespace, null === c2 ? a2.removeAttribute(b10) : (e3 = e3.type, c2 = 3 === e3 || 4 === e3 && true === c2 ? "" : "" + c2, d2 ? a2.setAttributeNS(d2, b10, c2) : a2.setAttribute(b10, c2))));
}
var ra = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, sa = 60103, ta = 60106, ua = 60107, wa = 60108, xa = 60114, ya = 60109, za = 60110, Aa = 60112, Ba = 60113, Ca = 60120, Da = 60115, Ea = 60116, Fa = 60121, Ga = 60128, Ha = 60129, Ia = 60130, Ja = 60131;
if ("function" === typeof Symbol && Symbol.for) {
  var E$1 = Symbol.for;
  sa = E$1("react.element");
  ta = E$1("react.portal");
  ua = E$1("react.fragment");
  wa = E$1("react.strict_mode");
  xa = E$1("react.profiler");
  ya = E$1("react.provider");
  za = E$1("react.context");
  Aa = E$1("react.forward_ref");
  Ba = E$1("react.suspense");
  Ca = E$1("react.suspense_list");
  Da = E$1("react.memo");
  Ea = E$1("react.lazy");
  Fa = E$1("react.block");
  E$1("react.scope");
  Ga = E$1("react.opaque.id");
  Ha = E$1("react.debug_trace_mode");
  Ia = E$1("react.offscreen");
  Ja = E$1("react.legacy_hidden");
}
var Ka = "function" === typeof Symbol && Symbol.iterator;
function La(a2) {
  if (null === a2 || "object" !== typeof a2)
    return null;
  a2 = Ka && a2[Ka] || a2["@@iterator"];
  return "function" === typeof a2 ? a2 : null;
}
var Ma;
function Na(a2) {
  if (void 0 === Ma)
    try {
      throw Error();
    } catch (c2) {
      var b10 = c2.stack.trim().match(/\n( *(at )?)/);
      Ma = b10 && b10[1] || "";
    }
  return "\n" + Ma + a2;
}
var Oa = false;
function Pa(a2, b10) {
  if (!a2 || Oa)
    return "";
  Oa = true;
  var c2 = Error.prepareStackTrace;
  Error.prepareStackTrace = void 0;
  try {
    if (b10)
      if (b10 = function() {
        throw Error();
      }, Object.defineProperty(b10.prototype, "props", { set: function() {
        throw Error();
      } }), "object" === typeof Reflect && Reflect.construct) {
        try {
          Reflect.construct(b10, []);
        } catch (k2) {
          var d2 = k2;
        }
        Reflect.construct(a2, [], b10);
      } else {
        try {
          b10.call();
        } catch (k2) {
          d2 = k2;
        }
        a2.call(b10.prototype);
      }
    else {
      try {
        throw Error();
      } catch (k2) {
        d2 = k2;
      }
      a2();
    }
  } catch (k2) {
    if (k2 && d2 && "string" === typeof k2.stack) {
      for (var e3 = k2.stack.split("\n"), f2 = d2.stack.split("\n"), g2 = e3.length - 1, h2 = f2.length - 1; 1 <= g2 && 0 <= h2 && e3[g2] !== f2[h2]; )
        h2--;
      for (; 1 <= g2 && 0 <= h2; g2--, h2--)
        if (e3[g2] !== f2[h2]) {
          if (1 !== g2 || 1 !== h2) {
            do
              if (g2--, h2--, 0 > h2 || e3[g2] !== f2[h2])
                return "\n" + e3[g2].replace(" at new ", " at ");
            while (1 <= g2 && 0 <= h2);
          }
          break;
        }
    }
  } finally {
    Oa = false, Error.prepareStackTrace = c2;
  }
  return (a2 = a2 ? a2.displayName || a2.name : "") ? Na(a2) : "";
}
function Qa(a2) {
  switch (a2.tag) {
    case 5:
      return Na(a2.type);
    case 16:
      return Na("Lazy");
    case 13:
      return Na("Suspense");
    case 19:
      return Na("SuspenseList");
    case 0:
    case 2:
    case 15:
      return a2 = Pa(a2.type, false), a2;
    case 11:
      return a2 = Pa(a2.type.render, false), a2;
    case 22:
      return a2 = Pa(a2.type._render, false), a2;
    case 1:
      return a2 = Pa(a2.type, true), a2;
    default:
      return "";
  }
}
function Ra(a2) {
  if (null == a2)
    return null;
  if ("function" === typeof a2)
    return a2.displayName || a2.name || null;
  if ("string" === typeof a2)
    return a2;
  switch (a2) {
    case ua:
      return "Fragment";
    case ta:
      return "Portal";
    case xa:
      return "Profiler";
    case wa:
      return "StrictMode";
    case Ba:
      return "Suspense";
    case Ca:
      return "SuspenseList";
  }
  if ("object" === typeof a2)
    switch (a2.$$typeof) {
      case za:
        return (a2.displayName || "Context") + ".Consumer";
      case ya:
        return (a2._context.displayName || "Context") + ".Provider";
      case Aa:
        var b10 = a2.render;
        b10 = b10.displayName || b10.name || "";
        return a2.displayName || ("" !== b10 ? "ForwardRef(" + b10 + ")" : "ForwardRef");
      case Da:
        return Ra(a2.type);
      case Fa:
        return Ra(a2._render);
      case Ea:
        b10 = a2._payload;
        a2 = a2._init;
        try {
          return Ra(a2(b10));
        } catch (c2) {
        }
    }
  return null;
}
function Sa(a2) {
  switch (typeof a2) {
    case "boolean":
    case "number":
    case "object":
    case "string":
    case "undefined":
      return a2;
    default:
      return "";
  }
}
function Ta(a2) {
  var b10 = a2.type;
  return (a2 = a2.nodeName) && "input" === a2.toLowerCase() && ("checkbox" === b10 || "radio" === b10);
}
function Ua(a2) {
  var b10 = Ta(a2) ? "checked" : "value", c2 = Object.getOwnPropertyDescriptor(a2.constructor.prototype, b10), d2 = "" + a2[b10];
  if (!a2.hasOwnProperty(b10) && "undefined" !== typeof c2 && "function" === typeof c2.get && "function" === typeof c2.set) {
    var e3 = c2.get, f2 = c2.set;
    Object.defineProperty(a2, b10, { configurable: true, get: function() {
      return e3.call(this);
    }, set: function(a3) {
      d2 = "" + a3;
      f2.call(this, a3);
    } });
    Object.defineProperty(a2, b10, { enumerable: c2.enumerable });
    return { getValue: function() {
      return d2;
    }, setValue: function(a3) {
      d2 = "" + a3;
    }, stopTracking: function() {
      a2._valueTracker = null;
      delete a2[b10];
    } };
  }
}
function Va(a2) {
  a2._valueTracker || (a2._valueTracker = Ua(a2));
}
function Wa(a2) {
  if (!a2)
    return false;
  var b10 = a2._valueTracker;
  if (!b10)
    return true;
  var c2 = b10.getValue();
  var d2 = "";
  a2 && (d2 = Ta(a2) ? a2.checked ? "true" : "false" : a2.value);
  a2 = d2;
  return a2 !== c2 ? (b10.setValue(a2), true) : false;
}
function Xa(a2) {
  a2 = a2 || ("undefined" !== typeof document ? document : void 0);
  if ("undefined" === typeof a2)
    return null;
  try {
    return a2.activeElement || a2.body;
  } catch (b10) {
    return a2.body;
  }
}
function Ya(a2, b10) {
  var c2 = b10.checked;
  return m$5({}, b10, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: null != c2 ? c2 : a2._wrapperState.initialChecked });
}
function Za(a2, b10) {
  var c2 = null == b10.defaultValue ? "" : b10.defaultValue, d2 = null != b10.checked ? b10.checked : b10.defaultChecked;
  c2 = Sa(null != b10.value ? b10.value : c2);
  a2._wrapperState = { initialChecked: d2, initialValue: c2, controlled: "checkbox" === b10.type || "radio" === b10.type ? null != b10.checked : null != b10.value };
}
function $a(a2, b10) {
  b10 = b10.checked;
  null != b10 && qa(a2, "checked", b10, false);
}
function ab(a2, b10) {
  $a(a2, b10);
  var c2 = Sa(b10.value), d2 = b10.type;
  if (null != c2)
    if ("number" === d2) {
      if (0 === c2 && "" === a2.value || a2.value != c2)
        a2.value = "" + c2;
    } else
      a2.value !== "" + c2 && (a2.value = "" + c2);
  else if ("submit" === d2 || "reset" === d2) {
    a2.removeAttribute("value");
    return;
  }
  b10.hasOwnProperty("value") ? bb(a2, b10.type, c2) : b10.hasOwnProperty("defaultValue") && bb(a2, b10.type, Sa(b10.defaultValue));
  null == b10.checked && null != b10.defaultChecked && (a2.defaultChecked = !!b10.defaultChecked);
}
function cb(a2, b10, c2) {
  if (b10.hasOwnProperty("value") || b10.hasOwnProperty("defaultValue")) {
    var d2 = b10.type;
    if (!("submit" !== d2 && "reset" !== d2 || void 0 !== b10.value && null !== b10.value))
      return;
    b10 = "" + a2._wrapperState.initialValue;
    c2 || b10 === a2.value || (a2.value = b10);
    a2.defaultValue = b10;
  }
  c2 = a2.name;
  "" !== c2 && (a2.name = "");
  a2.defaultChecked = !!a2._wrapperState.initialChecked;
  "" !== c2 && (a2.name = c2);
}
function bb(a2, b10, c2) {
  if ("number" !== b10 || Xa(a2.ownerDocument) !== a2)
    null == c2 ? a2.defaultValue = "" + a2._wrapperState.initialValue : a2.defaultValue !== "" + c2 && (a2.defaultValue = "" + c2);
}
function db(a2) {
  var b10 = "";
  aa.Children.forEach(a2, function(a3) {
    null != a3 && (b10 += a3);
  });
  return b10;
}
function eb(a2, b10) {
  a2 = m$5({ children: void 0 }, b10);
  if (b10 = db(b10.children))
    a2.children = b10;
  return a2;
}
function fb(a2, b10, c2, d2) {
  a2 = a2.options;
  if (b10) {
    b10 = {};
    for (var e3 = 0; e3 < c2.length; e3++)
      b10["$" + c2[e3]] = true;
    for (c2 = 0; c2 < a2.length; c2++)
      e3 = b10.hasOwnProperty("$" + a2[c2].value), a2[c2].selected !== e3 && (a2[c2].selected = e3), e3 && d2 && (a2[c2].defaultSelected = true);
  } else {
    c2 = "" + Sa(c2);
    b10 = null;
    for (e3 = 0; e3 < a2.length; e3++) {
      if (a2[e3].value === c2) {
        a2[e3].selected = true;
        d2 && (a2[e3].defaultSelected = true);
        return;
      }
      null !== b10 || a2[e3].disabled || (b10 = a2[e3]);
    }
    null !== b10 && (b10.selected = true);
  }
}
function gb(a2, b10) {
  if (null != b10.dangerouslySetInnerHTML)
    throw Error(y$2(91));
  return m$5({}, b10, { value: void 0, defaultValue: void 0, children: "" + a2._wrapperState.initialValue });
}
function hb(a2, b10) {
  var c2 = b10.value;
  if (null == c2) {
    c2 = b10.children;
    b10 = b10.defaultValue;
    if (null != c2) {
      if (null != b10)
        throw Error(y$2(92));
      if (Array.isArray(c2)) {
        if (!(1 >= c2.length))
          throw Error(y$2(93));
        c2 = c2[0];
      }
      b10 = c2;
    }
    null == b10 && (b10 = "");
    c2 = b10;
  }
  a2._wrapperState = { initialValue: Sa(c2) };
}
function ib(a2, b10) {
  var c2 = Sa(b10.value), d2 = Sa(b10.defaultValue);
  null != c2 && (c2 = "" + c2, c2 !== a2.value && (a2.value = c2), null == b10.defaultValue && a2.defaultValue !== c2 && (a2.defaultValue = c2));
  null != d2 && (a2.defaultValue = "" + d2);
}
function jb(a2) {
  var b10 = a2.textContent;
  b10 === a2._wrapperState.initialValue && "" !== b10 && null !== b10 && (a2.value = b10);
}
var kb = { html: "http://www.w3.org/1999/xhtml", mathml: "http://www.w3.org/1998/Math/MathML", svg: "http://www.w3.org/2000/svg" };
function lb(a2) {
  switch (a2) {
    case "svg":
      return "http://www.w3.org/2000/svg";
    case "math":
      return "http://www.w3.org/1998/Math/MathML";
    default:
      return "http://www.w3.org/1999/xhtml";
  }
}
function mb(a2, b10) {
  return null == a2 || "http://www.w3.org/1999/xhtml" === a2 ? lb(b10) : "http://www.w3.org/2000/svg" === a2 && "foreignObject" === b10 ? "http://www.w3.org/1999/xhtml" : a2;
}
var nb, ob = function(a2) {
  return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function(b10, c2, d2, e3) {
    MSApp.execUnsafeLocalFunction(function() {
      return a2(b10, c2, d2, e3);
    });
  } : a2;
}(function(a2, b10) {
  if (a2.namespaceURI !== kb.svg || "innerHTML" in a2)
    a2.innerHTML = b10;
  else {
    nb = nb || document.createElement("div");
    nb.innerHTML = "<svg>" + b10.valueOf().toString() + "</svg>";
    for (b10 = nb.firstChild; a2.firstChild; )
      a2.removeChild(a2.firstChild);
    for (; b10.firstChild; )
      a2.appendChild(b10.firstChild);
  }
});
function pb(a2, b10) {
  if (b10) {
    var c2 = a2.firstChild;
    if (c2 && c2 === a2.lastChild && 3 === c2.nodeType) {
      c2.nodeValue = b10;
      return;
    }
  }
  a2.textContent = b10;
}
var qb = {
  animationIterationCount: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  columns: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  gridArea: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowSpan: true,
  gridRowStart: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnSpan: true,
  gridColumnStart: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,
  fillOpacity: true,
  floodOpacity: true,
  stopOpacity: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true
}, rb = ["Webkit", "ms", "Moz", "O"];
Object.keys(qb).forEach(function(a2) {
  rb.forEach(function(b10) {
    b10 = b10 + a2.charAt(0).toUpperCase() + a2.substring(1);
    qb[b10] = qb[a2];
  });
});
function sb(a2, b10, c2) {
  return null == b10 || "boolean" === typeof b10 || "" === b10 ? "" : c2 || "number" !== typeof b10 || 0 === b10 || qb.hasOwnProperty(a2) && qb[a2] ? ("" + b10).trim() : b10 + "px";
}
function tb(a2, b10) {
  a2 = a2.style;
  for (var c2 in b10)
    if (b10.hasOwnProperty(c2)) {
      var d2 = 0 === c2.indexOf("--"), e3 = sb(c2, b10[c2], d2);
      "float" === c2 && (c2 = "cssFloat");
      d2 ? a2.setProperty(c2, e3) : a2[c2] = e3;
    }
}
var ub = m$5({ menuitem: true }, { area: true, base: true, br: true, col: true, embed: true, hr: true, img: true, input: true, keygen: true, link: true, meta: true, param: true, source: true, track: true, wbr: true });
function vb(a2, b10) {
  if (b10) {
    if (ub[a2] && (null != b10.children || null != b10.dangerouslySetInnerHTML))
      throw Error(y$2(137, a2));
    if (null != b10.dangerouslySetInnerHTML) {
      if (null != b10.children)
        throw Error(y$2(60));
      if (!("object" === typeof b10.dangerouslySetInnerHTML && "__html" in b10.dangerouslySetInnerHTML))
        throw Error(y$2(61));
    }
    if (null != b10.style && "object" !== typeof b10.style)
      throw Error(y$2(62));
  }
}
function wb(a2, b10) {
  if (-1 === a2.indexOf("-"))
    return "string" === typeof b10.is;
  switch (a2) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return false;
    default:
      return true;
  }
}
function xb(a2) {
  a2 = a2.target || a2.srcElement || window;
  a2.correspondingUseElement && (a2 = a2.correspondingUseElement);
  return 3 === a2.nodeType ? a2.parentNode : a2;
}
var yb = null, zb = null, Ab = null;
function Bb(a2) {
  if (a2 = Cb(a2)) {
    if ("function" !== typeof yb)
      throw Error(y$2(280));
    var b10 = a2.stateNode;
    b10 && (b10 = Db(b10), yb(a2.stateNode, a2.type, b10));
  }
}
function Eb(a2) {
  zb ? Ab ? Ab.push(a2) : Ab = [a2] : zb = a2;
}
function Fb() {
  if (zb) {
    var a2 = zb, b10 = Ab;
    Ab = zb = null;
    Bb(a2);
    if (b10)
      for (a2 = 0; a2 < b10.length; a2++)
        Bb(b10[a2]);
  }
}
function Gb(a2, b10) {
  return a2(b10);
}
function Hb(a2, b10, c2, d2, e3) {
  return a2(b10, c2, d2, e3);
}
function Ib() {
}
var Jb = Gb, Kb = false, Lb = false;
function Mb() {
  if (null !== zb || null !== Ab)
    Ib(), Fb();
}
function Nb(a2, b10, c2) {
  if (Lb)
    return a2(b10, c2);
  Lb = true;
  try {
    return Jb(a2, b10, c2);
  } finally {
    Lb = false, Mb();
  }
}
function Ob(a2, b10) {
  var c2 = a2.stateNode;
  if (null === c2)
    return null;
  var d2 = Db(c2);
  if (null === d2)
    return null;
  c2 = d2[b10];
  a:
    switch (b10) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (d2 = !d2.disabled) || (a2 = a2.type, d2 = !("button" === a2 || "input" === a2 || "select" === a2 || "textarea" === a2));
        a2 = !d2;
        break a;
      default:
        a2 = false;
    }
  if (a2)
    return null;
  if (c2 && "function" !== typeof c2)
    throw Error(y$2(231, b10, typeof c2));
  return c2;
}
var Pb = false;
if (fa)
  try {
    var Qb = {};
    Object.defineProperty(Qb, "passive", { get: function() {
      Pb = true;
    } });
    window.addEventListener("test", Qb, Qb);
    window.removeEventListener("test", Qb, Qb);
  } catch (a2) {
    Pb = false;
  }
function Rb(a2, b10, c2, d2, e3, f2, g2, h2, k2) {
  var l2 = Array.prototype.slice.call(arguments, 3);
  try {
    b10.apply(c2, l2);
  } catch (n2) {
    this.onError(n2);
  }
}
var Sb = false, Tb = null, Ub = false, Vb = null, Wb = { onError: function(a2) {
  Sb = true;
  Tb = a2;
} };
function Xb(a2, b10, c2, d2, e3, f2, g2, h2, k2) {
  Sb = false;
  Tb = null;
  Rb.apply(Wb, arguments);
}
function Yb(a2, b10, c2, d2, e3, f2, g2, h2, k2) {
  Xb.apply(this, arguments);
  if (Sb) {
    if (Sb) {
      var l2 = Tb;
      Sb = false;
      Tb = null;
    } else
      throw Error(y$2(198));
    Ub || (Ub = true, Vb = l2);
  }
}
function Zb(a2) {
  var b10 = a2, c2 = a2;
  if (a2.alternate)
    for (; b10.return; )
      b10 = b10.return;
  else {
    a2 = b10;
    do
      b10 = a2, 0 !== (b10.flags & 1026) && (c2 = b10.return), a2 = b10.return;
    while (a2);
  }
  return 3 === b10.tag ? c2 : null;
}
function $b(a2) {
  if (13 === a2.tag) {
    var b10 = a2.memoizedState;
    null === b10 && (a2 = a2.alternate, null !== a2 && (b10 = a2.memoizedState));
    if (null !== b10)
      return b10.dehydrated;
  }
  return null;
}
function ac(a2) {
  if (Zb(a2) !== a2)
    throw Error(y$2(188));
}
function bc(a2) {
  var b10 = a2.alternate;
  if (!b10) {
    b10 = Zb(a2);
    if (null === b10)
      throw Error(y$2(188));
    return b10 !== a2 ? null : a2;
  }
  for (var c2 = a2, d2 = b10; ; ) {
    var e3 = c2.return;
    if (null === e3)
      break;
    var f2 = e3.alternate;
    if (null === f2) {
      d2 = e3.return;
      if (null !== d2) {
        c2 = d2;
        continue;
      }
      break;
    }
    if (e3.child === f2.child) {
      for (f2 = e3.child; f2; ) {
        if (f2 === c2)
          return ac(e3), a2;
        if (f2 === d2)
          return ac(e3), b10;
        f2 = f2.sibling;
      }
      throw Error(y$2(188));
    }
    if (c2.return !== d2.return)
      c2 = e3, d2 = f2;
    else {
      for (var g2 = false, h2 = e3.child; h2; ) {
        if (h2 === c2) {
          g2 = true;
          c2 = e3;
          d2 = f2;
          break;
        }
        if (h2 === d2) {
          g2 = true;
          d2 = e3;
          c2 = f2;
          break;
        }
        h2 = h2.sibling;
      }
      if (!g2) {
        for (h2 = f2.child; h2; ) {
          if (h2 === c2) {
            g2 = true;
            c2 = f2;
            d2 = e3;
            break;
          }
          if (h2 === d2) {
            g2 = true;
            d2 = f2;
            c2 = e3;
            break;
          }
          h2 = h2.sibling;
        }
        if (!g2)
          throw Error(y$2(189));
      }
    }
    if (c2.alternate !== d2)
      throw Error(y$2(190));
  }
  if (3 !== c2.tag)
    throw Error(y$2(188));
  return c2.stateNode.current === c2 ? a2 : b10;
}
function cc(a2) {
  a2 = bc(a2);
  if (!a2)
    return null;
  for (var b10 = a2; ; ) {
    if (5 === b10.tag || 6 === b10.tag)
      return b10;
    if (b10.child)
      b10.child.return = b10, b10 = b10.child;
    else {
      if (b10 === a2)
        break;
      for (; !b10.sibling; ) {
        if (!b10.return || b10.return === a2)
          return null;
        b10 = b10.return;
      }
      b10.sibling.return = b10.return;
      b10 = b10.sibling;
    }
  }
  return null;
}
function dc(a2, b10) {
  for (var c2 = a2.alternate; null !== b10; ) {
    if (b10 === a2 || b10 === c2)
      return true;
    b10 = b10.return;
  }
  return false;
}
var ec, fc, gc, hc, ic = false, jc = [], kc = null, lc = null, mc = null, nc = /* @__PURE__ */ new Map(), oc = /* @__PURE__ */ new Map(), pc = [], qc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
function rc(a2, b10, c2, d2, e3) {
  return { blockedOn: a2, domEventName: b10, eventSystemFlags: c2 | 16, nativeEvent: e3, targetContainers: [d2] };
}
function sc(a2, b10) {
  switch (a2) {
    case "focusin":
    case "focusout":
      kc = null;
      break;
    case "dragenter":
    case "dragleave":
      lc = null;
      break;
    case "mouseover":
    case "mouseout":
      mc = null;
      break;
    case "pointerover":
    case "pointerout":
      nc.delete(b10.pointerId);
      break;
    case "gotpointercapture":
    case "lostpointercapture":
      oc.delete(b10.pointerId);
  }
}
function tc(a2, b10, c2, d2, e3, f2) {
  if (null === a2 || a2.nativeEvent !== f2)
    return a2 = rc(b10, c2, d2, e3, f2), null !== b10 && (b10 = Cb(b10), null !== b10 && fc(b10)), a2;
  a2.eventSystemFlags |= d2;
  b10 = a2.targetContainers;
  null !== e3 && -1 === b10.indexOf(e3) && b10.push(e3);
  return a2;
}
function uc(a2, b10, c2, d2, e3) {
  switch (b10) {
    case "focusin":
      return kc = tc(kc, a2, b10, c2, d2, e3), true;
    case "dragenter":
      return lc = tc(lc, a2, b10, c2, d2, e3), true;
    case "mouseover":
      return mc = tc(mc, a2, b10, c2, d2, e3), true;
    case "pointerover":
      var f2 = e3.pointerId;
      nc.set(f2, tc(nc.get(f2) || null, a2, b10, c2, d2, e3));
      return true;
    case "gotpointercapture":
      return f2 = e3.pointerId, oc.set(f2, tc(oc.get(f2) || null, a2, b10, c2, d2, e3)), true;
  }
  return false;
}
function vc(a2) {
  var b10 = wc(a2.target);
  if (null !== b10) {
    var c2 = Zb(b10);
    if (null !== c2) {
      if (b10 = c2.tag, 13 === b10) {
        if (b10 = $b(c2), null !== b10) {
          a2.blockedOn = b10;
          hc(a2.lanePriority, function() {
            r$4.unstable_runWithPriority(a2.priority, function() {
              gc(c2);
            });
          });
          return;
        }
      } else if (3 === b10 && c2.stateNode.hydrate) {
        a2.blockedOn = 3 === c2.tag ? c2.stateNode.containerInfo : null;
        return;
      }
    }
  }
  a2.blockedOn = null;
}
function xc(a2) {
  if (null !== a2.blockedOn)
    return false;
  for (var b10 = a2.targetContainers; 0 < b10.length; ) {
    var c2 = yc(a2.domEventName, a2.eventSystemFlags, b10[0], a2.nativeEvent);
    if (null !== c2)
      return b10 = Cb(c2), null !== b10 && fc(b10), a2.blockedOn = c2, false;
    b10.shift();
  }
  return true;
}
function zc(a2, b10, c2) {
  xc(a2) && c2.delete(b10);
}
function Ac() {
  for (ic = false; 0 < jc.length; ) {
    var a2 = jc[0];
    if (null !== a2.blockedOn) {
      a2 = Cb(a2.blockedOn);
      null !== a2 && ec(a2);
      break;
    }
    for (var b10 = a2.targetContainers; 0 < b10.length; ) {
      var c2 = yc(a2.domEventName, a2.eventSystemFlags, b10[0], a2.nativeEvent);
      if (null !== c2) {
        a2.blockedOn = c2;
        break;
      }
      b10.shift();
    }
    null === a2.blockedOn && jc.shift();
  }
  null !== kc && xc(kc) && (kc = null);
  null !== lc && xc(lc) && (lc = null);
  null !== mc && xc(mc) && (mc = null);
  nc.forEach(zc);
  oc.forEach(zc);
}
function Bc(a2, b10) {
  a2.blockedOn === b10 && (a2.blockedOn = null, ic || (ic = true, r$4.unstable_scheduleCallback(r$4.unstable_NormalPriority, Ac)));
}
function Cc(a2) {
  function b10(b11) {
    return Bc(b11, a2);
  }
  if (0 < jc.length) {
    Bc(jc[0], a2);
    for (var c2 = 1; c2 < jc.length; c2++) {
      var d2 = jc[c2];
      d2.blockedOn === a2 && (d2.blockedOn = null);
    }
  }
  null !== kc && Bc(kc, a2);
  null !== lc && Bc(lc, a2);
  null !== mc && Bc(mc, a2);
  nc.forEach(b10);
  oc.forEach(b10);
  for (c2 = 0; c2 < pc.length; c2++)
    d2 = pc[c2], d2.blockedOn === a2 && (d2.blockedOn = null);
  for (; 0 < pc.length && (c2 = pc[0], null === c2.blockedOn); )
    vc(c2), null === c2.blockedOn && pc.shift();
}
function Dc(a2, b10) {
  var c2 = {};
  c2[a2.toLowerCase()] = b10.toLowerCase();
  c2["Webkit" + a2] = "webkit" + b10;
  c2["Moz" + a2] = "moz" + b10;
  return c2;
}
var Ec = { animationend: Dc("Animation", "AnimationEnd"), animationiteration: Dc("Animation", "AnimationIteration"), animationstart: Dc("Animation", "AnimationStart"), transitionend: Dc("Transition", "TransitionEnd") }, Fc = {}, Gc = {};
fa && (Gc = document.createElement("div").style, "AnimationEvent" in window || (delete Ec.animationend.animation, delete Ec.animationiteration.animation, delete Ec.animationstart.animation), "TransitionEvent" in window || delete Ec.transitionend.transition);
function Hc(a2) {
  if (Fc[a2])
    return Fc[a2];
  if (!Ec[a2])
    return a2;
  var b10 = Ec[a2], c2;
  for (c2 in b10)
    if (b10.hasOwnProperty(c2) && c2 in Gc)
      return Fc[a2] = b10[c2];
  return a2;
}
var Ic = Hc("animationend"), Jc = Hc("animationiteration"), Kc = Hc("animationstart"), Lc = Hc("transitionend"), Mc = /* @__PURE__ */ new Map(), Nc = /* @__PURE__ */ new Map(), Oc = [
  "abort",
  "abort",
  Ic,
  "animationEnd",
  Jc,
  "animationIteration",
  Kc,
  "animationStart",
  "canplay",
  "canPlay",
  "canplaythrough",
  "canPlayThrough",
  "durationchange",
  "durationChange",
  "emptied",
  "emptied",
  "encrypted",
  "encrypted",
  "ended",
  "ended",
  "error",
  "error",
  "gotpointercapture",
  "gotPointerCapture",
  "load",
  "load",
  "loadeddata",
  "loadedData",
  "loadedmetadata",
  "loadedMetadata",
  "loadstart",
  "loadStart",
  "lostpointercapture",
  "lostPointerCapture",
  "playing",
  "playing",
  "progress",
  "progress",
  "seeking",
  "seeking",
  "stalled",
  "stalled",
  "suspend",
  "suspend",
  "timeupdate",
  "timeUpdate",
  Lc,
  "transitionEnd",
  "waiting",
  "waiting"
];
function Pc(a2, b10) {
  for (var c2 = 0; c2 < a2.length; c2 += 2) {
    var d2 = a2[c2], e3 = a2[c2 + 1];
    e3 = "on" + (e3[0].toUpperCase() + e3.slice(1));
    Nc.set(d2, b10);
    Mc.set(d2, e3);
    da(e3, [d2]);
  }
}
var Qc = r$4.unstable_now;
Qc();
var F$1 = 8;
function Rc(a2) {
  if (0 !== (1 & a2))
    return F$1 = 15, 1;
  if (0 !== (2 & a2))
    return F$1 = 14, 2;
  if (0 !== (4 & a2))
    return F$1 = 13, 4;
  var b10 = 24 & a2;
  if (0 !== b10)
    return F$1 = 12, b10;
  if (0 !== (a2 & 32))
    return F$1 = 11, 32;
  b10 = 192 & a2;
  if (0 !== b10)
    return F$1 = 10, b10;
  if (0 !== (a2 & 256))
    return F$1 = 9, 256;
  b10 = 3584 & a2;
  if (0 !== b10)
    return F$1 = 8, b10;
  if (0 !== (a2 & 4096))
    return F$1 = 7, 4096;
  b10 = 4186112 & a2;
  if (0 !== b10)
    return F$1 = 6, b10;
  b10 = 62914560 & a2;
  if (0 !== b10)
    return F$1 = 5, b10;
  if (a2 & 67108864)
    return F$1 = 4, 67108864;
  if (0 !== (a2 & 134217728))
    return F$1 = 3, 134217728;
  b10 = 805306368 & a2;
  if (0 !== b10)
    return F$1 = 2, b10;
  if (0 !== (1073741824 & a2))
    return F$1 = 1, 1073741824;
  F$1 = 8;
  return a2;
}
function Sc(a2) {
  switch (a2) {
    case 99:
      return 15;
    case 98:
      return 10;
    case 97:
    case 96:
      return 8;
    case 95:
      return 2;
    default:
      return 0;
  }
}
function Tc(a2) {
  switch (a2) {
    case 15:
    case 14:
      return 99;
    case 13:
    case 12:
    case 11:
    case 10:
      return 98;
    case 9:
    case 8:
    case 7:
    case 6:
    case 4:
    case 5:
      return 97;
    case 3:
    case 2:
    case 1:
      return 95;
    case 0:
      return 90;
    default:
      throw Error(y$2(358, a2));
  }
}
function Uc(a2, b10) {
  var c2 = a2.pendingLanes;
  if (0 === c2)
    return F$1 = 0;
  var d2 = 0, e3 = 0, f2 = a2.expiredLanes, g2 = a2.suspendedLanes, h2 = a2.pingedLanes;
  if (0 !== f2)
    d2 = f2, e3 = F$1 = 15;
  else if (f2 = c2 & 134217727, 0 !== f2) {
    var k2 = f2 & ~g2;
    0 !== k2 ? (d2 = Rc(k2), e3 = F$1) : (h2 &= f2, 0 !== h2 && (d2 = Rc(h2), e3 = F$1));
  } else
    f2 = c2 & ~g2, 0 !== f2 ? (d2 = Rc(f2), e3 = F$1) : 0 !== h2 && (d2 = Rc(h2), e3 = F$1);
  if (0 === d2)
    return 0;
  d2 = 31 - Vc(d2);
  d2 = c2 & ((0 > d2 ? 0 : 1 << d2) << 1) - 1;
  if (0 !== b10 && b10 !== d2 && 0 === (b10 & g2)) {
    Rc(b10);
    if (e3 <= F$1)
      return b10;
    F$1 = e3;
  }
  b10 = a2.entangledLanes;
  if (0 !== b10)
    for (a2 = a2.entanglements, b10 &= d2; 0 < b10; )
      c2 = 31 - Vc(b10), e3 = 1 << c2, d2 |= a2[c2], b10 &= ~e3;
  return d2;
}
function Wc(a2) {
  a2 = a2.pendingLanes & -1073741825;
  return 0 !== a2 ? a2 : a2 & 1073741824 ? 1073741824 : 0;
}
function Xc(a2, b10) {
  switch (a2) {
    case 15:
      return 1;
    case 14:
      return 2;
    case 12:
      return a2 = Yc(24 & ~b10), 0 === a2 ? Xc(10, b10) : a2;
    case 10:
      return a2 = Yc(192 & ~b10), 0 === a2 ? Xc(8, b10) : a2;
    case 8:
      return a2 = Yc(3584 & ~b10), 0 === a2 && (a2 = Yc(4186112 & ~b10), 0 === a2 && (a2 = 512)), a2;
    case 2:
      return b10 = Yc(805306368 & ~b10), 0 === b10 && (b10 = 268435456), b10;
  }
  throw Error(y$2(358, a2));
}
function Yc(a2) {
  return a2 & -a2;
}
function Zc(a2) {
  for (var b10 = [], c2 = 0; 31 > c2; c2++)
    b10.push(a2);
  return b10;
}
function $c(a2, b10, c2) {
  a2.pendingLanes |= b10;
  var d2 = b10 - 1;
  a2.suspendedLanes &= d2;
  a2.pingedLanes &= d2;
  a2 = a2.eventTimes;
  b10 = 31 - Vc(b10);
  a2[b10] = c2;
}
var Vc = Math.clz32 ? Math.clz32 : ad, bd = Math.log, cd = Math.LN2;
function ad(a2) {
  return 0 === a2 ? 32 : 31 - (bd(a2) / cd | 0) | 0;
}
var dd = r$4.unstable_UserBlockingPriority, ed = r$4.unstable_runWithPriority, fd = true;
function gd(a2, b10, c2, d2) {
  Kb || Ib();
  var e3 = hd, f2 = Kb;
  Kb = true;
  try {
    Hb(e3, a2, b10, c2, d2);
  } finally {
    (Kb = f2) || Mb();
  }
}
function id$2(a2, b10, c2, d2) {
  ed(dd, hd.bind(null, a2, b10, c2, d2));
}
function hd(a2, b10, c2, d2) {
  if (fd) {
    var e3;
    if ((e3 = 0 === (b10 & 4)) && 0 < jc.length && -1 < qc.indexOf(a2))
      a2 = rc(null, a2, b10, c2, d2), jc.push(a2);
    else {
      var f2 = yc(a2, b10, c2, d2);
      if (null === f2)
        e3 && sc(a2, d2);
      else {
        if (e3) {
          if (-1 < qc.indexOf(a2)) {
            a2 = rc(f2, a2, b10, c2, d2);
            jc.push(a2);
            return;
          }
          if (uc(f2, a2, b10, c2, d2))
            return;
          sc(a2, d2);
        }
        jd(a2, b10, d2, null, c2);
      }
    }
  }
}
function yc(a2, b10, c2, d2) {
  var e3 = xb(d2);
  e3 = wc(e3);
  if (null !== e3) {
    var f2 = Zb(e3);
    if (null === f2)
      e3 = null;
    else {
      var g2 = f2.tag;
      if (13 === g2) {
        e3 = $b(f2);
        if (null !== e3)
          return e3;
        e3 = null;
      } else if (3 === g2) {
        if (f2.stateNode.hydrate)
          return 3 === f2.tag ? f2.stateNode.containerInfo : null;
        e3 = null;
      } else
        f2 !== e3 && (e3 = null);
    }
  }
  jd(a2, b10, d2, e3, c2);
  return null;
}
var kd = null, ld = null, md = null;
function nd() {
  if (md)
    return md;
  var a2, b10 = ld, c2 = b10.length, d2, e3 = "value" in kd ? kd.value : kd.textContent, f2 = e3.length;
  for (a2 = 0; a2 < c2 && b10[a2] === e3[a2]; a2++)
    ;
  var g2 = c2 - a2;
  for (d2 = 1; d2 <= g2 && b10[c2 - d2] === e3[f2 - d2]; d2++)
    ;
  return md = e3.slice(a2, 1 < d2 ? 1 - d2 : void 0);
}
function od(a2) {
  var b10 = a2.keyCode;
  "charCode" in a2 ? (a2 = a2.charCode, 0 === a2 && 13 === b10 && (a2 = 13)) : a2 = b10;
  10 === a2 && (a2 = 13);
  return 32 <= a2 || 13 === a2 ? a2 : 0;
}
function pd() {
  return true;
}
function qd() {
  return false;
}
function rd(a2) {
  function b10(b11, d2, e3, f2, g2) {
    this._reactName = b11;
    this._targetInst = e3;
    this.type = d2;
    this.nativeEvent = f2;
    this.target = g2;
    this.currentTarget = null;
    for (var c2 in a2)
      a2.hasOwnProperty(c2) && (b11 = a2[c2], this[c2] = b11 ? b11(f2) : f2[c2]);
    this.isDefaultPrevented = (null != f2.defaultPrevented ? f2.defaultPrevented : false === f2.returnValue) ? pd : qd;
    this.isPropagationStopped = qd;
    return this;
  }
  m$5(b10.prototype, { preventDefault: function() {
    this.defaultPrevented = true;
    var a3 = this.nativeEvent;
    a3 && (a3.preventDefault ? a3.preventDefault() : "unknown" !== typeof a3.returnValue && (a3.returnValue = false), this.isDefaultPrevented = pd);
  }, stopPropagation: function() {
    var a3 = this.nativeEvent;
    a3 && (a3.stopPropagation ? a3.stopPropagation() : "unknown" !== typeof a3.cancelBubble && (a3.cancelBubble = true), this.isPropagationStopped = pd);
  }, persist: function() {
  }, isPersistent: pd });
  return b10;
}
var sd = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(a2) {
  return a2.timeStamp || Date.now();
}, defaultPrevented: 0, isTrusted: 0 }, td = rd(sd), ud = m$5({}, sd, { view: 0, detail: 0 }), vd = rd(ud), wd, xd, yd, Ad = m$5({}, ud, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zd, button: 0, buttons: 0, relatedTarget: function(a2) {
  return void 0 === a2.relatedTarget ? a2.fromElement === a2.srcElement ? a2.toElement : a2.fromElement : a2.relatedTarget;
}, movementX: function(a2) {
  if ("movementX" in a2)
    return a2.movementX;
  a2 !== yd && (yd && "mousemove" === a2.type ? (wd = a2.screenX - yd.screenX, xd = a2.screenY - yd.screenY) : xd = wd = 0, yd = a2);
  return wd;
}, movementY: function(a2) {
  return "movementY" in a2 ? a2.movementY : xd;
} }), Bd = rd(Ad), Cd = m$5({}, Ad, { dataTransfer: 0 }), Dd = rd(Cd), Ed = m$5({}, ud, { relatedTarget: 0 }), Fd = rd(Ed), Gd = m$5({}, sd, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Hd = rd(Gd), Id = m$5({}, sd, { clipboardData: function(a2) {
  return "clipboardData" in a2 ? a2.clipboardData : window.clipboardData;
} }), Jd = rd(Id), Kd = m$5({}, sd, { data: 0 }), Ld = rd(Kd), Md = {
  Esc: "Escape",
  Spacebar: " ",
  Left: "ArrowLeft",
  Up: "ArrowUp",
  Right: "ArrowRight",
  Down: "ArrowDown",
  Del: "Delete",
  Win: "OS",
  Menu: "ContextMenu",
  Apps: "ContextMenu",
  Scroll: "ScrollLock",
  MozPrintableKey: "Unidentified"
}, Nd = {
  8: "Backspace",
  9: "Tab",
  12: "Clear",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  19: "Pause",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  45: "Insert",
  46: "Delete",
  112: "F1",
  113: "F2",
  114: "F3",
  115: "F4",
  116: "F5",
  117: "F6",
  118: "F7",
  119: "F8",
  120: "F9",
  121: "F10",
  122: "F11",
  123: "F12",
  144: "NumLock",
  145: "ScrollLock",
  224: "Meta"
}, Od = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
function Pd(a2) {
  var b10 = this.nativeEvent;
  return b10.getModifierState ? b10.getModifierState(a2) : (a2 = Od[a2]) ? !!b10[a2] : false;
}
function zd() {
  return Pd;
}
var Qd = m$5({}, ud, { key: function(a2) {
  if (a2.key) {
    var b10 = Md[a2.key] || a2.key;
    if ("Unidentified" !== b10)
      return b10;
  }
  return "keypress" === a2.type ? (a2 = od(a2), 13 === a2 ? "Enter" : String.fromCharCode(a2)) : "keydown" === a2.type || "keyup" === a2.type ? Nd[a2.keyCode] || "Unidentified" : "";
}, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zd, charCode: function(a2) {
  return "keypress" === a2.type ? od(a2) : 0;
}, keyCode: function(a2) {
  return "keydown" === a2.type || "keyup" === a2.type ? a2.keyCode : 0;
}, which: function(a2) {
  return "keypress" === a2.type ? od(a2) : "keydown" === a2.type || "keyup" === a2.type ? a2.keyCode : 0;
} }), Rd = rd(Qd), Sd = m$5({}, Ad, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Td = rd(Sd), Ud = m$5({}, ud, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zd }), Vd = rd(Ud), Wd = m$5({}, sd, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Xd = rd(Wd), Yd = m$5({}, Ad, {
  deltaX: function(a2) {
    return "deltaX" in a2 ? a2.deltaX : "wheelDeltaX" in a2 ? -a2.wheelDeltaX : 0;
  },
  deltaY: function(a2) {
    return "deltaY" in a2 ? a2.deltaY : "wheelDeltaY" in a2 ? -a2.wheelDeltaY : "wheelDelta" in a2 ? -a2.wheelDelta : 0;
  },
  deltaZ: 0,
  deltaMode: 0
}), Zd = rd(Yd), $d = [9, 13, 27, 32], ae = fa && "CompositionEvent" in window, be = null;
fa && "documentMode" in document && (be = document.documentMode);
var ce = fa && "TextEvent" in window && !be, de = fa && (!ae || be && 8 < be && 11 >= be), ee = String.fromCharCode(32), fe = false;
function ge(a2, b10) {
  switch (a2) {
    case "keyup":
      return -1 !== $d.indexOf(b10.keyCode);
    case "keydown":
      return 229 !== b10.keyCode;
    case "keypress":
    case "mousedown":
    case "focusout":
      return true;
    default:
      return false;
  }
}
function he(a2) {
  a2 = a2.detail;
  return "object" === typeof a2 && "data" in a2 ? a2.data : null;
}
var ie = false;
function je(a2, b10) {
  switch (a2) {
    case "compositionend":
      return he(b10);
    case "keypress":
      if (32 !== b10.which)
        return null;
      fe = true;
      return ee;
    case "textInput":
      return a2 = b10.data, a2 === ee && fe ? null : a2;
    default:
      return null;
  }
}
function ke(a2, b10) {
  if (ie)
    return "compositionend" === a2 || !ae && ge(a2, b10) ? (a2 = nd(), md = ld = kd = null, ie = false, a2) : null;
  switch (a2) {
    case "paste":
      return null;
    case "keypress":
      if (!(b10.ctrlKey || b10.altKey || b10.metaKey) || b10.ctrlKey && b10.altKey) {
        if (b10.char && 1 < b10.char.length)
          return b10.char;
        if (b10.which)
          return String.fromCharCode(b10.which);
      }
      return null;
    case "compositionend":
      return de && "ko" !== b10.locale ? null : b10.data;
    default:
      return null;
  }
}
var le = { color: true, date: true, datetime: true, "datetime-local": true, email: true, month: true, number: true, password: true, range: true, search: true, tel: true, text: true, time: true, url: true, week: true };
function me(a2) {
  var b10 = a2 && a2.nodeName && a2.nodeName.toLowerCase();
  return "input" === b10 ? !!le[a2.type] : "textarea" === b10 ? true : false;
}
function ne(a2, b10, c2, d2) {
  Eb(d2);
  b10 = oe(b10, "onChange");
  0 < b10.length && (c2 = new td("onChange", "change", null, c2, d2), a2.push({ event: c2, listeners: b10 }));
}
var pe = null, qe = null;
function re(a2) {
  se(a2, 0);
}
function te(a2) {
  var b10 = ue(a2);
  if (Wa(b10))
    return a2;
}
function ve(a2, b10) {
  if ("change" === a2)
    return b10;
}
var we = false;
if (fa) {
  var xe;
  if (fa) {
    var ye = "oninput" in document;
    if (!ye) {
      var ze = document.createElement("div");
      ze.setAttribute("oninput", "return;");
      ye = "function" === typeof ze.oninput;
    }
    xe = ye;
  } else
    xe = false;
  we = xe && (!document.documentMode || 9 < document.documentMode);
}
function Ae() {
  pe && (pe.detachEvent("onpropertychange", Be), qe = pe = null);
}
function Be(a2) {
  if ("value" === a2.propertyName && te(qe)) {
    var b10 = [];
    ne(b10, qe, a2, xb(a2));
    a2 = re;
    if (Kb)
      a2(b10);
    else {
      Kb = true;
      try {
        Gb(a2, b10);
      } finally {
        Kb = false, Mb();
      }
    }
  }
}
function Ce(a2, b10, c2) {
  "focusin" === a2 ? (Ae(), pe = b10, qe = c2, pe.attachEvent("onpropertychange", Be)) : "focusout" === a2 && Ae();
}
function De(a2) {
  if ("selectionchange" === a2 || "keyup" === a2 || "keydown" === a2)
    return te(qe);
}
function Ee(a2, b10) {
  if ("click" === a2)
    return te(b10);
}
function Fe(a2, b10) {
  if ("input" === a2 || "change" === a2)
    return te(b10);
}
function Ge(a2, b10) {
  return a2 === b10 && (0 !== a2 || 1 / a2 === 1 / b10) || a2 !== a2 && b10 !== b10;
}
var He = "function" === typeof Object.is ? Object.is : Ge, Ie = Object.prototype.hasOwnProperty;
function Je(a2, b10) {
  if (He(a2, b10))
    return true;
  if ("object" !== typeof a2 || null === a2 || "object" !== typeof b10 || null === b10)
    return false;
  var c2 = Object.keys(a2), d2 = Object.keys(b10);
  if (c2.length !== d2.length)
    return false;
  for (d2 = 0; d2 < c2.length; d2++)
    if (!Ie.call(b10, c2[d2]) || !He(a2[c2[d2]], b10[c2[d2]]))
      return false;
  return true;
}
function Ke(a2) {
  for (; a2 && a2.firstChild; )
    a2 = a2.firstChild;
  return a2;
}
function Le(a2, b10) {
  var c2 = Ke(a2);
  a2 = 0;
  for (var d2; c2; ) {
    if (3 === c2.nodeType) {
      d2 = a2 + c2.textContent.length;
      if (a2 <= b10 && d2 >= b10)
        return { node: c2, offset: b10 - a2 };
      a2 = d2;
    }
    a: {
      for (; c2; ) {
        if (c2.nextSibling) {
          c2 = c2.nextSibling;
          break a;
        }
        c2 = c2.parentNode;
      }
      c2 = void 0;
    }
    c2 = Ke(c2);
  }
}
function Me(a2, b10) {
  return a2 && b10 ? a2 === b10 ? true : a2 && 3 === a2.nodeType ? false : b10 && 3 === b10.nodeType ? Me(a2, b10.parentNode) : "contains" in a2 ? a2.contains(b10) : a2.compareDocumentPosition ? !!(a2.compareDocumentPosition(b10) & 16) : false : false;
}
function Ne() {
  for (var a2 = window, b10 = Xa(); b10 instanceof a2.HTMLIFrameElement; ) {
    try {
      var c2 = "string" === typeof b10.contentWindow.location.href;
    } catch (d2) {
      c2 = false;
    }
    if (c2)
      a2 = b10.contentWindow;
    else
      break;
    b10 = Xa(a2.document);
  }
  return b10;
}
function Oe(a2) {
  var b10 = a2 && a2.nodeName && a2.nodeName.toLowerCase();
  return b10 && ("input" === b10 && ("text" === a2.type || "search" === a2.type || "tel" === a2.type || "url" === a2.type || "password" === a2.type) || "textarea" === b10 || "true" === a2.contentEditable);
}
var Pe = fa && "documentMode" in document && 11 >= document.documentMode, Qe = null, Re = null, Se = null, Te = false;
function Ue(a2, b10, c2) {
  var d2 = c2.window === c2 ? c2.document : 9 === c2.nodeType ? c2 : c2.ownerDocument;
  Te || null == Qe || Qe !== Xa(d2) || (d2 = Qe, "selectionStart" in d2 && Oe(d2) ? d2 = { start: d2.selectionStart, end: d2.selectionEnd } : (d2 = (d2.ownerDocument && d2.ownerDocument.defaultView || window).getSelection(), d2 = { anchorNode: d2.anchorNode, anchorOffset: d2.anchorOffset, focusNode: d2.focusNode, focusOffset: d2.focusOffset }), Se && Je(Se, d2) || (Se = d2, d2 = oe(Re, "onSelect"), 0 < d2.length && (b10 = new td("onSelect", "select", null, b10, c2), a2.push({ event: b10, listeners: d2 }), b10.target = Qe)));
}
Pc(
  "cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focusin focus focusout blur input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),
  0
);
Pc("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "), 1);
Pc(Oc, 2);
for (var Ve = "change selectionchange textInput compositionstart compositionend compositionupdate".split(" "), We = 0; We < Ve.length; We++)
  Nc.set(Ve[We], 0);
ea("onMouseEnter", ["mouseout", "mouseover"]);
ea("onMouseLeave", ["mouseout", "mouseover"]);
ea("onPointerEnter", ["pointerout", "pointerover"]);
ea("onPointerLeave", ["pointerout", "pointerover"]);
da("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
da("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
da("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
da("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
da("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
da("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
var Xe = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), Ye = new Set("cancel close invalid load scroll toggle".split(" ").concat(Xe));
function Ze(a2, b10, c2) {
  var d2 = a2.type || "unknown-event";
  a2.currentTarget = c2;
  Yb(d2, b10, void 0, a2);
  a2.currentTarget = null;
}
function se(a2, b10) {
  b10 = 0 !== (b10 & 4);
  for (var c2 = 0; c2 < a2.length; c2++) {
    var d2 = a2[c2], e3 = d2.event;
    d2 = d2.listeners;
    a: {
      var f2 = void 0;
      if (b10)
        for (var g2 = d2.length - 1; 0 <= g2; g2--) {
          var h2 = d2[g2], k2 = h2.instance, l2 = h2.currentTarget;
          h2 = h2.listener;
          if (k2 !== f2 && e3.isPropagationStopped())
            break a;
          Ze(e3, h2, l2);
          f2 = k2;
        }
      else
        for (g2 = 0; g2 < d2.length; g2++) {
          h2 = d2[g2];
          k2 = h2.instance;
          l2 = h2.currentTarget;
          h2 = h2.listener;
          if (k2 !== f2 && e3.isPropagationStopped())
            break a;
          Ze(e3, h2, l2);
          f2 = k2;
        }
    }
  }
  if (Ub)
    throw a2 = Vb, Ub = false, Vb = null, a2;
}
function G$1(a2, b10) {
  var c2 = $e(b10), d2 = a2 + "__bubble";
  c2.has(d2) || (af(b10, a2, 2, false), c2.add(d2));
}
var bf = "_reactListening" + Math.random().toString(36).slice(2);
function cf(a2) {
  a2[bf] || (a2[bf] = true, ba.forEach(function(b10) {
    Ye.has(b10) || df(b10, false, a2, null);
    df(b10, true, a2, null);
  }));
}
function df(a2, b10, c2, d2) {
  var e3 = 4 < arguments.length && void 0 !== arguments[4] ? arguments[4] : 0, f2 = c2;
  "selectionchange" === a2 && 9 !== c2.nodeType && (f2 = c2.ownerDocument);
  if (null !== d2 && !b10 && Ye.has(a2)) {
    if ("scroll" !== a2)
      return;
    e3 |= 2;
    f2 = d2;
  }
  var g2 = $e(f2), h2 = a2 + "__" + (b10 ? "capture" : "bubble");
  g2.has(h2) || (b10 && (e3 |= 4), af(f2, a2, e3, b10), g2.add(h2));
}
function af(a2, b10, c2, d2) {
  var e3 = Nc.get(b10);
  switch (void 0 === e3 ? 2 : e3) {
    case 0:
      e3 = gd;
      break;
    case 1:
      e3 = id$2;
      break;
    default:
      e3 = hd;
  }
  c2 = e3.bind(null, b10, c2, a2);
  e3 = void 0;
  !Pb || "touchstart" !== b10 && "touchmove" !== b10 && "wheel" !== b10 || (e3 = true);
  d2 ? void 0 !== e3 ? a2.addEventListener(b10, c2, { capture: true, passive: e3 }) : a2.addEventListener(b10, c2, true) : void 0 !== e3 ? a2.addEventListener(b10, c2, { passive: e3 }) : a2.addEventListener(b10, c2, false);
}
function jd(a2, b10, c2, d2, e3) {
  var f2 = d2;
  if (0 === (b10 & 1) && 0 === (b10 & 2) && null !== d2)
    a:
      for (; ; ) {
        if (null === d2)
          return;
        var g2 = d2.tag;
        if (3 === g2 || 4 === g2) {
          var h2 = d2.stateNode.containerInfo;
          if (h2 === e3 || 8 === h2.nodeType && h2.parentNode === e3)
            break;
          if (4 === g2)
            for (g2 = d2.return; null !== g2; ) {
              var k2 = g2.tag;
              if (3 === k2 || 4 === k2) {
                if (k2 = g2.stateNode.containerInfo, k2 === e3 || 8 === k2.nodeType && k2.parentNode === e3)
                  return;
              }
              g2 = g2.return;
            }
          for (; null !== h2; ) {
            g2 = wc(h2);
            if (null === g2)
              return;
            k2 = g2.tag;
            if (5 === k2 || 6 === k2) {
              d2 = f2 = g2;
              continue a;
            }
            h2 = h2.parentNode;
          }
        }
        d2 = d2.return;
      }
  Nb(function() {
    var d3 = f2, e4 = xb(c2), g3 = [];
    a: {
      var h3 = Mc.get(a2);
      if (void 0 !== h3) {
        var k3 = td, x2 = a2;
        switch (a2) {
          case "keypress":
            if (0 === od(c2))
              break a;
          case "keydown":
          case "keyup":
            k3 = Rd;
            break;
          case "focusin":
            x2 = "focus";
            k3 = Fd;
            break;
          case "focusout":
            x2 = "blur";
            k3 = Fd;
            break;
          case "beforeblur":
          case "afterblur":
            k3 = Fd;
            break;
          case "click":
            if (2 === c2.button)
              break a;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            k3 = Bd;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            k3 = Dd;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            k3 = Vd;
            break;
          case Ic:
          case Jc:
          case Kc:
            k3 = Hd;
            break;
          case Lc:
            k3 = Xd;
            break;
          case "scroll":
            k3 = vd;
            break;
          case "wheel":
            k3 = Zd;
            break;
          case "copy":
          case "cut":
          case "paste":
            k3 = Jd;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            k3 = Td;
        }
        var w2 = 0 !== (b10 & 4), z2 = !w2 && "scroll" === a2, u2 = w2 ? null !== h3 ? h3 + "Capture" : null : h3;
        w2 = [];
        for (var t2 = d3, q2; null !== t2; ) {
          q2 = t2;
          var v2 = q2.stateNode;
          5 === q2.tag && null !== v2 && (q2 = v2, null !== u2 && (v2 = Ob(t2, u2), null != v2 && w2.push(ef(t2, v2, q2))));
          if (z2)
            break;
          t2 = t2.return;
        }
        0 < w2.length && (h3 = new k3(h3, x2, null, c2, e4), g3.push({ event: h3, listeners: w2 }));
      }
    }
    if (0 === (b10 & 7)) {
      a: {
        h3 = "mouseover" === a2 || "pointerover" === a2;
        k3 = "mouseout" === a2 || "pointerout" === a2;
        if (h3 && 0 === (b10 & 16) && (x2 = c2.relatedTarget || c2.fromElement) && (wc(x2) || x2[ff]))
          break a;
        if (k3 || h3) {
          h3 = e4.window === e4 ? e4 : (h3 = e4.ownerDocument) ? h3.defaultView || h3.parentWindow : window;
          if (k3) {
            if (x2 = c2.relatedTarget || c2.toElement, k3 = d3, x2 = x2 ? wc(x2) : null, null !== x2 && (z2 = Zb(x2), x2 !== z2 || 5 !== x2.tag && 6 !== x2.tag))
              x2 = null;
          } else
            k3 = null, x2 = d3;
          if (k3 !== x2) {
            w2 = Bd;
            v2 = "onMouseLeave";
            u2 = "onMouseEnter";
            t2 = "mouse";
            if ("pointerout" === a2 || "pointerover" === a2)
              w2 = Td, v2 = "onPointerLeave", u2 = "onPointerEnter", t2 = "pointer";
            z2 = null == k3 ? h3 : ue(k3);
            q2 = null == x2 ? h3 : ue(x2);
            h3 = new w2(v2, t2 + "leave", k3, c2, e4);
            h3.target = z2;
            h3.relatedTarget = q2;
            v2 = null;
            wc(e4) === d3 && (w2 = new w2(u2, t2 + "enter", x2, c2, e4), w2.target = q2, w2.relatedTarget = z2, v2 = w2);
            z2 = v2;
            if (k3 && x2)
              b: {
                w2 = k3;
                u2 = x2;
                t2 = 0;
                for (q2 = w2; q2; q2 = gf(q2))
                  t2++;
                q2 = 0;
                for (v2 = u2; v2; v2 = gf(v2))
                  q2++;
                for (; 0 < t2 - q2; )
                  w2 = gf(w2), t2--;
                for (; 0 < q2 - t2; )
                  u2 = gf(u2), q2--;
                for (; t2--; ) {
                  if (w2 === u2 || null !== u2 && w2 === u2.alternate)
                    break b;
                  w2 = gf(w2);
                  u2 = gf(u2);
                }
                w2 = null;
              }
            else
              w2 = null;
            null !== k3 && hf(g3, h3, k3, w2, false);
            null !== x2 && null !== z2 && hf(g3, z2, x2, w2, true);
          }
        }
      }
      a: {
        h3 = d3 ? ue(d3) : window;
        k3 = h3.nodeName && h3.nodeName.toLowerCase();
        if ("select" === k3 || "input" === k3 && "file" === h3.type)
          var J2 = ve;
        else if (me(h3))
          if (we)
            J2 = Fe;
          else {
            J2 = De;
            var K2 = Ce;
          }
        else
          (k3 = h3.nodeName) && "input" === k3.toLowerCase() && ("checkbox" === h3.type || "radio" === h3.type) && (J2 = Ee);
        if (J2 && (J2 = J2(a2, d3))) {
          ne(g3, J2, c2, e4);
          break a;
        }
        K2 && K2(a2, h3, d3);
        "focusout" === a2 && (K2 = h3._wrapperState) && K2.controlled && "number" === h3.type && bb(h3, "number", h3.value);
      }
      K2 = d3 ? ue(d3) : window;
      switch (a2) {
        case "focusin":
          if (me(K2) || "true" === K2.contentEditable)
            Qe = K2, Re = d3, Se = null;
          break;
        case "focusout":
          Se = Re = Qe = null;
          break;
        case "mousedown":
          Te = true;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          Te = false;
          Ue(g3, c2, e4);
          break;
        case "selectionchange":
          if (Pe)
            break;
        case "keydown":
        case "keyup":
          Ue(g3, c2, e4);
      }
      var Q2;
      if (ae)
        b: {
          switch (a2) {
            case "compositionstart":
              var L2 = "onCompositionStart";
              break b;
            case "compositionend":
              L2 = "onCompositionEnd";
              break b;
            case "compositionupdate":
              L2 = "onCompositionUpdate";
              break b;
          }
          L2 = void 0;
        }
      else
        ie ? ge(a2, c2) && (L2 = "onCompositionEnd") : "keydown" === a2 && 229 === c2.keyCode && (L2 = "onCompositionStart");
      L2 && (de && "ko" !== c2.locale && (ie || "onCompositionStart" !== L2 ? "onCompositionEnd" === L2 && ie && (Q2 = nd()) : (kd = e4, ld = "value" in kd ? kd.value : kd.textContent, ie = true)), K2 = oe(d3, L2), 0 < K2.length && (L2 = new Ld(L2, a2, null, c2, e4), g3.push({ event: L2, listeners: K2 }), Q2 ? L2.data = Q2 : (Q2 = he(c2), null !== Q2 && (L2.data = Q2))));
      if (Q2 = ce ? je(a2, c2) : ke(a2, c2))
        d3 = oe(d3, "onBeforeInput"), 0 < d3.length && (e4 = new Ld(
          "onBeforeInput",
          "beforeinput",
          null,
          c2,
          e4
        ), g3.push({ event: e4, listeners: d3 }), e4.data = Q2);
    }
    se(g3, b10);
  });
}
function ef(a2, b10, c2) {
  return { instance: a2, listener: b10, currentTarget: c2 };
}
function oe(a2, b10) {
  for (var c2 = b10 + "Capture", d2 = []; null !== a2; ) {
    var e3 = a2, f2 = e3.stateNode;
    5 === e3.tag && null !== f2 && (e3 = f2, f2 = Ob(a2, c2), null != f2 && d2.unshift(ef(a2, f2, e3)), f2 = Ob(a2, b10), null != f2 && d2.push(ef(a2, f2, e3)));
    a2 = a2.return;
  }
  return d2;
}
function gf(a2) {
  if (null === a2)
    return null;
  do
    a2 = a2.return;
  while (a2 && 5 !== a2.tag);
  return a2 ? a2 : null;
}
function hf(a2, b10, c2, d2, e3) {
  for (var f2 = b10._reactName, g2 = []; null !== c2 && c2 !== d2; ) {
    var h2 = c2, k2 = h2.alternate, l2 = h2.stateNode;
    if (null !== k2 && k2 === d2)
      break;
    5 === h2.tag && null !== l2 && (h2 = l2, e3 ? (k2 = Ob(c2, f2), null != k2 && g2.unshift(ef(c2, k2, h2))) : e3 || (k2 = Ob(c2, f2), null != k2 && g2.push(ef(c2, k2, h2))));
    c2 = c2.return;
  }
  0 !== g2.length && a2.push({ event: b10, listeners: g2 });
}
function jf() {
}
var kf = null, lf = null;
function mf(a2, b10) {
  switch (a2) {
    case "button":
    case "input":
    case "select":
    case "textarea":
      return !!b10.autoFocus;
  }
  return false;
}
function nf(a2, b10) {
  return "textarea" === a2 || "option" === a2 || "noscript" === a2 || "string" === typeof b10.children || "number" === typeof b10.children || "object" === typeof b10.dangerouslySetInnerHTML && null !== b10.dangerouslySetInnerHTML && null != b10.dangerouslySetInnerHTML.__html;
}
var of = "function" === typeof setTimeout ? setTimeout : void 0, pf = "function" === typeof clearTimeout ? clearTimeout : void 0;
function qf(a2) {
  1 === a2.nodeType ? a2.textContent = "" : 9 === a2.nodeType && (a2 = a2.body, null != a2 && (a2.textContent = ""));
}
function rf(a2) {
  for (; null != a2; a2 = a2.nextSibling) {
    var b10 = a2.nodeType;
    if (1 === b10 || 3 === b10)
      break;
  }
  return a2;
}
function sf(a2) {
  a2 = a2.previousSibling;
  for (var b10 = 0; a2; ) {
    if (8 === a2.nodeType) {
      var c2 = a2.data;
      if ("$" === c2 || "$!" === c2 || "$?" === c2) {
        if (0 === b10)
          return a2;
        b10--;
      } else
        "/$" === c2 && b10++;
    }
    a2 = a2.previousSibling;
  }
  return null;
}
var tf = 0;
function uf(a2) {
  return { $$typeof: Ga, toString: a2, valueOf: a2 };
}
var vf = Math.random().toString(36).slice(2), wf = "__reactFiber$" + vf, xf = "__reactProps$" + vf, ff = "__reactContainer$" + vf, yf = "__reactEvents$" + vf;
function wc(a2) {
  var b10 = a2[wf];
  if (b10)
    return b10;
  for (var c2 = a2.parentNode; c2; ) {
    if (b10 = c2[ff] || c2[wf]) {
      c2 = b10.alternate;
      if (null !== b10.child || null !== c2 && null !== c2.child)
        for (a2 = sf(a2); null !== a2; ) {
          if (c2 = a2[wf])
            return c2;
          a2 = sf(a2);
        }
      return b10;
    }
    a2 = c2;
    c2 = a2.parentNode;
  }
  return null;
}
function Cb(a2) {
  a2 = a2[wf] || a2[ff];
  return !a2 || 5 !== a2.tag && 6 !== a2.tag && 13 !== a2.tag && 3 !== a2.tag ? null : a2;
}
function ue(a2) {
  if (5 === a2.tag || 6 === a2.tag)
    return a2.stateNode;
  throw Error(y$2(33));
}
function Db(a2) {
  return a2[xf] || null;
}
function $e(a2) {
  var b10 = a2[yf];
  void 0 === b10 && (b10 = a2[yf] = /* @__PURE__ */ new Set());
  return b10;
}
var zf = [], Af = -1;
function Bf(a2) {
  return { current: a2 };
}
function H$1(a2) {
  0 > Af || (a2.current = zf[Af], zf[Af] = null, Af--);
}
function I$1(a2, b10) {
  Af++;
  zf[Af] = a2.current;
  a2.current = b10;
}
var Cf = {}, M$1 = Bf(Cf), N$1 = Bf(false), Df = Cf;
function Ef(a2, b10) {
  var c2 = a2.type.contextTypes;
  if (!c2)
    return Cf;
  var d2 = a2.stateNode;
  if (d2 && d2.__reactInternalMemoizedUnmaskedChildContext === b10)
    return d2.__reactInternalMemoizedMaskedChildContext;
  var e3 = {}, f2;
  for (f2 in c2)
    e3[f2] = b10[f2];
  d2 && (a2 = a2.stateNode, a2.__reactInternalMemoizedUnmaskedChildContext = b10, a2.__reactInternalMemoizedMaskedChildContext = e3);
  return e3;
}
function Ff(a2) {
  a2 = a2.childContextTypes;
  return null !== a2 && void 0 !== a2;
}
function Gf() {
  H$1(N$1);
  H$1(M$1);
}
function Hf(a2, b10, c2) {
  if (M$1.current !== Cf)
    throw Error(y$2(168));
  I$1(M$1, b10);
  I$1(N$1, c2);
}
function If(a2, b10, c2) {
  var d2 = a2.stateNode;
  a2 = b10.childContextTypes;
  if ("function" !== typeof d2.getChildContext)
    return c2;
  d2 = d2.getChildContext();
  for (var e3 in d2)
    if (!(e3 in a2))
      throw Error(y$2(108, Ra(b10) || "Unknown", e3));
  return m$5({}, c2, d2);
}
function Jf(a2) {
  a2 = (a2 = a2.stateNode) && a2.__reactInternalMemoizedMergedChildContext || Cf;
  Df = M$1.current;
  I$1(M$1, a2);
  I$1(N$1, N$1.current);
  return true;
}
function Kf(a2, b10, c2) {
  var d2 = a2.stateNode;
  if (!d2)
    throw Error(y$2(169));
  c2 ? (a2 = If(a2, b10, Df), d2.__reactInternalMemoizedMergedChildContext = a2, H$1(N$1), H$1(M$1), I$1(M$1, a2)) : H$1(N$1);
  I$1(N$1, c2);
}
var Lf = null, Mf = null, Nf = r$4.unstable_runWithPriority, Of = r$4.unstable_scheduleCallback, Pf = r$4.unstable_cancelCallback, Qf = r$4.unstable_shouldYield, Rf = r$4.unstable_requestPaint, Sf = r$4.unstable_now, Tf = r$4.unstable_getCurrentPriorityLevel, Uf = r$4.unstable_ImmediatePriority, Vf = r$4.unstable_UserBlockingPriority, Wf = r$4.unstable_NormalPriority, Xf = r$4.unstable_LowPriority, Yf = r$4.unstable_IdlePriority, Zf = {}, $f = void 0 !== Rf ? Rf : function() {
}, ag = null, bg = null, cg = false, dg = Sf(), O$1 = 1e4 > dg ? Sf : function() {
  return Sf() - dg;
};
function eg() {
  switch (Tf()) {
    case Uf:
      return 99;
    case Vf:
      return 98;
    case Wf:
      return 97;
    case Xf:
      return 96;
    case Yf:
      return 95;
    default:
      throw Error(y$2(332));
  }
}
function fg(a2) {
  switch (a2) {
    case 99:
      return Uf;
    case 98:
      return Vf;
    case 97:
      return Wf;
    case 96:
      return Xf;
    case 95:
      return Yf;
    default:
      throw Error(y$2(332));
  }
}
function gg(a2, b10) {
  a2 = fg(a2);
  return Nf(a2, b10);
}
function hg(a2, b10, c2) {
  a2 = fg(a2);
  return Of(a2, b10, c2);
}
function ig() {
  if (null !== bg) {
    var a2 = bg;
    bg = null;
    Pf(a2);
  }
  jg();
}
function jg() {
  if (!cg && null !== ag) {
    cg = true;
    var a2 = 0;
    try {
      var b10 = ag;
      gg(99, function() {
        for (; a2 < b10.length; a2++) {
          var c2 = b10[a2];
          do
            c2 = c2(true);
          while (null !== c2);
        }
      });
      ag = null;
    } catch (c2) {
      throw null !== ag && (ag = ag.slice(a2 + 1)), Of(Uf, ig), c2;
    } finally {
      cg = false;
    }
  }
}
var kg = ra.ReactCurrentBatchConfig;
function lg(a2, b10) {
  if (a2 && a2.defaultProps) {
    b10 = m$5({}, b10);
    a2 = a2.defaultProps;
    for (var c2 in a2)
      void 0 === b10[c2] && (b10[c2] = a2[c2]);
    return b10;
  }
  return b10;
}
var mg = Bf(null), ng = null, og = null, pg = null;
function qg() {
  pg = og = ng = null;
}
function rg(a2) {
  var b10 = mg.current;
  H$1(mg);
  a2.type._context._currentValue = b10;
}
function sg(a2, b10) {
  for (; null !== a2; ) {
    var c2 = a2.alternate;
    if ((a2.childLanes & b10) === b10)
      if (null === c2 || (c2.childLanes & b10) === b10)
        break;
      else
        c2.childLanes |= b10;
    else
      a2.childLanes |= b10, null !== c2 && (c2.childLanes |= b10);
    a2 = a2.return;
  }
}
function tg(a2, b10) {
  ng = a2;
  pg = og = null;
  a2 = a2.dependencies;
  null !== a2 && null !== a2.firstContext && (0 !== (a2.lanes & b10) && (ug = true), a2.firstContext = null);
}
function vg(a2, b10) {
  if (pg !== a2 && false !== b10 && 0 !== b10) {
    if ("number" !== typeof b10 || 1073741823 === b10)
      pg = a2, b10 = 1073741823;
    b10 = { context: a2, observedBits: b10, next: null };
    if (null === og) {
      if (null === ng)
        throw Error(y$2(308));
      og = b10;
      ng.dependencies = { lanes: 0, firstContext: b10, responders: null };
    } else
      og = og.next = b10;
  }
  return a2._currentValue;
}
var wg = false;
function xg(a2) {
  a2.updateQueue = { baseState: a2.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null }, effects: null };
}
function yg(a2, b10) {
  a2 = a2.updateQueue;
  b10.updateQueue === a2 && (b10.updateQueue = { baseState: a2.baseState, firstBaseUpdate: a2.firstBaseUpdate, lastBaseUpdate: a2.lastBaseUpdate, shared: a2.shared, effects: a2.effects });
}
function zg(a2, b10) {
  return { eventTime: a2, lane: b10, tag: 0, payload: null, callback: null, next: null };
}
function Ag(a2, b10) {
  a2 = a2.updateQueue;
  if (null !== a2) {
    a2 = a2.shared;
    var c2 = a2.pending;
    null === c2 ? b10.next = b10 : (b10.next = c2.next, c2.next = b10);
    a2.pending = b10;
  }
}
function Bg(a2, b10) {
  var c2 = a2.updateQueue, d2 = a2.alternate;
  if (null !== d2 && (d2 = d2.updateQueue, c2 === d2)) {
    var e3 = null, f2 = null;
    c2 = c2.firstBaseUpdate;
    if (null !== c2) {
      do {
        var g2 = { eventTime: c2.eventTime, lane: c2.lane, tag: c2.tag, payload: c2.payload, callback: c2.callback, next: null };
        null === f2 ? e3 = f2 = g2 : f2 = f2.next = g2;
        c2 = c2.next;
      } while (null !== c2);
      null === f2 ? e3 = f2 = b10 : f2 = f2.next = b10;
    } else
      e3 = f2 = b10;
    c2 = { baseState: d2.baseState, firstBaseUpdate: e3, lastBaseUpdate: f2, shared: d2.shared, effects: d2.effects };
    a2.updateQueue = c2;
    return;
  }
  a2 = c2.lastBaseUpdate;
  null === a2 ? c2.firstBaseUpdate = b10 : a2.next = b10;
  c2.lastBaseUpdate = b10;
}
function Cg(a2, b10, c2, d2) {
  var e3 = a2.updateQueue;
  wg = false;
  var f2 = e3.firstBaseUpdate, g2 = e3.lastBaseUpdate, h2 = e3.shared.pending;
  if (null !== h2) {
    e3.shared.pending = null;
    var k2 = h2, l2 = k2.next;
    k2.next = null;
    null === g2 ? f2 = l2 : g2.next = l2;
    g2 = k2;
    var n2 = a2.alternate;
    if (null !== n2) {
      n2 = n2.updateQueue;
      var A2 = n2.lastBaseUpdate;
      A2 !== g2 && (null === A2 ? n2.firstBaseUpdate = l2 : A2.next = l2, n2.lastBaseUpdate = k2);
    }
  }
  if (null !== f2) {
    A2 = e3.baseState;
    g2 = 0;
    n2 = l2 = k2 = null;
    do {
      h2 = f2.lane;
      var p2 = f2.eventTime;
      if ((d2 & h2) === h2) {
        null !== n2 && (n2 = n2.next = {
          eventTime: p2,
          lane: 0,
          tag: f2.tag,
          payload: f2.payload,
          callback: f2.callback,
          next: null
        });
        a: {
          var C2 = a2, x2 = f2;
          h2 = b10;
          p2 = c2;
          switch (x2.tag) {
            case 1:
              C2 = x2.payload;
              if ("function" === typeof C2) {
                A2 = C2.call(p2, A2, h2);
                break a;
              }
              A2 = C2;
              break a;
            case 3:
              C2.flags = C2.flags & -4097 | 64;
            case 0:
              C2 = x2.payload;
              h2 = "function" === typeof C2 ? C2.call(p2, A2, h2) : C2;
              if (null === h2 || void 0 === h2)
                break a;
              A2 = m$5({}, A2, h2);
              break a;
            case 2:
              wg = true;
          }
        }
        null !== f2.callback && (a2.flags |= 32, h2 = e3.effects, null === h2 ? e3.effects = [f2] : h2.push(f2));
      } else
        p2 = { eventTime: p2, lane: h2, tag: f2.tag, payload: f2.payload, callback: f2.callback, next: null }, null === n2 ? (l2 = n2 = p2, k2 = A2) : n2 = n2.next = p2, g2 |= h2;
      f2 = f2.next;
      if (null === f2)
        if (h2 = e3.shared.pending, null === h2)
          break;
        else
          f2 = h2.next, h2.next = null, e3.lastBaseUpdate = h2, e3.shared.pending = null;
    } while (1);
    null === n2 && (k2 = A2);
    e3.baseState = k2;
    e3.firstBaseUpdate = l2;
    e3.lastBaseUpdate = n2;
    Dg |= g2;
    a2.lanes = g2;
    a2.memoizedState = A2;
  }
}
function Eg(a2, b10, c2) {
  a2 = b10.effects;
  b10.effects = null;
  if (null !== a2)
    for (b10 = 0; b10 < a2.length; b10++) {
      var d2 = a2[b10], e3 = d2.callback;
      if (null !== e3) {
        d2.callback = null;
        d2 = c2;
        if ("function" !== typeof e3)
          throw Error(y$2(191, e3));
        e3.call(d2);
      }
    }
}
var Fg = new aa.Component().refs;
function Gg(a2, b10, c2, d2) {
  b10 = a2.memoizedState;
  c2 = c2(d2, b10);
  c2 = null === c2 || void 0 === c2 ? b10 : m$5({}, b10, c2);
  a2.memoizedState = c2;
  0 === a2.lanes && (a2.updateQueue.baseState = c2);
}
var Kg = { isMounted: function(a2) {
  return (a2 = a2._reactInternals) ? Zb(a2) === a2 : false;
}, enqueueSetState: function(a2, b10, c2) {
  a2 = a2._reactInternals;
  var d2 = Hg(), e3 = Ig(a2), f2 = zg(d2, e3);
  f2.payload = b10;
  void 0 !== c2 && null !== c2 && (f2.callback = c2);
  Ag(a2, f2);
  Jg(a2, e3, d2);
}, enqueueReplaceState: function(a2, b10, c2) {
  a2 = a2._reactInternals;
  var d2 = Hg(), e3 = Ig(a2), f2 = zg(d2, e3);
  f2.tag = 1;
  f2.payload = b10;
  void 0 !== c2 && null !== c2 && (f2.callback = c2);
  Ag(a2, f2);
  Jg(a2, e3, d2);
}, enqueueForceUpdate: function(a2, b10) {
  a2 = a2._reactInternals;
  var c2 = Hg(), d2 = Ig(a2), e3 = zg(c2, d2);
  e3.tag = 2;
  void 0 !== b10 && null !== b10 && (e3.callback = b10);
  Ag(a2, e3);
  Jg(a2, d2, c2);
} };
function Lg(a2, b10, c2, d2, e3, f2, g2) {
  a2 = a2.stateNode;
  return "function" === typeof a2.shouldComponentUpdate ? a2.shouldComponentUpdate(d2, f2, g2) : b10.prototype && b10.prototype.isPureReactComponent ? !Je(c2, d2) || !Je(e3, f2) : true;
}
function Mg(a2, b10, c2) {
  var d2 = false, e3 = Cf;
  var f2 = b10.contextType;
  "object" === typeof f2 && null !== f2 ? f2 = vg(f2) : (e3 = Ff(b10) ? Df : M$1.current, d2 = b10.contextTypes, f2 = (d2 = null !== d2 && void 0 !== d2) ? Ef(a2, e3) : Cf);
  b10 = new b10(c2, f2);
  a2.memoizedState = null !== b10.state && void 0 !== b10.state ? b10.state : null;
  b10.updater = Kg;
  a2.stateNode = b10;
  b10._reactInternals = a2;
  d2 && (a2 = a2.stateNode, a2.__reactInternalMemoizedUnmaskedChildContext = e3, a2.__reactInternalMemoizedMaskedChildContext = f2);
  return b10;
}
function Ng(a2, b10, c2, d2) {
  a2 = b10.state;
  "function" === typeof b10.componentWillReceiveProps && b10.componentWillReceiveProps(c2, d2);
  "function" === typeof b10.UNSAFE_componentWillReceiveProps && b10.UNSAFE_componentWillReceiveProps(c2, d2);
  b10.state !== a2 && Kg.enqueueReplaceState(b10, b10.state, null);
}
function Og(a2, b10, c2, d2) {
  var e3 = a2.stateNode;
  e3.props = c2;
  e3.state = a2.memoizedState;
  e3.refs = Fg;
  xg(a2);
  var f2 = b10.contextType;
  "object" === typeof f2 && null !== f2 ? e3.context = vg(f2) : (f2 = Ff(b10) ? Df : M$1.current, e3.context = Ef(a2, f2));
  Cg(a2, c2, e3, d2);
  e3.state = a2.memoizedState;
  f2 = b10.getDerivedStateFromProps;
  "function" === typeof f2 && (Gg(a2, b10, f2, c2), e3.state = a2.memoizedState);
  "function" === typeof b10.getDerivedStateFromProps || "function" === typeof e3.getSnapshotBeforeUpdate || "function" !== typeof e3.UNSAFE_componentWillMount && "function" !== typeof e3.componentWillMount || (b10 = e3.state, "function" === typeof e3.componentWillMount && e3.componentWillMount(), "function" === typeof e3.UNSAFE_componentWillMount && e3.UNSAFE_componentWillMount(), b10 !== e3.state && Kg.enqueueReplaceState(e3, e3.state, null), Cg(a2, c2, e3, d2), e3.state = a2.memoizedState);
  "function" === typeof e3.componentDidMount && (a2.flags |= 4);
}
var Pg = Array.isArray;
function Qg(a2, b10, c2) {
  a2 = c2.ref;
  if (null !== a2 && "function" !== typeof a2 && "object" !== typeof a2) {
    if (c2._owner) {
      c2 = c2._owner;
      if (c2) {
        if (1 !== c2.tag)
          throw Error(y$2(309));
        var d2 = c2.stateNode;
      }
      if (!d2)
        throw Error(y$2(147, a2));
      var e3 = "" + a2;
      if (null !== b10 && null !== b10.ref && "function" === typeof b10.ref && b10.ref._stringRef === e3)
        return b10.ref;
      b10 = function(a3) {
        var b11 = d2.refs;
        b11 === Fg && (b11 = d2.refs = {});
        null === a3 ? delete b11[e3] : b11[e3] = a3;
      };
      b10._stringRef = e3;
      return b10;
    }
    if ("string" !== typeof a2)
      throw Error(y$2(284));
    if (!c2._owner)
      throw Error(y$2(290, a2));
  }
  return a2;
}
function Rg(a2, b10) {
  if ("textarea" !== a2.type)
    throw Error(y$2(31, "[object Object]" === Object.prototype.toString.call(b10) ? "object with keys {" + Object.keys(b10).join(", ") + "}" : b10));
}
function Sg(a2) {
  function b10(b11, c3) {
    if (a2) {
      var d3 = b11.lastEffect;
      null !== d3 ? (d3.nextEffect = c3, b11.lastEffect = c3) : b11.firstEffect = b11.lastEffect = c3;
      c3.nextEffect = null;
      c3.flags = 8;
    }
  }
  function c2(c3, d3) {
    if (!a2)
      return null;
    for (; null !== d3; )
      b10(c3, d3), d3 = d3.sibling;
    return null;
  }
  function d2(a3, b11) {
    for (a3 = /* @__PURE__ */ new Map(); null !== b11; )
      null !== b11.key ? a3.set(b11.key, b11) : a3.set(b11.index, b11), b11 = b11.sibling;
    return a3;
  }
  function e3(a3, b11) {
    a3 = Tg(a3, b11);
    a3.index = 0;
    a3.sibling = null;
    return a3;
  }
  function f2(b11, c3, d3) {
    b11.index = d3;
    if (!a2)
      return c3;
    d3 = b11.alternate;
    if (null !== d3)
      return d3 = d3.index, d3 < c3 ? (b11.flags = 2, c3) : d3;
    b11.flags = 2;
    return c3;
  }
  function g2(b11) {
    a2 && null === b11.alternate && (b11.flags = 2);
    return b11;
  }
  function h2(a3, b11, c3, d3) {
    if (null === b11 || 6 !== b11.tag)
      return b11 = Ug(c3, a3.mode, d3), b11.return = a3, b11;
    b11 = e3(b11, c3);
    b11.return = a3;
    return b11;
  }
  function k2(a3, b11, c3, d3) {
    if (null !== b11 && b11.elementType === c3.type)
      return d3 = e3(b11, c3.props), d3.ref = Qg(a3, b11, c3), d3.return = a3, d3;
    d3 = Vg(c3.type, c3.key, c3.props, null, a3.mode, d3);
    d3.ref = Qg(a3, b11, c3);
    d3.return = a3;
    return d3;
  }
  function l2(a3, b11, c3, d3) {
    if (null === b11 || 4 !== b11.tag || b11.stateNode.containerInfo !== c3.containerInfo || b11.stateNode.implementation !== c3.implementation)
      return b11 = Wg(c3, a3.mode, d3), b11.return = a3, b11;
    b11 = e3(b11, c3.children || []);
    b11.return = a3;
    return b11;
  }
  function n2(a3, b11, c3, d3, f3) {
    if (null === b11 || 7 !== b11.tag)
      return b11 = Xg(c3, a3.mode, d3, f3), b11.return = a3, b11;
    b11 = e3(b11, c3);
    b11.return = a3;
    return b11;
  }
  function A2(a3, b11, c3) {
    if ("string" === typeof b11 || "number" === typeof b11)
      return b11 = Ug("" + b11, a3.mode, c3), b11.return = a3, b11;
    if ("object" === typeof b11 && null !== b11) {
      switch (b11.$$typeof) {
        case sa:
          return c3 = Vg(b11.type, b11.key, b11.props, null, a3.mode, c3), c3.ref = Qg(a3, null, b11), c3.return = a3, c3;
        case ta:
          return b11 = Wg(b11, a3.mode, c3), b11.return = a3, b11;
      }
      if (Pg(b11) || La(b11))
        return b11 = Xg(
          b11,
          a3.mode,
          c3,
          null
        ), b11.return = a3, b11;
      Rg(a3, b11);
    }
    return null;
  }
  function p2(a3, b11, c3, d3) {
    var e4 = null !== b11 ? b11.key : null;
    if ("string" === typeof c3 || "number" === typeof c3)
      return null !== e4 ? null : h2(a3, b11, "" + c3, d3);
    if ("object" === typeof c3 && null !== c3) {
      switch (c3.$$typeof) {
        case sa:
          return c3.key === e4 ? c3.type === ua ? n2(a3, b11, c3.props.children, d3, e4) : k2(a3, b11, c3, d3) : null;
        case ta:
          return c3.key === e4 ? l2(a3, b11, c3, d3) : null;
      }
      if (Pg(c3) || La(c3))
        return null !== e4 ? null : n2(a3, b11, c3, d3, null);
      Rg(a3, c3);
    }
    return null;
  }
  function C2(a3, b11, c3, d3, e4) {
    if ("string" === typeof d3 || "number" === typeof d3)
      return a3 = a3.get(c3) || null, h2(b11, a3, "" + d3, e4);
    if ("object" === typeof d3 && null !== d3) {
      switch (d3.$$typeof) {
        case sa:
          return a3 = a3.get(null === d3.key ? c3 : d3.key) || null, d3.type === ua ? n2(b11, a3, d3.props.children, e4, d3.key) : k2(b11, a3, d3, e4);
        case ta:
          return a3 = a3.get(null === d3.key ? c3 : d3.key) || null, l2(b11, a3, d3, e4);
      }
      if (Pg(d3) || La(d3))
        return a3 = a3.get(c3) || null, n2(b11, a3, d3, e4, null);
      Rg(b11, d3);
    }
    return null;
  }
  function x2(e4, g3, h3, k3) {
    for (var l3 = null, t2 = null, u2 = g3, z2 = g3 = 0, q2 = null; null !== u2 && z2 < h3.length; z2++) {
      u2.index > z2 ? (q2 = u2, u2 = null) : q2 = u2.sibling;
      var n3 = p2(e4, u2, h3[z2], k3);
      if (null === n3) {
        null === u2 && (u2 = q2);
        break;
      }
      a2 && u2 && null === n3.alternate && b10(e4, u2);
      g3 = f2(n3, g3, z2);
      null === t2 ? l3 = n3 : t2.sibling = n3;
      t2 = n3;
      u2 = q2;
    }
    if (z2 === h3.length)
      return c2(e4, u2), l3;
    if (null === u2) {
      for (; z2 < h3.length; z2++)
        u2 = A2(e4, h3[z2], k3), null !== u2 && (g3 = f2(u2, g3, z2), null === t2 ? l3 = u2 : t2.sibling = u2, t2 = u2);
      return l3;
    }
    for (u2 = d2(e4, u2); z2 < h3.length; z2++)
      q2 = C2(u2, e4, z2, h3[z2], k3), null !== q2 && (a2 && null !== q2.alternate && u2.delete(null === q2.key ? z2 : q2.key), g3 = f2(q2, g3, z2), null === t2 ? l3 = q2 : t2.sibling = q2, t2 = q2);
    a2 && u2.forEach(function(a3) {
      return b10(e4, a3);
    });
    return l3;
  }
  function w2(e4, g3, h3, k3) {
    var l3 = La(h3);
    if ("function" !== typeof l3)
      throw Error(y$2(150));
    h3 = l3.call(h3);
    if (null == h3)
      throw Error(y$2(151));
    for (var t2 = l3 = null, u2 = g3, z2 = g3 = 0, q2 = null, n3 = h3.next(); null !== u2 && !n3.done; z2++, n3 = h3.next()) {
      u2.index > z2 ? (q2 = u2, u2 = null) : q2 = u2.sibling;
      var w3 = p2(e4, u2, n3.value, k3);
      if (null === w3) {
        null === u2 && (u2 = q2);
        break;
      }
      a2 && u2 && null === w3.alternate && b10(e4, u2);
      g3 = f2(w3, g3, z2);
      null === t2 ? l3 = w3 : t2.sibling = w3;
      t2 = w3;
      u2 = q2;
    }
    if (n3.done)
      return c2(e4, u2), l3;
    if (null === u2) {
      for (; !n3.done; z2++, n3 = h3.next())
        n3 = A2(e4, n3.value, k3), null !== n3 && (g3 = f2(n3, g3, z2), null === t2 ? l3 = n3 : t2.sibling = n3, t2 = n3);
      return l3;
    }
    for (u2 = d2(e4, u2); !n3.done; z2++, n3 = h3.next())
      n3 = C2(u2, e4, z2, n3.value, k3), null !== n3 && (a2 && null !== n3.alternate && u2.delete(null === n3.key ? z2 : n3.key), g3 = f2(n3, g3, z2), null === t2 ? l3 = n3 : t2.sibling = n3, t2 = n3);
    a2 && u2.forEach(function(a3) {
      return b10(e4, a3);
    });
    return l3;
  }
  return function(a3, d3, f3, h3) {
    var k3 = "object" === typeof f3 && null !== f3 && f3.type === ua && null === f3.key;
    k3 && (f3 = f3.props.children);
    var l3 = "object" === typeof f3 && null !== f3;
    if (l3)
      switch (f3.$$typeof) {
        case sa:
          a: {
            l3 = f3.key;
            for (k3 = d3; null !== k3; ) {
              if (k3.key === l3) {
                switch (k3.tag) {
                  case 7:
                    if (f3.type === ua) {
                      c2(a3, k3.sibling);
                      d3 = e3(k3, f3.props.children);
                      d3.return = a3;
                      a3 = d3;
                      break a;
                    }
                    break;
                  default:
                    if (k3.elementType === f3.type) {
                      c2(a3, k3.sibling);
                      d3 = e3(k3, f3.props);
                      d3.ref = Qg(a3, k3, f3);
                      d3.return = a3;
                      a3 = d3;
                      break a;
                    }
                }
                c2(a3, k3);
                break;
              } else
                b10(a3, k3);
              k3 = k3.sibling;
            }
            f3.type === ua ? (d3 = Xg(f3.props.children, a3.mode, h3, f3.key), d3.return = a3, a3 = d3) : (h3 = Vg(f3.type, f3.key, f3.props, null, a3.mode, h3), h3.ref = Qg(a3, d3, f3), h3.return = a3, a3 = h3);
          }
          return g2(a3);
        case ta:
          a: {
            for (k3 = f3.key; null !== d3; ) {
              if (d3.key === k3)
                if (4 === d3.tag && d3.stateNode.containerInfo === f3.containerInfo && d3.stateNode.implementation === f3.implementation) {
                  c2(a3, d3.sibling);
                  d3 = e3(d3, f3.children || []);
                  d3.return = a3;
                  a3 = d3;
                  break a;
                } else {
                  c2(a3, d3);
                  break;
                }
              else
                b10(a3, d3);
              d3 = d3.sibling;
            }
            d3 = Wg(f3, a3.mode, h3);
            d3.return = a3;
            a3 = d3;
          }
          return g2(a3);
      }
    if ("string" === typeof f3 || "number" === typeof f3)
      return f3 = "" + f3, null !== d3 && 6 === d3.tag ? (c2(a3, d3.sibling), d3 = e3(d3, f3), d3.return = a3, a3 = d3) : (c2(a3, d3), d3 = Ug(f3, a3.mode, h3), d3.return = a3, a3 = d3), g2(a3);
    if (Pg(f3))
      return x2(a3, d3, f3, h3);
    if (La(f3))
      return w2(a3, d3, f3, h3);
    l3 && Rg(a3, f3);
    if ("undefined" === typeof f3 && !k3)
      switch (a3.tag) {
        case 1:
        case 22:
        case 0:
        case 11:
        case 15:
          throw Error(y$2(152, Ra(a3.type) || "Component"));
      }
    return c2(a3, d3);
  };
}
var Yg = Sg(true), Zg = Sg(false), $g = {}, ah = Bf($g), bh = Bf($g), ch$1 = Bf($g);
function dh(a2) {
  if (a2 === $g)
    throw Error(y$2(174));
  return a2;
}
function eh(a2, b10) {
  I$1(ch$1, b10);
  I$1(bh, a2);
  I$1(ah, $g);
  a2 = b10.nodeType;
  switch (a2) {
    case 9:
    case 11:
      b10 = (b10 = b10.documentElement) ? b10.namespaceURI : mb(null, "");
      break;
    default:
      a2 = 8 === a2 ? b10.parentNode : b10, b10 = a2.namespaceURI || null, a2 = a2.tagName, b10 = mb(b10, a2);
  }
  H$1(ah);
  I$1(ah, b10);
}
function fh() {
  H$1(ah);
  H$1(bh);
  H$1(ch$1);
}
function gh(a2) {
  dh(ch$1.current);
  var b10 = dh(ah.current);
  var c2 = mb(b10, a2.type);
  b10 !== c2 && (I$1(bh, a2), I$1(ah, c2));
}
function hh(a2) {
  bh.current === a2 && (H$1(ah), H$1(bh));
}
var P$1 = Bf(0);
function ih(a2) {
  for (var b10 = a2; null !== b10; ) {
    if (13 === b10.tag) {
      var c2 = b10.memoizedState;
      if (null !== c2 && (c2 = c2.dehydrated, null === c2 || "$?" === c2.data || "$!" === c2.data))
        return b10;
    } else if (19 === b10.tag && void 0 !== b10.memoizedProps.revealOrder) {
      if (0 !== (b10.flags & 64))
        return b10;
    } else if (null !== b10.child) {
      b10.child.return = b10;
      b10 = b10.child;
      continue;
    }
    if (b10 === a2)
      break;
    for (; null === b10.sibling; ) {
      if (null === b10.return || b10.return === a2)
        return null;
      b10 = b10.return;
    }
    b10.sibling.return = b10.return;
    b10 = b10.sibling;
  }
  return null;
}
var jh = null, kh = null, lh = false;
function mh(a2, b10) {
  var c2 = nh(5, null, null, 0);
  c2.elementType = "DELETED";
  c2.type = "DELETED";
  c2.stateNode = b10;
  c2.return = a2;
  c2.flags = 8;
  null !== a2.lastEffect ? (a2.lastEffect.nextEffect = c2, a2.lastEffect = c2) : a2.firstEffect = a2.lastEffect = c2;
}
function oh(a2, b10) {
  switch (a2.tag) {
    case 5:
      var c2 = a2.type;
      b10 = 1 !== b10.nodeType || c2.toLowerCase() !== b10.nodeName.toLowerCase() ? null : b10;
      return null !== b10 ? (a2.stateNode = b10, true) : false;
    case 6:
      return b10 = "" === a2.pendingProps || 3 !== b10.nodeType ? null : b10, null !== b10 ? (a2.stateNode = b10, true) : false;
    case 13:
      return false;
    default:
      return false;
  }
}
function ph(a2) {
  if (lh) {
    var b10 = kh;
    if (b10) {
      var c2 = b10;
      if (!oh(a2, b10)) {
        b10 = rf(c2.nextSibling);
        if (!b10 || !oh(a2, b10)) {
          a2.flags = a2.flags & -1025 | 2;
          lh = false;
          jh = a2;
          return;
        }
        mh(jh, c2);
      }
      jh = a2;
      kh = rf(b10.firstChild);
    } else
      a2.flags = a2.flags & -1025 | 2, lh = false, jh = a2;
  }
}
function qh(a2) {
  for (a2 = a2.return; null !== a2 && 5 !== a2.tag && 3 !== a2.tag && 13 !== a2.tag; )
    a2 = a2.return;
  jh = a2;
}
function rh(a2) {
  if (a2 !== jh)
    return false;
  if (!lh)
    return qh(a2), lh = true, false;
  var b10 = a2.type;
  if (5 !== a2.tag || "head" !== b10 && "body" !== b10 && !nf(b10, a2.memoizedProps))
    for (b10 = kh; b10; )
      mh(a2, b10), b10 = rf(b10.nextSibling);
  qh(a2);
  if (13 === a2.tag) {
    a2 = a2.memoizedState;
    a2 = null !== a2 ? a2.dehydrated : null;
    if (!a2)
      throw Error(y$2(317));
    a: {
      a2 = a2.nextSibling;
      for (b10 = 0; a2; ) {
        if (8 === a2.nodeType) {
          var c2 = a2.data;
          if ("/$" === c2) {
            if (0 === b10) {
              kh = rf(a2.nextSibling);
              break a;
            }
            b10--;
          } else
            "$" !== c2 && "$!" !== c2 && "$?" !== c2 || b10++;
        }
        a2 = a2.nextSibling;
      }
      kh = null;
    }
  } else
    kh = jh ? rf(a2.stateNode.nextSibling) : null;
  return true;
}
function sh() {
  kh = jh = null;
  lh = false;
}
var th = [];
function uh() {
  for (var a2 = 0; a2 < th.length; a2++)
    th[a2]._workInProgressVersionPrimary = null;
  th.length = 0;
}
var vh = ra.ReactCurrentDispatcher, wh = ra.ReactCurrentBatchConfig, xh = 0, R$1 = null, S$1 = null, T = null, yh = false, zh = false;
function Ah() {
  throw Error(y$2(321));
}
function Bh(a2, b10) {
  if (null === b10)
    return false;
  for (var c2 = 0; c2 < b10.length && c2 < a2.length; c2++)
    if (!He(a2[c2], b10[c2]))
      return false;
  return true;
}
function Ch(a2, b10, c2, d2, e3, f2) {
  xh = f2;
  R$1 = b10;
  b10.memoizedState = null;
  b10.updateQueue = null;
  b10.lanes = 0;
  vh.current = null === a2 || null === a2.memoizedState ? Dh : Eh;
  a2 = c2(d2, e3);
  if (zh) {
    f2 = 0;
    do {
      zh = false;
      if (!(25 > f2))
        throw Error(y$2(301));
      f2 += 1;
      T = S$1 = null;
      b10.updateQueue = null;
      vh.current = Fh;
      a2 = c2(d2, e3);
    } while (zh);
  }
  vh.current = Gh;
  b10 = null !== S$1 && null !== S$1.next;
  xh = 0;
  T = S$1 = R$1 = null;
  yh = false;
  if (b10)
    throw Error(y$2(300));
  return a2;
}
function Hh() {
  var a2 = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
  null === T ? R$1.memoizedState = T = a2 : T = T.next = a2;
  return T;
}
function Ih() {
  if (null === S$1) {
    var a2 = R$1.alternate;
    a2 = null !== a2 ? a2.memoizedState : null;
  } else
    a2 = S$1.next;
  var b10 = null === T ? R$1.memoizedState : T.next;
  if (null !== b10)
    T = b10, S$1 = a2;
  else {
    if (null === a2)
      throw Error(y$2(310));
    S$1 = a2;
    a2 = { memoizedState: S$1.memoizedState, baseState: S$1.baseState, baseQueue: S$1.baseQueue, queue: S$1.queue, next: null };
    null === T ? R$1.memoizedState = T = a2 : T = T.next = a2;
  }
  return T;
}
function Jh(a2, b10) {
  return "function" === typeof b10 ? b10(a2) : b10;
}
function Kh(a2) {
  var b10 = Ih(), c2 = b10.queue;
  if (null === c2)
    throw Error(y$2(311));
  c2.lastRenderedReducer = a2;
  var d2 = S$1, e3 = d2.baseQueue, f2 = c2.pending;
  if (null !== f2) {
    if (null !== e3) {
      var g2 = e3.next;
      e3.next = f2.next;
      f2.next = g2;
    }
    d2.baseQueue = e3 = f2;
    c2.pending = null;
  }
  if (null !== e3) {
    e3 = e3.next;
    d2 = d2.baseState;
    var h2 = g2 = f2 = null, k2 = e3;
    do {
      var l2 = k2.lane;
      if ((xh & l2) === l2)
        null !== h2 && (h2 = h2.next = { lane: 0, action: k2.action, eagerReducer: k2.eagerReducer, eagerState: k2.eagerState, next: null }), d2 = k2.eagerReducer === a2 ? k2.eagerState : a2(d2, k2.action);
      else {
        var n2 = {
          lane: l2,
          action: k2.action,
          eagerReducer: k2.eagerReducer,
          eagerState: k2.eagerState,
          next: null
        };
        null === h2 ? (g2 = h2 = n2, f2 = d2) : h2 = h2.next = n2;
        R$1.lanes |= l2;
        Dg |= l2;
      }
      k2 = k2.next;
    } while (null !== k2 && k2 !== e3);
    null === h2 ? f2 = d2 : h2.next = g2;
    He(d2, b10.memoizedState) || (ug = true);
    b10.memoizedState = d2;
    b10.baseState = f2;
    b10.baseQueue = h2;
    c2.lastRenderedState = d2;
  }
  return [b10.memoizedState, c2.dispatch];
}
function Lh(a2) {
  var b10 = Ih(), c2 = b10.queue;
  if (null === c2)
    throw Error(y$2(311));
  c2.lastRenderedReducer = a2;
  var d2 = c2.dispatch, e3 = c2.pending, f2 = b10.memoizedState;
  if (null !== e3) {
    c2.pending = null;
    var g2 = e3 = e3.next;
    do
      f2 = a2(f2, g2.action), g2 = g2.next;
    while (g2 !== e3);
    He(f2, b10.memoizedState) || (ug = true);
    b10.memoizedState = f2;
    null === b10.baseQueue && (b10.baseState = f2);
    c2.lastRenderedState = f2;
  }
  return [f2, d2];
}
function Mh(a2, b10, c2) {
  var d2 = b10._getVersion;
  d2 = d2(b10._source);
  var e3 = b10._workInProgressVersionPrimary;
  if (null !== e3)
    a2 = e3 === d2;
  else if (a2 = a2.mutableReadLanes, a2 = (xh & a2) === a2)
    b10._workInProgressVersionPrimary = d2, th.push(b10);
  if (a2)
    return c2(b10._source);
  th.push(b10);
  throw Error(y$2(350));
}
function Nh(a2, b10, c2, d2) {
  var e3 = U$1;
  if (null === e3)
    throw Error(y$2(349));
  var f2 = b10._getVersion, g2 = f2(b10._source), h2 = vh.current, k2 = h2.useState(function() {
    return Mh(e3, b10, c2);
  }), l2 = k2[1], n2 = k2[0];
  k2 = T;
  var A2 = a2.memoizedState, p2 = A2.refs, C2 = p2.getSnapshot, x2 = A2.source;
  A2 = A2.subscribe;
  var w2 = R$1;
  a2.memoizedState = { refs: p2, source: b10, subscribe: d2 };
  h2.useEffect(function() {
    p2.getSnapshot = c2;
    p2.setSnapshot = l2;
    var a3 = f2(b10._source);
    if (!He(g2, a3)) {
      a3 = c2(b10._source);
      He(n2, a3) || (l2(a3), a3 = Ig(w2), e3.mutableReadLanes |= a3 & e3.pendingLanes);
      a3 = e3.mutableReadLanes;
      e3.entangledLanes |= a3;
      for (var d3 = e3.entanglements, h3 = a3; 0 < h3; ) {
        var k3 = 31 - Vc(h3), v2 = 1 << k3;
        d3[k3] |= a3;
        h3 &= ~v2;
      }
    }
  }, [c2, b10, d2]);
  h2.useEffect(function() {
    return d2(b10._source, function() {
      var a3 = p2.getSnapshot, c3 = p2.setSnapshot;
      try {
        c3(a3(b10._source));
        var d3 = Ig(w2);
        e3.mutableReadLanes |= d3 & e3.pendingLanes;
      } catch (q2) {
        c3(function() {
          throw q2;
        });
      }
    });
  }, [b10, d2]);
  He(C2, c2) && He(x2, b10) && He(A2, d2) || (a2 = { pending: null, dispatch: null, lastRenderedReducer: Jh, lastRenderedState: n2 }, a2.dispatch = l2 = Oh.bind(null, R$1, a2), k2.queue = a2, k2.baseQueue = null, n2 = Mh(e3, b10, c2), k2.memoizedState = k2.baseState = n2);
  return n2;
}
function Ph(a2, b10, c2) {
  var d2 = Ih();
  return Nh(d2, a2, b10, c2);
}
function Qh(a2) {
  var b10 = Hh();
  "function" === typeof a2 && (a2 = a2());
  b10.memoizedState = b10.baseState = a2;
  a2 = b10.queue = { pending: null, dispatch: null, lastRenderedReducer: Jh, lastRenderedState: a2 };
  a2 = a2.dispatch = Oh.bind(null, R$1, a2);
  return [b10.memoizedState, a2];
}
function Rh(a2, b10, c2, d2) {
  a2 = { tag: a2, create: b10, destroy: c2, deps: d2, next: null };
  b10 = R$1.updateQueue;
  null === b10 ? (b10 = { lastEffect: null }, R$1.updateQueue = b10, b10.lastEffect = a2.next = a2) : (c2 = b10.lastEffect, null === c2 ? b10.lastEffect = a2.next = a2 : (d2 = c2.next, c2.next = a2, a2.next = d2, b10.lastEffect = a2));
  return a2;
}
function Sh(a2) {
  var b10 = Hh();
  a2 = { current: a2 };
  return b10.memoizedState = a2;
}
function Th() {
  return Ih().memoizedState;
}
function Uh(a2, b10, c2, d2) {
  var e3 = Hh();
  R$1.flags |= a2;
  e3.memoizedState = Rh(1 | b10, c2, void 0, void 0 === d2 ? null : d2);
}
function Vh(a2, b10, c2, d2) {
  var e3 = Ih();
  d2 = void 0 === d2 ? null : d2;
  var f2 = void 0;
  if (null !== S$1) {
    var g2 = S$1.memoizedState;
    f2 = g2.destroy;
    if (null !== d2 && Bh(d2, g2.deps)) {
      Rh(b10, c2, f2, d2);
      return;
    }
  }
  R$1.flags |= a2;
  e3.memoizedState = Rh(1 | b10, c2, f2, d2);
}
function Wh(a2, b10) {
  return Uh(516, 4, a2, b10);
}
function Xh(a2, b10) {
  return Vh(516, 4, a2, b10);
}
function Yh(a2, b10) {
  return Vh(4, 2, a2, b10);
}
function Zh(a2, b10) {
  if ("function" === typeof b10)
    return a2 = a2(), b10(a2), function() {
      b10(null);
    };
  if (null !== b10 && void 0 !== b10)
    return a2 = a2(), b10.current = a2, function() {
      b10.current = null;
    };
}
function $h(a2, b10, c2) {
  c2 = null !== c2 && void 0 !== c2 ? c2.concat([a2]) : null;
  return Vh(4, 2, Zh.bind(null, b10, a2), c2);
}
function ai() {
}
function bi(a2, b10) {
  var c2 = Ih();
  b10 = void 0 === b10 ? null : b10;
  var d2 = c2.memoizedState;
  if (null !== d2 && null !== b10 && Bh(b10, d2[1]))
    return d2[0];
  c2.memoizedState = [a2, b10];
  return a2;
}
function ci(a2, b10) {
  var c2 = Ih();
  b10 = void 0 === b10 ? null : b10;
  var d2 = c2.memoizedState;
  if (null !== d2 && null !== b10 && Bh(b10, d2[1]))
    return d2[0];
  a2 = a2();
  c2.memoizedState = [a2, b10];
  return a2;
}
function di(a2, b10) {
  var c2 = eg();
  gg(98 > c2 ? 98 : c2, function() {
    a2(true);
  });
  gg(97 < c2 ? 97 : c2, function() {
    var c3 = wh.transition;
    wh.transition = 1;
    try {
      a2(false), b10();
    } finally {
      wh.transition = c3;
    }
  });
}
function Oh(a2, b10, c2) {
  var d2 = Hg(), e3 = Ig(a2), f2 = { lane: e3, action: c2, eagerReducer: null, eagerState: null, next: null }, g2 = b10.pending;
  null === g2 ? f2.next = f2 : (f2.next = g2.next, g2.next = f2);
  b10.pending = f2;
  g2 = a2.alternate;
  if (a2 === R$1 || null !== g2 && g2 === R$1)
    zh = yh = true;
  else {
    if (0 === a2.lanes && (null === g2 || 0 === g2.lanes) && (g2 = b10.lastRenderedReducer, null !== g2))
      try {
        var h2 = b10.lastRenderedState, k2 = g2(h2, c2);
        f2.eagerReducer = g2;
        f2.eagerState = k2;
        if (He(k2, h2))
          return;
      } catch (l2) {
      } finally {
      }
    Jg(a2, e3, d2);
  }
}
var Gh = { readContext: vg, useCallback: Ah, useContext: Ah, useEffect: Ah, useImperativeHandle: Ah, useLayoutEffect: Ah, useMemo: Ah, useReducer: Ah, useRef: Ah, useState: Ah, useDebugValue: Ah, useDeferredValue: Ah, useTransition: Ah, useMutableSource: Ah, useOpaqueIdentifier: Ah, unstable_isNewReconciler: false }, Dh = { readContext: vg, useCallback: function(a2, b10) {
  Hh().memoizedState = [a2, void 0 === b10 ? null : b10];
  return a2;
}, useContext: vg, useEffect: Wh, useImperativeHandle: function(a2, b10, c2) {
  c2 = null !== c2 && void 0 !== c2 ? c2.concat([a2]) : null;
  return Uh(4, 2, Zh.bind(
    null,
    b10,
    a2
  ), c2);
}, useLayoutEffect: function(a2, b10) {
  return Uh(4, 2, a2, b10);
}, useMemo: function(a2, b10) {
  var c2 = Hh();
  b10 = void 0 === b10 ? null : b10;
  a2 = a2();
  c2.memoizedState = [a2, b10];
  return a2;
}, useReducer: function(a2, b10, c2) {
  var d2 = Hh();
  b10 = void 0 !== c2 ? c2(b10) : b10;
  d2.memoizedState = d2.baseState = b10;
  a2 = d2.queue = { pending: null, dispatch: null, lastRenderedReducer: a2, lastRenderedState: b10 };
  a2 = a2.dispatch = Oh.bind(null, R$1, a2);
  return [d2.memoizedState, a2];
}, useRef: Sh, useState: Qh, useDebugValue: ai, useDeferredValue: function(a2) {
  var b10 = Qh(a2), c2 = b10[0], d2 = b10[1];
  Wh(function() {
    var b11 = wh.transition;
    wh.transition = 1;
    try {
      d2(a2);
    } finally {
      wh.transition = b11;
    }
  }, [a2]);
  return c2;
}, useTransition: function() {
  var a2 = Qh(false), b10 = a2[0];
  a2 = di.bind(null, a2[1]);
  Sh(a2);
  return [a2, b10];
}, useMutableSource: function(a2, b10, c2) {
  var d2 = Hh();
  d2.memoizedState = { refs: { getSnapshot: b10, setSnapshot: null }, source: a2, subscribe: c2 };
  return Nh(d2, a2, b10, c2);
}, useOpaqueIdentifier: function() {
  if (lh) {
    var a2 = false, b10 = uf(function() {
      a2 || (a2 = true, c2("r:" + (tf++).toString(36)));
      throw Error(y$2(355));
    }), c2 = Qh(b10)[1];
    0 === (R$1.mode & 2) && (R$1.flags |= 516, Rh(
      5,
      function() {
        c2("r:" + (tf++).toString(36));
      },
      void 0,
      null
    ));
    return b10;
  }
  b10 = "r:" + (tf++).toString(36);
  Qh(b10);
  return b10;
}, unstable_isNewReconciler: false }, Eh = { readContext: vg, useCallback: bi, useContext: vg, useEffect: Xh, useImperativeHandle: $h, useLayoutEffect: Yh, useMemo: ci, useReducer: Kh, useRef: Th, useState: function() {
  return Kh(Jh);
}, useDebugValue: ai, useDeferredValue: function(a2) {
  var b10 = Kh(Jh), c2 = b10[0], d2 = b10[1];
  Xh(function() {
    var b11 = wh.transition;
    wh.transition = 1;
    try {
      d2(a2);
    } finally {
      wh.transition = b11;
    }
  }, [a2]);
  return c2;
}, useTransition: function() {
  var a2 = Kh(Jh)[0];
  return [
    Th().current,
    a2
  ];
}, useMutableSource: Ph, useOpaqueIdentifier: function() {
  return Kh(Jh)[0];
}, unstable_isNewReconciler: false }, Fh = { readContext: vg, useCallback: bi, useContext: vg, useEffect: Xh, useImperativeHandle: $h, useLayoutEffect: Yh, useMemo: ci, useReducer: Lh, useRef: Th, useState: function() {
  return Lh(Jh);
}, useDebugValue: ai, useDeferredValue: function(a2) {
  var b10 = Lh(Jh), c2 = b10[0], d2 = b10[1];
  Xh(function() {
    var b11 = wh.transition;
    wh.transition = 1;
    try {
      d2(a2);
    } finally {
      wh.transition = b11;
    }
  }, [a2]);
  return c2;
}, useTransition: function() {
  var a2 = Lh(Jh)[0];
  return [
    Th().current,
    a2
  ];
}, useMutableSource: Ph, useOpaqueIdentifier: function() {
  return Lh(Jh)[0];
}, unstable_isNewReconciler: false }, ei = ra.ReactCurrentOwner, ug = false;
function fi(a2, b10, c2, d2) {
  b10.child = null === a2 ? Zg(b10, null, c2, d2) : Yg(b10, a2.child, c2, d2);
}
function gi(a2, b10, c2, d2, e3) {
  c2 = c2.render;
  var f2 = b10.ref;
  tg(b10, e3);
  d2 = Ch(a2, b10, c2, d2, f2, e3);
  if (null !== a2 && !ug)
    return b10.updateQueue = a2.updateQueue, b10.flags &= -517, a2.lanes &= ~e3, hi(a2, b10, e3);
  b10.flags |= 1;
  fi(a2, b10, d2, e3);
  return b10.child;
}
function ii(a2, b10, c2, d2, e3, f2) {
  if (null === a2) {
    var g2 = c2.type;
    if ("function" === typeof g2 && !ji(g2) && void 0 === g2.defaultProps && null === c2.compare && void 0 === c2.defaultProps)
      return b10.tag = 15, b10.type = g2, ki(a2, b10, g2, d2, e3, f2);
    a2 = Vg(c2.type, null, d2, b10, b10.mode, f2);
    a2.ref = b10.ref;
    a2.return = b10;
    return b10.child = a2;
  }
  g2 = a2.child;
  if (0 === (e3 & f2) && (e3 = g2.memoizedProps, c2 = c2.compare, c2 = null !== c2 ? c2 : Je, c2(e3, d2) && a2.ref === b10.ref))
    return hi(a2, b10, f2);
  b10.flags |= 1;
  a2 = Tg(g2, d2);
  a2.ref = b10.ref;
  a2.return = b10;
  return b10.child = a2;
}
function ki(a2, b10, c2, d2, e3, f2) {
  if (null !== a2 && Je(a2.memoizedProps, d2) && a2.ref === b10.ref)
    if (ug = false, 0 !== (f2 & e3))
      0 !== (a2.flags & 16384) && (ug = true);
    else
      return b10.lanes = a2.lanes, hi(a2, b10, f2);
  return li(a2, b10, c2, d2, f2);
}
function mi(a2, b10, c2) {
  var d2 = b10.pendingProps, e3 = d2.children, f2 = null !== a2 ? a2.memoizedState : null;
  if ("hidden" === d2.mode || "unstable-defer-without-hiding" === d2.mode)
    if (0 === (b10.mode & 4))
      b10.memoizedState = { baseLanes: 0 }, ni(b10, c2);
    else if (0 !== (c2 & 1073741824))
      b10.memoizedState = { baseLanes: 0 }, ni(b10, null !== f2 ? f2.baseLanes : c2);
    else
      return a2 = null !== f2 ? f2.baseLanes | c2 : c2, b10.lanes = b10.childLanes = 1073741824, b10.memoizedState = { baseLanes: a2 }, ni(b10, a2), null;
  else
    null !== f2 ? (d2 = f2.baseLanes | c2, b10.memoizedState = null) : d2 = c2, ni(b10, d2);
  fi(a2, b10, e3, c2);
  return b10.child;
}
function oi(a2, b10) {
  var c2 = b10.ref;
  if (null === a2 && null !== c2 || null !== a2 && a2.ref !== c2)
    b10.flags |= 128;
}
function li(a2, b10, c2, d2, e3) {
  var f2 = Ff(c2) ? Df : M$1.current;
  f2 = Ef(b10, f2);
  tg(b10, e3);
  c2 = Ch(a2, b10, c2, d2, f2, e3);
  if (null !== a2 && !ug)
    return b10.updateQueue = a2.updateQueue, b10.flags &= -517, a2.lanes &= ~e3, hi(a2, b10, e3);
  b10.flags |= 1;
  fi(a2, b10, c2, e3);
  return b10.child;
}
function pi$1(a2, b10, c2, d2, e3) {
  if (Ff(c2)) {
    var f2 = true;
    Jf(b10);
  } else
    f2 = false;
  tg(b10, e3);
  if (null === b10.stateNode)
    null !== a2 && (a2.alternate = null, b10.alternate = null, b10.flags |= 2), Mg(b10, c2, d2), Og(b10, c2, d2, e3), d2 = true;
  else if (null === a2) {
    var g2 = b10.stateNode, h2 = b10.memoizedProps;
    g2.props = h2;
    var k2 = g2.context, l2 = c2.contextType;
    "object" === typeof l2 && null !== l2 ? l2 = vg(l2) : (l2 = Ff(c2) ? Df : M$1.current, l2 = Ef(b10, l2));
    var n2 = c2.getDerivedStateFromProps, A2 = "function" === typeof n2 || "function" === typeof g2.getSnapshotBeforeUpdate;
    A2 || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h2 !== d2 || k2 !== l2) && Ng(b10, g2, d2, l2);
    wg = false;
    var p2 = b10.memoizedState;
    g2.state = p2;
    Cg(b10, d2, g2, e3);
    k2 = b10.memoizedState;
    h2 !== d2 || p2 !== k2 || N$1.current || wg ? ("function" === typeof n2 && (Gg(b10, c2, n2, d2), k2 = b10.memoizedState), (h2 = wg || Lg(b10, c2, h2, d2, p2, k2, l2)) ? (A2 || "function" !== typeof g2.UNSAFE_componentWillMount && "function" !== typeof g2.componentWillMount || ("function" === typeof g2.componentWillMount && g2.componentWillMount(), "function" === typeof g2.UNSAFE_componentWillMount && g2.UNSAFE_componentWillMount()), "function" === typeof g2.componentDidMount && (b10.flags |= 4)) : ("function" === typeof g2.componentDidMount && (b10.flags |= 4), b10.memoizedProps = d2, b10.memoizedState = k2), g2.props = d2, g2.state = k2, g2.context = l2, d2 = h2) : ("function" === typeof g2.componentDidMount && (b10.flags |= 4), d2 = false);
  } else {
    g2 = b10.stateNode;
    yg(a2, b10);
    h2 = b10.memoizedProps;
    l2 = b10.type === b10.elementType ? h2 : lg(b10.type, h2);
    g2.props = l2;
    A2 = b10.pendingProps;
    p2 = g2.context;
    k2 = c2.contextType;
    "object" === typeof k2 && null !== k2 ? k2 = vg(k2) : (k2 = Ff(c2) ? Df : M$1.current, k2 = Ef(b10, k2));
    var C2 = c2.getDerivedStateFromProps;
    (n2 = "function" === typeof C2 || "function" === typeof g2.getSnapshotBeforeUpdate) || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h2 !== A2 || p2 !== k2) && Ng(b10, g2, d2, k2);
    wg = false;
    p2 = b10.memoizedState;
    g2.state = p2;
    Cg(b10, d2, g2, e3);
    var x2 = b10.memoizedState;
    h2 !== A2 || p2 !== x2 || N$1.current || wg ? ("function" === typeof C2 && (Gg(b10, c2, C2, d2), x2 = b10.memoizedState), (l2 = wg || Lg(b10, c2, l2, d2, p2, x2, k2)) ? (n2 || "function" !== typeof g2.UNSAFE_componentWillUpdate && "function" !== typeof g2.componentWillUpdate || ("function" === typeof g2.componentWillUpdate && g2.componentWillUpdate(
      d2,
      x2,
      k2
    ), "function" === typeof g2.UNSAFE_componentWillUpdate && g2.UNSAFE_componentWillUpdate(d2, x2, k2)), "function" === typeof g2.componentDidUpdate && (b10.flags |= 4), "function" === typeof g2.getSnapshotBeforeUpdate && (b10.flags |= 256)) : ("function" !== typeof g2.componentDidUpdate || h2 === a2.memoizedProps && p2 === a2.memoizedState || (b10.flags |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h2 === a2.memoizedProps && p2 === a2.memoizedState || (b10.flags |= 256), b10.memoizedProps = d2, b10.memoizedState = x2), g2.props = d2, g2.state = x2, g2.context = k2, d2 = l2) : ("function" !== typeof g2.componentDidUpdate || h2 === a2.memoizedProps && p2 === a2.memoizedState || (b10.flags |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h2 === a2.memoizedProps && p2 === a2.memoizedState || (b10.flags |= 256), d2 = false);
  }
  return qi(a2, b10, c2, d2, f2, e3);
}
function qi(a2, b10, c2, d2, e3, f2) {
  oi(a2, b10);
  var g2 = 0 !== (b10.flags & 64);
  if (!d2 && !g2)
    return e3 && Kf(b10, c2, false), hi(a2, b10, f2);
  d2 = b10.stateNode;
  ei.current = b10;
  var h2 = g2 && "function" !== typeof c2.getDerivedStateFromError ? null : d2.render();
  b10.flags |= 1;
  null !== a2 && g2 ? (b10.child = Yg(b10, a2.child, null, f2), b10.child = Yg(b10, null, h2, f2)) : fi(a2, b10, h2, f2);
  b10.memoizedState = d2.state;
  e3 && Kf(b10, c2, true);
  return b10.child;
}
function ri(a2) {
  var b10 = a2.stateNode;
  b10.pendingContext ? Hf(a2, b10.pendingContext, b10.pendingContext !== b10.context) : b10.context && Hf(a2, b10.context, false);
  eh(a2, b10.containerInfo);
}
var si = { dehydrated: null, retryLane: 0 };
function ti(a2, b10, c2) {
  var d2 = b10.pendingProps, e3 = P$1.current, f2 = false, g2;
  (g2 = 0 !== (b10.flags & 64)) || (g2 = null !== a2 && null === a2.memoizedState ? false : 0 !== (e3 & 2));
  g2 ? (f2 = true, b10.flags &= -65) : null !== a2 && null === a2.memoizedState || void 0 === d2.fallback || true === d2.unstable_avoidThisFallback || (e3 |= 1);
  I$1(P$1, e3 & 1);
  if (null === a2) {
    void 0 !== d2.fallback && ph(b10);
    a2 = d2.children;
    e3 = d2.fallback;
    if (f2)
      return a2 = ui(b10, a2, e3, c2), b10.child.memoizedState = { baseLanes: c2 }, b10.memoizedState = si, a2;
    if ("number" === typeof d2.unstable_expectedLoadTime)
      return a2 = ui(b10, a2, e3, c2), b10.child.memoizedState = { baseLanes: c2 }, b10.memoizedState = si, b10.lanes = 33554432, a2;
    c2 = vi({ mode: "visible", children: a2 }, b10.mode, c2, null);
    c2.return = b10;
    return b10.child = c2;
  }
  if (null !== a2.memoizedState) {
    if (f2)
      return d2 = wi(a2, b10, d2.children, d2.fallback, c2), f2 = b10.child, e3 = a2.child.memoizedState, f2.memoizedState = null === e3 ? { baseLanes: c2 } : { baseLanes: e3.baseLanes | c2 }, f2.childLanes = a2.childLanes & ~c2, b10.memoizedState = si, d2;
    c2 = xi(a2, b10, d2.children, c2);
    b10.memoizedState = null;
    return c2;
  }
  if (f2)
    return d2 = wi(a2, b10, d2.children, d2.fallback, c2), f2 = b10.child, e3 = a2.child.memoizedState, f2.memoizedState = null === e3 ? { baseLanes: c2 } : { baseLanes: e3.baseLanes | c2 }, f2.childLanes = a2.childLanes & ~c2, b10.memoizedState = si, d2;
  c2 = xi(a2, b10, d2.children, c2);
  b10.memoizedState = null;
  return c2;
}
function ui(a2, b10, c2, d2) {
  var e3 = a2.mode, f2 = a2.child;
  b10 = { mode: "hidden", children: b10 };
  0 === (e3 & 2) && null !== f2 ? (f2.childLanes = 0, f2.pendingProps = b10) : f2 = vi(b10, e3, 0, null);
  c2 = Xg(c2, e3, d2, null);
  f2.return = a2;
  c2.return = a2;
  f2.sibling = c2;
  a2.child = f2;
  return c2;
}
function xi(a2, b10, c2, d2) {
  var e3 = a2.child;
  a2 = e3.sibling;
  c2 = Tg(e3, { mode: "visible", children: c2 });
  0 === (b10.mode & 2) && (c2.lanes = d2);
  c2.return = b10;
  c2.sibling = null;
  null !== a2 && (a2.nextEffect = null, a2.flags = 8, b10.firstEffect = b10.lastEffect = a2);
  return b10.child = c2;
}
function wi(a2, b10, c2, d2, e3) {
  var f2 = b10.mode, g2 = a2.child;
  a2 = g2.sibling;
  var h2 = { mode: "hidden", children: c2 };
  0 === (f2 & 2) && b10.child !== g2 ? (c2 = b10.child, c2.childLanes = 0, c2.pendingProps = h2, g2 = c2.lastEffect, null !== g2 ? (b10.firstEffect = c2.firstEffect, b10.lastEffect = g2, g2.nextEffect = null) : b10.firstEffect = b10.lastEffect = null) : c2 = Tg(g2, h2);
  null !== a2 ? d2 = Tg(a2, d2) : (d2 = Xg(d2, f2, e3, null), d2.flags |= 2);
  d2.return = b10;
  c2.return = b10;
  c2.sibling = d2;
  b10.child = c2;
  return d2;
}
function yi(a2, b10) {
  a2.lanes |= b10;
  var c2 = a2.alternate;
  null !== c2 && (c2.lanes |= b10);
  sg(a2.return, b10);
}
function zi(a2, b10, c2, d2, e3, f2) {
  var g2 = a2.memoizedState;
  null === g2 ? a2.memoizedState = { isBackwards: b10, rendering: null, renderingStartTime: 0, last: d2, tail: c2, tailMode: e3, lastEffect: f2 } : (g2.isBackwards = b10, g2.rendering = null, g2.renderingStartTime = 0, g2.last = d2, g2.tail = c2, g2.tailMode = e3, g2.lastEffect = f2);
}
function Ai(a2, b10, c2) {
  var d2 = b10.pendingProps, e3 = d2.revealOrder, f2 = d2.tail;
  fi(a2, b10, d2.children, c2);
  d2 = P$1.current;
  if (0 !== (d2 & 2))
    d2 = d2 & 1 | 2, b10.flags |= 64;
  else {
    if (null !== a2 && 0 !== (a2.flags & 64))
      a:
        for (a2 = b10.child; null !== a2; ) {
          if (13 === a2.tag)
            null !== a2.memoizedState && yi(a2, c2);
          else if (19 === a2.tag)
            yi(a2, c2);
          else if (null !== a2.child) {
            a2.child.return = a2;
            a2 = a2.child;
            continue;
          }
          if (a2 === b10)
            break a;
          for (; null === a2.sibling; ) {
            if (null === a2.return || a2.return === b10)
              break a;
            a2 = a2.return;
          }
          a2.sibling.return = a2.return;
          a2 = a2.sibling;
        }
    d2 &= 1;
  }
  I$1(P$1, d2);
  if (0 === (b10.mode & 2))
    b10.memoizedState = null;
  else
    switch (e3) {
      case "forwards":
        c2 = b10.child;
        for (e3 = null; null !== c2; )
          a2 = c2.alternate, null !== a2 && null === ih(a2) && (e3 = c2), c2 = c2.sibling;
        c2 = e3;
        null === c2 ? (e3 = b10.child, b10.child = null) : (e3 = c2.sibling, c2.sibling = null);
        zi(b10, false, e3, c2, f2, b10.lastEffect);
        break;
      case "backwards":
        c2 = null;
        e3 = b10.child;
        for (b10.child = null; null !== e3; ) {
          a2 = e3.alternate;
          if (null !== a2 && null === ih(a2)) {
            b10.child = e3;
            break;
          }
          a2 = e3.sibling;
          e3.sibling = c2;
          c2 = e3;
          e3 = a2;
        }
        zi(b10, true, c2, null, f2, b10.lastEffect);
        break;
      case "together":
        zi(b10, false, null, null, void 0, b10.lastEffect);
        break;
      default:
        b10.memoizedState = null;
    }
  return b10.child;
}
function hi(a2, b10, c2) {
  null !== a2 && (b10.dependencies = a2.dependencies);
  Dg |= b10.lanes;
  if (0 !== (c2 & b10.childLanes)) {
    if (null !== a2 && b10.child !== a2.child)
      throw Error(y$2(153));
    if (null !== b10.child) {
      a2 = b10.child;
      c2 = Tg(a2, a2.pendingProps);
      b10.child = c2;
      for (c2.return = b10; null !== a2.sibling; )
        a2 = a2.sibling, c2 = c2.sibling = Tg(a2, a2.pendingProps), c2.return = b10;
      c2.sibling = null;
    }
    return b10.child;
  }
  return null;
}
var Bi, Ci, Di, Ei;
Bi = function(a2, b10) {
  for (var c2 = b10.child; null !== c2; ) {
    if (5 === c2.tag || 6 === c2.tag)
      a2.appendChild(c2.stateNode);
    else if (4 !== c2.tag && null !== c2.child) {
      c2.child.return = c2;
      c2 = c2.child;
      continue;
    }
    if (c2 === b10)
      break;
    for (; null === c2.sibling; ) {
      if (null === c2.return || c2.return === b10)
        return;
      c2 = c2.return;
    }
    c2.sibling.return = c2.return;
    c2 = c2.sibling;
  }
};
Ci = function() {
};
Di = function(a2, b10, c2, d2) {
  var e3 = a2.memoizedProps;
  if (e3 !== d2) {
    a2 = b10.stateNode;
    dh(ah.current);
    var f2 = null;
    switch (c2) {
      case "input":
        e3 = Ya(a2, e3);
        d2 = Ya(a2, d2);
        f2 = [];
        break;
      case "option":
        e3 = eb(a2, e3);
        d2 = eb(a2, d2);
        f2 = [];
        break;
      case "select":
        e3 = m$5({}, e3, { value: void 0 });
        d2 = m$5({}, d2, { value: void 0 });
        f2 = [];
        break;
      case "textarea":
        e3 = gb(a2, e3);
        d2 = gb(a2, d2);
        f2 = [];
        break;
      default:
        "function" !== typeof e3.onClick && "function" === typeof d2.onClick && (a2.onclick = jf);
    }
    vb(c2, d2);
    var g2;
    c2 = null;
    for (l2 in e3)
      if (!d2.hasOwnProperty(l2) && e3.hasOwnProperty(l2) && null != e3[l2])
        if ("style" === l2) {
          var h2 = e3[l2];
          for (g2 in h2)
            h2.hasOwnProperty(g2) && (c2 || (c2 = {}), c2[g2] = "");
        } else
          "dangerouslySetInnerHTML" !== l2 && "children" !== l2 && "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && "autoFocus" !== l2 && (ca.hasOwnProperty(l2) ? f2 || (f2 = []) : (f2 = f2 || []).push(l2, null));
    for (l2 in d2) {
      var k2 = d2[l2];
      h2 = null != e3 ? e3[l2] : void 0;
      if (d2.hasOwnProperty(l2) && k2 !== h2 && (null != k2 || null != h2))
        if ("style" === l2)
          if (h2) {
            for (g2 in h2)
              !h2.hasOwnProperty(g2) || k2 && k2.hasOwnProperty(g2) || (c2 || (c2 = {}), c2[g2] = "");
            for (g2 in k2)
              k2.hasOwnProperty(g2) && h2[g2] !== k2[g2] && (c2 || (c2 = {}), c2[g2] = k2[g2]);
          } else
            c2 || (f2 || (f2 = []), f2.push(l2, c2)), c2 = k2;
        else
          "dangerouslySetInnerHTML" === l2 ? (k2 = k2 ? k2.__html : void 0, h2 = h2 ? h2.__html : void 0, null != k2 && h2 !== k2 && (f2 = f2 || []).push(l2, k2)) : "children" === l2 ? "string" !== typeof k2 && "number" !== typeof k2 || (f2 = f2 || []).push(l2, "" + k2) : "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && (ca.hasOwnProperty(l2) ? (null != k2 && "onScroll" === l2 && G$1("scroll", a2), f2 || h2 === k2 || (f2 = [])) : "object" === typeof k2 && null !== k2 && k2.$$typeof === Ga ? k2.toString() : (f2 = f2 || []).push(l2, k2));
    }
    c2 && (f2 = f2 || []).push(
      "style",
      c2
    );
    var l2 = f2;
    if (b10.updateQueue = l2)
      b10.flags |= 4;
  }
};
Ei = function(a2, b10, c2, d2) {
  c2 !== d2 && (b10.flags |= 4);
};
function Fi(a2, b10) {
  if (!lh)
    switch (a2.tailMode) {
      case "hidden":
        b10 = a2.tail;
        for (var c2 = null; null !== b10; )
          null !== b10.alternate && (c2 = b10), b10 = b10.sibling;
        null === c2 ? a2.tail = null : c2.sibling = null;
        break;
      case "collapsed":
        c2 = a2.tail;
        for (var d2 = null; null !== c2; )
          null !== c2.alternate && (d2 = c2), c2 = c2.sibling;
        null === d2 ? b10 || null === a2.tail ? a2.tail = null : a2.tail.sibling = null : d2.sibling = null;
    }
}
function Gi(a2, b10, c2) {
  var d2 = b10.pendingProps;
  switch (b10.tag) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
      return null;
    case 1:
      return Ff(b10.type) && Gf(), null;
    case 3:
      fh();
      H$1(N$1);
      H$1(M$1);
      uh();
      d2 = b10.stateNode;
      d2.pendingContext && (d2.context = d2.pendingContext, d2.pendingContext = null);
      if (null === a2 || null === a2.child)
        rh(b10) ? b10.flags |= 4 : d2.hydrate || (b10.flags |= 256);
      Ci(b10);
      return null;
    case 5:
      hh(b10);
      var e3 = dh(ch$1.current);
      c2 = b10.type;
      if (null !== a2 && null != b10.stateNode)
        Di(a2, b10, c2, d2, e3), a2.ref !== b10.ref && (b10.flags |= 128);
      else {
        if (!d2) {
          if (null === b10.stateNode)
            throw Error(y$2(166));
          return null;
        }
        a2 = dh(ah.current);
        if (rh(b10)) {
          d2 = b10.stateNode;
          c2 = b10.type;
          var f2 = b10.memoizedProps;
          d2[wf] = b10;
          d2[xf] = f2;
          switch (c2) {
            case "dialog":
              G$1("cancel", d2);
              G$1("close", d2);
              break;
            case "iframe":
            case "object":
            case "embed":
              G$1("load", d2);
              break;
            case "video":
            case "audio":
              for (a2 = 0; a2 < Xe.length; a2++)
                G$1(Xe[a2], d2);
              break;
            case "source":
              G$1("error", d2);
              break;
            case "img":
            case "image":
            case "link":
              G$1("error", d2);
              G$1("load", d2);
              break;
            case "details":
              G$1("toggle", d2);
              break;
            case "input":
              Za(d2, f2);
              G$1("invalid", d2);
              break;
            case "select":
              d2._wrapperState = { wasMultiple: !!f2.multiple };
              G$1("invalid", d2);
              break;
            case "textarea":
              hb(d2, f2), G$1("invalid", d2);
          }
          vb(c2, f2);
          a2 = null;
          for (var g2 in f2)
            f2.hasOwnProperty(g2) && (e3 = f2[g2], "children" === g2 ? "string" === typeof e3 ? d2.textContent !== e3 && (a2 = ["children", e3]) : "number" === typeof e3 && d2.textContent !== "" + e3 && (a2 = ["children", "" + e3]) : ca.hasOwnProperty(g2) && null != e3 && "onScroll" === g2 && G$1("scroll", d2));
          switch (c2) {
            case "input":
              Va(d2);
              cb(d2, f2, true);
              break;
            case "textarea":
              Va(d2);
              jb(d2);
              break;
            case "select":
            case "option":
              break;
            default:
              "function" === typeof f2.onClick && (d2.onclick = jf);
          }
          d2 = a2;
          b10.updateQueue = d2;
          null !== d2 && (b10.flags |= 4);
        } else {
          g2 = 9 === e3.nodeType ? e3 : e3.ownerDocument;
          a2 === kb.html && (a2 = lb(c2));
          a2 === kb.html ? "script" === c2 ? (a2 = g2.createElement("div"), a2.innerHTML = "<script><\/script>", a2 = a2.removeChild(a2.firstChild)) : "string" === typeof d2.is ? a2 = g2.createElement(c2, { is: d2.is }) : (a2 = g2.createElement(c2), "select" === c2 && (g2 = a2, d2.multiple ? g2.multiple = true : d2.size && (g2.size = d2.size))) : a2 = g2.createElementNS(a2, c2);
          a2[wf] = b10;
          a2[xf] = d2;
          Bi(a2, b10, false, false);
          b10.stateNode = a2;
          g2 = wb(c2, d2);
          switch (c2) {
            case "dialog":
              G$1("cancel", a2);
              G$1("close", a2);
              e3 = d2;
              break;
            case "iframe":
            case "object":
            case "embed":
              G$1("load", a2);
              e3 = d2;
              break;
            case "video":
            case "audio":
              for (e3 = 0; e3 < Xe.length; e3++)
                G$1(Xe[e3], a2);
              e3 = d2;
              break;
            case "source":
              G$1("error", a2);
              e3 = d2;
              break;
            case "img":
            case "image":
            case "link":
              G$1("error", a2);
              G$1("load", a2);
              e3 = d2;
              break;
            case "details":
              G$1("toggle", a2);
              e3 = d2;
              break;
            case "input":
              Za(a2, d2);
              e3 = Ya(a2, d2);
              G$1("invalid", a2);
              break;
            case "option":
              e3 = eb(a2, d2);
              break;
            case "select":
              a2._wrapperState = { wasMultiple: !!d2.multiple };
              e3 = m$5({}, d2, { value: void 0 });
              G$1("invalid", a2);
              break;
            case "textarea":
              hb(a2, d2);
              e3 = gb(a2, d2);
              G$1("invalid", a2);
              break;
            default:
              e3 = d2;
          }
          vb(c2, e3);
          var h2 = e3;
          for (f2 in h2)
            if (h2.hasOwnProperty(f2)) {
              var k2 = h2[f2];
              "style" === f2 ? tb(a2, k2) : "dangerouslySetInnerHTML" === f2 ? (k2 = k2 ? k2.__html : void 0, null != k2 && ob(a2, k2)) : "children" === f2 ? "string" === typeof k2 ? ("textarea" !== c2 || "" !== k2) && pb(a2, k2) : "number" === typeof k2 && pb(a2, "" + k2) : "suppressContentEditableWarning" !== f2 && "suppressHydrationWarning" !== f2 && "autoFocus" !== f2 && (ca.hasOwnProperty(f2) ? null != k2 && "onScroll" === f2 && G$1("scroll", a2) : null != k2 && qa(a2, f2, k2, g2));
            }
          switch (c2) {
            case "input":
              Va(a2);
              cb(a2, d2, false);
              break;
            case "textarea":
              Va(a2);
              jb(a2);
              break;
            case "option":
              null != d2.value && a2.setAttribute("value", "" + Sa(d2.value));
              break;
            case "select":
              a2.multiple = !!d2.multiple;
              f2 = d2.value;
              null != f2 ? fb(a2, !!d2.multiple, f2, false) : null != d2.defaultValue && fb(a2, !!d2.multiple, d2.defaultValue, true);
              break;
            default:
              "function" === typeof e3.onClick && (a2.onclick = jf);
          }
          mf(c2, d2) && (b10.flags |= 4);
        }
        null !== b10.ref && (b10.flags |= 128);
      }
      return null;
    case 6:
      if (a2 && null != b10.stateNode)
        Ei(a2, b10, a2.memoizedProps, d2);
      else {
        if ("string" !== typeof d2 && null === b10.stateNode)
          throw Error(y$2(166));
        c2 = dh(ch$1.current);
        dh(ah.current);
        rh(b10) ? (d2 = b10.stateNode, c2 = b10.memoizedProps, d2[wf] = b10, d2.nodeValue !== c2 && (b10.flags |= 4)) : (d2 = (9 === c2.nodeType ? c2 : c2.ownerDocument).createTextNode(d2), d2[wf] = b10, b10.stateNode = d2);
      }
      return null;
    case 13:
      H$1(P$1);
      d2 = b10.memoizedState;
      if (0 !== (b10.flags & 64))
        return b10.lanes = c2, b10;
      d2 = null !== d2;
      c2 = false;
      null === a2 ? void 0 !== b10.memoizedProps.fallback && rh(b10) : c2 = null !== a2.memoizedState;
      if (d2 && !c2 && 0 !== (b10.mode & 2))
        if (null === a2 && true !== b10.memoizedProps.unstable_avoidThisFallback || 0 !== (P$1.current & 1))
          0 === V && (V = 3);
        else {
          if (0 === V || 3 === V)
            V = 4;
          null === U$1 || 0 === (Dg & 134217727) && 0 === (Hi & 134217727) || Ii(U$1, W$1);
        }
      if (d2 || c2)
        b10.flags |= 4;
      return null;
    case 4:
      return fh(), Ci(b10), null === a2 && cf(b10.stateNode.containerInfo), null;
    case 10:
      return rg(b10), null;
    case 17:
      return Ff(b10.type) && Gf(), null;
    case 19:
      H$1(P$1);
      d2 = b10.memoizedState;
      if (null === d2)
        return null;
      f2 = 0 !== (b10.flags & 64);
      g2 = d2.rendering;
      if (null === g2)
        if (f2)
          Fi(d2, false);
        else {
          if (0 !== V || null !== a2 && 0 !== (a2.flags & 64))
            for (a2 = b10.child; null !== a2; ) {
              g2 = ih(a2);
              if (null !== g2) {
                b10.flags |= 64;
                Fi(d2, false);
                f2 = g2.updateQueue;
                null !== f2 && (b10.updateQueue = f2, b10.flags |= 4);
                null === d2.lastEffect && (b10.firstEffect = null);
                b10.lastEffect = d2.lastEffect;
                d2 = c2;
                for (c2 = b10.child; null !== c2; )
                  f2 = c2, a2 = d2, f2.flags &= 2, f2.nextEffect = null, f2.firstEffect = null, f2.lastEffect = null, g2 = f2.alternate, null === g2 ? (f2.childLanes = 0, f2.lanes = a2, f2.child = null, f2.memoizedProps = null, f2.memoizedState = null, f2.updateQueue = null, f2.dependencies = null, f2.stateNode = null) : (f2.childLanes = g2.childLanes, f2.lanes = g2.lanes, f2.child = g2.child, f2.memoizedProps = g2.memoizedProps, f2.memoizedState = g2.memoizedState, f2.updateQueue = g2.updateQueue, f2.type = g2.type, a2 = g2.dependencies, f2.dependencies = null === a2 ? null : { lanes: a2.lanes, firstContext: a2.firstContext }), c2 = c2.sibling;
                I$1(P$1, P$1.current & 1 | 2);
                return b10.child;
              }
              a2 = a2.sibling;
            }
          null !== d2.tail && O$1() > Ji && (b10.flags |= 64, f2 = true, Fi(d2, false), b10.lanes = 33554432);
        }
      else {
        if (!f2)
          if (a2 = ih(g2), null !== a2) {
            if (b10.flags |= 64, f2 = true, c2 = a2.updateQueue, null !== c2 && (b10.updateQueue = c2, b10.flags |= 4), Fi(d2, true), null === d2.tail && "hidden" === d2.tailMode && !g2.alternate && !lh)
              return b10 = b10.lastEffect = d2.lastEffect, null !== b10 && (b10.nextEffect = null), null;
          } else
            2 * O$1() - d2.renderingStartTime > Ji && 1073741824 !== c2 && (b10.flags |= 64, f2 = true, Fi(d2, false), b10.lanes = 33554432);
        d2.isBackwards ? (g2.sibling = b10.child, b10.child = g2) : (c2 = d2.last, null !== c2 ? c2.sibling = g2 : b10.child = g2, d2.last = g2);
      }
      return null !== d2.tail ? (c2 = d2.tail, d2.rendering = c2, d2.tail = c2.sibling, d2.lastEffect = b10.lastEffect, d2.renderingStartTime = O$1(), c2.sibling = null, b10 = P$1.current, I$1(P$1, f2 ? b10 & 1 | 2 : b10 & 1), c2) : null;
    case 23:
    case 24:
      return Ki(), null !== a2 && null !== a2.memoizedState !== (null !== b10.memoizedState) && "unstable-defer-without-hiding" !== d2.mode && (b10.flags |= 4), null;
  }
  throw Error(y$2(156, b10.tag));
}
function Li(a2) {
  switch (a2.tag) {
    case 1:
      Ff(a2.type) && Gf();
      var b10 = a2.flags;
      return b10 & 4096 ? (a2.flags = b10 & -4097 | 64, a2) : null;
    case 3:
      fh();
      H$1(N$1);
      H$1(M$1);
      uh();
      b10 = a2.flags;
      if (0 !== (b10 & 64))
        throw Error(y$2(285));
      a2.flags = b10 & -4097 | 64;
      return a2;
    case 5:
      return hh(a2), null;
    case 13:
      return H$1(P$1), b10 = a2.flags, b10 & 4096 ? (a2.flags = b10 & -4097 | 64, a2) : null;
    case 19:
      return H$1(P$1), null;
    case 4:
      return fh(), null;
    case 10:
      return rg(a2), null;
    case 23:
    case 24:
      return Ki(), null;
    default:
      return null;
  }
}
function Mi(a2, b10) {
  try {
    var c2 = "", d2 = b10;
    do
      c2 += Qa(d2), d2 = d2.return;
    while (d2);
    var e3 = c2;
  } catch (f2) {
    e3 = "\nError generating stack: " + f2.message + "\n" + f2.stack;
  }
  return { value: a2, source: b10, stack: e3 };
}
function Ni(a2, b10) {
  try {
    console.error(b10.value);
  } catch (c2) {
    setTimeout(function() {
      throw c2;
    });
  }
}
var Oi = "function" === typeof WeakMap ? WeakMap : Map;
function Pi(a2, b10, c2) {
  c2 = zg(-1, c2);
  c2.tag = 3;
  c2.payload = { element: null };
  var d2 = b10.value;
  c2.callback = function() {
    Qi || (Qi = true, Ri = d2);
    Ni(a2, b10);
  };
  return c2;
}
function Si(a2, b10, c2) {
  c2 = zg(-1, c2);
  c2.tag = 3;
  var d2 = a2.type.getDerivedStateFromError;
  if ("function" === typeof d2) {
    var e3 = b10.value;
    c2.payload = function() {
      Ni(a2, b10);
      return d2(e3);
    };
  }
  var f2 = a2.stateNode;
  null !== f2 && "function" === typeof f2.componentDidCatch && (c2.callback = function() {
    "function" !== typeof d2 && (null === Ti ? Ti = /* @__PURE__ */ new Set([this]) : Ti.add(this), Ni(a2, b10));
    var c3 = b10.stack;
    this.componentDidCatch(b10.value, { componentStack: null !== c3 ? c3 : "" });
  });
  return c2;
}
var Ui = "function" === typeof WeakSet ? WeakSet : Set;
function Vi(a2) {
  var b10 = a2.ref;
  if (null !== b10)
    if ("function" === typeof b10)
      try {
        b10(null);
      } catch (c2) {
        Wi(a2, c2);
      }
    else
      b10.current = null;
}
function Xi(a2, b10) {
  switch (b10.tag) {
    case 0:
    case 11:
    case 15:
    case 22:
      return;
    case 1:
      if (b10.flags & 256 && null !== a2) {
        var c2 = a2.memoizedProps, d2 = a2.memoizedState;
        a2 = b10.stateNode;
        b10 = a2.getSnapshotBeforeUpdate(b10.elementType === b10.type ? c2 : lg(b10.type, c2), d2);
        a2.__reactInternalSnapshotBeforeUpdate = b10;
      }
      return;
    case 3:
      b10.flags & 256 && qf(b10.stateNode.containerInfo);
      return;
    case 5:
    case 6:
    case 4:
    case 17:
      return;
  }
  throw Error(y$2(163));
}
function Yi(a2, b10, c2) {
  switch (c2.tag) {
    case 0:
    case 11:
    case 15:
    case 22:
      b10 = c2.updateQueue;
      b10 = null !== b10 ? b10.lastEffect : null;
      if (null !== b10) {
        a2 = b10 = b10.next;
        do {
          if (3 === (a2.tag & 3)) {
            var d2 = a2.create;
            a2.destroy = d2();
          }
          a2 = a2.next;
        } while (a2 !== b10);
      }
      b10 = c2.updateQueue;
      b10 = null !== b10 ? b10.lastEffect : null;
      if (null !== b10) {
        a2 = b10 = b10.next;
        do {
          var e3 = a2;
          d2 = e3.next;
          e3 = e3.tag;
          0 !== (e3 & 4) && 0 !== (e3 & 1) && (Zi(c2, a2), $i(c2, a2));
          a2 = d2;
        } while (a2 !== b10);
      }
      return;
    case 1:
      a2 = c2.stateNode;
      c2.flags & 4 && (null === b10 ? a2.componentDidMount() : (d2 = c2.elementType === c2.type ? b10.memoizedProps : lg(c2.type, b10.memoizedProps), a2.componentDidUpdate(
        d2,
        b10.memoizedState,
        a2.__reactInternalSnapshotBeforeUpdate
      )));
      b10 = c2.updateQueue;
      null !== b10 && Eg(c2, b10, a2);
      return;
    case 3:
      b10 = c2.updateQueue;
      if (null !== b10) {
        a2 = null;
        if (null !== c2.child)
          switch (c2.child.tag) {
            case 5:
              a2 = c2.child.stateNode;
              break;
            case 1:
              a2 = c2.child.stateNode;
          }
        Eg(c2, b10, a2);
      }
      return;
    case 5:
      a2 = c2.stateNode;
      null === b10 && c2.flags & 4 && mf(c2.type, c2.memoizedProps) && a2.focus();
      return;
    case 6:
      return;
    case 4:
      return;
    case 12:
      return;
    case 13:
      null === c2.memoizedState && (c2 = c2.alternate, null !== c2 && (c2 = c2.memoizedState, null !== c2 && (c2 = c2.dehydrated, null !== c2 && Cc(c2))));
      return;
    case 19:
    case 17:
    case 20:
    case 21:
    case 23:
    case 24:
      return;
  }
  throw Error(y$2(163));
}
function aj(a2, b10) {
  for (var c2 = a2; ; ) {
    if (5 === c2.tag) {
      var d2 = c2.stateNode;
      if (b10)
        d2 = d2.style, "function" === typeof d2.setProperty ? d2.setProperty("display", "none", "important") : d2.display = "none";
      else {
        d2 = c2.stateNode;
        var e3 = c2.memoizedProps.style;
        e3 = void 0 !== e3 && null !== e3 && e3.hasOwnProperty("display") ? e3.display : null;
        d2.style.display = sb("display", e3);
      }
    } else if (6 === c2.tag)
      c2.stateNode.nodeValue = b10 ? "" : c2.memoizedProps;
    else if ((23 !== c2.tag && 24 !== c2.tag || null === c2.memoizedState || c2 === a2) && null !== c2.child) {
      c2.child.return = c2;
      c2 = c2.child;
      continue;
    }
    if (c2 === a2)
      break;
    for (; null === c2.sibling; ) {
      if (null === c2.return || c2.return === a2)
        return;
      c2 = c2.return;
    }
    c2.sibling.return = c2.return;
    c2 = c2.sibling;
  }
}
function bj(a2, b10) {
  if (Mf && "function" === typeof Mf.onCommitFiberUnmount)
    try {
      Mf.onCommitFiberUnmount(Lf, b10);
    } catch (f2) {
    }
  switch (b10.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
    case 22:
      a2 = b10.updateQueue;
      if (null !== a2 && (a2 = a2.lastEffect, null !== a2)) {
        var c2 = a2 = a2.next;
        do {
          var d2 = c2, e3 = d2.destroy;
          d2 = d2.tag;
          if (void 0 !== e3)
            if (0 !== (d2 & 4))
              Zi(b10, c2);
            else {
              d2 = b10;
              try {
                e3();
              } catch (f2) {
                Wi(d2, f2);
              }
            }
          c2 = c2.next;
        } while (c2 !== a2);
      }
      break;
    case 1:
      Vi(b10);
      a2 = b10.stateNode;
      if ("function" === typeof a2.componentWillUnmount)
        try {
          a2.props = b10.memoizedProps, a2.state = b10.memoizedState, a2.componentWillUnmount();
        } catch (f2) {
          Wi(
            b10,
            f2
          );
        }
      break;
    case 5:
      Vi(b10);
      break;
    case 4:
      cj(a2, b10);
  }
}
function dj(a2) {
  a2.alternate = null;
  a2.child = null;
  a2.dependencies = null;
  a2.firstEffect = null;
  a2.lastEffect = null;
  a2.memoizedProps = null;
  a2.memoizedState = null;
  a2.pendingProps = null;
  a2.return = null;
  a2.updateQueue = null;
}
function ej(a2) {
  return 5 === a2.tag || 3 === a2.tag || 4 === a2.tag;
}
function fj(a2) {
  a: {
    for (var b10 = a2.return; null !== b10; ) {
      if (ej(b10))
        break a;
      b10 = b10.return;
    }
    throw Error(y$2(160));
  }
  var c2 = b10;
  b10 = c2.stateNode;
  switch (c2.tag) {
    case 5:
      var d2 = false;
      break;
    case 3:
      b10 = b10.containerInfo;
      d2 = true;
      break;
    case 4:
      b10 = b10.containerInfo;
      d2 = true;
      break;
    default:
      throw Error(y$2(161));
  }
  c2.flags & 16 && (pb(b10, ""), c2.flags &= -17);
  a:
    b:
      for (c2 = a2; ; ) {
        for (; null === c2.sibling; ) {
          if (null === c2.return || ej(c2.return)) {
            c2 = null;
            break a;
          }
          c2 = c2.return;
        }
        c2.sibling.return = c2.return;
        for (c2 = c2.sibling; 5 !== c2.tag && 6 !== c2.tag && 18 !== c2.tag; ) {
          if (c2.flags & 2)
            continue b;
          if (null === c2.child || 4 === c2.tag)
            continue b;
          else
            c2.child.return = c2, c2 = c2.child;
        }
        if (!(c2.flags & 2)) {
          c2 = c2.stateNode;
          break a;
        }
      }
  d2 ? gj(a2, c2, b10) : hj(a2, c2, b10);
}
function gj(a2, b10, c2) {
  var d2 = a2.tag, e3 = 5 === d2 || 6 === d2;
  if (e3)
    a2 = e3 ? a2.stateNode : a2.stateNode.instance, b10 ? 8 === c2.nodeType ? c2.parentNode.insertBefore(a2, b10) : c2.insertBefore(a2, b10) : (8 === c2.nodeType ? (b10 = c2.parentNode, b10.insertBefore(a2, c2)) : (b10 = c2, b10.appendChild(a2)), c2 = c2._reactRootContainer, null !== c2 && void 0 !== c2 || null !== b10.onclick || (b10.onclick = jf));
  else if (4 !== d2 && (a2 = a2.child, null !== a2))
    for (gj(a2, b10, c2), a2 = a2.sibling; null !== a2; )
      gj(a2, b10, c2), a2 = a2.sibling;
}
function hj(a2, b10, c2) {
  var d2 = a2.tag, e3 = 5 === d2 || 6 === d2;
  if (e3)
    a2 = e3 ? a2.stateNode : a2.stateNode.instance, b10 ? c2.insertBefore(a2, b10) : c2.appendChild(a2);
  else if (4 !== d2 && (a2 = a2.child, null !== a2))
    for (hj(a2, b10, c2), a2 = a2.sibling; null !== a2; )
      hj(a2, b10, c2), a2 = a2.sibling;
}
function cj(a2, b10) {
  for (var c2 = b10, d2 = false, e3, f2; ; ) {
    if (!d2) {
      d2 = c2.return;
      a:
        for (; ; ) {
          if (null === d2)
            throw Error(y$2(160));
          e3 = d2.stateNode;
          switch (d2.tag) {
            case 5:
              f2 = false;
              break a;
            case 3:
              e3 = e3.containerInfo;
              f2 = true;
              break a;
            case 4:
              e3 = e3.containerInfo;
              f2 = true;
              break a;
          }
          d2 = d2.return;
        }
      d2 = true;
    }
    if (5 === c2.tag || 6 === c2.tag) {
      a:
        for (var g2 = a2, h2 = c2, k2 = h2; ; )
          if (bj(g2, k2), null !== k2.child && 4 !== k2.tag)
            k2.child.return = k2, k2 = k2.child;
          else {
            if (k2 === h2)
              break a;
            for (; null === k2.sibling; ) {
              if (null === k2.return || k2.return === h2)
                break a;
              k2 = k2.return;
            }
            k2.sibling.return = k2.return;
            k2 = k2.sibling;
          }
      f2 ? (g2 = e3, h2 = c2.stateNode, 8 === g2.nodeType ? g2.parentNode.removeChild(h2) : g2.removeChild(h2)) : e3.removeChild(c2.stateNode);
    } else if (4 === c2.tag) {
      if (null !== c2.child) {
        e3 = c2.stateNode.containerInfo;
        f2 = true;
        c2.child.return = c2;
        c2 = c2.child;
        continue;
      }
    } else if (bj(a2, c2), null !== c2.child) {
      c2.child.return = c2;
      c2 = c2.child;
      continue;
    }
    if (c2 === b10)
      break;
    for (; null === c2.sibling; ) {
      if (null === c2.return || c2.return === b10)
        return;
      c2 = c2.return;
      4 === c2.tag && (d2 = false);
    }
    c2.sibling.return = c2.return;
    c2 = c2.sibling;
  }
}
function ij(a2, b10) {
  switch (b10.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
    case 22:
      var c2 = b10.updateQueue;
      c2 = null !== c2 ? c2.lastEffect : null;
      if (null !== c2) {
        var d2 = c2 = c2.next;
        do
          3 === (d2.tag & 3) && (a2 = d2.destroy, d2.destroy = void 0, void 0 !== a2 && a2()), d2 = d2.next;
        while (d2 !== c2);
      }
      return;
    case 1:
      return;
    case 5:
      c2 = b10.stateNode;
      if (null != c2) {
        d2 = b10.memoizedProps;
        var e3 = null !== a2 ? a2.memoizedProps : d2;
        a2 = b10.type;
        var f2 = b10.updateQueue;
        b10.updateQueue = null;
        if (null !== f2) {
          c2[xf] = d2;
          "input" === a2 && "radio" === d2.type && null != d2.name && $a(c2, d2);
          wb(a2, e3);
          b10 = wb(a2, d2);
          for (e3 = 0; e3 < f2.length; e3 += 2) {
            var g2 = f2[e3], h2 = f2[e3 + 1];
            "style" === g2 ? tb(c2, h2) : "dangerouslySetInnerHTML" === g2 ? ob(c2, h2) : "children" === g2 ? pb(c2, h2) : qa(c2, g2, h2, b10);
          }
          switch (a2) {
            case "input":
              ab(c2, d2);
              break;
            case "textarea":
              ib(c2, d2);
              break;
            case "select":
              a2 = c2._wrapperState.wasMultiple, c2._wrapperState.wasMultiple = !!d2.multiple, f2 = d2.value, null != f2 ? fb(c2, !!d2.multiple, f2, false) : a2 !== !!d2.multiple && (null != d2.defaultValue ? fb(c2, !!d2.multiple, d2.defaultValue, true) : fb(c2, !!d2.multiple, d2.multiple ? [] : "", false));
          }
        }
      }
      return;
    case 6:
      if (null === b10.stateNode)
        throw Error(y$2(162));
      b10.stateNode.nodeValue = b10.memoizedProps;
      return;
    case 3:
      c2 = b10.stateNode;
      c2.hydrate && (c2.hydrate = false, Cc(c2.containerInfo));
      return;
    case 12:
      return;
    case 13:
      null !== b10.memoizedState && (jj = O$1(), aj(b10.child, true));
      kj(b10);
      return;
    case 19:
      kj(b10);
      return;
    case 17:
      return;
    case 23:
    case 24:
      aj(b10, null !== b10.memoizedState);
      return;
  }
  throw Error(y$2(163));
}
function kj(a2) {
  var b10 = a2.updateQueue;
  if (null !== b10) {
    a2.updateQueue = null;
    var c2 = a2.stateNode;
    null === c2 && (c2 = a2.stateNode = new Ui());
    b10.forEach(function(b11) {
      var d2 = lj.bind(null, a2, b11);
      c2.has(b11) || (c2.add(b11), b11.then(d2, d2));
    });
  }
}
function mj(a2, b10) {
  return null !== a2 && (a2 = a2.memoizedState, null === a2 || null !== a2.dehydrated) ? (b10 = b10.memoizedState, null !== b10 && null === b10.dehydrated) : false;
}
var nj = Math.ceil, oj = ra.ReactCurrentDispatcher, pj = ra.ReactCurrentOwner, X$1 = 0, U$1 = null, Y = null, W$1 = 0, qj = 0, rj = Bf(0), V = 0, sj = null, tj = 0, Dg = 0, Hi = 0, uj = 0, vj = null, jj = 0, Ji = Infinity;
function wj() {
  Ji = O$1() + 500;
}
var Z$1 = null, Qi = false, Ri = null, Ti = null, xj = false, yj = null, zj = 90, Aj = [], Bj = [], Cj = null, Dj = 0, Ej = null, Fj = -1, Gj = 0, Hj = 0, Ij = null, Jj = false;
function Hg() {
  return 0 !== (X$1 & 48) ? O$1() : -1 !== Fj ? Fj : Fj = O$1();
}
function Ig(a2) {
  a2 = a2.mode;
  if (0 === (a2 & 2))
    return 1;
  if (0 === (a2 & 4))
    return 99 === eg() ? 1 : 2;
  0 === Gj && (Gj = tj);
  if (0 !== kg.transition) {
    0 !== Hj && (Hj = null !== vj ? vj.pendingLanes : 0);
    a2 = Gj;
    var b10 = 4186112 & ~Hj;
    b10 &= -b10;
    0 === b10 && (a2 = 4186112 & ~a2, b10 = a2 & -a2, 0 === b10 && (b10 = 8192));
    return b10;
  }
  a2 = eg();
  0 !== (X$1 & 4) && 98 === a2 ? a2 = Xc(12, Gj) : (a2 = Sc(a2), a2 = Xc(a2, Gj));
  return a2;
}
function Jg(a2, b10, c2) {
  if (50 < Dj)
    throw Dj = 0, Ej = null, Error(y$2(185));
  a2 = Kj(a2, b10);
  if (null === a2)
    return null;
  $c(a2, b10, c2);
  a2 === U$1 && (Hi |= b10, 4 === V && Ii(a2, W$1));
  var d2 = eg();
  1 === b10 ? 0 !== (X$1 & 8) && 0 === (X$1 & 48) ? Lj(a2) : (Mj(a2, c2), 0 === X$1 && (wj(), ig())) : (0 === (X$1 & 4) || 98 !== d2 && 99 !== d2 || (null === Cj ? Cj = /* @__PURE__ */ new Set([a2]) : Cj.add(a2)), Mj(a2, c2));
  vj = a2;
}
function Kj(a2, b10) {
  a2.lanes |= b10;
  var c2 = a2.alternate;
  null !== c2 && (c2.lanes |= b10);
  c2 = a2;
  for (a2 = a2.return; null !== a2; )
    a2.childLanes |= b10, c2 = a2.alternate, null !== c2 && (c2.childLanes |= b10), c2 = a2, a2 = a2.return;
  return 3 === c2.tag ? c2.stateNode : null;
}
function Mj(a2, b10) {
  for (var c2 = a2.callbackNode, d2 = a2.suspendedLanes, e3 = a2.pingedLanes, f2 = a2.expirationTimes, g2 = a2.pendingLanes; 0 < g2; ) {
    var h2 = 31 - Vc(g2), k2 = 1 << h2, l2 = f2[h2];
    if (-1 === l2) {
      if (0 === (k2 & d2) || 0 !== (k2 & e3)) {
        l2 = b10;
        Rc(k2);
        var n2 = F$1;
        f2[h2] = 10 <= n2 ? l2 + 250 : 6 <= n2 ? l2 + 5e3 : -1;
      }
    } else
      l2 <= b10 && (a2.expiredLanes |= k2);
    g2 &= ~k2;
  }
  d2 = Uc(a2, a2 === U$1 ? W$1 : 0);
  b10 = F$1;
  if (0 === d2)
    null !== c2 && (c2 !== Zf && Pf(c2), a2.callbackNode = null, a2.callbackPriority = 0);
  else {
    if (null !== c2) {
      if (a2.callbackPriority === b10)
        return;
      c2 !== Zf && Pf(c2);
    }
    15 === b10 ? (c2 = Lj.bind(null, a2), null === ag ? (ag = [c2], bg = Of(Uf, jg)) : ag.push(c2), c2 = Zf) : 14 === b10 ? c2 = hg(99, Lj.bind(null, a2)) : (c2 = Tc(b10), c2 = hg(c2, Nj.bind(null, a2)));
    a2.callbackPriority = b10;
    a2.callbackNode = c2;
  }
}
function Nj(a2) {
  Fj = -1;
  Hj = Gj = 0;
  if (0 !== (X$1 & 48))
    throw Error(y$2(327));
  var b10 = a2.callbackNode;
  if (Oj() && a2.callbackNode !== b10)
    return null;
  var c2 = Uc(a2, a2 === U$1 ? W$1 : 0);
  if (0 === c2)
    return null;
  var d2 = c2;
  var e3 = X$1;
  X$1 |= 16;
  var f2 = Pj();
  if (U$1 !== a2 || W$1 !== d2)
    wj(), Qj(a2, d2);
  do
    try {
      Rj();
      break;
    } catch (h2) {
      Sj(a2, h2);
    }
  while (1);
  qg();
  oj.current = f2;
  X$1 = e3;
  null !== Y ? d2 = 0 : (U$1 = null, W$1 = 0, d2 = V);
  if (0 !== (tj & Hi))
    Qj(a2, 0);
  else if (0 !== d2) {
    2 === d2 && (X$1 |= 64, a2.hydrate && (a2.hydrate = false, qf(a2.containerInfo)), c2 = Wc(a2), 0 !== c2 && (d2 = Tj(a2, c2)));
    if (1 === d2)
      throw b10 = sj, Qj(a2, 0), Ii(a2, c2), Mj(a2, O$1()), b10;
    a2.finishedWork = a2.current.alternate;
    a2.finishedLanes = c2;
    switch (d2) {
      case 0:
      case 1:
        throw Error(y$2(345));
      case 2:
        Uj(a2);
        break;
      case 3:
        Ii(a2, c2);
        if ((c2 & 62914560) === c2 && (d2 = jj + 500 - O$1(), 10 < d2)) {
          if (0 !== Uc(a2, 0))
            break;
          e3 = a2.suspendedLanes;
          if ((e3 & c2) !== c2) {
            Hg();
            a2.pingedLanes |= a2.suspendedLanes & e3;
            break;
          }
          a2.timeoutHandle = of(Uj.bind(null, a2), d2);
          break;
        }
        Uj(a2);
        break;
      case 4:
        Ii(a2, c2);
        if ((c2 & 4186112) === c2)
          break;
        d2 = a2.eventTimes;
        for (e3 = -1; 0 < c2; ) {
          var g2 = 31 - Vc(c2);
          f2 = 1 << g2;
          g2 = d2[g2];
          g2 > e3 && (e3 = g2);
          c2 &= ~f2;
        }
        c2 = e3;
        c2 = O$1() - c2;
        c2 = (120 > c2 ? 120 : 480 > c2 ? 480 : 1080 > c2 ? 1080 : 1920 > c2 ? 1920 : 3e3 > c2 ? 3e3 : 4320 > c2 ? 4320 : 1960 * nj(c2 / 1960)) - c2;
        if (10 < c2) {
          a2.timeoutHandle = of(Uj.bind(null, a2), c2);
          break;
        }
        Uj(a2);
        break;
      case 5:
        Uj(a2);
        break;
      default:
        throw Error(y$2(329));
    }
  }
  Mj(a2, O$1());
  return a2.callbackNode === b10 ? Nj.bind(null, a2) : null;
}
function Ii(a2, b10) {
  b10 &= ~uj;
  b10 &= ~Hi;
  a2.suspendedLanes |= b10;
  a2.pingedLanes &= ~b10;
  for (a2 = a2.expirationTimes; 0 < b10; ) {
    var c2 = 31 - Vc(b10), d2 = 1 << c2;
    a2[c2] = -1;
    b10 &= ~d2;
  }
}
function Lj(a2) {
  if (0 !== (X$1 & 48))
    throw Error(y$2(327));
  Oj();
  if (a2 === U$1 && 0 !== (a2.expiredLanes & W$1)) {
    var b10 = W$1;
    var c2 = Tj(a2, b10);
    0 !== (tj & Hi) && (b10 = Uc(a2, b10), c2 = Tj(a2, b10));
  } else
    b10 = Uc(a2, 0), c2 = Tj(a2, b10);
  0 !== a2.tag && 2 === c2 && (X$1 |= 64, a2.hydrate && (a2.hydrate = false, qf(a2.containerInfo)), b10 = Wc(a2), 0 !== b10 && (c2 = Tj(a2, b10)));
  if (1 === c2)
    throw c2 = sj, Qj(a2, 0), Ii(a2, b10), Mj(a2, O$1()), c2;
  a2.finishedWork = a2.current.alternate;
  a2.finishedLanes = b10;
  Uj(a2);
  Mj(a2, O$1());
  return null;
}
function Vj() {
  if (null !== Cj) {
    var a2 = Cj;
    Cj = null;
    a2.forEach(function(a3) {
      a3.expiredLanes |= 24 & a3.pendingLanes;
      Mj(a3, O$1());
    });
  }
  ig();
}
function Wj(a2, b10) {
  var c2 = X$1;
  X$1 |= 1;
  try {
    return a2(b10);
  } finally {
    X$1 = c2, 0 === X$1 && (wj(), ig());
  }
}
function Xj(a2, b10) {
  var c2 = X$1;
  X$1 &= -2;
  X$1 |= 8;
  try {
    return a2(b10);
  } finally {
    X$1 = c2, 0 === X$1 && (wj(), ig());
  }
}
function ni(a2, b10) {
  I$1(rj, qj);
  qj |= b10;
  tj |= b10;
}
function Ki() {
  qj = rj.current;
  H$1(rj);
}
function Qj(a2, b10) {
  a2.finishedWork = null;
  a2.finishedLanes = 0;
  var c2 = a2.timeoutHandle;
  -1 !== c2 && (a2.timeoutHandle = -1, pf(c2));
  if (null !== Y)
    for (c2 = Y.return; null !== c2; ) {
      var d2 = c2;
      switch (d2.tag) {
        case 1:
          d2 = d2.type.childContextTypes;
          null !== d2 && void 0 !== d2 && Gf();
          break;
        case 3:
          fh();
          H$1(N$1);
          H$1(M$1);
          uh();
          break;
        case 5:
          hh(d2);
          break;
        case 4:
          fh();
          break;
        case 13:
          H$1(P$1);
          break;
        case 19:
          H$1(P$1);
          break;
        case 10:
          rg(d2);
          break;
        case 23:
        case 24:
          Ki();
      }
      c2 = c2.return;
    }
  U$1 = a2;
  Y = Tg(a2.current, null);
  W$1 = qj = tj = b10;
  V = 0;
  sj = null;
  uj = Hi = Dg = 0;
}
function Sj(a2, b10) {
  do {
    var c2 = Y;
    try {
      qg();
      vh.current = Gh;
      if (yh) {
        for (var d2 = R$1.memoizedState; null !== d2; ) {
          var e3 = d2.queue;
          null !== e3 && (e3.pending = null);
          d2 = d2.next;
        }
        yh = false;
      }
      xh = 0;
      T = S$1 = R$1 = null;
      zh = false;
      pj.current = null;
      if (null === c2 || null === c2.return) {
        V = 1;
        sj = b10;
        Y = null;
        break;
      }
      a: {
        var f2 = a2, g2 = c2.return, h2 = c2, k2 = b10;
        b10 = W$1;
        h2.flags |= 2048;
        h2.firstEffect = h2.lastEffect = null;
        if (null !== k2 && "object" === typeof k2 && "function" === typeof k2.then) {
          var l2 = k2;
          if (0 === (h2.mode & 2)) {
            var n2 = h2.alternate;
            n2 ? (h2.updateQueue = n2.updateQueue, h2.memoizedState = n2.memoizedState, h2.lanes = n2.lanes) : (h2.updateQueue = null, h2.memoizedState = null);
          }
          var A2 = 0 !== (P$1.current & 1), p2 = g2;
          do {
            var C2;
            if (C2 = 13 === p2.tag) {
              var x2 = p2.memoizedState;
              if (null !== x2)
                C2 = null !== x2.dehydrated ? true : false;
              else {
                var w2 = p2.memoizedProps;
                C2 = void 0 === w2.fallback ? false : true !== w2.unstable_avoidThisFallback ? true : A2 ? false : true;
              }
            }
            if (C2) {
              var z2 = p2.updateQueue;
              if (null === z2) {
                var u2 = /* @__PURE__ */ new Set();
                u2.add(l2);
                p2.updateQueue = u2;
              } else
                z2.add(l2);
              if (0 === (p2.mode & 2)) {
                p2.flags |= 64;
                h2.flags |= 16384;
                h2.flags &= -2981;
                if (1 === h2.tag)
                  if (null === h2.alternate)
                    h2.tag = 17;
                  else {
                    var t2 = zg(-1, 1);
                    t2.tag = 2;
                    Ag(h2, t2);
                  }
                h2.lanes |= 1;
                break a;
              }
              k2 = void 0;
              h2 = b10;
              var q2 = f2.pingCache;
              null === q2 ? (q2 = f2.pingCache = new Oi(), k2 = /* @__PURE__ */ new Set(), q2.set(l2, k2)) : (k2 = q2.get(l2), void 0 === k2 && (k2 = /* @__PURE__ */ new Set(), q2.set(l2, k2)));
              if (!k2.has(h2)) {
                k2.add(h2);
                var v2 = Yj.bind(null, f2, l2, h2);
                l2.then(v2, v2);
              }
              p2.flags |= 4096;
              p2.lanes = b10;
              break a;
            }
            p2 = p2.return;
          } while (null !== p2);
          k2 = Error((Ra(h2.type) || "A React component") + " suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display.");
        }
        5 !== V && (V = 2);
        k2 = Mi(k2, h2);
        p2 = g2;
        do {
          switch (p2.tag) {
            case 3:
              f2 = k2;
              p2.flags |= 4096;
              b10 &= -b10;
              p2.lanes |= b10;
              var J2 = Pi(p2, f2, b10);
              Bg(p2, J2);
              break a;
            case 1:
              f2 = k2;
              var K2 = p2.type, Q2 = p2.stateNode;
              if (0 === (p2.flags & 64) && ("function" === typeof K2.getDerivedStateFromError || null !== Q2 && "function" === typeof Q2.componentDidCatch && (null === Ti || !Ti.has(Q2)))) {
                p2.flags |= 4096;
                b10 &= -b10;
                p2.lanes |= b10;
                var L2 = Si(p2, f2, b10);
                Bg(p2, L2);
                break a;
              }
          }
          p2 = p2.return;
        } while (null !== p2);
      }
      Zj(c2);
    } catch (va) {
      b10 = va;
      Y === c2 && null !== c2 && (Y = c2 = c2.return);
      continue;
    }
    break;
  } while (1);
}
function Pj() {
  var a2 = oj.current;
  oj.current = Gh;
  return null === a2 ? Gh : a2;
}
function Tj(a2, b10) {
  var c2 = X$1;
  X$1 |= 16;
  var d2 = Pj();
  U$1 === a2 && W$1 === b10 || Qj(a2, b10);
  do
    try {
      ak();
      break;
    } catch (e3) {
      Sj(a2, e3);
    }
  while (1);
  qg();
  X$1 = c2;
  oj.current = d2;
  if (null !== Y)
    throw Error(y$2(261));
  U$1 = null;
  W$1 = 0;
  return V;
}
function ak() {
  for (; null !== Y; )
    bk(Y);
}
function Rj() {
  for (; null !== Y && !Qf(); )
    bk(Y);
}
function bk(a2) {
  var b10 = ck(a2.alternate, a2, qj);
  a2.memoizedProps = a2.pendingProps;
  null === b10 ? Zj(a2) : Y = b10;
  pj.current = null;
}
function Zj(a2) {
  var b10 = a2;
  do {
    var c2 = b10.alternate;
    a2 = b10.return;
    if (0 === (b10.flags & 2048)) {
      c2 = Gi(c2, b10, qj);
      if (null !== c2) {
        Y = c2;
        return;
      }
      c2 = b10;
      if (24 !== c2.tag && 23 !== c2.tag || null === c2.memoizedState || 0 !== (qj & 1073741824) || 0 === (c2.mode & 4)) {
        for (var d2 = 0, e3 = c2.child; null !== e3; )
          d2 |= e3.lanes | e3.childLanes, e3 = e3.sibling;
        c2.childLanes = d2;
      }
      null !== a2 && 0 === (a2.flags & 2048) && (null === a2.firstEffect && (a2.firstEffect = b10.firstEffect), null !== b10.lastEffect && (null !== a2.lastEffect && (a2.lastEffect.nextEffect = b10.firstEffect), a2.lastEffect = b10.lastEffect), 1 < b10.flags && (null !== a2.lastEffect ? a2.lastEffect.nextEffect = b10 : a2.firstEffect = b10, a2.lastEffect = b10));
    } else {
      c2 = Li(b10);
      if (null !== c2) {
        c2.flags &= 2047;
        Y = c2;
        return;
      }
      null !== a2 && (a2.firstEffect = a2.lastEffect = null, a2.flags |= 2048);
    }
    b10 = b10.sibling;
    if (null !== b10) {
      Y = b10;
      return;
    }
    Y = b10 = a2;
  } while (null !== b10);
  0 === V && (V = 5);
}
function Uj(a2) {
  var b10 = eg();
  gg(99, dk.bind(null, a2, b10));
  return null;
}
function dk(a2, b10) {
  do
    Oj();
  while (null !== yj);
  if (0 !== (X$1 & 48))
    throw Error(y$2(327));
  var c2 = a2.finishedWork;
  if (null === c2)
    return null;
  a2.finishedWork = null;
  a2.finishedLanes = 0;
  if (c2 === a2.current)
    throw Error(y$2(177));
  a2.callbackNode = null;
  var d2 = c2.lanes | c2.childLanes, e3 = d2, f2 = a2.pendingLanes & ~e3;
  a2.pendingLanes = e3;
  a2.suspendedLanes = 0;
  a2.pingedLanes = 0;
  a2.expiredLanes &= e3;
  a2.mutableReadLanes &= e3;
  a2.entangledLanes &= e3;
  e3 = a2.entanglements;
  for (var g2 = a2.eventTimes, h2 = a2.expirationTimes; 0 < f2; ) {
    var k2 = 31 - Vc(f2), l2 = 1 << k2;
    e3[k2] = 0;
    g2[k2] = -1;
    h2[k2] = -1;
    f2 &= ~l2;
  }
  null !== Cj && 0 === (d2 & 24) && Cj.has(a2) && Cj.delete(a2);
  a2 === U$1 && (Y = U$1 = null, W$1 = 0);
  1 < c2.flags ? null !== c2.lastEffect ? (c2.lastEffect.nextEffect = c2, d2 = c2.firstEffect) : d2 = c2 : d2 = c2.firstEffect;
  if (null !== d2) {
    e3 = X$1;
    X$1 |= 32;
    pj.current = null;
    kf = fd;
    g2 = Ne();
    if (Oe(g2)) {
      if ("selectionStart" in g2)
        h2 = { start: g2.selectionStart, end: g2.selectionEnd };
      else
        a:
          if (h2 = (h2 = g2.ownerDocument) && h2.defaultView || window, (l2 = h2.getSelection && h2.getSelection()) && 0 !== l2.rangeCount) {
            h2 = l2.anchorNode;
            f2 = l2.anchorOffset;
            k2 = l2.focusNode;
            l2 = l2.focusOffset;
            try {
              h2.nodeType, k2.nodeType;
            } catch (va) {
              h2 = null;
              break a;
            }
            var n2 = 0, A2 = -1, p2 = -1, C2 = 0, x2 = 0, w2 = g2, z2 = null;
            b:
              for (; ; ) {
                for (var u2; ; ) {
                  w2 !== h2 || 0 !== f2 && 3 !== w2.nodeType || (A2 = n2 + f2);
                  w2 !== k2 || 0 !== l2 && 3 !== w2.nodeType || (p2 = n2 + l2);
                  3 === w2.nodeType && (n2 += w2.nodeValue.length);
                  if (null === (u2 = w2.firstChild))
                    break;
                  z2 = w2;
                  w2 = u2;
                }
                for (; ; ) {
                  if (w2 === g2)
                    break b;
                  z2 === h2 && ++C2 === f2 && (A2 = n2);
                  z2 === k2 && ++x2 === l2 && (p2 = n2);
                  if (null !== (u2 = w2.nextSibling))
                    break;
                  w2 = z2;
                  z2 = w2.parentNode;
                }
                w2 = u2;
              }
            h2 = -1 === A2 || -1 === p2 ? null : { start: A2, end: p2 };
          } else
            h2 = null;
      h2 = h2 || { start: 0, end: 0 };
    } else
      h2 = null;
    lf = { focusedElem: g2, selectionRange: h2 };
    fd = false;
    Ij = null;
    Jj = false;
    Z$1 = d2;
    do
      try {
        ek();
      } catch (va) {
        if (null === Z$1)
          throw Error(y$2(330));
        Wi(Z$1, va);
        Z$1 = Z$1.nextEffect;
      }
    while (null !== Z$1);
    Ij = null;
    Z$1 = d2;
    do
      try {
        for (g2 = a2; null !== Z$1; ) {
          var t2 = Z$1.flags;
          t2 & 16 && pb(Z$1.stateNode, "");
          if (t2 & 128) {
            var q2 = Z$1.alternate;
            if (null !== q2) {
              var v2 = q2.ref;
              null !== v2 && ("function" === typeof v2 ? v2(null) : v2.current = null);
            }
          }
          switch (t2 & 1038) {
            case 2:
              fj(Z$1);
              Z$1.flags &= -3;
              break;
            case 6:
              fj(Z$1);
              Z$1.flags &= -3;
              ij(Z$1.alternate, Z$1);
              break;
            case 1024:
              Z$1.flags &= -1025;
              break;
            case 1028:
              Z$1.flags &= -1025;
              ij(Z$1.alternate, Z$1);
              break;
            case 4:
              ij(Z$1.alternate, Z$1);
              break;
            case 8:
              h2 = Z$1;
              cj(g2, h2);
              var J2 = h2.alternate;
              dj(h2);
              null !== J2 && dj(J2);
          }
          Z$1 = Z$1.nextEffect;
        }
      } catch (va) {
        if (null === Z$1)
          throw Error(y$2(330));
        Wi(Z$1, va);
        Z$1 = Z$1.nextEffect;
      }
    while (null !== Z$1);
    v2 = lf;
    q2 = Ne();
    t2 = v2.focusedElem;
    g2 = v2.selectionRange;
    if (q2 !== t2 && t2 && t2.ownerDocument && Me(t2.ownerDocument.documentElement, t2)) {
      null !== g2 && Oe(t2) && (q2 = g2.start, v2 = g2.end, void 0 === v2 && (v2 = q2), "selectionStart" in t2 ? (t2.selectionStart = q2, t2.selectionEnd = Math.min(v2, t2.value.length)) : (v2 = (q2 = t2.ownerDocument || document) && q2.defaultView || window, v2.getSelection && (v2 = v2.getSelection(), h2 = t2.textContent.length, J2 = Math.min(g2.start, h2), g2 = void 0 === g2.end ? J2 : Math.min(g2.end, h2), !v2.extend && J2 > g2 && (h2 = g2, g2 = J2, J2 = h2), h2 = Le(t2, J2), f2 = Le(t2, g2), h2 && f2 && (1 !== v2.rangeCount || v2.anchorNode !== h2.node || v2.anchorOffset !== h2.offset || v2.focusNode !== f2.node || v2.focusOffset !== f2.offset) && (q2 = q2.createRange(), q2.setStart(h2.node, h2.offset), v2.removeAllRanges(), J2 > g2 ? (v2.addRange(q2), v2.extend(f2.node, f2.offset)) : (q2.setEnd(f2.node, f2.offset), v2.addRange(q2))))));
      q2 = [];
      for (v2 = t2; v2 = v2.parentNode; )
        1 === v2.nodeType && q2.push({ element: v2, left: v2.scrollLeft, top: v2.scrollTop });
      "function" === typeof t2.focus && t2.focus();
      for (t2 = 0; t2 < q2.length; t2++)
        v2 = q2[t2], v2.element.scrollLeft = v2.left, v2.element.scrollTop = v2.top;
    }
    fd = !!kf;
    lf = kf = null;
    a2.current = c2;
    Z$1 = d2;
    do
      try {
        for (t2 = a2; null !== Z$1; ) {
          var K2 = Z$1.flags;
          K2 & 36 && Yi(t2, Z$1.alternate, Z$1);
          if (K2 & 128) {
            q2 = void 0;
            var Q2 = Z$1.ref;
            if (null !== Q2) {
              var L2 = Z$1.stateNode;
              switch (Z$1.tag) {
                case 5:
                  q2 = L2;
                  break;
                default:
                  q2 = L2;
              }
              "function" === typeof Q2 ? Q2(q2) : Q2.current = q2;
            }
          }
          Z$1 = Z$1.nextEffect;
        }
      } catch (va) {
        if (null === Z$1)
          throw Error(y$2(330));
        Wi(Z$1, va);
        Z$1 = Z$1.nextEffect;
      }
    while (null !== Z$1);
    Z$1 = null;
    $f();
    X$1 = e3;
  } else
    a2.current = c2;
  if (xj)
    xj = false, yj = a2, zj = b10;
  else
    for (Z$1 = d2; null !== Z$1; )
      b10 = Z$1.nextEffect, Z$1.nextEffect = null, Z$1.flags & 8 && (K2 = Z$1, K2.sibling = null, K2.stateNode = null), Z$1 = b10;
  d2 = a2.pendingLanes;
  0 === d2 && (Ti = null);
  1 === d2 ? a2 === Ej ? Dj++ : (Dj = 0, Ej = a2) : Dj = 0;
  c2 = c2.stateNode;
  if (Mf && "function" === typeof Mf.onCommitFiberRoot)
    try {
      Mf.onCommitFiberRoot(Lf, c2, void 0, 64 === (c2.current.flags & 64));
    } catch (va) {
    }
  Mj(a2, O$1());
  if (Qi)
    throw Qi = false, a2 = Ri, Ri = null, a2;
  if (0 !== (X$1 & 8))
    return null;
  ig();
  return null;
}
function ek() {
  for (; null !== Z$1; ) {
    var a2 = Z$1.alternate;
    Jj || null === Ij || (0 !== (Z$1.flags & 8) ? dc(Z$1, Ij) && (Jj = true) : 13 === Z$1.tag && mj(a2, Z$1) && dc(Z$1, Ij) && (Jj = true));
    var b10 = Z$1.flags;
    0 !== (b10 & 256) && Xi(a2, Z$1);
    0 === (b10 & 512) || xj || (xj = true, hg(97, function() {
      Oj();
      return null;
    }));
    Z$1 = Z$1.nextEffect;
  }
}
function Oj() {
  if (90 !== zj) {
    var a2 = 97 < zj ? 97 : zj;
    zj = 90;
    return gg(a2, fk);
  }
  return false;
}
function $i(a2, b10) {
  Aj.push(b10, a2);
  xj || (xj = true, hg(97, function() {
    Oj();
    return null;
  }));
}
function Zi(a2, b10) {
  Bj.push(b10, a2);
  xj || (xj = true, hg(97, function() {
    Oj();
    return null;
  }));
}
function fk() {
  if (null === yj)
    return false;
  var a2 = yj;
  yj = null;
  if (0 !== (X$1 & 48))
    throw Error(y$2(331));
  var b10 = X$1;
  X$1 |= 32;
  var c2 = Bj;
  Bj = [];
  for (var d2 = 0; d2 < c2.length; d2 += 2) {
    var e3 = c2[d2], f2 = c2[d2 + 1], g2 = e3.destroy;
    e3.destroy = void 0;
    if ("function" === typeof g2)
      try {
        g2();
      } catch (k2) {
        if (null === f2)
          throw Error(y$2(330));
        Wi(f2, k2);
      }
  }
  c2 = Aj;
  Aj = [];
  for (d2 = 0; d2 < c2.length; d2 += 2) {
    e3 = c2[d2];
    f2 = c2[d2 + 1];
    try {
      var h2 = e3.create;
      e3.destroy = h2();
    } catch (k2) {
      if (null === f2)
        throw Error(y$2(330));
      Wi(f2, k2);
    }
  }
  for (h2 = a2.current.firstEffect; null !== h2; )
    a2 = h2.nextEffect, h2.nextEffect = null, h2.flags & 8 && (h2.sibling = null, h2.stateNode = null), h2 = a2;
  X$1 = b10;
  ig();
  return true;
}
function gk(a2, b10, c2) {
  b10 = Mi(c2, b10);
  b10 = Pi(a2, b10, 1);
  Ag(a2, b10);
  b10 = Hg();
  a2 = Kj(a2, 1);
  null !== a2 && ($c(a2, 1, b10), Mj(a2, b10));
}
function Wi(a2, b10) {
  if (3 === a2.tag)
    gk(a2, a2, b10);
  else
    for (var c2 = a2.return; null !== c2; ) {
      if (3 === c2.tag) {
        gk(c2, a2, b10);
        break;
      } else if (1 === c2.tag) {
        var d2 = c2.stateNode;
        if ("function" === typeof c2.type.getDerivedStateFromError || "function" === typeof d2.componentDidCatch && (null === Ti || !Ti.has(d2))) {
          a2 = Mi(b10, a2);
          var e3 = Si(c2, a2, 1);
          Ag(c2, e3);
          e3 = Hg();
          c2 = Kj(c2, 1);
          if (null !== c2)
            $c(c2, 1, e3), Mj(c2, e3);
          else if ("function" === typeof d2.componentDidCatch && (null === Ti || !Ti.has(d2)))
            try {
              d2.componentDidCatch(b10, a2);
            } catch (f2) {
            }
          break;
        }
      }
      c2 = c2.return;
    }
}
function Yj(a2, b10, c2) {
  var d2 = a2.pingCache;
  null !== d2 && d2.delete(b10);
  b10 = Hg();
  a2.pingedLanes |= a2.suspendedLanes & c2;
  U$1 === a2 && (W$1 & c2) === c2 && (4 === V || 3 === V && (W$1 & 62914560) === W$1 && 500 > O$1() - jj ? Qj(a2, 0) : uj |= c2);
  Mj(a2, b10);
}
function lj(a2, b10) {
  var c2 = a2.stateNode;
  null !== c2 && c2.delete(b10);
  b10 = 0;
  0 === b10 && (b10 = a2.mode, 0 === (b10 & 2) ? b10 = 1 : 0 === (b10 & 4) ? b10 = 99 === eg() ? 1 : 2 : (0 === Gj && (Gj = tj), b10 = Yc(62914560 & ~Gj), 0 === b10 && (b10 = 4194304)));
  c2 = Hg();
  a2 = Kj(a2, b10);
  null !== a2 && ($c(a2, b10, c2), Mj(a2, c2));
}
var ck;
ck = function(a2, b10, c2) {
  var d2 = b10.lanes;
  if (null !== a2)
    if (a2.memoizedProps !== b10.pendingProps || N$1.current)
      ug = true;
    else if (0 !== (c2 & d2))
      ug = 0 !== (a2.flags & 16384) ? true : false;
    else {
      ug = false;
      switch (b10.tag) {
        case 3:
          ri(b10);
          sh();
          break;
        case 5:
          gh(b10);
          break;
        case 1:
          Ff(b10.type) && Jf(b10);
          break;
        case 4:
          eh(b10, b10.stateNode.containerInfo);
          break;
        case 10:
          d2 = b10.memoizedProps.value;
          var e3 = b10.type._context;
          I$1(mg, e3._currentValue);
          e3._currentValue = d2;
          break;
        case 13:
          if (null !== b10.memoizedState) {
            if (0 !== (c2 & b10.child.childLanes))
              return ti(a2, b10, c2);
            I$1(P$1, P$1.current & 1);
            b10 = hi(a2, b10, c2);
            return null !== b10 ? b10.sibling : null;
          }
          I$1(P$1, P$1.current & 1);
          break;
        case 19:
          d2 = 0 !== (c2 & b10.childLanes);
          if (0 !== (a2.flags & 64)) {
            if (d2)
              return Ai(a2, b10, c2);
            b10.flags |= 64;
          }
          e3 = b10.memoizedState;
          null !== e3 && (e3.rendering = null, e3.tail = null, e3.lastEffect = null);
          I$1(P$1, P$1.current);
          if (d2)
            break;
          else
            return null;
        case 23:
        case 24:
          return b10.lanes = 0, mi(a2, b10, c2);
      }
      return hi(a2, b10, c2);
    }
  else
    ug = false;
  b10.lanes = 0;
  switch (b10.tag) {
    case 2:
      d2 = b10.type;
      null !== a2 && (a2.alternate = null, b10.alternate = null, b10.flags |= 2);
      a2 = b10.pendingProps;
      e3 = Ef(b10, M$1.current);
      tg(b10, c2);
      e3 = Ch(null, b10, d2, a2, e3, c2);
      b10.flags |= 1;
      if ("object" === typeof e3 && null !== e3 && "function" === typeof e3.render && void 0 === e3.$$typeof) {
        b10.tag = 1;
        b10.memoizedState = null;
        b10.updateQueue = null;
        if (Ff(d2)) {
          var f2 = true;
          Jf(b10);
        } else
          f2 = false;
        b10.memoizedState = null !== e3.state && void 0 !== e3.state ? e3.state : null;
        xg(b10);
        var g2 = d2.getDerivedStateFromProps;
        "function" === typeof g2 && Gg(b10, d2, g2, a2);
        e3.updater = Kg;
        b10.stateNode = e3;
        e3._reactInternals = b10;
        Og(b10, d2, a2, c2);
        b10 = qi(null, b10, d2, true, f2, c2);
      } else
        b10.tag = 0, fi(null, b10, e3, c2), b10 = b10.child;
      return b10;
    case 16:
      e3 = b10.elementType;
      a: {
        null !== a2 && (a2.alternate = null, b10.alternate = null, b10.flags |= 2);
        a2 = b10.pendingProps;
        f2 = e3._init;
        e3 = f2(e3._payload);
        b10.type = e3;
        f2 = b10.tag = hk(e3);
        a2 = lg(e3, a2);
        switch (f2) {
          case 0:
            b10 = li(null, b10, e3, a2, c2);
            break a;
          case 1:
            b10 = pi$1(null, b10, e3, a2, c2);
            break a;
          case 11:
            b10 = gi(null, b10, e3, a2, c2);
            break a;
          case 14:
            b10 = ii(null, b10, e3, lg(e3.type, a2), d2, c2);
            break a;
        }
        throw Error(y$2(306, e3, ""));
      }
      return b10;
    case 0:
      return d2 = b10.type, e3 = b10.pendingProps, e3 = b10.elementType === d2 ? e3 : lg(d2, e3), li(a2, b10, d2, e3, c2);
    case 1:
      return d2 = b10.type, e3 = b10.pendingProps, e3 = b10.elementType === d2 ? e3 : lg(d2, e3), pi$1(a2, b10, d2, e3, c2);
    case 3:
      ri(b10);
      d2 = b10.updateQueue;
      if (null === a2 || null === d2)
        throw Error(y$2(282));
      d2 = b10.pendingProps;
      e3 = b10.memoizedState;
      e3 = null !== e3 ? e3.element : null;
      yg(a2, b10);
      Cg(b10, d2, null, c2);
      d2 = b10.memoizedState.element;
      if (d2 === e3)
        sh(), b10 = hi(a2, b10, c2);
      else {
        e3 = b10.stateNode;
        if (f2 = e3.hydrate)
          kh = rf(b10.stateNode.containerInfo.firstChild), jh = b10, f2 = lh = true;
        if (f2) {
          a2 = e3.mutableSourceEagerHydrationData;
          if (null != a2)
            for (e3 = 0; e3 < a2.length; e3 += 2)
              f2 = a2[e3], f2._workInProgressVersionPrimary = a2[e3 + 1], th.push(f2);
          c2 = Zg(b10, null, d2, c2);
          for (b10.child = c2; c2; )
            c2.flags = c2.flags & -3 | 1024, c2 = c2.sibling;
        } else
          fi(a2, b10, d2, c2), sh();
        b10 = b10.child;
      }
      return b10;
    case 5:
      return gh(b10), null === a2 && ph(b10), d2 = b10.type, e3 = b10.pendingProps, f2 = null !== a2 ? a2.memoizedProps : null, g2 = e3.children, nf(d2, e3) ? g2 = null : null !== f2 && nf(d2, f2) && (b10.flags |= 16), oi(a2, b10), fi(a2, b10, g2, c2), b10.child;
    case 6:
      return null === a2 && ph(b10), null;
    case 13:
      return ti(a2, b10, c2);
    case 4:
      return eh(b10, b10.stateNode.containerInfo), d2 = b10.pendingProps, null === a2 ? b10.child = Yg(b10, null, d2, c2) : fi(a2, b10, d2, c2), b10.child;
    case 11:
      return d2 = b10.type, e3 = b10.pendingProps, e3 = b10.elementType === d2 ? e3 : lg(d2, e3), gi(a2, b10, d2, e3, c2);
    case 7:
      return fi(a2, b10, b10.pendingProps, c2), b10.child;
    case 8:
      return fi(
        a2,
        b10,
        b10.pendingProps.children,
        c2
      ), b10.child;
    case 12:
      return fi(a2, b10, b10.pendingProps.children, c2), b10.child;
    case 10:
      a: {
        d2 = b10.type._context;
        e3 = b10.pendingProps;
        g2 = b10.memoizedProps;
        f2 = e3.value;
        var h2 = b10.type._context;
        I$1(mg, h2._currentValue);
        h2._currentValue = f2;
        if (null !== g2)
          if (h2 = g2.value, f2 = He(h2, f2) ? 0 : ("function" === typeof d2._calculateChangedBits ? d2._calculateChangedBits(h2, f2) : 1073741823) | 0, 0 === f2) {
            if (g2.children === e3.children && !N$1.current) {
              b10 = hi(a2, b10, c2);
              break a;
            }
          } else
            for (h2 = b10.child, null !== h2 && (h2.return = b10); null !== h2; ) {
              var k2 = h2.dependencies;
              if (null !== k2) {
                g2 = h2.child;
                for (var l2 = k2.firstContext; null !== l2; ) {
                  if (l2.context === d2 && 0 !== (l2.observedBits & f2)) {
                    1 === h2.tag && (l2 = zg(-1, c2 & -c2), l2.tag = 2, Ag(h2, l2));
                    h2.lanes |= c2;
                    l2 = h2.alternate;
                    null !== l2 && (l2.lanes |= c2);
                    sg(h2.return, c2);
                    k2.lanes |= c2;
                    break;
                  }
                  l2 = l2.next;
                }
              } else
                g2 = 10 === h2.tag ? h2.type === b10.type ? null : h2.child : h2.child;
              if (null !== g2)
                g2.return = h2;
              else
                for (g2 = h2; null !== g2; ) {
                  if (g2 === b10) {
                    g2 = null;
                    break;
                  }
                  h2 = g2.sibling;
                  if (null !== h2) {
                    h2.return = g2.return;
                    g2 = h2;
                    break;
                  }
                  g2 = g2.return;
                }
              h2 = g2;
            }
        fi(a2, b10, e3.children, c2);
        b10 = b10.child;
      }
      return b10;
    case 9:
      return e3 = b10.type, f2 = b10.pendingProps, d2 = f2.children, tg(b10, c2), e3 = vg(
        e3,
        f2.unstable_observedBits
      ), d2 = d2(e3), b10.flags |= 1, fi(a2, b10, d2, c2), b10.child;
    case 14:
      return e3 = b10.type, f2 = lg(e3, b10.pendingProps), f2 = lg(e3.type, f2), ii(a2, b10, e3, f2, d2, c2);
    case 15:
      return ki(a2, b10, b10.type, b10.pendingProps, d2, c2);
    case 17:
      return d2 = b10.type, e3 = b10.pendingProps, e3 = b10.elementType === d2 ? e3 : lg(d2, e3), null !== a2 && (a2.alternate = null, b10.alternate = null, b10.flags |= 2), b10.tag = 1, Ff(d2) ? (a2 = true, Jf(b10)) : a2 = false, tg(b10, c2), Mg(b10, d2, e3), Og(b10, d2, e3, c2), qi(null, b10, d2, true, a2, c2);
    case 19:
      return Ai(a2, b10, c2);
    case 23:
      return mi(a2, b10, c2);
    case 24:
      return mi(a2, b10, c2);
  }
  throw Error(y$2(156, b10.tag));
};
function ik(a2, b10, c2, d2) {
  this.tag = a2;
  this.key = c2;
  this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
  this.index = 0;
  this.ref = null;
  this.pendingProps = b10;
  this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
  this.mode = d2;
  this.flags = 0;
  this.lastEffect = this.firstEffect = this.nextEffect = null;
  this.childLanes = this.lanes = 0;
  this.alternate = null;
}
function nh(a2, b10, c2, d2) {
  return new ik(a2, b10, c2, d2);
}
function ji(a2) {
  a2 = a2.prototype;
  return !(!a2 || !a2.isReactComponent);
}
function hk(a2) {
  if ("function" === typeof a2)
    return ji(a2) ? 1 : 0;
  if (void 0 !== a2 && null !== a2) {
    a2 = a2.$$typeof;
    if (a2 === Aa)
      return 11;
    if (a2 === Da)
      return 14;
  }
  return 2;
}
function Tg(a2, b10) {
  var c2 = a2.alternate;
  null === c2 ? (c2 = nh(a2.tag, b10, a2.key, a2.mode), c2.elementType = a2.elementType, c2.type = a2.type, c2.stateNode = a2.stateNode, c2.alternate = a2, a2.alternate = c2) : (c2.pendingProps = b10, c2.type = a2.type, c2.flags = 0, c2.nextEffect = null, c2.firstEffect = null, c2.lastEffect = null);
  c2.childLanes = a2.childLanes;
  c2.lanes = a2.lanes;
  c2.child = a2.child;
  c2.memoizedProps = a2.memoizedProps;
  c2.memoizedState = a2.memoizedState;
  c2.updateQueue = a2.updateQueue;
  b10 = a2.dependencies;
  c2.dependencies = null === b10 ? null : { lanes: b10.lanes, firstContext: b10.firstContext };
  c2.sibling = a2.sibling;
  c2.index = a2.index;
  c2.ref = a2.ref;
  return c2;
}
function Vg(a2, b10, c2, d2, e3, f2) {
  var g2 = 2;
  d2 = a2;
  if ("function" === typeof a2)
    ji(a2) && (g2 = 1);
  else if ("string" === typeof a2)
    g2 = 5;
  else
    a:
      switch (a2) {
        case ua:
          return Xg(c2.children, e3, f2, b10);
        case Ha:
          g2 = 8;
          e3 |= 16;
          break;
        case wa:
          g2 = 8;
          e3 |= 1;
          break;
        case xa:
          return a2 = nh(12, c2, b10, e3 | 8), a2.elementType = xa, a2.type = xa, a2.lanes = f2, a2;
        case Ba:
          return a2 = nh(13, c2, b10, e3), a2.type = Ba, a2.elementType = Ba, a2.lanes = f2, a2;
        case Ca:
          return a2 = nh(19, c2, b10, e3), a2.elementType = Ca, a2.lanes = f2, a2;
        case Ia:
          return vi(c2, e3, f2, b10);
        case Ja:
          return a2 = nh(24, c2, b10, e3), a2.elementType = Ja, a2.lanes = f2, a2;
        default:
          if ("object" === typeof a2 && null !== a2)
            switch (a2.$$typeof) {
              case ya:
                g2 = 10;
                break a;
              case za:
                g2 = 9;
                break a;
              case Aa:
                g2 = 11;
                break a;
              case Da:
                g2 = 14;
                break a;
              case Ea:
                g2 = 16;
                d2 = null;
                break a;
              case Fa:
                g2 = 22;
                break a;
            }
          throw Error(y$2(130, null == a2 ? a2 : typeof a2, ""));
      }
  b10 = nh(g2, c2, b10, e3);
  b10.elementType = a2;
  b10.type = d2;
  b10.lanes = f2;
  return b10;
}
function Xg(a2, b10, c2, d2) {
  a2 = nh(7, a2, d2, b10);
  a2.lanes = c2;
  return a2;
}
function vi(a2, b10, c2, d2) {
  a2 = nh(23, a2, d2, b10);
  a2.elementType = Ia;
  a2.lanes = c2;
  return a2;
}
function Ug(a2, b10, c2) {
  a2 = nh(6, a2, null, b10);
  a2.lanes = c2;
  return a2;
}
function Wg(a2, b10, c2) {
  b10 = nh(4, null !== a2.children ? a2.children : [], a2.key, b10);
  b10.lanes = c2;
  b10.stateNode = { containerInfo: a2.containerInfo, pendingChildren: null, implementation: a2.implementation };
  return b10;
}
function jk(a2, b10, c2) {
  this.tag = b10;
  this.containerInfo = a2;
  this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
  this.timeoutHandle = -1;
  this.pendingContext = this.context = null;
  this.hydrate = c2;
  this.callbackNode = null;
  this.callbackPriority = 0;
  this.eventTimes = Zc(0);
  this.expirationTimes = Zc(-1);
  this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
  this.entanglements = Zc(0);
  this.mutableSourceEagerHydrationData = null;
}
function kk(a2, b10, c2) {
  var d2 = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
  return { $$typeof: ta, key: null == d2 ? null : "" + d2, children: a2, containerInfo: b10, implementation: c2 };
}
function lk(a2, b10, c2, d2) {
  var e3 = b10.current, f2 = Hg(), g2 = Ig(e3);
  a:
    if (c2) {
      c2 = c2._reactInternals;
      b: {
        if (Zb(c2) !== c2 || 1 !== c2.tag)
          throw Error(y$2(170));
        var h2 = c2;
        do {
          switch (h2.tag) {
            case 3:
              h2 = h2.stateNode.context;
              break b;
            case 1:
              if (Ff(h2.type)) {
                h2 = h2.stateNode.__reactInternalMemoizedMergedChildContext;
                break b;
              }
          }
          h2 = h2.return;
        } while (null !== h2);
        throw Error(y$2(171));
      }
      if (1 === c2.tag) {
        var k2 = c2.type;
        if (Ff(k2)) {
          c2 = If(c2, k2, h2);
          break a;
        }
      }
      c2 = h2;
    } else
      c2 = Cf;
  null === b10.context ? b10.context = c2 : b10.pendingContext = c2;
  b10 = zg(f2, g2);
  b10.payload = { element: a2 };
  d2 = void 0 === d2 ? null : d2;
  null !== d2 && (b10.callback = d2);
  Ag(e3, b10);
  Jg(e3, g2, f2);
  return g2;
}
function mk(a2) {
  a2 = a2.current;
  if (!a2.child)
    return null;
  switch (a2.child.tag) {
    case 5:
      return a2.child.stateNode;
    default:
      return a2.child.stateNode;
  }
}
function nk(a2, b10) {
  a2 = a2.memoizedState;
  if (null !== a2 && null !== a2.dehydrated) {
    var c2 = a2.retryLane;
    a2.retryLane = 0 !== c2 && c2 < b10 ? c2 : b10;
  }
}
function ok(a2, b10) {
  nk(a2, b10);
  (a2 = a2.alternate) && nk(a2, b10);
}
function pk() {
  return null;
}
function qk(a2, b10, c2) {
  var d2 = null != c2 && null != c2.hydrationOptions && c2.hydrationOptions.mutableSources || null;
  c2 = new jk(a2, b10, null != c2 && true === c2.hydrate);
  b10 = nh(3, null, null, 2 === b10 ? 7 : 1 === b10 ? 3 : 0);
  c2.current = b10;
  b10.stateNode = c2;
  xg(b10);
  a2[ff] = c2.current;
  cf(8 === a2.nodeType ? a2.parentNode : a2);
  if (d2)
    for (a2 = 0; a2 < d2.length; a2++) {
      b10 = d2[a2];
      var e3 = b10._getVersion;
      e3 = e3(b10._source);
      null == c2.mutableSourceEagerHydrationData ? c2.mutableSourceEagerHydrationData = [b10, e3] : c2.mutableSourceEagerHydrationData.push(b10, e3);
    }
  this._internalRoot = c2;
}
qk.prototype.render = function(a2) {
  lk(a2, this._internalRoot, null, null);
};
qk.prototype.unmount = function() {
  var a2 = this._internalRoot, b10 = a2.containerInfo;
  lk(null, a2, null, function() {
    b10[ff] = null;
  });
};
function rk(a2) {
  return !(!a2 || 1 !== a2.nodeType && 9 !== a2.nodeType && 11 !== a2.nodeType && (8 !== a2.nodeType || " react-mount-point-unstable " !== a2.nodeValue));
}
function sk(a2, b10) {
  b10 || (b10 = a2 ? 9 === a2.nodeType ? a2.documentElement : a2.firstChild : null, b10 = !(!b10 || 1 !== b10.nodeType || !b10.hasAttribute("data-reactroot")));
  if (!b10)
    for (var c2; c2 = a2.lastChild; )
      a2.removeChild(c2);
  return new qk(a2, 0, b10 ? { hydrate: true } : void 0);
}
function tk(a2, b10, c2, d2, e3) {
  var f2 = c2._reactRootContainer;
  if (f2) {
    var g2 = f2._internalRoot;
    if ("function" === typeof e3) {
      var h2 = e3;
      e3 = function() {
        var a3 = mk(g2);
        h2.call(a3);
      };
    }
    lk(b10, g2, a2, e3);
  } else {
    f2 = c2._reactRootContainer = sk(c2, d2);
    g2 = f2._internalRoot;
    if ("function" === typeof e3) {
      var k2 = e3;
      e3 = function() {
        var a3 = mk(g2);
        k2.call(a3);
      };
    }
    Xj(function() {
      lk(b10, g2, a2, e3);
    });
  }
  return mk(g2);
}
ec = function(a2) {
  if (13 === a2.tag) {
    var b10 = Hg();
    Jg(a2, 4, b10);
    ok(a2, 4);
  }
};
fc = function(a2) {
  if (13 === a2.tag) {
    var b10 = Hg();
    Jg(a2, 67108864, b10);
    ok(a2, 67108864);
  }
};
gc = function(a2) {
  if (13 === a2.tag) {
    var b10 = Hg(), c2 = Ig(a2);
    Jg(a2, c2, b10);
    ok(a2, c2);
  }
};
hc = function(a2, b10) {
  return b10();
};
yb = function(a2, b10, c2) {
  switch (b10) {
    case "input":
      ab(a2, c2);
      b10 = c2.name;
      if ("radio" === c2.type && null != b10) {
        for (c2 = a2; c2.parentNode; )
          c2 = c2.parentNode;
        c2 = c2.querySelectorAll("input[name=" + JSON.stringify("" + b10) + '][type="radio"]');
        for (b10 = 0; b10 < c2.length; b10++) {
          var d2 = c2[b10];
          if (d2 !== a2 && d2.form === a2.form) {
            var e3 = Db(d2);
            if (!e3)
              throw Error(y$2(90));
            Wa(d2);
            ab(d2, e3);
          }
        }
      }
      break;
    case "textarea":
      ib(a2, c2);
      break;
    case "select":
      b10 = c2.value, null != b10 && fb(a2, !!c2.multiple, b10, false);
  }
};
Gb = Wj;
Hb = function(a2, b10, c2, d2, e3) {
  var f2 = X$1;
  X$1 |= 4;
  try {
    return gg(98, a2.bind(null, b10, c2, d2, e3));
  } finally {
    X$1 = f2, 0 === X$1 && (wj(), ig());
  }
};
Ib = function() {
  0 === (X$1 & 49) && (Vj(), Oj());
};
Jb = function(a2, b10) {
  var c2 = X$1;
  X$1 |= 2;
  try {
    return a2(b10);
  } finally {
    X$1 = c2, 0 === X$1 && (wj(), ig());
  }
};
function uk(a2, b10) {
  var c2 = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
  if (!rk(b10))
    throw Error(y$2(200));
  return kk(a2, b10, null, c2);
}
var vk = { Events: [Cb, ue, Db, Eb, Fb, Oj, { current: false }] }, wk = { findFiberByHostInstance: wc, bundleType: 0, version: "17.0.2", rendererPackageName: "react-dom" };
var xk = { bundleType: wk.bundleType, version: wk.version, rendererPackageName: wk.rendererPackageName, rendererConfig: wk.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ra.ReactCurrentDispatcher, findHostInstanceByFiber: function(a2) {
  a2 = cc(a2);
  return null === a2 ? null : a2.stateNode;
}, findFiberByHostInstance: wk.findFiberByHostInstance || pk, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null };
if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
  var yk = __REACT_DEVTOOLS_GLOBAL_HOOK__;
  if (!yk.isDisabled && yk.supportsFiber)
    try {
      Lf = yk.inject(xk), Mf = yk;
    } catch (a2) {
    }
}
reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = vk;
reactDom_production_min.createPortal = uk;
reactDom_production_min.findDOMNode = function(a2) {
  if (null == a2)
    return null;
  if (1 === a2.nodeType)
    return a2;
  var b10 = a2._reactInternals;
  if (void 0 === b10) {
    if ("function" === typeof a2.render)
      throw Error(y$2(188));
    throw Error(y$2(268, Object.keys(a2)));
  }
  a2 = cc(b10);
  a2 = null === a2 ? null : a2.stateNode;
  return a2;
};
reactDom_production_min.flushSync = function(a2, b10) {
  var c2 = X$1;
  if (0 !== (c2 & 48))
    return a2(b10);
  X$1 |= 1;
  try {
    if (a2)
      return gg(99, a2.bind(null, b10));
  } finally {
    X$1 = c2, ig();
  }
};
reactDom_production_min.hydrate = function(a2, b10, c2) {
  if (!rk(b10))
    throw Error(y$2(200));
  return tk(null, a2, b10, true, c2);
};
reactDom_production_min.render = function(a2, b10, c2) {
  if (!rk(b10))
    throw Error(y$2(200));
  return tk(null, a2, b10, false, c2);
};
reactDom_production_min.unmountComponentAtNode = function(a2) {
  if (!rk(a2))
    throw Error(y$2(40));
  return a2._reactRootContainer ? (Xj(function() {
    tk(null, null, a2, false, function() {
      a2._reactRootContainer = null;
      a2[ff] = null;
    });
  }), true) : false;
};
reactDom_production_min.unstable_batchedUpdates = Wj;
reactDom_production_min.unstable_createPortal = function(a2, b10) {
  return uk(a2, b10, 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null);
};
reactDom_production_min.unstable_renderSubtreeIntoContainer = function(a2, b10, c2, d2) {
  if (!rk(c2))
    throw Error(y$2(200));
  if (null == a2 || void 0 === a2._reactInternals)
    throw Error(y$2(38));
  return tk(a2, b10, c2, false, d2);
};
reactDom_production_min.version = "17.0.2";
function checkDCE() {
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
    return;
  }
  try {
    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
  } catch (err) {
    console.error(err);
  }
}
{
  checkDCE();
  reactDom.exports = reactDom_production_min;
}
var ReactDOM = reactDom.exports;
var ReactDOM$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  "default": ReactDOM
}, [reactDom.exports]);
/**
 * @remix-run/router v1.0.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function _extends$5() {
  _extends$5 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key2 in source) {
        if (Object.prototype.hasOwnProperty.call(source, key2)) {
          target[key2] = source[key2];
        }
      }
    }
    return target;
  };
  return _extends$5.apply(this, arguments);
}
var Action$1;
(function(Action2) {
  Action2["Pop"] = "POP";
  Action2["Push"] = "PUSH";
  Action2["Replace"] = "REPLACE";
})(Action$1 || (Action$1 = {}));
const PopStateEventType = "popstate";
function createBrowserHistory(options) {
  if (options === void 0) {
    options = {};
  }
  function createBrowserLocation(window2, globalHistory) {
    let {
      pathname,
      search,
      hash
    } = window2.location;
    return createLocation(
      "",
      {
        pathname,
        search,
        hash
      },
      globalHistory.state && globalHistory.state.usr || null,
      globalHistory.state && globalHistory.state.key || "default"
    );
  }
  function createBrowserHref(window2, to) {
    return typeof to === "string" ? to : createPath(to);
  }
  return getUrlBasedHistory(createBrowserLocation, createBrowserHref, null, options);
}
function createKey() {
  return Math.random().toString(36).substr(2, 8);
}
function getHistoryState(location) {
  return {
    usr: location.state,
    key: location.key
  };
}
function createLocation(current, to, state2, key2) {
  if (state2 === void 0) {
    state2 = null;
  }
  let location = _extends$5({
    pathname: typeof current === "string" ? current : current.pathname,
    search: "",
    hash: ""
  }, typeof to === "string" ? parsePath$1(to) : to, {
    state: state2,
    key: to && to.key || key2 || createKey()
  });
  return location;
}
function createPath(_ref) {
  let {
    pathname = "/",
    search = "",
    hash = ""
  } = _ref;
  if (search && search !== "?")
    pathname += search.charAt(0) === "?" ? search : "?" + search;
  if (hash && hash !== "#")
    pathname += hash.charAt(0) === "#" ? hash : "#" + hash;
  return pathname;
}
function parsePath$1(path2) {
  let parsedPath = {};
  if (path2) {
    let hashIndex = path2.indexOf("#");
    if (hashIndex >= 0) {
      parsedPath.hash = path2.substr(hashIndex);
      path2 = path2.substr(0, hashIndex);
    }
    let searchIndex = path2.indexOf("?");
    if (searchIndex >= 0) {
      parsedPath.search = path2.substr(searchIndex);
      path2 = path2.substr(0, searchIndex);
    }
    if (path2) {
      parsedPath.pathname = path2;
    }
  }
  return parsedPath;
}
function getUrlBasedHistory(getLocation, createHref, validateLocation, options) {
  if (options === void 0) {
    options = {};
  }
  let {
    window: window2 = document.defaultView,
    v5Compat = false
  } = options;
  let globalHistory = window2.history;
  let action = Action$1.Pop;
  let listener = null;
  function handlePop() {
    action = Action$1.Pop;
    if (listener) {
      listener({
        action,
        location: history.location
      });
    }
  }
  function push(to, state2) {
    action = Action$1.Push;
    let location = createLocation(history.location, to, state2);
    if (validateLocation)
      validateLocation(location, to);
    let historyState = getHistoryState(location);
    let url2 = history.createHref(location);
    try {
      globalHistory.pushState(historyState, "", url2);
    } catch (error) {
      window2.location.assign(url2);
    }
    if (v5Compat && listener) {
      listener({
        action,
        location
      });
    }
  }
  function replace(to, state2) {
    action = Action$1.Replace;
    let location = createLocation(history.location, to, state2);
    if (validateLocation)
      validateLocation(location, to);
    let historyState = getHistoryState(location);
    let url2 = history.createHref(location);
    globalHistory.replaceState(historyState, "", url2);
    if (v5Compat && listener) {
      listener({
        action,
        location
      });
    }
  }
  let history = {
    get action() {
      return action;
    },
    get location() {
      return getLocation(window2, globalHistory);
    },
    listen(fn2) {
      if (listener) {
        throw new Error("A history only accepts one active listener");
      }
      window2.addEventListener(PopStateEventType, handlePop);
      listener = fn2;
      return () => {
        window2.removeEventListener(PopStateEventType, handlePop);
        listener = null;
      };
    },
    createHref(to) {
      return createHref(window2, to);
    },
    push,
    replace,
    go(n2) {
      return globalHistory.go(n2);
    }
  };
  return history;
}
var ResultType;
(function(ResultType2) {
  ResultType2["data"] = "data";
  ResultType2["deferred"] = "deferred";
  ResultType2["redirect"] = "redirect";
  ResultType2["error"] = "error";
})(ResultType || (ResultType = {}));
function matchRoutes(routes, locationArg, basename) {
  if (basename === void 0) {
    basename = "/";
  }
  let location = typeof locationArg === "string" ? parsePath$1(locationArg) : locationArg;
  let pathname = stripBasename(location.pathname || "/", basename);
  if (pathname == null) {
    return null;
  }
  let branches = flattenRoutes(routes);
  rankRouteBranches(branches);
  let matches = null;
  for (let i2 = 0; matches == null && i2 < branches.length; ++i2) {
    matches = matchRouteBranch(branches[i2], pathname);
  }
  return matches;
}
function flattenRoutes(routes, branches, parentsMeta, parentPath) {
  if (branches === void 0) {
    branches = [];
  }
  if (parentsMeta === void 0) {
    parentsMeta = [];
  }
  if (parentPath === void 0) {
    parentPath = "";
  }
  routes.forEach((route, index2) => {
    let meta2 = {
      relativePath: route.path || "",
      caseSensitive: route.caseSensitive === true,
      childrenIndex: index2,
      route
    };
    if (meta2.relativePath.startsWith("/")) {
      invariant(meta2.relativePath.startsWith(parentPath), 'Absolute route path "' + meta2.relativePath + '" nested under path ' + ('"' + parentPath + '" is not valid. An absolute child route path ') + "must start with the combined path of all its parent routes.");
      meta2.relativePath = meta2.relativePath.slice(parentPath.length);
    }
    let path2 = joinPaths([parentPath, meta2.relativePath]);
    let routesMeta = parentsMeta.concat(meta2);
    if (route.children && route.children.length > 0) {
      invariant(route.index !== true, "Index routes must not have child routes. Please remove " + ('all child routes from route path "' + path2 + '".'));
      flattenRoutes(route.children, branches, routesMeta, path2);
    }
    if (route.path == null && !route.index) {
      return;
    }
    branches.push({
      path: path2,
      score: computeScore(path2, route.index),
      routesMeta
    });
  });
  return branches;
}
function rankRouteBranches(branches) {
  branches.sort((a2, b10) => a2.score !== b10.score ? b10.score - a2.score : compareIndexes(a2.routesMeta.map((meta2) => meta2.childrenIndex), b10.routesMeta.map((meta2) => meta2.childrenIndex)));
}
const paramRe = /^:\w+$/;
const dynamicSegmentValue = 3;
const indexRouteValue = 2;
const emptySegmentValue = 1;
const staticSegmentValue = 10;
const splatPenalty = -2;
const isSplat = (s2) => s2 === "*";
function computeScore(path2, index2) {
  let segments = path2.split("/");
  let initialScore = segments.length;
  if (segments.some(isSplat)) {
    initialScore += splatPenalty;
  }
  if (index2) {
    initialScore += indexRouteValue;
  }
  return segments.filter((s2) => !isSplat(s2)).reduce((score2, segment) => score2 + (paramRe.test(segment) ? dynamicSegmentValue : segment === "" ? emptySegmentValue : staticSegmentValue), initialScore);
}
function compareIndexes(a2, b10) {
  let siblings2 = a2.length === b10.length && a2.slice(0, -1).every((n2, i2) => n2 === b10[i2]);
  return siblings2 ? a2[a2.length - 1] - b10[b10.length - 1] : 0;
}
function matchRouteBranch(branch, pathname) {
  let {
    routesMeta
  } = branch;
  let matchedParams = {};
  let matchedPathname = "/";
  let matches = [];
  for (let i2 = 0; i2 < routesMeta.length; ++i2) {
    let meta2 = routesMeta[i2];
    let end = i2 === routesMeta.length - 1;
    let remainingPathname = matchedPathname === "/" ? pathname : pathname.slice(matchedPathname.length) || "/";
    let match2 = matchPath({
      path: meta2.relativePath,
      caseSensitive: meta2.caseSensitive,
      end
    }, remainingPathname);
    if (!match2)
      return null;
    Object.assign(matchedParams, match2.params);
    let route = meta2.route;
    matches.push({
      params: matchedParams,
      pathname: joinPaths([matchedPathname, match2.pathname]),
      pathnameBase: normalizePathname(joinPaths([matchedPathname, match2.pathnameBase])),
      route
    });
    if (match2.pathnameBase !== "/") {
      matchedPathname = joinPaths([matchedPathname, match2.pathnameBase]);
    }
  }
  return matches;
}
function matchPath(pattern4, pathname) {
  if (typeof pattern4 === "string") {
    pattern4 = {
      path: pattern4,
      caseSensitive: false,
      end: true
    };
  }
  let [matcher, paramNames] = compilePath(pattern4.path, pattern4.caseSensitive, pattern4.end);
  let match2 = pathname.match(matcher);
  if (!match2)
    return null;
  let matchedPathname = match2[0];
  let pathnameBase = matchedPathname.replace(/(.)\/+$/, "$1");
  let captureGroups = match2.slice(1);
  let params = paramNames.reduce((memo, paramName, index2) => {
    if (paramName === "*") {
      let splatValue = captureGroups[index2] || "";
      pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\/+$/, "$1");
    }
    memo[paramName] = safelyDecodeURIComponent(captureGroups[index2] || "", paramName);
    return memo;
  }, {});
  return {
    params,
    pathname: matchedPathname,
    pathnameBase,
    pattern: pattern4
  };
}
function compilePath(path2, caseSensitive, end) {
  if (caseSensitive === void 0) {
    caseSensitive = false;
  }
  if (end === void 0) {
    end = true;
  }
  warning$3(path2 === "*" || !path2.endsWith("*") || path2.endsWith("/*"), 'Route path "' + path2 + '" will be treated as if it were ' + ('"' + path2.replace(/\*$/, "/*") + '" because the `*` character must ') + "always follow a `/` in the pattern. To get rid of this warning, " + ('please change the route path to "' + path2.replace(/\*$/, "/*") + '".'));
  let paramNames = [];
  let regexpSource = "^" + path2.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^$?{}|()[\]]/g, "\\$&").replace(/:(\w+)/g, (_2, paramName) => {
    paramNames.push(paramName);
    return "([^\\/]+)";
  });
  if (path2.endsWith("*")) {
    paramNames.push("*");
    regexpSource += path2 === "*" || path2 === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$";
  } else {
    regexpSource += end ? "\\/*$" : "(?:(?=[@.~-]|%[0-9A-F]{2})|\\b|\\/|$)";
  }
  let matcher = new RegExp(regexpSource, caseSensitive ? void 0 : "i");
  return [matcher, paramNames];
}
function safelyDecodeURIComponent(value2, paramName) {
  try {
    return decodeURIComponent(value2);
  } catch (error) {
    warning$3(false, 'The value for the URL param "' + paramName + '" will not be decoded because' + (' the string "' + value2 + '" is a malformed URL segment. This is probably') + (" due to a bad percent encoding (" + error + ")."));
    return value2;
  }
}
function stripBasename(pathname, basename) {
  if (basename === "/")
    return pathname;
  if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {
    return null;
  }
  let startIndex = basename.endsWith("/") ? basename.length - 1 : basename.length;
  let nextChar = pathname.charAt(startIndex);
  if (nextChar && nextChar !== "/") {
    return null;
  }
  return pathname.slice(startIndex) || "/";
}
function invariant(value2, message2) {
  if (value2 === false || value2 === null || typeof value2 === "undefined") {
    throw new Error(message2);
  }
}
function warning$3(cond, message2) {
  if (!cond) {
    if (typeof console !== "undefined")
      console.warn(message2);
    try {
      throw new Error(message2);
    } catch (e3) {
    }
  }
}
function resolvePath(to, fromPathname) {
  if (fromPathname === void 0) {
    fromPathname = "/";
  }
  let {
    pathname: toPathname,
    search = "",
    hash = ""
  } = typeof to === "string" ? parsePath$1(to) : to;
  let pathname = toPathname ? toPathname.startsWith("/") ? toPathname : resolvePathname(toPathname, fromPathname) : fromPathname;
  return {
    pathname,
    search: normalizeSearch(search),
    hash: normalizeHash(hash)
  };
}
function resolvePathname(relativePath, fromPathname) {
  let segments = fromPathname.replace(/\/+$/, "").split("/");
  let relativeSegments = relativePath.split("/");
  relativeSegments.forEach((segment) => {
    if (segment === "..") {
      if (segments.length > 1)
        segments.pop();
    } else if (segment !== ".") {
      segments.push(segment);
    }
  });
  return segments.length > 1 ? segments.join("/") : "/";
}
function resolveTo(toArg, routePathnames, locationPathname, isPathRelative) {
  if (isPathRelative === void 0) {
    isPathRelative = false;
  }
  let to = typeof toArg === "string" ? parsePath$1(toArg) : _extends$5({}, toArg);
  let isEmptyPath = toArg === "" || to.pathname === "";
  let toPathname = isEmptyPath ? "/" : to.pathname;
  let from;
  if (isPathRelative || toPathname == null) {
    from = locationPathname;
  } else {
    let routePathnameIndex = routePathnames.length - 1;
    if (toPathname.startsWith("..")) {
      let toSegments = toPathname.split("/");
      while (toSegments[0] === "..") {
        toSegments.shift();
        routePathnameIndex -= 1;
      }
      to.pathname = toSegments.join("/");
    }
    from = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : "/";
  }
  let path2 = resolvePath(to, from);
  let hasExplicitTrailingSlash = toPathname && toPathname !== "/" && toPathname.endsWith("/");
  let hasCurrentTrailingSlash = (isEmptyPath || toPathname === ".") && locationPathname.endsWith("/");
  if (!path2.pathname.endsWith("/") && (hasExplicitTrailingSlash || hasCurrentTrailingSlash)) {
    path2.pathname += "/";
  }
  return path2;
}
const joinPaths = (paths) => paths.join("/").replace(/\/\/+/g, "/");
const normalizePathname = (pathname) => pathname.replace(/\/+$/, "").replace(/^\/*/, "/");
const normalizeSearch = (search) => !search || search === "?" ? "" : search.startsWith("?") ? search : "?" + search;
const normalizeHash = (hash) => !hash || hash === "#" ? "" : hash.startsWith("#") ? hash : "#" + hash;
class ErrorResponse {
  constructor(status, statusText, data2) {
    this.status = status;
    this.statusText = statusText || "";
    this.data = data2;
  }
}
function isRouteErrorResponse(e3) {
  return e3 instanceof ErrorResponse;
}
/**
 * React Router v6.4.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function _extends$4() {
  _extends$4 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key2 in source) {
        if (Object.prototype.hasOwnProperty.call(source, key2)) {
          target[key2] = source[key2];
        }
      }
    }
    return target;
  };
  return _extends$4.apply(this, arguments);
}
function isPolyfill(x2, y2) {
  return x2 === y2 && (x2 !== 0 || 1 / x2 === 1 / y2) || x2 !== x2 && y2 !== y2;
}
const is = typeof Object.is === "function" ? Object.is : isPolyfill;
const {
  useState: useState$1,
  useEffect: useEffect$1,
  useLayoutEffect: useLayoutEffect$2,
  useDebugValue
} = React$1;
function useSyncExternalStore$2(subscribe2, getSnapshot, getServerSnapshot) {
  const value2 = getSnapshot();
  const [{
    inst
  }, forceUpdate] = useState$1({
    inst: {
      value: value2,
      getSnapshot
    }
  });
  useLayoutEffect$2(() => {
    inst.value = value2;
    inst.getSnapshot = getSnapshot;
    if (checkIfSnapshotChanged(inst)) {
      forceUpdate({
        inst
      });
    }
  }, [subscribe2, value2, getSnapshot]);
  useEffect$1(() => {
    if (checkIfSnapshotChanged(inst)) {
      forceUpdate({
        inst
      });
    }
    const handleStoreChange = () => {
      if (checkIfSnapshotChanged(inst)) {
        forceUpdate({
          inst
        });
      }
    };
    return subscribe2(handleStoreChange);
  }, [subscribe2]);
  useDebugValue(value2);
  return value2;
}
function checkIfSnapshotChanged(inst) {
  const latestGetSnapshot = inst.getSnapshot;
  const prevValue = inst.value;
  try {
    const nextValue = latestGetSnapshot();
    return !is(prevValue, nextValue);
  } catch (error) {
    return true;
  }
}
function useSyncExternalStore$1(subscribe2, getSnapshot, getServerSnapshot) {
  return getSnapshot();
}
const canUseDOM$1 = !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
const isServerEnvironment = !canUseDOM$1;
const shim$1 = isServerEnvironment ? useSyncExternalStore$1 : useSyncExternalStore$2;
"useSyncExternalStore" in React$1 ? ((module) => module.useSyncExternalStore)(React$1) : shim$1;
const DataStaticRouterContext = /* @__PURE__ */ react.exports.createContext(null);
const DataRouterContext = /* @__PURE__ */ react.exports.createContext(null);
const DataRouterStateContext = /* @__PURE__ */ react.exports.createContext(null);
const NavigationContext = /* @__PURE__ */ react.exports.createContext(null);
const LocationContext = /* @__PURE__ */ react.exports.createContext(null);
const RouteContext = /* @__PURE__ */ react.exports.createContext({
  outlet: null,
  matches: []
});
const RouteErrorContext = /* @__PURE__ */ react.exports.createContext(null);
function useHref(to, _temp) {
  let {
    relative
  } = _temp === void 0 ? {} : _temp;
  !useInRouterContext() ? invariant(false) : void 0;
  let {
    basename,
    navigator: navigator2
  } = react.exports.useContext(NavigationContext);
  let {
    hash,
    pathname,
    search
  } = useResolvedPath(to, {
    relative
  });
  let joinedPathname = pathname;
  if (basename !== "/") {
    joinedPathname = pathname === "/" ? basename : joinPaths([basename, pathname]);
  }
  return navigator2.createHref({
    pathname: joinedPathname,
    search,
    hash
  });
}
function useInRouterContext() {
  return react.exports.useContext(LocationContext) != null;
}
function useLocation() {
  !useInRouterContext() ? invariant(false) : void 0;
  return react.exports.useContext(LocationContext).location;
}
function useMatch(pattern4) {
  !useInRouterContext() ? invariant(false) : void 0;
  let {
    pathname
  } = useLocation();
  return react.exports.useMemo(() => matchPath(pattern4, pathname), [pathname, pattern4]);
}
function getPathContributingMatches(matches) {
  return matches.filter((match2, index2) => index2 === 0 || !match2.route.index && match2.pathnameBase !== matches[index2 - 1].pathnameBase);
}
function useNavigate() {
  !useInRouterContext() ? invariant(false) : void 0;
  let {
    basename,
    navigator: navigator2
  } = react.exports.useContext(NavigationContext);
  let {
    matches
  } = react.exports.useContext(RouteContext);
  let {
    pathname: locationPathname
  } = useLocation();
  let routePathnamesJson = JSON.stringify(getPathContributingMatches(matches).map((match2) => match2.pathnameBase));
  let activeRef = react.exports.useRef(false);
  react.exports.useEffect(() => {
    activeRef.current = true;
  });
  let navigate = react.exports.useCallback(function(to, options) {
    if (options === void 0) {
      options = {};
    }
    if (!activeRef.current)
      return;
    if (typeof to === "number") {
      navigator2.go(to);
      return;
    }
    let path2 = resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, options.relative === "path");
    if (basename !== "/") {
      path2.pathname = path2.pathname === "/" ? basename : joinPaths([basename, path2.pathname]);
    }
    (!!options.replace ? navigator2.replace : navigator2.push)(path2, options.state, options);
  }, [basename, navigator2, routePathnamesJson, locationPathname]);
  return navigate;
}
function useParams() {
  let {
    matches
  } = react.exports.useContext(RouteContext);
  let routeMatch = matches[matches.length - 1];
  return routeMatch ? routeMatch.params : {};
}
function useResolvedPath(to, _temp2) {
  let {
    relative
  } = _temp2 === void 0 ? {} : _temp2;
  let {
    matches
  } = react.exports.useContext(RouteContext);
  let {
    pathname: locationPathname
  } = useLocation();
  let routePathnamesJson = JSON.stringify(getPathContributingMatches(matches).map((match2) => match2.pathnameBase));
  return react.exports.useMemo(() => resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, relative === "path"), [to, routePathnamesJson, locationPathname, relative]);
}
function useRoutes(routes, locationArg) {
  !useInRouterContext() ? invariant(false) : void 0;
  let dataRouterStateContext = react.exports.useContext(DataRouterStateContext);
  let {
    matches: parentMatches
  } = react.exports.useContext(RouteContext);
  let routeMatch = parentMatches[parentMatches.length - 1];
  let parentParams = routeMatch ? routeMatch.params : {};
  routeMatch ? routeMatch.pathname : "/";
  let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : "/";
  routeMatch && routeMatch.route;
  let locationFromContext = useLocation();
  let location;
  if (locationArg) {
    var _parsedLocationArg$pa;
    let parsedLocationArg = typeof locationArg === "string" ? parsePath$1(locationArg) : locationArg;
    !(parentPathnameBase === "/" || ((_parsedLocationArg$pa = parsedLocationArg.pathname) == null ? void 0 : _parsedLocationArg$pa.startsWith(parentPathnameBase))) ? invariant(false) : void 0;
    location = parsedLocationArg;
  } else {
    location = locationFromContext;
  }
  let pathname = location.pathname || "/";
  let remainingPathname = parentPathnameBase === "/" ? pathname : pathname.slice(parentPathnameBase.length) || "/";
  let matches = matchRoutes(routes, {
    pathname: remainingPathname
  });
  let renderedMatches = _renderMatches(matches && matches.map((match2) => Object.assign({}, match2, {
    params: Object.assign({}, parentParams, match2.params),
    pathname: joinPaths([parentPathnameBase, match2.pathname]),
    pathnameBase: match2.pathnameBase === "/" ? parentPathnameBase : joinPaths([parentPathnameBase, match2.pathnameBase])
  })), parentMatches, dataRouterStateContext || void 0);
  if (locationArg) {
    return /* @__PURE__ */ react.exports.createElement(LocationContext.Provider, {
      value: {
        location: _extends$4({
          pathname: "/",
          search: "",
          hash: "",
          state: null,
          key: "default"
        }, location),
        navigationType: Action$1.Pop
      }
    }, renderedMatches);
  }
  return renderedMatches;
}
function DefaultErrorElement() {
  let error = useRouteError();
  let message2 = isRouteErrorResponse(error) ? error.status + " " + error.statusText : error instanceof Error ? error.message : JSON.stringify(error);
  let stack = error instanceof Error ? error.stack : null;
  let lightgrey = "rgba(200,200,200, 0.5)";
  let preStyles = {
    padding: "0.5rem",
    backgroundColor: lightgrey
  };
  let codeStyles = {
    padding: "2px 4px",
    backgroundColor: lightgrey
  };
  return /* @__PURE__ */ react.exports.createElement(react.exports.Fragment, null, /* @__PURE__ */ react.exports.createElement("h2", null, "Unhandled Thrown Error!"), /* @__PURE__ */ react.exports.createElement("h3", {
    style: {
      fontStyle: "italic"
    }
  }, message2), stack ? /* @__PURE__ */ react.exports.createElement("pre", {
    style: preStyles
  }, stack) : null, /* @__PURE__ */ react.exports.createElement("p", null, "\u{1F4BF} Hey developer \u{1F44B}"), /* @__PURE__ */ react.exports.createElement("p", null, "You can provide a way better UX than this when your app throws errors by providing your own\xA0", /* @__PURE__ */ react.exports.createElement("code", {
    style: codeStyles
  }, "errorElement"), " props on\xA0", /* @__PURE__ */ react.exports.createElement("code", {
    style: codeStyles
  }, "<Route>")));
}
class RenderErrorBoundary extends react.exports.Component {
  constructor(props) {
    super(props);
    this.state = {
      location: props.location,
      error: props.error
    };
  }
  static getDerivedStateFromError(error) {
    return {
      error
    };
  }
  static getDerivedStateFromProps(props, state2) {
    if (state2.location !== props.location) {
      return {
        error: props.error,
        location: props.location
      };
    }
    return {
      error: props.error || state2.error,
      location: state2.location
    };
  }
  componentDidCatch(error, errorInfo) {
    console.error("React Router caught the following error during render", error, errorInfo);
  }
  render() {
    return this.state.error ? /* @__PURE__ */ react.exports.createElement(RouteErrorContext.Provider, {
      value: this.state.error,
      children: this.props.component
    }) : this.props.children;
  }
}
function RenderedRoute(_ref) {
  let {
    routeContext,
    match: match2,
    children
  } = _ref;
  let dataStaticRouterContext = react.exports.useContext(DataStaticRouterContext);
  if (dataStaticRouterContext && match2.route.errorElement) {
    dataStaticRouterContext._deepestRenderedBoundaryId = match2.route.id;
  }
  return /* @__PURE__ */ react.exports.createElement(RouteContext.Provider, {
    value: routeContext
  }, children);
}
function _renderMatches(matches, parentMatches, dataRouterState) {
  if (parentMatches === void 0) {
    parentMatches = [];
  }
  if (matches == null) {
    if (dataRouterState != null && dataRouterState.errors) {
      matches = dataRouterState.matches;
    } else {
      return null;
    }
  }
  let renderedMatches = matches;
  let errors = dataRouterState == null ? void 0 : dataRouterState.errors;
  if (errors != null) {
    let errorIndex = renderedMatches.findIndex((m2) => m2.route.id && (errors == null ? void 0 : errors[m2.route.id]));
    !(errorIndex >= 0) ? invariant(false) : void 0;
    renderedMatches = renderedMatches.slice(0, Math.min(renderedMatches.length, errorIndex + 1));
  }
  return renderedMatches.reduceRight((outlet, match2, index2) => {
    let error = match2.route.id ? errors == null ? void 0 : errors[match2.route.id] : null;
    let errorElement = dataRouterState ? match2.route.errorElement || /* @__PURE__ */ react.exports.createElement(DefaultErrorElement, null) : null;
    let getChildren = () => /* @__PURE__ */ react.exports.createElement(RenderedRoute, {
      match: match2,
      routeContext: {
        outlet,
        matches: parentMatches.concat(renderedMatches.slice(0, index2 + 1))
      }
    }, error ? errorElement : match2.route.element !== void 0 ? match2.route.element : outlet);
    return dataRouterState && (match2.route.errorElement || index2 === 0) ? /* @__PURE__ */ react.exports.createElement(RenderErrorBoundary, {
      location: dataRouterState.location,
      component: errorElement,
      error,
      children: getChildren()
    }) : getChildren();
  }, null);
}
var DataRouterHook;
(function(DataRouterHook2) {
  DataRouterHook2["UseLoaderData"] = "useLoaderData";
  DataRouterHook2["UseActionData"] = "useActionData";
  DataRouterHook2["UseRouteError"] = "useRouteError";
  DataRouterHook2["UseNavigation"] = "useNavigation";
  DataRouterHook2["UseRouteLoaderData"] = "useRouteLoaderData";
  DataRouterHook2["UseMatches"] = "useMatches";
  DataRouterHook2["UseRevalidator"] = "useRevalidator";
})(DataRouterHook || (DataRouterHook = {}));
function useDataRouterState(hookName) {
  let state2 = react.exports.useContext(DataRouterStateContext);
  !state2 ? invariant(false) : void 0;
  return state2;
}
function useRouteError() {
  var _state$errors;
  let error = react.exports.useContext(RouteErrorContext);
  let state2 = useDataRouterState(DataRouterHook.UseRouteError);
  let route = react.exports.useContext(RouteContext);
  let thisRoute = route.matches[route.matches.length - 1];
  if (error) {
    return error;
  }
  !route ? invariant(false) : void 0;
  !thisRoute.route.id ? invariant(false) : void 0;
  return (_state$errors = state2.errors) == null ? void 0 : _state$errors[thisRoute.route.id];
}
function Navigate(_ref3) {
  let {
    to,
    replace,
    state: state2,
    relative
  } = _ref3;
  !useInRouterContext() ? invariant(false) : void 0;
  let dataRouterState = react.exports.useContext(DataRouterStateContext);
  let navigate = useNavigate();
  react.exports.useEffect(() => {
    if (dataRouterState && dataRouterState.navigation.state !== "idle") {
      return;
    }
    navigate(to, {
      replace,
      state: state2,
      relative
    });
  });
  return null;
}
function Route(_props) {
  invariant(false);
}
function Router(_ref4) {
  let {
    basename: basenameProp = "/",
    children = null,
    location: locationProp,
    navigationType = Action$1.Pop,
    navigator: navigator2,
    static: staticProp = false
  } = _ref4;
  !!useInRouterContext() ? invariant(false) : void 0;
  let basename = basenameProp.replace(/^\/*/, "/");
  let navigationContext = react.exports.useMemo(() => ({
    basename,
    navigator: navigator2,
    static: staticProp
  }), [basename, navigator2, staticProp]);
  if (typeof locationProp === "string") {
    locationProp = parsePath$1(locationProp);
  }
  let {
    pathname = "/",
    search = "",
    hash = "",
    state: state2 = null,
    key: key2 = "default"
  } = locationProp;
  let location = react.exports.useMemo(() => {
    let trailingPathname = stripBasename(pathname, basename);
    if (trailingPathname == null) {
      return null;
    }
    return {
      pathname: trailingPathname,
      search,
      hash,
      state: state2,
      key: key2
    };
  }, [basename, pathname, search, hash, state2, key2]);
  if (location == null) {
    return null;
  }
  return /* @__PURE__ */ react.exports.createElement(NavigationContext.Provider, {
    value: navigationContext
  }, /* @__PURE__ */ react.exports.createElement(LocationContext.Provider, {
    children,
    value: {
      location,
      navigationType
    }
  }));
}
function Routes(_ref5) {
  let {
    children,
    location
  } = _ref5;
  let dataRouterContext = react.exports.useContext(DataRouterContext);
  let routes = dataRouterContext && !children ? dataRouterContext.router.routes : createRoutesFromChildren(children);
  return useRoutes(routes, location);
}
var AwaitRenderStatus;
(function(AwaitRenderStatus2) {
  AwaitRenderStatus2[AwaitRenderStatus2["pending"] = 0] = "pending";
  AwaitRenderStatus2[AwaitRenderStatus2["success"] = 1] = "success";
  AwaitRenderStatus2[AwaitRenderStatus2["error"] = 2] = "error";
})(AwaitRenderStatus || (AwaitRenderStatus = {}));
new Promise(() => {
});
function createRoutesFromChildren(children, parentPath) {
  if (parentPath === void 0) {
    parentPath = [];
  }
  let routes = [];
  react.exports.Children.forEach(children, (element, index2) => {
    if (!/* @__PURE__ */ react.exports.isValidElement(element)) {
      return;
    }
    if (element.type === react.exports.Fragment) {
      routes.push.apply(routes, createRoutesFromChildren(element.props.children, parentPath));
      return;
    }
    !(element.type === Route) ? invariant(false) : void 0;
    let treePath = [...parentPath, index2];
    let route = {
      id: element.props.id || treePath.join("-"),
      caseSensitive: element.props.caseSensitive,
      element: element.props.element,
      index: element.props.index,
      path: element.props.path,
      loader: element.props.loader,
      action: element.props.action,
      errorElement: element.props.errorElement,
      hasErrorBoundary: element.props.errorElement != null,
      shouldRevalidate: element.props.shouldRevalidate,
      handle: element.props.handle
    };
    if (element.props.children) {
      route.children = createRoutesFromChildren(element.props.children, treePath);
    }
    routes.push(route);
  });
  return routes;
}
/**
 * React Router DOM v6.4.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function _extends$3() {
  _extends$3 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key2 in source) {
        if (Object.prototype.hasOwnProperty.call(source, key2)) {
          target[key2] = source[key2];
        }
      }
    }
    return target;
  };
  return _extends$3.apply(this, arguments);
}
function _objectWithoutPropertiesLoose$2(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key2, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key2 = sourceKeys[i2];
    if (excluded.indexOf(key2) >= 0)
      continue;
    target[key2] = source[key2];
  }
  return target;
}
function isModifiedEvent(event) {
  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
}
function shouldProcessLinkClick(event, target) {
  return event.button === 0 && (!target || target === "_self") && !isModifiedEvent(event);
}
const _excluded$E = ["onClick", "relative", "reloadDocument", "replace", "state", "target", "to", "preventScrollReset"];
function BrowserRouter(_ref) {
  let {
    basename,
    children,
    window: window2
  } = _ref;
  let historyRef = react.exports.useRef();
  if (historyRef.current == null) {
    historyRef.current = createBrowserHistory({
      window: window2,
      v5Compat: true
    });
  }
  let history = historyRef.current;
  let [state2, setState] = react.exports.useState({
    action: history.action,
    location: history.location
  });
  react.exports.useLayoutEffect(() => history.listen(setState), [history]);
  return /* @__PURE__ */ react.exports.createElement(Router, {
    basename,
    children,
    location: state2.location,
    navigationType: state2.action,
    navigator: history
  });
}
const Link = /* @__PURE__ */ react.exports.forwardRef(function LinkWithRef(_ref4, ref) {
  let {
    onClick,
    relative,
    reloadDocument,
    replace,
    state: state2,
    target,
    to,
    preventScrollReset
  } = _ref4, rest = _objectWithoutPropertiesLoose$2(_ref4, _excluded$E);
  let href = useHref(to, {
    relative
  });
  let internalOnClick = useLinkClickHandler(to, {
    replace,
    state: state2,
    target,
    preventScrollReset,
    relative
  });
  function handleClick(event) {
    if (onClick)
      onClick(event);
    if (!event.defaultPrevented) {
      internalOnClick(event);
    }
  }
  return /* @__PURE__ */ react.exports.createElement("a", _extends$3({}, rest, {
    href,
    onClick: reloadDocument ? onClick : handleClick,
    ref,
    target
  }));
});
function useLinkClickHandler(to, _temp) {
  let {
    target,
    replace: replaceProp,
    state: state2,
    preventScrollReset,
    relative
  } = _temp === void 0 ? {} : _temp;
  let navigate = useNavigate();
  let location = useLocation();
  let path2 = useResolvedPath(to, {
    relative
  });
  return react.exports.useCallback((event) => {
    if (shouldProcessLinkClick(event, target)) {
      event.preventDefault();
      let replace = replaceProp !== void 0 ? replaceProp : createPath(location) === createPath(path2);
      navigate(to, {
        replace,
        state: state2,
        preventScrollReset,
        relative
      });
    }
  }, [location, navigate, path2, replaceProp, state2, target, to, preventScrollReset, relative]);
}
var shim = { exports: {} };
var useSyncExternalStoreShim_production_min = {};
/**
 * @license React
 * use-sync-external-store-shim.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var e$2 = react.exports;
function h$5(a2, b10) {
  return a2 === b10 && (0 !== a2 || 1 / a2 === 1 / b10) || a2 !== a2 && b10 !== b10;
}
var k$3 = "function" === typeof Object.is ? Object.is : h$5, l$3 = e$2.useState, m$4 = e$2.useEffect, n$5 = e$2.useLayoutEffect, p$5 = e$2.useDebugValue;
function q$5(a2, b10) {
  var d2 = b10(), f2 = l$3({ inst: { value: d2, getSnapshot: b10 } }), c2 = f2[0].inst, g2 = f2[1];
  n$5(function() {
    c2.value = d2;
    c2.getSnapshot = b10;
    r$3(c2) && g2({ inst: c2 });
  }, [a2, d2, b10]);
  m$4(function() {
    r$3(c2) && g2({ inst: c2 });
    return a2(function() {
      r$3(c2) && g2({ inst: c2 });
    });
  }, [a2]);
  p$5(d2);
  return d2;
}
function r$3(a2) {
  var b10 = a2.getSnapshot;
  a2 = a2.value;
  try {
    var d2 = b10();
    return !k$3(a2, d2);
  } catch (f2) {
    return true;
  }
}
function t$4(a2, b10) {
  return b10();
}
var u$3 = "undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement ? t$4 : q$5;
useSyncExternalStoreShim_production_min.useSyncExternalStore = void 0 !== e$2.useSyncExternalStore ? e$2.useSyncExternalStore : u$3;
{
  shim.exports = useSyncExternalStoreShim_production_min;
}
var withSelector = { exports: {} };
var withSelector_production_min = {};
/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var h$4 = react.exports, n$4 = shim.exports;
function p$4(a2, b10) {
  return a2 === b10 && (0 !== a2 || 1 / a2 === 1 / b10) || a2 !== a2 && b10 !== b10;
}
var q$4 = "function" === typeof Object.is ? Object.is : p$4, r$2 = n$4.useSyncExternalStore, t$3 = h$4.useRef, u$2 = h$4.useEffect, v$3 = h$4.useMemo, w$2 = h$4.useDebugValue;
withSelector_production_min.useSyncExternalStoreWithSelector = function(a2, b10, e3, l2, g2) {
  var c2 = t$3(null);
  if (null === c2.current) {
    var f2 = { hasValue: false, value: null };
    c2.current = f2;
  } else
    f2 = c2.current;
  c2 = v$3(function() {
    function a3(a4) {
      if (!c3) {
        c3 = true;
        d3 = a4;
        a4 = l2(a4);
        if (void 0 !== g2 && f2.hasValue) {
          var b11 = f2.value;
          if (g2(b11, a4))
            return k2 = b11;
        }
        return k2 = a4;
      }
      b11 = k2;
      if (q$4(d3, a4))
        return b11;
      var e4 = l2(a4);
      if (void 0 !== g2 && g2(b11, e4))
        return b11;
      d3 = a4;
      return k2 = e4;
    }
    var c3 = false, d3, k2, m2 = void 0 === e3 ? null : e3;
    return [function() {
      return a3(b10());
    }, null === m2 ? void 0 : function() {
      return a3(m2());
    }];
  }, [b10, e3, l2, g2]);
  var d2 = r$2(a2, c2[0], c2[1]);
  u$2(function() {
    f2.hasValue = true;
    f2.value = d2;
  }, [d2]);
  w$2(d2);
  return d2;
};
{
  withSelector.exports = withSelector_production_min;
}
function defaultNoopBatch(callback) {
  callback();
}
let batch = defaultNoopBatch;
const setBatch = (newBatch) => batch = newBatch;
const getBatch = () => batch;
const ReactReduxContext = /* @__PURE__ */ react.exports.createContext(null);
function useReduxContext() {
  const contextValue = react.exports.useContext(ReactReduxContext);
  return contextValue;
}
const notInitialized = () => {
  throw new Error("uSES not initialized!");
};
let useSyncExternalStoreWithSelector = notInitialized;
const initializeUseSelector = (fn2) => {
  useSyncExternalStoreWithSelector = fn2;
};
const refEquality = (a2, b10) => a2 === b10;
function createSelectorHook(context2 = ReactReduxContext) {
  const useReduxContext$1 = context2 === ReactReduxContext ? useReduxContext : () => react.exports.useContext(context2);
  return function useSelector2(selector, equalityFn = refEquality) {
    const {
      store: store2,
      subscription,
      getServerState
    } = useReduxContext$1();
    const selectedState = useSyncExternalStoreWithSelector(subscription.addNestedSub, store2.getState, getServerState || store2.getState, selector, equalityFn);
    react.exports.useDebugValue(selectedState);
    return selectedState;
  };
}
const useSelector = /* @__PURE__ */ createSelectorHook();
function _extends$2() {
  _extends$2 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key2 in source) {
        if (Object.prototype.hasOwnProperty.call(source, key2)) {
          target[key2] = source[key2];
        }
      }
    }
    return target;
  };
  return _extends$2.apply(this, arguments);
}
function _objectWithoutPropertiesLoose$1(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key2, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key2 = sourceKeys[i2];
    if (excluded.indexOf(key2) >= 0)
      continue;
    target[key2] = source[key2];
  }
  return target;
}
var reactIs$1 = { exports: {} };
var reactIs_production_min$1 = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var b$2 = "function" === typeof Symbol && Symbol.for, c$2 = b$2 ? Symbol.for("react.element") : 60103, d$2 = b$2 ? Symbol.for("react.portal") : 60106, e$1 = b$2 ? Symbol.for("react.fragment") : 60107, f$3 = b$2 ? Symbol.for("react.strict_mode") : 60108, g$3 = b$2 ? Symbol.for("react.profiler") : 60114, h$3 = b$2 ? Symbol.for("react.provider") : 60109, k$2 = b$2 ? Symbol.for("react.context") : 60110, l$2 = b$2 ? Symbol.for("react.async_mode") : 60111, m$3 = b$2 ? Symbol.for("react.concurrent_mode") : 60111, n$3 = b$2 ? Symbol.for("react.forward_ref") : 60112, p$3 = b$2 ? Symbol.for("react.suspense") : 60113, q$3 = b$2 ? Symbol.for("react.suspense_list") : 60120, r$1 = b$2 ? Symbol.for("react.memo") : 60115, t$2 = b$2 ? Symbol.for("react.lazy") : 60116, v$2 = b$2 ? Symbol.for("react.block") : 60121, w$1 = b$2 ? Symbol.for("react.fundamental") : 60117, x$1 = b$2 ? Symbol.for("react.responder") : 60118, y$1 = b$2 ? Symbol.for("react.scope") : 60119;
function z$1(a2) {
  if ("object" === typeof a2 && null !== a2) {
    var u2 = a2.$$typeof;
    switch (u2) {
      case c$2:
        switch (a2 = a2.type, a2) {
          case l$2:
          case m$3:
          case e$1:
          case g$3:
          case f$3:
          case p$3:
            return a2;
          default:
            switch (a2 = a2 && a2.$$typeof, a2) {
              case k$2:
              case n$3:
              case t$2:
              case r$1:
              case h$3:
                return a2;
              default:
                return u2;
            }
        }
      case d$2:
        return u2;
    }
  }
}
function A$1(a2) {
  return z$1(a2) === m$3;
}
reactIs_production_min$1.AsyncMode = l$2;
reactIs_production_min$1.ConcurrentMode = m$3;
reactIs_production_min$1.ContextConsumer = k$2;
reactIs_production_min$1.ContextProvider = h$3;
reactIs_production_min$1.Element = c$2;
reactIs_production_min$1.ForwardRef = n$3;
reactIs_production_min$1.Fragment = e$1;
reactIs_production_min$1.Lazy = t$2;
reactIs_production_min$1.Memo = r$1;
reactIs_production_min$1.Portal = d$2;
reactIs_production_min$1.Profiler = g$3;
reactIs_production_min$1.StrictMode = f$3;
reactIs_production_min$1.Suspense = p$3;
reactIs_production_min$1.isAsyncMode = function(a2) {
  return A$1(a2) || z$1(a2) === l$2;
};
reactIs_production_min$1.isConcurrentMode = A$1;
reactIs_production_min$1.isContextConsumer = function(a2) {
  return z$1(a2) === k$2;
};
reactIs_production_min$1.isContextProvider = function(a2) {
  return z$1(a2) === h$3;
};
reactIs_production_min$1.isElement = function(a2) {
  return "object" === typeof a2 && null !== a2 && a2.$$typeof === c$2;
};
reactIs_production_min$1.isForwardRef = function(a2) {
  return z$1(a2) === n$3;
};
reactIs_production_min$1.isFragment = function(a2) {
  return z$1(a2) === e$1;
};
reactIs_production_min$1.isLazy = function(a2) {
  return z$1(a2) === t$2;
};
reactIs_production_min$1.isMemo = function(a2) {
  return z$1(a2) === r$1;
};
reactIs_production_min$1.isPortal = function(a2) {
  return z$1(a2) === d$2;
};
reactIs_production_min$1.isProfiler = function(a2) {
  return z$1(a2) === g$3;
};
reactIs_production_min$1.isStrictMode = function(a2) {
  return z$1(a2) === f$3;
};
reactIs_production_min$1.isSuspense = function(a2) {
  return z$1(a2) === p$3;
};
reactIs_production_min$1.isValidElementType = function(a2) {
  return "string" === typeof a2 || "function" === typeof a2 || a2 === e$1 || a2 === m$3 || a2 === g$3 || a2 === f$3 || a2 === p$3 || a2 === q$3 || "object" === typeof a2 && null !== a2 && (a2.$$typeof === t$2 || a2.$$typeof === r$1 || a2.$$typeof === h$3 || a2.$$typeof === k$2 || a2.$$typeof === n$3 || a2.$$typeof === w$1 || a2.$$typeof === x$1 || a2.$$typeof === y$1 || a2.$$typeof === v$2);
};
reactIs_production_min$1.typeOf = z$1;
{
  reactIs$1.exports = reactIs_production_min$1;
}
var reactIs = reactIs$1.exports;
var FORWARD_REF_STATICS = {
  "$$typeof": true,
  render: true,
  defaultProps: true,
  displayName: true,
  propTypes: true
};
var MEMO_STATICS = {
  "$$typeof": true,
  compare: true,
  defaultProps: true,
  displayName: true,
  propTypes: true,
  type: true
};
var TYPE_STATICS = {};
TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;
var reactIs_production_min = {};
/**
 * @license React
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var b$1 = Symbol.for("react.element"), c$1 = Symbol.for("react.portal"), d$1 = Symbol.for("react.fragment"), e = Symbol.for("react.strict_mode"), f$2 = Symbol.for("react.profiler"), g$2 = Symbol.for("react.provider"), h$2 = Symbol.for("react.context"), k$1 = Symbol.for("react.server_context"), l$1 = Symbol.for("react.forward_ref"), m$2 = Symbol.for("react.suspense"), n$2 = Symbol.for("react.suspense_list"), p$2 = Symbol.for("react.memo"), q$2 = Symbol.for("react.lazy"), t$1 = Symbol.for("react.offscreen"), u$1;
u$1 = Symbol.for("react.module.reference");
function v$1(a2) {
  if ("object" === typeof a2 && null !== a2) {
    var r2 = a2.$$typeof;
    switch (r2) {
      case b$1:
        switch (a2 = a2.type, a2) {
          case d$1:
          case f$2:
          case e:
          case m$2:
          case n$2:
            return a2;
          default:
            switch (a2 = a2 && a2.$$typeof, a2) {
              case k$1:
              case h$2:
              case l$1:
              case q$2:
              case p$2:
              case g$2:
                return a2;
              default:
                return r2;
            }
        }
      case c$1:
        return r2;
    }
  }
}
reactIs_production_min.ContextConsumer = h$2;
reactIs_production_min.ContextProvider = g$2;
reactIs_production_min.Element = b$1;
reactIs_production_min.ForwardRef = l$1;
reactIs_production_min.Fragment = d$1;
reactIs_production_min.Lazy = q$2;
reactIs_production_min.Memo = p$2;
reactIs_production_min.Portal = c$1;
reactIs_production_min.Profiler = f$2;
reactIs_production_min.StrictMode = e;
reactIs_production_min.Suspense = m$2;
reactIs_production_min.SuspenseList = n$2;
reactIs_production_min.isAsyncMode = function() {
  return false;
};
reactIs_production_min.isConcurrentMode = function() {
  return false;
};
reactIs_production_min.isContextConsumer = function(a2) {
  return v$1(a2) === h$2;
};
reactIs_production_min.isContextProvider = function(a2) {
  return v$1(a2) === g$2;
};
reactIs_production_min.isElement = function(a2) {
  return "object" === typeof a2 && null !== a2 && a2.$$typeof === b$1;
};
reactIs_production_min.isForwardRef = function(a2) {
  return v$1(a2) === l$1;
};
reactIs_production_min.isFragment = function(a2) {
  return v$1(a2) === d$1;
};
reactIs_production_min.isLazy = function(a2) {
  return v$1(a2) === q$2;
};
reactIs_production_min.isMemo = function(a2) {
  return v$1(a2) === p$2;
};
reactIs_production_min.isPortal = function(a2) {
  return v$1(a2) === c$1;
};
reactIs_production_min.isProfiler = function(a2) {
  return v$1(a2) === f$2;
};
reactIs_production_min.isStrictMode = function(a2) {
  return v$1(a2) === e;
};
reactIs_production_min.isSuspense = function(a2) {
  return v$1(a2) === m$2;
};
reactIs_production_min.isSuspenseList = function(a2) {
  return v$1(a2) === n$2;
};
reactIs_production_min.isValidElementType = function(a2) {
  return "string" === typeof a2 || "function" === typeof a2 || a2 === d$1 || a2 === f$2 || a2 === e || a2 === m$2 || a2 === n$2 || a2 === t$1 || "object" === typeof a2 && null !== a2 && (a2.$$typeof === q$2 || a2.$$typeof === p$2 || a2.$$typeof === g$2 || a2.$$typeof === h$2 || a2.$$typeof === l$1 || a2.$$typeof === u$1 || void 0 !== a2.getModuleId) ? true : false;
};
reactIs_production_min.typeOf = v$1;
function createListenerCollection() {
  const batch2 = getBatch();
  let first = null;
  let last2 = null;
  return {
    clear() {
      first = null;
      last2 = null;
    },
    notify() {
      batch2(() => {
        let listener = first;
        while (listener) {
          listener.callback();
          listener = listener.next;
        }
      });
    },
    get() {
      let listeners = [];
      let listener = first;
      while (listener) {
        listeners.push(listener);
        listener = listener.next;
      }
      return listeners;
    },
    subscribe(callback) {
      let isSubscribed = true;
      let listener = last2 = {
        callback,
        next: null,
        prev: last2
      };
      if (listener.prev) {
        listener.prev.next = listener;
      } else {
        first = listener;
      }
      return function unsubscribe2() {
        if (!isSubscribed || first === null)
          return;
        isSubscribed = false;
        if (listener.next) {
          listener.next.prev = listener.prev;
        } else {
          last2 = listener.prev;
        }
        if (listener.prev) {
          listener.prev.next = listener.next;
        } else {
          first = listener.next;
        }
      };
    }
  };
}
const nullListeners = {
  notify() {
  },
  get: () => []
};
function createSubscription(store2, parentSub) {
  let unsubscribe2;
  let listeners = nullListeners;
  function addNestedSub(listener) {
    trySubscribe();
    return listeners.subscribe(listener);
  }
  function notifyNestedSubs() {
    listeners.notify();
  }
  function handleChangeWrapper() {
    if (subscription.onStateChange) {
      subscription.onStateChange();
    }
  }
  function isSubscribed() {
    return Boolean(unsubscribe2);
  }
  function trySubscribe() {
    if (!unsubscribe2) {
      unsubscribe2 = parentSub ? parentSub.addNestedSub(handleChangeWrapper) : store2.subscribe(handleChangeWrapper);
      listeners = createListenerCollection();
    }
  }
  function tryUnsubscribe() {
    if (unsubscribe2) {
      unsubscribe2();
      unsubscribe2 = void 0;
      listeners.clear();
      listeners = nullListeners;
    }
  }
  const subscription = {
    addNestedSub,
    notifyNestedSubs,
    handleChangeWrapper,
    isSubscribed,
    trySubscribe,
    tryUnsubscribe,
    getListeners: () => listeners
  };
  return subscription;
}
const canUseDOM = !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
const useIsomorphicLayoutEffect$1 = canUseDOM ? react.exports.useLayoutEffect : react.exports.useEffect;
var jsxRuntime = { exports: {} };
var reactJsxRuntime_production_min = {};
/** @license React v17.0.2
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var f$1 = react.exports, g$1 = 60103;
reactJsxRuntime_production_min.Fragment = 60107;
if ("function" === typeof Symbol && Symbol.for) {
  var h$1 = Symbol.for;
  g$1 = h$1("react.element");
  reactJsxRuntime_production_min.Fragment = h$1("react.fragment");
}
var m$1 = f$1.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, n$1 = Object.prototype.hasOwnProperty, p$1 = { key: true, ref: true, __self: true, __source: true };
function q$1(c2, a2, k2) {
  var b10, d2 = {}, e3 = null, l2 = null;
  void 0 !== k2 && (e3 = "" + k2);
  void 0 !== a2.key && (e3 = "" + a2.key);
  void 0 !== a2.ref && (l2 = a2.ref);
  for (b10 in a2)
    n$1.call(a2, b10) && !p$1.hasOwnProperty(b10) && (d2[b10] = a2[b10]);
  if (c2 && c2.defaultProps)
    for (b10 in a2 = c2.defaultProps, a2)
      void 0 === d2[b10] && (d2[b10] = a2[b10]);
  return { $$typeof: g$1, type: c2, key: e3, ref: l2, props: d2, _owner: m$1.current };
}
reactJsxRuntime_production_min.jsx = q$1;
reactJsxRuntime_production_min.jsxs = q$1;
{
  jsxRuntime.exports = reactJsxRuntime_production_min;
}
const jsx = jsxRuntime.exports.jsx;
const jsxs = jsxRuntime.exports.jsxs;
const Fragment = jsxRuntime.exports.Fragment;
function Provider$1({
  store: store2,
  context: context2,
  children,
  serverState
}) {
  const contextValue = react.exports.useMemo(() => {
    const subscription = createSubscription(store2);
    return {
      store: store2,
      subscription,
      getServerState: serverState ? () => serverState : void 0
    };
  }, [store2, serverState]);
  const previousState = react.exports.useMemo(() => store2.getState(), [store2]);
  useIsomorphicLayoutEffect$1(() => {
    const {
      subscription
    } = contextValue;
    subscription.onStateChange = subscription.notifyNestedSubs;
    subscription.trySubscribe();
    if (previousState !== store2.getState()) {
      subscription.notifyNestedSubs();
    }
    return () => {
      subscription.tryUnsubscribe();
      subscription.onStateChange = void 0;
    };
  }, [contextValue, previousState]);
  const Context2 = context2 || ReactReduxContext;
  return /* @__PURE__ */ jsx(Context2.Provider, {
    value: contextValue,
    children
  });
}
function createStoreHook(context2 = ReactReduxContext) {
  const useReduxContext$1 = context2 === ReactReduxContext ? useReduxContext : () => react.exports.useContext(context2);
  return function useStore2() {
    const {
      store: store2
    } = useReduxContext$1();
    return store2;
  };
}
const useStore = /* @__PURE__ */ createStoreHook();
function createDispatchHook(context2 = ReactReduxContext) {
  const useStore$1 = context2 === ReactReduxContext ? useStore : createStoreHook(context2);
  return function useDispatch2() {
    const store2 = useStore$1();
    return store2.dispatch;
  };
}
const useDispatch = /* @__PURE__ */ createDispatchHook();
initializeUseSelector(withSelector.exports.useSyncExternalStoreWithSelector);
setBatch(reactDom.exports.unstable_batchedUpdates);
function Header$1() {
  return /* @__PURE__ */ jsx("div", {
    className: "page-header",
    children: /* @__PURE__ */ jsx(Link, {
      to: "/",
      children: "Free Chain"
    })
  });
}
function Footer$1() {
  return /* @__PURE__ */ jsxs("div", {
    className: "footer",
    children: [/* @__PURE__ */ jsx("p", {
      className: "footer-title",
      children: "FreeScan"
    }), /* @__PURE__ */ jsx("p", {
      className: "footer-content",
      children: "Block explorer for FreeChain, a new blockchain built for the next generation of NFR"
    })]
  });
}
var index$e = "";
function __variableDynamicImportRuntime0__(path2) {
  switch (path2) {
    default:
      return new Promise(function(resolve, reject) {
        (typeof queueMicrotask === "function" ? queueMicrotask : setTimeout)(
          reject.bind(null, new Error("Unknown variable dynamic import: " + path2))
        );
      });
  }
}
function Layout(props) {
  const {
    routes
  } = props;
  return /* @__PURE__ */ jsx(Routes, {
    children: routes.map((route2) => {
      const {
        path: path2 = "",
        PageComponent,
        exact = true,
        redirect
      } = route2;
      if (redirect) {
        return /* @__PURE__ */ jsx(Navigate, {
          replace: true,
          to: redirect
        });
      }
      const Component2 = PageComponent && (typeof PageComponent === "string" ? /* @__PURE__ */ jsx(React.Suspense, {
        fallback: /* @__PURE__ */ jsx("p", {
          children: "loading"
        }),
        children: React.lazy(() => __variableDynamicImportRuntime0__(`../../pages/${PageComponent}.tsx`))
      }) : PageComponent);
      const MyRender = (props2) => /* @__PURE__ */ jsxs("div", {
        className: "page-layout",
        children: [/* @__PURE__ */ jsx(Header$1, {}), /* @__PURE__ */ jsx("div", {
          className: "content",
          children: /* @__PURE__ */ jsx(Component2, {
            ...props2
          })
        }), /* @__PURE__ */ jsx(Footer$1, {})]
      });
      return /* @__PURE__ */ react.exports.createElement(Route, {
        ...props,
        path: path2,
        key: path2,
        element: /* @__PURE__ */ jsx(MyRender, {})
      });
    })
  });
}
function _defineProperty$4(obj, key2, value2) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, {
      value: value2,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key2] = value2;
  }
  return obj;
}
function _classCallCheck$2(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$2(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$2(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$2(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$2(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _setPrototypeOf$2(o2, p2) {
  _setPrototypeOf$2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o3, p3) {
    o3.__proto__ = p3;
    return o3;
  };
  return _setPrototypeOf$2(o2, p2);
}
function _inherits$1(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass)
    _setPrototypeOf$2(subClass, superClass);
}
function _getPrototypeOf$2(o2) {
  _getPrototypeOf$2 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o3) {
    return o3.__proto__ || Object.getPrototypeOf(o3);
  };
  return _getPrototypeOf$2(o2);
}
function _isNativeReflectConstruct$2() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function _typeof$4(obj) {
  "@babel/helpers - typeof";
  return _typeof$4 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$4(obj);
}
function _assertThisInitialized$1(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _possibleConstructorReturn$1(self2, call2) {
  if (call2 && (_typeof$4(call2) === "object" || typeof call2 === "function")) {
    return call2;
  } else if (call2 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$1(self2);
}
function _createSuper$1(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$2();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$2(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$2(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$1(this, result);
  };
}
var classnames = { exports: {} };
/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/
(function(module) {
  (function() {
    var hasOwn = {}.hasOwnProperty;
    function classNames2() {
      var classes = [];
      for (var i2 = 0; i2 < arguments.length; i2++) {
        var arg = arguments[i2];
        if (!arg)
          continue;
        var argType = typeof arg;
        if (argType === "string" || argType === "number") {
          classes.push(arg);
        } else if (Array.isArray(arg)) {
          if (arg.length) {
            var inner = classNames2.apply(null, arg);
            if (inner) {
              classes.push(inner);
            }
          }
        } else if (argType === "object") {
          if (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes("[native code]")) {
            classes.push(arg.toString());
            continue;
          }
          for (var key2 in arg) {
            if (hasOwn.call(arg, key2) && arg[key2]) {
              classes.push(key2);
            }
          }
        }
      }
      return classes.join(" ");
    }
    if (module.exports) {
      classNames2.default = classNames2;
      module.exports = classNames2;
    } else {
      window.classNames = classNames2;
    }
  })();
})(classnames);
var classNames = classnames.exports;
function toArray$5(children) {
  var option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var ret = [];
  React.Children.forEach(children, function(child) {
    if ((child === void 0 || child === null) && !option.keepEmpty) {
      return;
    }
    if (Array.isArray(child)) {
      ret = ret.concat(toArray$5(child));
    } else if (reactIs$1.exports.isFragment(child) && child.props) {
      ret = ret.concat(toArray$5(child.props.children, option));
    } else {
      ret.push(child);
    }
  });
  return ret;
}
var warned = {};
function warning$2(valid, message2) {
}
function call(method4, valid, message2) {
  if (!valid && !warned[message2]) {
    method4(false, message2);
    warned[message2] = true;
  }
}
function warningOnce(valid, message2) {
  call(warning$2, valid, message2);
}
function ownKeys$3(object4, enumerableOnly) {
  var keys2 = Object.keys(object4);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object4);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object4, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread2$1(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? ownKeys$3(Object(source), true).forEach(function(key2) {
      _defineProperty$4(target, key2, source[key2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$3(Object(source)).forEach(function(key2) {
      Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source, key2));
    });
  }
  return target;
}
function useMemo(getValue2, condition, shouldUpdate) {
  var cacheRef = react.exports.useRef({});
  if (!("value" in cacheRef.current) || shouldUpdate(cacheRef.current.condition, condition)) {
    cacheRef.current.value = getValue2();
    cacheRef.current.condition = condition;
  }
  return cacheRef.current.value;
}
function fillRef(ref, node) {
  if (typeof ref === "function") {
    ref(node);
  } else if (_typeof$4(ref) === "object" && ref && "current" in ref) {
    ref.current = node;
  }
}
function composeRef() {
  for (var _len = arguments.length, refs = new Array(_len), _key = 0; _key < _len; _key++) {
    refs[_key] = arguments[_key];
  }
  var refList = refs.filter(function(ref) {
    return ref;
  });
  if (refList.length <= 1) {
    return refList[0];
  }
  return function(node) {
    refs.forEach(function(ref) {
      fillRef(ref, node);
    });
  };
}
function useComposeRef() {
  for (var _len2 = arguments.length, refs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    refs[_key2] = arguments[_key2];
  }
  return useMemo(function() {
    return composeRef.apply(void 0, refs);
  }, refs, function(prev, next) {
    return prev.length === next.length && prev.every(function(ref, i2) {
      return ref === next[i2];
    });
  });
}
function supportRef(nodeOrComponent) {
  var _type$prototype, _nodeOrComponent$prot;
  var type4 = reactIs$1.exports.isMemo(nodeOrComponent) ? nodeOrComponent.type.type : nodeOrComponent.type;
  if (typeof type4 === "function" && !((_type$prototype = type4.prototype) === null || _type$prototype === void 0 ? void 0 : _type$prototype.render)) {
    return false;
  }
  if (typeof nodeOrComponent === "function" && !((_nodeOrComponent$prot = nodeOrComponent.prototype) === null || _nodeOrComponent$prot === void 0 ? void 0 : _nodeOrComponent$prot.render)) {
    return false;
  }
  return true;
}
function findDOMNode(node) {
  if (node instanceof HTMLElement) {
    return node;
  }
  return ReactDOM.findDOMNode(node);
}
var MapShim = function() {
  if (typeof Map !== "undefined") {
    return Map;
  }
  function getIndex(arr, key2) {
    var result = -1;
    arr.some(function(entry, index2) {
      if (entry[0] === key2) {
        result = index2;
        return true;
      }
      return false;
    });
    return result;
  }
  return function() {
    function class_1() {
      this.__entries__ = [];
    }
    Object.defineProperty(class_1.prototype, "size", {
      get: function() {
        return this.__entries__.length;
      },
      enumerable: true,
      configurable: true
    });
    class_1.prototype.get = function(key2) {
      var index2 = getIndex(this.__entries__, key2);
      var entry = this.__entries__[index2];
      return entry && entry[1];
    };
    class_1.prototype.set = function(key2, value2) {
      var index2 = getIndex(this.__entries__, key2);
      if (~index2) {
        this.__entries__[index2][1] = value2;
      } else {
        this.__entries__.push([key2, value2]);
      }
    };
    class_1.prototype.delete = function(key2) {
      var entries = this.__entries__;
      var index2 = getIndex(entries, key2);
      if (~index2) {
        entries.splice(index2, 1);
      }
    };
    class_1.prototype.has = function(key2) {
      return !!~getIndex(this.__entries__, key2);
    };
    class_1.prototype.clear = function() {
      this.__entries__.splice(0);
    };
    class_1.prototype.forEach = function(callback, ctx2) {
      if (ctx2 === void 0) {
        ctx2 = null;
      }
      for (var _i = 0, _a2 = this.__entries__; _i < _a2.length; _i++) {
        var entry = _a2[_i];
        callback.call(ctx2, entry[1], entry[0]);
      }
    };
    return class_1;
  }();
}();
var isBrowser$1 = typeof window !== "undefined" && typeof document !== "undefined" && window.document === document;
var global$1 = function() {
  if (typeof global !== "undefined" && global.Math === Math) {
    return global;
  }
  if (typeof self !== "undefined" && self.Math === Math) {
    return self;
  }
  if (typeof window !== "undefined" && window.Math === Math) {
    return window;
  }
  return Function("return this")();
}();
var requestAnimationFrame$1$1 = function() {
  if (typeof requestAnimationFrame === "function") {
    return requestAnimationFrame.bind(global$1);
  }
  return function(callback) {
    return setTimeout(function() {
      return callback(Date.now());
    }, 1e3 / 60);
  };
}();
var trailingTimeout = 2;
function throttle$1(callback, delay) {
  var leadingCall = false, trailingCall = false, lastCallTime = 0;
  function resolvePending() {
    if (leadingCall) {
      leadingCall = false;
      callback();
    }
    if (trailingCall) {
      proxy();
    }
  }
  function timeoutCallback() {
    requestAnimationFrame$1$1(resolvePending);
  }
  function proxy() {
    var timeStamp = Date.now();
    if (leadingCall) {
      if (timeStamp - lastCallTime < trailingTimeout) {
        return;
      }
      trailingCall = true;
    } else {
      leadingCall = true;
      trailingCall = false;
      setTimeout(timeoutCallback, delay);
    }
    lastCallTime = timeStamp;
  }
  return proxy;
}
var REFRESH_DELAY = 20;
var transitionKeys = ["top", "right", "bottom", "left", "width", "height", "size", "weight"];
var mutationObserverSupported = typeof MutationObserver !== "undefined";
var ResizeObserverController = function() {
  function ResizeObserverController2() {
    this.connected_ = false;
    this.mutationEventsAdded_ = false;
    this.mutationsObserver_ = null;
    this.observers_ = [];
    this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);
    this.refresh = throttle$1(this.refresh.bind(this), REFRESH_DELAY);
  }
  ResizeObserverController2.prototype.addObserver = function(observer) {
    if (!~this.observers_.indexOf(observer)) {
      this.observers_.push(observer);
    }
    if (!this.connected_) {
      this.connect_();
    }
  };
  ResizeObserverController2.prototype.removeObserver = function(observer) {
    var observers2 = this.observers_;
    var index2 = observers2.indexOf(observer);
    if (~index2) {
      observers2.splice(index2, 1);
    }
    if (!observers2.length && this.connected_) {
      this.disconnect_();
    }
  };
  ResizeObserverController2.prototype.refresh = function() {
    var changesDetected = this.updateObservers_();
    if (changesDetected) {
      this.refresh();
    }
  };
  ResizeObserverController2.prototype.updateObservers_ = function() {
    var activeObservers = this.observers_.filter(function(observer) {
      return observer.gatherActive(), observer.hasActive();
    });
    activeObservers.forEach(function(observer) {
      return observer.broadcastActive();
    });
    return activeObservers.length > 0;
  };
  ResizeObserverController2.prototype.connect_ = function() {
    if (!isBrowser$1 || this.connected_) {
      return;
    }
    document.addEventListener("transitionend", this.onTransitionEnd_);
    window.addEventListener("resize", this.refresh);
    if (mutationObserverSupported) {
      this.mutationsObserver_ = new MutationObserver(this.refresh);
      this.mutationsObserver_.observe(document, {
        attributes: true,
        childList: true,
        characterData: true,
        subtree: true
      });
    } else {
      document.addEventListener("DOMSubtreeModified", this.refresh);
      this.mutationEventsAdded_ = true;
    }
    this.connected_ = true;
  };
  ResizeObserverController2.prototype.disconnect_ = function() {
    if (!isBrowser$1 || !this.connected_) {
      return;
    }
    document.removeEventListener("transitionend", this.onTransitionEnd_);
    window.removeEventListener("resize", this.refresh);
    if (this.mutationsObserver_) {
      this.mutationsObserver_.disconnect();
    }
    if (this.mutationEventsAdded_) {
      document.removeEventListener("DOMSubtreeModified", this.refresh);
    }
    this.mutationsObserver_ = null;
    this.mutationEventsAdded_ = false;
    this.connected_ = false;
  };
  ResizeObserverController2.prototype.onTransitionEnd_ = function(_a2) {
    var _b = _a2.propertyName, propertyName = _b === void 0 ? "" : _b;
    var isReflowProperty = transitionKeys.some(function(key2) {
      return !!~propertyName.indexOf(key2);
    });
    if (isReflowProperty) {
      this.refresh();
    }
  };
  ResizeObserverController2.getInstance = function() {
    if (!this.instance_) {
      this.instance_ = new ResizeObserverController2();
    }
    return this.instance_;
  };
  ResizeObserverController2.instance_ = null;
  return ResizeObserverController2;
}();
var defineConfigurable = function(target, props) {
  for (var _i = 0, _a2 = Object.keys(props); _i < _a2.length; _i++) {
    var key2 = _a2[_i];
    Object.defineProperty(target, key2, {
      value: props[key2],
      enumerable: false,
      writable: false,
      configurable: true
    });
  }
  return target;
};
var getWindowOf = function(target) {
  var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;
  return ownerGlobal || global$1;
};
var emptyRect = createRectInit(0, 0, 0, 0);
function toFloat(value2) {
  return parseFloat(value2) || 0;
}
function getBordersSize(styles) {
  var positions = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    positions[_i - 1] = arguments[_i];
  }
  return positions.reduce(function(size2, position) {
    var value2 = styles["border-" + position + "-width"];
    return size2 + toFloat(value2);
  }, 0);
}
function getPaddings(styles) {
  var positions = ["top", "right", "bottom", "left"];
  var paddings = {};
  for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {
    var position = positions_1[_i];
    var value2 = styles["padding-" + position];
    paddings[position] = toFloat(value2);
  }
  return paddings;
}
function getSVGContentRect(target) {
  var bbox = target.getBBox();
  return createRectInit(0, 0, bbox.width, bbox.height);
}
function getHTMLElementContentRect(target) {
  var clientWidth = target.clientWidth, clientHeight = target.clientHeight;
  if (!clientWidth && !clientHeight) {
    return emptyRect;
  }
  var styles = getWindowOf(target).getComputedStyle(target);
  var paddings = getPaddings(styles);
  var horizPad = paddings.left + paddings.right;
  var vertPad = paddings.top + paddings.bottom;
  var width = toFloat(styles.width), height = toFloat(styles.height);
  if (styles.boxSizing === "border-box") {
    if (Math.round(width + horizPad) !== clientWidth) {
      width -= getBordersSize(styles, "left", "right") + horizPad;
    }
    if (Math.round(height + vertPad) !== clientHeight) {
      height -= getBordersSize(styles, "top", "bottom") + vertPad;
    }
  }
  if (!isDocumentElement(target)) {
    var vertScrollbar = Math.round(width + horizPad) - clientWidth;
    var horizScrollbar = Math.round(height + vertPad) - clientHeight;
    if (Math.abs(vertScrollbar) !== 1) {
      width -= vertScrollbar;
    }
    if (Math.abs(horizScrollbar) !== 1) {
      height -= horizScrollbar;
    }
  }
  return createRectInit(paddings.left, paddings.top, width, height);
}
var isSVGGraphicsElement = function() {
  if (typeof SVGGraphicsElement !== "undefined") {
    return function(target) {
      return target instanceof getWindowOf(target).SVGGraphicsElement;
    };
  }
  return function(target) {
    return target instanceof getWindowOf(target).SVGElement && typeof target.getBBox === "function";
  };
}();
function isDocumentElement(target) {
  return target === getWindowOf(target).document.documentElement;
}
function getContentRect(target) {
  if (!isBrowser$1) {
    return emptyRect;
  }
  if (isSVGGraphicsElement(target)) {
    return getSVGContentRect(target);
  }
  return getHTMLElementContentRect(target);
}
function createReadOnlyRect(_a2) {
  var x2 = _a2.x, y2 = _a2.y, width = _a2.width, height = _a2.height;
  var Constr = typeof DOMRectReadOnly !== "undefined" ? DOMRectReadOnly : Object;
  var rect2 = Object.create(Constr.prototype);
  defineConfigurable(rect2, {
    x: x2,
    y: y2,
    width,
    height,
    top: y2,
    right: x2 + width,
    bottom: height + y2,
    left: x2
  });
  return rect2;
}
function createRectInit(x2, y2, width, height) {
  return { x: x2, y: y2, width, height };
}
var ResizeObservation = function() {
  function ResizeObservation2(target) {
    this.broadcastWidth = 0;
    this.broadcastHeight = 0;
    this.contentRect_ = createRectInit(0, 0, 0, 0);
    this.target = target;
  }
  ResizeObservation2.prototype.isActive = function() {
    var rect2 = getContentRect(this.target);
    this.contentRect_ = rect2;
    return rect2.width !== this.broadcastWidth || rect2.height !== this.broadcastHeight;
  };
  ResizeObservation2.prototype.broadcastRect = function() {
    var rect2 = this.contentRect_;
    this.broadcastWidth = rect2.width;
    this.broadcastHeight = rect2.height;
    return rect2;
  };
  return ResizeObservation2;
}();
var ResizeObserverEntry = function() {
  function ResizeObserverEntry2(target, rectInit) {
    var contentRect = createReadOnlyRect(rectInit);
    defineConfigurable(this, { target, contentRect });
  }
  return ResizeObserverEntry2;
}();
var ResizeObserverSPI = function() {
  function ResizeObserverSPI2(callback, controller, callbackCtx) {
    this.activeObservations_ = [];
    this.observations_ = new MapShim();
    if (typeof callback !== "function") {
      throw new TypeError("The callback provided as parameter 1 is not a function.");
    }
    this.callback_ = callback;
    this.controller_ = controller;
    this.callbackCtx_ = callbackCtx;
  }
  ResizeObserverSPI2.prototype.observe = function(target) {
    if (!arguments.length) {
      throw new TypeError("1 argument required, but only 0 present.");
    }
    if (typeof Element === "undefined" || !(Element instanceof Object)) {
      return;
    }
    if (!(target instanceof getWindowOf(target).Element)) {
      throw new TypeError('parameter 1 is not of type "Element".');
    }
    var observations = this.observations_;
    if (observations.has(target)) {
      return;
    }
    observations.set(target, new ResizeObservation(target));
    this.controller_.addObserver(this);
    this.controller_.refresh();
  };
  ResizeObserverSPI2.prototype.unobserve = function(target) {
    if (!arguments.length) {
      throw new TypeError("1 argument required, but only 0 present.");
    }
    if (typeof Element === "undefined" || !(Element instanceof Object)) {
      return;
    }
    if (!(target instanceof getWindowOf(target).Element)) {
      throw new TypeError('parameter 1 is not of type "Element".');
    }
    var observations = this.observations_;
    if (!observations.has(target)) {
      return;
    }
    observations.delete(target);
    if (!observations.size) {
      this.controller_.removeObserver(this);
    }
  };
  ResizeObserverSPI2.prototype.disconnect = function() {
    this.clearActive();
    this.observations_.clear();
    this.controller_.removeObserver(this);
  };
  ResizeObserverSPI2.prototype.gatherActive = function() {
    var _this = this;
    this.clearActive();
    this.observations_.forEach(function(observation) {
      if (observation.isActive()) {
        _this.activeObservations_.push(observation);
      }
    });
  };
  ResizeObserverSPI2.prototype.broadcastActive = function() {
    if (!this.hasActive()) {
      return;
    }
    var ctx2 = this.callbackCtx_;
    var entries = this.activeObservations_.map(function(observation) {
      return new ResizeObserverEntry(observation.target, observation.broadcastRect());
    });
    this.callback_.call(ctx2, entries, ctx2);
    this.clearActive();
  };
  ResizeObserverSPI2.prototype.clearActive = function() {
    this.activeObservations_.splice(0);
  };
  ResizeObserverSPI2.prototype.hasActive = function() {
    return this.activeObservations_.length > 0;
  };
  return ResizeObserverSPI2;
}();
var observers = typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : new MapShim();
var ResizeObserver$2 = function() {
  function ResizeObserver2(callback) {
    if (!(this instanceof ResizeObserver2)) {
      throw new TypeError("Cannot call a class as a function.");
    }
    if (!arguments.length) {
      throw new TypeError("1 argument required, but only 0 present.");
    }
    var controller = ResizeObserverController.getInstance();
    var observer = new ResizeObserverSPI(callback, controller, this);
    observers.set(this, observer);
  }
  return ResizeObserver2;
}();
[
  "observe",
  "unobserve",
  "disconnect"
].forEach(function(method4) {
  ResizeObserver$2.prototype[method4] = function() {
    var _a2;
    return (_a2 = observers.get(this))[method4].apply(_a2, arguments);
  };
});
var index$d = function() {
  if (typeof global$1.ResizeObserver !== "undefined") {
    return global$1.ResizeObserver;
  }
  return ResizeObserver$2;
}();
var elementListeners = /* @__PURE__ */ new Map();
function onResize(entities) {
  entities.forEach(function(entity) {
    var _elementListeners$get;
    var target = entity.target;
    (_elementListeners$get = elementListeners.get(target)) === null || _elementListeners$get === void 0 ? void 0 : _elementListeners$get.forEach(function(listener) {
      return listener(target);
    });
  });
}
var resizeObserver$1 = new index$d(onResize);
function observe(element, callback) {
  if (!elementListeners.has(element)) {
    elementListeners.set(element, /* @__PURE__ */ new Set());
    resizeObserver$1.observe(element);
  }
  elementListeners.get(element).add(callback);
}
function unobserve(element, callback) {
  if (elementListeners.has(element)) {
    elementListeners.get(element).delete(callback);
    if (!elementListeners.get(element).size) {
      resizeObserver$1.unobserve(element);
      elementListeners.delete(element);
    }
  }
}
var DomWrapper$1 = /* @__PURE__ */ function(_React$Component) {
  _inherits$1(DomWrapper2, _React$Component);
  var _super = _createSuper$1(DomWrapper2);
  function DomWrapper2() {
    _classCallCheck$2(this, DomWrapper2);
    return _super.apply(this, arguments);
  }
  _createClass$2(DomWrapper2, [{
    key: "render",
    value: function render2() {
      return this.props.children;
    }
  }]);
  return DomWrapper2;
}(react.exports.Component);
var CollectionContext = /* @__PURE__ */ react.exports.createContext(null);
function Collection(_ref) {
  var children = _ref.children, onBatchResize = _ref.onBatchResize;
  var resizeIdRef = react.exports.useRef(0);
  var resizeInfosRef = react.exports.useRef([]);
  var onCollectionResize = react.exports.useContext(CollectionContext);
  var onResize2 = react.exports.useCallback(function(size2, element, data2) {
    resizeIdRef.current += 1;
    var currentId = resizeIdRef.current;
    resizeInfosRef.current.push({
      size: size2,
      element,
      data: data2
    });
    Promise.resolve().then(function() {
      if (currentId === resizeIdRef.current) {
        onBatchResize === null || onBatchResize === void 0 ? void 0 : onBatchResize(resizeInfosRef.current);
        resizeInfosRef.current = [];
      }
    });
    onCollectionResize === null || onCollectionResize === void 0 ? void 0 : onCollectionResize(size2, element, data2);
  }, [onBatchResize, onCollectionResize]);
  return /* @__PURE__ */ react.exports.createElement(CollectionContext.Provider, {
    value: onResize2
  }, children);
}
function SingleObserver(props) {
  var children = props.children, disabled = props.disabled;
  var elementRef = react.exports.useRef(null);
  var wrapperRef = react.exports.useRef(null);
  var onCollectionResize = react.exports.useContext(CollectionContext);
  var isRenderProps = typeof children === "function";
  var mergedChildren = isRenderProps ? children(elementRef) : children;
  var sizeRef = react.exports.useRef({
    width: -1,
    height: -1,
    offsetWidth: -1,
    offsetHeight: -1
  });
  var canRef = !isRenderProps && /* @__PURE__ */ react.exports.isValidElement(mergedChildren) && supportRef(mergedChildren);
  var originRef = canRef ? mergedChildren.ref : null;
  var mergedRef = react.exports.useMemo(function() {
    return composeRef(originRef, elementRef);
  }, [originRef, elementRef]);
  var propsRef = react.exports.useRef(props);
  propsRef.current = props;
  var onInternalResize = react.exports.useCallback(function(target) {
    var _propsRef$current = propsRef.current, onResize2 = _propsRef$current.onResize, data2 = _propsRef$current.data;
    var _target$getBoundingCl = target.getBoundingClientRect(), width = _target$getBoundingCl.width, height = _target$getBoundingCl.height;
    var offsetWidth = target.offsetWidth, offsetHeight = target.offsetHeight;
    var fixedWidth = Math.floor(width);
    var fixedHeight = Math.floor(height);
    if (sizeRef.current.width !== fixedWidth || sizeRef.current.height !== fixedHeight || sizeRef.current.offsetWidth !== offsetWidth || sizeRef.current.offsetHeight !== offsetHeight) {
      var size2 = {
        width: fixedWidth,
        height: fixedHeight,
        offsetWidth,
        offsetHeight
      };
      sizeRef.current = size2;
      var mergedOffsetWidth = offsetWidth === Math.round(width) ? width : offsetWidth;
      var mergedOffsetHeight = offsetHeight === Math.round(height) ? height : offsetHeight;
      var sizeInfo = _objectSpread2$1(_objectSpread2$1({}, size2), {}, {
        offsetWidth: mergedOffsetWidth,
        offsetHeight: mergedOffsetHeight
      });
      onCollectionResize === null || onCollectionResize === void 0 ? void 0 : onCollectionResize(sizeInfo, target, data2);
      if (onResize2) {
        Promise.resolve().then(function() {
          onResize2(sizeInfo, target);
        });
      }
    }
  }, []);
  react.exports.useEffect(function() {
    var currentElement = findDOMNode(elementRef.current) || findDOMNode(wrapperRef.current);
    if (currentElement && !disabled) {
      observe(currentElement, onInternalResize);
    }
    return function() {
      return unobserve(currentElement, onInternalResize);
    };
  }, [elementRef.current, disabled]);
  return /* @__PURE__ */ react.exports.createElement(DomWrapper$1, {
    ref: wrapperRef
  }, canRef ? /* @__PURE__ */ react.exports.cloneElement(mergedChildren, {
    ref: mergedRef
  }) : mergedChildren);
}
var INTERNAL_PREFIX_KEY = "rc-observer-key";
function ResizeObserver$1(props) {
  var children = props.children;
  var childNodes = typeof children === "function" ? [children] : toArray$5(children);
  return childNodes.map(function(child, index2) {
    var key2 = (child === null || child === void 0 ? void 0 : child.key) || "".concat(INTERNAL_PREFIX_KEY, "-").concat(index2);
    return /* @__PURE__ */ react.exports.createElement(SingleObserver, _extends$2({}, props, {
      key: key2
    }), child);
  });
}
ResizeObserver$1.Collection = Collection;
function omit$2(obj, fields) {
  var clone3 = _objectSpread2$1({}, obj);
  if (Array.isArray(fields)) {
    fields.forEach(function(key2) {
      delete clone3[key2];
    });
  }
  return clone3;
}
var IconContext = /* @__PURE__ */ react.exports.createContext({});
var Context$2 = IconContext;
function _objectWithoutProperties$1(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose$1(source, excluded);
  var key2, i2;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
      key2 = sourceSymbolKeys[i2];
      if (excluded.indexOf(key2) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key2))
        continue;
      target[key2] = source[key2];
    }
  }
  return target;
}
function _arrayLikeToArray$3(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) {
    arr2[i2] = arr[i2];
  }
  return arr2;
}
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray$3(arr);
}
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _unsupportedIterableToArray$3(o2, minLen) {
  if (!o2)
    return;
  if (typeof o2 === "string")
    return _arrayLikeToArray$3(o2, minLen);
  var n2 = Object.prototype.toString.call(o2).slice(8, -1);
  if (n2 === "Object" && o2.constructor)
    n2 = o2.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o2);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$3(o2, minLen);
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray$3(arr) || _nonIterableSpread();
}
var HOOK_MARK = "RC_FORM_INTERNAL_HOOKS";
var warningFunc = function warningFunc2() {
  warningOnce(false, "Can not find FormContext. Please make sure you wrap Field under Form.");
};
var Context$1 = /* @__PURE__ */ react.exports.createContext({
  getFieldValue: warningFunc,
  getFieldsValue: warningFunc,
  getFieldError: warningFunc,
  getFieldWarning: warningFunc,
  getFieldsError: warningFunc,
  isFieldsTouched: warningFunc,
  isFieldTouched: warningFunc,
  isFieldValidating: warningFunc,
  isFieldsValidating: warningFunc,
  resetFields: warningFunc,
  setFields: warningFunc,
  setFieldValue: warningFunc,
  setFieldsValue: warningFunc,
  validateFields: warningFunc,
  submit: warningFunc,
  getInternalHooks: function getInternalHooks() {
    warningFunc();
    return {
      dispatch: warningFunc,
      initEntityValue: warningFunc,
      registerField: warningFunc,
      useSubscribe: warningFunc,
      setInitialValues: warningFunc,
      destroyForm: warningFunc,
      setCallbacks: warningFunc,
      registerWatch: warningFunc,
      getFields: warningFunc,
      setValidateMessages: warningFunc,
      setPreserve: warningFunc,
      getInitialValue: warningFunc
    };
  }
});
function toArray$4(value2) {
  if (value2 === void 0 || value2 === null) {
    return [];
  }
  return Array.isArray(value2) ? value2 : [value2];
}
function _regeneratorRuntime() {
  /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */
  _regeneratorRuntime = function _regeneratorRuntime2() {
    return exports;
  };
  var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
  function define2(obj, key2, value2) {
    return Object.defineProperty(obj, key2, {
      value: value2,
      enumerable: true,
      configurable: true,
      writable: true
    }), obj[key2];
  }
  try {
    define2({}, "");
  } catch (err) {
    define2 = function define3(obj, key2, value2) {
      return obj[key2] = value2;
    };
  }
  function wrap(innerFn, outerFn, self2, tryLocsList) {
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context2 = new Context2(tryLocsList || []);
    return generator._invoke = function(innerFn2, self3, context3) {
      var state2 = "suspendedStart";
      return function(method4, arg) {
        if ("executing" === state2)
          throw new Error("Generator is already running");
        if ("completed" === state2) {
          if ("throw" === method4)
            throw arg;
          return doneResult();
        }
        for (context3.method = method4, context3.arg = arg; ; ) {
          var delegate = context3.delegate;
          if (delegate) {
            var delegateResult = maybeInvokeDelegate(delegate, context3);
            if (delegateResult) {
              if (delegateResult === ContinueSentinel)
                continue;
              return delegateResult;
            }
          }
          if ("next" === context3.method)
            context3.sent = context3._sent = context3.arg;
          else if ("throw" === context3.method) {
            if ("suspendedStart" === state2)
              throw state2 = "completed", context3.arg;
            context3.dispatchException(context3.arg);
          } else
            "return" === context3.method && context3.abrupt("return", context3.arg);
          state2 = "executing";
          var record = tryCatch(innerFn2, self3, context3);
          if ("normal" === record.type) {
            if (state2 = context3.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel)
              continue;
            return {
              value: record.arg,
              done: context3.done
            };
          }
          "throw" === record.type && (state2 = "completed", context3.method = "throw", context3.arg = record.arg);
        }
      };
    }(innerFn, self2, context2), generator;
  }
  function tryCatch(fn2, obj, arg) {
    try {
      return {
        type: "normal",
        arg: fn2.call(obj, arg)
      };
    } catch (err) {
      return {
        type: "throw",
        arg: err
      };
    }
  }
  exports.wrap = wrap;
  var ContinueSentinel = {};
  function Generator() {
  }
  function GeneratorFunction() {
  }
  function GeneratorFunctionPrototype() {
  }
  var IteratorPrototype = {};
  define2(IteratorPrototype, iteratorSymbol, function() {
    return this;
  });
  var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values2([])));
  NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
  function defineIteratorMethods(prototype2) {
    ["next", "throw", "return"].forEach(function(method4) {
      define2(prototype2, method4, function(arg) {
        return this._invoke(method4, arg);
      });
    });
  }
  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method4, arg, resolve, reject) {
      var record = tryCatch(generator[method4], generator, arg);
      if ("throw" !== record.type) {
        var result = record.arg, value2 = result.value;
        return value2 && "object" == _typeof$4(value2) && hasOwn.call(value2, "__await") ? PromiseImpl.resolve(value2.__await).then(function(value3) {
          invoke("next", value3, resolve, reject);
        }, function(err) {
          invoke("throw", err, resolve, reject);
        }) : PromiseImpl.resolve(value2).then(function(unwrapped) {
          result.value = unwrapped, resolve(result);
        }, function(error) {
          return invoke("throw", error, resolve, reject);
        });
      }
      reject(record.arg);
    }
    var previousPromise;
    this._invoke = function(method4, arg) {
      function callInvokeWithMethodAndArg() {
        return new PromiseImpl(function(resolve, reject) {
          invoke(method4, arg, resolve, reject);
        });
      }
      return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
    };
  }
  function maybeInvokeDelegate(delegate, context2) {
    var method4 = delegate.iterator[context2.method];
    if (void 0 === method4) {
      if (context2.delegate = null, "throw" === context2.method) {
        if (delegate.iterator["return"] && (context2.method = "return", context2.arg = void 0, maybeInvokeDelegate(delegate, context2), "throw" === context2.method))
          return ContinueSentinel;
        context2.method = "throw", context2.arg = new TypeError("The iterator does not provide a 'throw' method");
      }
      return ContinueSentinel;
    }
    var record = tryCatch(method4, delegate.iterator, context2.arg);
    if ("throw" === record.type)
      return context2.method = "throw", context2.arg = record.arg, context2.delegate = null, ContinueSentinel;
    var info = record.arg;
    return info ? info.done ? (context2[delegate.resultName] = info.value, context2.next = delegate.nextLoc, "return" !== context2.method && (context2.method = "next", context2.arg = void 0), context2.delegate = null, ContinueSentinel) : info : (context2.method = "throw", context2.arg = new TypeError("iterator result is not an object"), context2.delegate = null, ContinueSentinel);
  }
  function pushTryEntry(locs) {
    var entry = {
      tryLoc: locs[0]
    };
    1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
  }
  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal", delete record.arg, entry.completion = record;
  }
  function Context2(tryLocsList) {
    this.tryEntries = [{
      tryLoc: "root"
    }], tryLocsList.forEach(pushTryEntry, this), this.reset(true);
  }
  function values2(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod)
        return iteratorMethod.call(iterable);
      if ("function" == typeof iterable.next)
        return iterable;
      if (!isNaN(iterable.length)) {
        var i2 = -1, next = function next2() {
          for (; ++i2 < iterable.length; ) {
            if (hasOwn.call(iterable, i2))
              return next2.value = iterable[i2], next2.done = false, next2;
          }
          return next2.value = void 0, next2.done = true, next2;
        };
        return next.next = next;
      }
    }
    return {
      next: doneResult
    };
  }
  function doneResult() {
    return {
      value: void 0,
      done: true
    };
  }
  return GeneratorFunction.prototype = GeneratorFunctionPrototype, define2(Gp, "constructor", GeneratorFunctionPrototype), define2(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define2(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function(genFun) {
    var ctor = "function" == typeof genFun && genFun.constructor;
    return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
  }, exports.mark = function(genFun) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define2(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
  }, exports.awrap = function(arg) {
    return {
      __await: arg
    };
  }, defineIteratorMethods(AsyncIterator.prototype), define2(AsyncIterator.prototype, asyncIteratorSymbol, function() {
    return this;
  }), exports.AsyncIterator = AsyncIterator, exports.async = function(innerFn, outerFn, self2, tryLocsList, PromiseImpl) {
    void 0 === PromiseImpl && (PromiseImpl = Promise);
    var iter = new AsyncIterator(wrap(innerFn, outerFn, self2, tryLocsList), PromiseImpl);
    return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function(result) {
      return result.done ? result.value : iter.next();
    });
  }, defineIteratorMethods(Gp), define2(Gp, toStringTagSymbol, "Generator"), define2(Gp, iteratorSymbol, function() {
    return this;
  }), define2(Gp, "toString", function() {
    return "[object Generator]";
  }), exports.keys = function(object4) {
    var keys2 = [];
    for (var key2 in object4) {
      keys2.push(key2);
    }
    return keys2.reverse(), function next() {
      for (; keys2.length; ) {
        var key3 = keys2.pop();
        if (key3 in object4)
          return next.value = key3, next.done = false, next;
      }
      return next.done = true, next;
    };
  }, exports.values = values2, Context2.prototype = {
    constructor: Context2,
    reset: function reset(skipTempReset) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = void 0, this.done = false, this.delegate = null, this.method = "next", this.arg = void 0, this.tryEntries.forEach(resetTryEntry), !skipTempReset)
        for (var name in this) {
          "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = void 0);
        }
    },
    stop: function stop() {
      this.done = true;
      var rootRecord = this.tryEntries[0].completion;
      if ("throw" === rootRecord.type)
        throw rootRecord.arg;
      return this.rval;
    },
    dispatchException: function dispatchException(exception) {
      if (this.done)
        throw exception;
      var context2 = this;
      function handle(loc, caught) {
        return record.type = "throw", record.arg = exception, context2.next = loc, caught && (context2.method = "next", context2.arg = void 0), !!caught;
      }
      for (var i2 = this.tryEntries.length - 1; i2 >= 0; --i2) {
        var entry = this.tryEntries[i2], record = entry.completion;
        if ("root" === entry.tryLoc)
          return handle("end");
        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc");
          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc)
              return handle(entry.catchLoc, true);
            if (this.prev < entry.finallyLoc)
              return handle(entry.finallyLoc);
          } else if (hasCatch) {
            if (this.prev < entry.catchLoc)
              return handle(entry.catchLoc, true);
          } else {
            if (!hasFinally)
              throw new Error("try statement without catch or finally");
            if (this.prev < entry.finallyLoc)
              return handle(entry.finallyLoc);
          }
        }
      }
    },
    abrupt: function abrupt(type4, arg) {
      for (var i2 = this.tryEntries.length - 1; i2 >= 0; --i2) {
        var entry = this.tryEntries[i2];
        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }
      finallyEntry && ("break" === type4 || "continue" === type4) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
      var record = finallyEntry ? finallyEntry.completion : {};
      return record.type = type4, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
    },
    complete: function complete(record, afterLoc) {
      if ("throw" === record.type)
        throw record.arg;
      return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
    },
    finish: function finish(finallyLoc) {
      for (var i2 = this.tryEntries.length - 1; i2 >= 0; --i2) {
        var entry = this.tryEntries[i2];
        if (entry.finallyLoc === finallyLoc)
          return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
      }
    },
    "catch": function _catch(tryLoc) {
      for (var i2 = this.tryEntries.length - 1; i2 >= 0; --i2) {
        var entry = this.tryEntries[i2];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if ("throw" === record.type) {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }
      throw new Error("illegal catch attempt");
    },
    delegateYield: function delegateYield(iterable, resultName, nextLoc) {
      return this.delegate = {
        iterator: values2(iterable),
        resultName,
        nextLoc
      }, "next" === this.method && (this.arg = void 0), ContinueSentinel;
    }
  }, exports;
}
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key2, arg) {
  try {
    var info = gen[key2](arg);
    var value2 = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve(value2);
  } else {
    Promise.resolve(value2).then(_next, _throw);
  }
}
function _asyncToGenerator(fn2) {
  return function() {
    var self2 = this, args = arguments;
    return new Promise(function(resolve, reject) {
      var gen = fn2.apply(self2, args);
      function _next(value2) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value2);
      }
      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }
      _next(void 0);
    });
  };
}
function _extends$1() {
  _extends$1 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key2 in source) {
        if (Object.prototype.hasOwnProperty.call(source, key2)) {
          target[key2] = source[key2];
        }
      }
    }
    return target;
  };
  return _extends$1.apply(this, arguments);
}
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf$1(subClass, superClass);
}
function _getPrototypeOf$1(o2) {
  _getPrototypeOf$1 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o3) {
    return o3.__proto__ || Object.getPrototypeOf(o3);
  };
  return _getPrototypeOf$1(o2);
}
function _setPrototypeOf$1(o2, p2) {
  _setPrototypeOf$1 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o3, p3) {
    o3.__proto__ = p3;
    return o3;
  };
  return _setPrototypeOf$1(o2, p2);
}
function _isNativeReflectConstruct$1() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct$1()) {
    _construct = Reflect.construct.bind();
  } else {
    _construct = function _construct2(Parent2, args2, Class2) {
      var a2 = [null];
      a2.push.apply(a2, args2);
      var Constructor = Function.bind.apply(Parent2, a2);
      var instance = new Constructor();
      if (Class2)
        _setPrototypeOf$1(instance, Class2.prototype);
      return instance;
    };
  }
  return _construct.apply(null, arguments);
}
function _isNativeFunction(fn2) {
  return Function.toString.call(fn2).indexOf("[native code]") !== -1;
}
function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
  _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
    if (Class2 === null || !_isNativeFunction(Class2))
      return Class2;
    if (typeof Class2 !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }
    if (typeof _cache !== "undefined") {
      if (_cache.has(Class2))
        return _cache.get(Class2);
      _cache.set(Class2, Wrapper);
    }
    function Wrapper() {
      return _construct(Class2, arguments, _getPrototypeOf$1(this).constructor);
    }
    Wrapper.prototype = Object.create(Class2.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf$1(Wrapper, Class2);
  };
  return _wrapNativeSuper(Class);
}
var formatRegExp = /%[sdj%]/g;
var warning$1 = function warning2() {
};
if (typeof process !== "undefined" && process.env && false) {
  warning$1 = function warning3(type4, errors) {
    if (typeof console !== "undefined" && console.warn && typeof ASYNC_VALIDATOR_NO_WARNING === "undefined") {
      if (errors.every(function(e3) {
        return typeof e3 === "string";
      })) {
        console.warn(type4, errors);
      }
    }
  };
}
function convertFieldsError(errors) {
  if (!errors || !errors.length)
    return null;
  var fields = {};
  errors.forEach(function(error) {
    var field2 = error.field;
    fields[field2] = fields[field2] || [];
    fields[field2].push(error);
  });
  return fields;
}
function format$1(template2) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }
  var i2 = 0;
  var len = args.length;
  if (typeof template2 === "function") {
    return template2.apply(null, args);
  }
  if (typeof template2 === "string") {
    var str = template2.replace(formatRegExp, function(x2) {
      if (x2 === "%%") {
        return "%";
      }
      if (i2 >= len) {
        return x2;
      }
      switch (x2) {
        case "%s":
          return String(args[i2++]);
        case "%d":
          return Number(args[i2++]);
        case "%j":
          try {
            return JSON.stringify(args[i2++]);
          } catch (_2) {
            return "[Circular]";
          }
          break;
        default:
          return x2;
      }
    });
    return str;
  }
  return template2;
}
function isNativeStringType(type4) {
  return type4 === "string" || type4 === "url" || type4 === "hex" || type4 === "email" || type4 === "date" || type4 === "pattern";
}
function isEmptyValue(value2, type4) {
  if (value2 === void 0 || value2 === null) {
    return true;
  }
  if (type4 === "array" && Array.isArray(value2) && !value2.length) {
    return true;
  }
  if (isNativeStringType(type4) && typeof value2 === "string" && !value2) {
    return true;
  }
  return false;
}
function asyncParallelArray(arr, func, callback) {
  var results = [];
  var total = 0;
  var arrLength = arr.length;
  function count2(errors) {
    results.push.apply(results, errors || []);
    total++;
    if (total === arrLength) {
      callback(results);
    }
  }
  arr.forEach(function(a2) {
    func(a2, count2);
  });
}
function asyncSerialArray(arr, func, callback) {
  var index2 = 0;
  var arrLength = arr.length;
  function next(errors) {
    if (errors && errors.length) {
      callback(errors);
      return;
    }
    var original = index2;
    index2 = index2 + 1;
    if (original < arrLength) {
      func(arr[original], next);
    } else {
      callback([]);
    }
  }
  next([]);
}
function flattenObjArr(objArr) {
  var ret = [];
  Object.keys(objArr).forEach(function(k2) {
    ret.push.apply(ret, objArr[k2] || []);
  });
  return ret;
}
var AsyncValidationError = /* @__PURE__ */ function(_Error) {
  _inheritsLoose(AsyncValidationError2, _Error);
  function AsyncValidationError2(errors, fields) {
    var _this;
    _this = _Error.call(this, "Async Validation Error") || this;
    _this.errors = errors;
    _this.fields = fields;
    return _this;
  }
  return AsyncValidationError2;
}(/* @__PURE__ */ _wrapNativeSuper(Error));
function asyncMap(objArr, option, func, callback, source) {
  if (option.first) {
    var _pending = new Promise(function(resolve, reject) {
      var next = function next2(errors) {
        callback(errors);
        return errors.length ? reject(new AsyncValidationError(errors, convertFieldsError(errors))) : resolve(source);
      };
      var flattenArr = flattenObjArr(objArr);
      asyncSerialArray(flattenArr, func, next);
    });
    _pending["catch"](function(e3) {
      return e3;
    });
    return _pending;
  }
  var firstFields = option.firstFields === true ? Object.keys(objArr) : option.firstFields || [];
  var objArrKeys = Object.keys(objArr);
  var objArrLength = objArrKeys.length;
  var total = 0;
  var results = [];
  var pending = new Promise(function(resolve, reject) {
    var next = function next2(errors) {
      results.push.apply(results, errors);
      total++;
      if (total === objArrLength) {
        callback(results);
        return results.length ? reject(new AsyncValidationError(results, convertFieldsError(results))) : resolve(source);
      }
    };
    if (!objArrKeys.length) {
      callback(results);
      resolve(source);
    }
    objArrKeys.forEach(function(key2) {
      var arr = objArr[key2];
      if (firstFields.indexOf(key2) !== -1) {
        asyncSerialArray(arr, func, next);
      } else {
        asyncParallelArray(arr, func, next);
      }
    });
  });
  pending["catch"](function(e3) {
    return e3;
  });
  return pending;
}
function isErrorObj(obj) {
  return !!(obj && obj.message !== void 0);
}
function getValue$5(value2, path2) {
  var v2 = value2;
  for (var i2 = 0; i2 < path2.length; i2++) {
    if (v2 == void 0) {
      return v2;
    }
    v2 = v2[path2[i2]];
  }
  return v2;
}
function complementError(rule, source) {
  return function(oe2) {
    var fieldValue;
    if (rule.fullFields) {
      fieldValue = getValue$5(source, rule.fullFields);
    } else {
      fieldValue = source[oe2.field || rule.fullField];
    }
    if (isErrorObj(oe2)) {
      oe2.field = oe2.field || rule.fullField;
      oe2.fieldValue = fieldValue;
      return oe2;
    }
    return {
      message: typeof oe2 === "function" ? oe2() : oe2,
      fieldValue,
      field: oe2.field || rule.fullField
    };
  };
}
function deepMerge(target, source) {
  if (source) {
    for (var s2 in source) {
      if (source.hasOwnProperty(s2)) {
        var value2 = source[s2];
        if (typeof value2 === "object" && typeof target[s2] === "object") {
          target[s2] = _extends$1({}, target[s2], value2);
        } else {
          target[s2] = value2;
        }
      }
    }
  }
  return target;
}
var required$1 = function required2(rule, value2, source, errors, options, type4) {
  if (rule.required && (!source.hasOwnProperty(rule.field) || isEmptyValue(value2, type4 || rule.type))) {
    errors.push(format$1(options.messages.required, rule.fullField));
  }
};
var whitespace = function whitespace2(rule, value2, source, errors, options) {
  if (/^\s+$/.test(value2) || value2 === "") {
    errors.push(format$1(options.messages.whitespace, rule.fullField));
  }
};
var urlReg;
var getUrlRegex = function() {
  if (urlReg) {
    return urlReg;
  }
  var word2 = "[a-fA-F\\d:]";
  var b10 = function b11(options) {
    return options && options.includeBoundaries ? "(?:(?<=\\s|^)(?=" + word2 + ")|(?<=" + word2 + ")(?=\\s|$))" : "";
  };
  var v4 = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}";
  var v6seg = "[a-fA-F\\d]{1,4}";
  var v6 = ("\n(?:\n(?:" + v6seg + ":){7}(?:" + v6seg + "|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8\n(?:" + v6seg + ":){6}(?:" + v4 + "|:" + v6seg + "|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4\n(?:" + v6seg + ":){5}(?::" + v4 + "|(?::" + v6seg + "){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4\n(?:" + v6seg + ":){4}(?:(?::" + v6seg + "){0,1}:" + v4 + "|(?::" + v6seg + "){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4\n(?:" + v6seg + ":){3}(?:(?::" + v6seg + "){0,2}:" + v4 + "|(?::" + v6seg + "){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4\n(?:" + v6seg + ":){2}(?:(?::" + v6seg + "){0,3}:" + v4 + "|(?::" + v6seg + "){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4\n(?:" + v6seg + ":){1}(?:(?::" + v6seg + "){0,4}:" + v4 + "|(?::" + v6seg + "){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4\n(?::(?:(?::" + v6seg + "){0,5}:" + v4 + "|(?::" + v6seg + "){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4\n)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1\n").replace(/\s*\/\/.*$/gm, "").replace(/\n/g, "").trim();
  var v46Exact = new RegExp("(?:^" + v4 + "$)|(?:^" + v6 + "$)");
  var v4exact = new RegExp("^" + v4 + "$");
  var v6exact = new RegExp("^" + v6 + "$");
  var ip = function ip2(options) {
    return options && options.exact ? v46Exact : new RegExp("(?:" + b10(options) + v4 + b10(options) + ")|(?:" + b10(options) + v6 + b10(options) + ")", "g");
  };
  ip.v4 = function(options) {
    return options && options.exact ? v4exact : new RegExp("" + b10(options) + v4 + b10(options), "g");
  };
  ip.v6 = function(options) {
    return options && options.exact ? v6exact : new RegExp("" + b10(options) + v6 + b10(options), "g");
  };
  var protocol = "(?:(?:[a-z]+:)?//)";
  var auth = "(?:\\S+(?::\\S*)?@)?";
  var ipv4 = ip.v4().source;
  var ipv6 = ip.v6().source;
  var host = "(?:(?:[a-z\\u00a1-\\uffff0-9][-_]*)*[a-z\\u00a1-\\uffff0-9]+)";
  var domain = "(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*";
  var tld = "(?:\\.(?:[a-z\\u00a1-\\uffff]{2,}))";
  var port = "(?::\\d{2,5})?";
  var path2 = '(?:[/?#][^\\s"]*)?';
  var regex = "(?:" + protocol + "|www\\.)" + auth + "(?:localhost|" + ipv4 + "|" + ipv6 + "|" + host + domain + tld + ")" + port + path2;
  urlReg = new RegExp("(?:^" + regex + "$)", "i");
  return urlReg;
};
var pattern$2 = {
  email: /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+\.)+[a-zA-Z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}))$/,
  hex: /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i
};
var types = {
  integer: function integer2(value2) {
    return types.number(value2) && parseInt(value2, 10) === value2;
  },
  "float": function float(value2) {
    return types.number(value2) && !types.integer(value2);
  },
  array: function array2(value2) {
    return Array.isArray(value2);
  },
  regexp: function regexp2(value2) {
    if (value2 instanceof RegExp) {
      return true;
    }
    try {
      return !!new RegExp(value2);
    } catch (e3) {
      return false;
    }
  },
  date: function date2(value2) {
    return typeof value2.getTime === "function" && typeof value2.getMonth === "function" && typeof value2.getYear === "function" && !isNaN(value2.getTime());
  },
  number: function number2(value2) {
    if (isNaN(value2)) {
      return false;
    }
    return typeof value2 === "number";
  },
  object: function object2(value2) {
    return typeof value2 === "object" && !types.array(value2);
  },
  method: function method2(value2) {
    return typeof value2 === "function";
  },
  email: function email(value2) {
    return typeof value2 === "string" && value2.length <= 320 && !!value2.match(pattern$2.email);
  },
  url: function url(value2) {
    return typeof value2 === "string" && value2.length <= 2048 && !!value2.match(getUrlRegex());
  },
  hex: function hex2(value2) {
    return typeof value2 === "string" && !!value2.match(pattern$2.hex);
  }
};
var type$1 = function type2(rule, value2, source, errors, options) {
  if (rule.required && value2 === void 0) {
    required$1(rule, value2, source, errors, options);
    return;
  }
  var custom12 = ["integer", "float", "array", "regexp", "object", "method", "email", "number", "date", "url", "hex"];
  var ruleType = rule.type;
  if (custom12.indexOf(ruleType) > -1) {
    if (!types[ruleType](value2)) {
      errors.push(format$1(options.messages.types[ruleType], rule.fullField, rule.type));
    }
  } else if (ruleType && typeof value2 !== rule.type) {
    errors.push(format$1(options.messages.types[ruleType], rule.fullField, rule.type));
  }
};
var range = function range2(rule, value2, source, errors, options) {
  var len = typeof rule.len === "number";
  var min2 = typeof rule.min === "number";
  var max2 = typeof rule.max === "number";
  var spRegexp = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
  var val = value2;
  var key2 = null;
  var num = typeof value2 === "number";
  var str = typeof value2 === "string";
  var arr = Array.isArray(value2);
  if (num) {
    key2 = "number";
  } else if (str) {
    key2 = "string";
  } else if (arr) {
    key2 = "array";
  }
  if (!key2) {
    return false;
  }
  if (arr) {
    val = value2.length;
  }
  if (str) {
    val = value2.replace(spRegexp, "_").length;
  }
  if (len) {
    if (val !== rule.len) {
      errors.push(format$1(options.messages[key2].len, rule.fullField, rule.len));
    }
  } else if (min2 && !max2 && val < rule.min) {
    errors.push(format$1(options.messages[key2].min, rule.fullField, rule.min));
  } else if (max2 && !min2 && val > rule.max) {
    errors.push(format$1(options.messages[key2].max, rule.fullField, rule.max));
  } else if (min2 && max2 && (val < rule.min || val > rule.max)) {
    errors.push(format$1(options.messages[key2].range, rule.fullField, rule.min, rule.max));
  }
};
var ENUM$1 = "enum";
var enumerable$1 = function enumerable2(rule, value2, source, errors, options) {
  rule[ENUM$1] = Array.isArray(rule[ENUM$1]) ? rule[ENUM$1] : [];
  if (rule[ENUM$1].indexOf(value2) === -1) {
    errors.push(format$1(options.messages[ENUM$1], rule.fullField, rule[ENUM$1].join(", ")));
  }
};
var pattern$1 = function pattern2(rule, value2, source, errors, options) {
  if (rule.pattern) {
    if (rule.pattern instanceof RegExp) {
      rule.pattern.lastIndex = 0;
      if (!rule.pattern.test(value2)) {
        errors.push(format$1(options.messages.pattern.mismatch, rule.fullField, value2, rule.pattern));
      }
    } else if (typeof rule.pattern === "string") {
      var _pattern = new RegExp(rule.pattern);
      if (!_pattern.test(value2)) {
        errors.push(format$1(options.messages.pattern.mismatch, rule.fullField, value2, rule.pattern));
      }
    }
  }
};
var rules = {
  required: required$1,
  whitespace,
  type: type$1,
  range,
  "enum": enumerable$1,
  pattern: pattern$1
};
var string$1 = function string2(rule, value2, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value2, "string") && !rule.required) {
      return callback();
    }
    rules.required(rule, value2, source, errors, options, "string");
    if (!isEmptyValue(value2, "string")) {
      rules.type(rule, value2, source, errors, options);
      rules.range(rule, value2, source, errors, options);
      rules.pattern(rule, value2, source, errors, options);
      if (rule.whitespace === true) {
        rules.whitespace(rule, value2, source, errors, options);
      }
    }
  }
  callback(errors);
};
var method = function method3(rule, value2, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value2) && !rule.required) {
      return callback();
    }
    rules.required(rule, value2, source, errors, options);
    if (value2 !== void 0) {
      rules.type(rule, value2, source, errors, options);
    }
  }
  callback(errors);
};
var number$1 = function number3(rule, value2, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (value2 === "") {
      value2 = void 0;
    }
    if (isEmptyValue(value2) && !rule.required) {
      return callback();
    }
    rules.required(rule, value2, source, errors, options);
    if (value2 !== void 0) {
      rules.type(rule, value2, source, errors, options);
      rules.range(rule, value2, source, errors, options);
    }
  }
  callback(errors);
};
var _boolean = function _boolean2(rule, value2, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value2) && !rule.required) {
      return callback();
    }
    rules.required(rule, value2, source, errors, options);
    if (value2 !== void 0) {
      rules.type(rule, value2, source, errors, options);
    }
  }
  callback(errors);
};
var regexp = function regexp3(rule, value2, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value2) && !rule.required) {
      return callback();
    }
    rules.required(rule, value2, source, errors, options);
    if (!isEmptyValue(value2)) {
      rules.type(rule, value2, source, errors, options);
    }
  }
  callback(errors);
};
var integer = function integer3(rule, value2, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value2) && !rule.required) {
      return callback();
    }
    rules.required(rule, value2, source, errors, options);
    if (value2 !== void 0) {
      rules.type(rule, value2, source, errors, options);
      rules.range(rule, value2, source, errors, options);
    }
  }
  callback(errors);
};
var floatFn = function floatFn2(rule, value2, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value2) && !rule.required) {
      return callback();
    }
    rules.required(rule, value2, source, errors, options);
    if (value2 !== void 0) {
      rules.type(rule, value2, source, errors, options);
      rules.range(rule, value2, source, errors, options);
    }
  }
  callback(errors);
};
var array$1 = function array3(rule, value2, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if ((value2 === void 0 || value2 === null) && !rule.required) {
      return callback();
    }
    rules.required(rule, value2, source, errors, options, "array");
    if (value2 !== void 0 && value2 !== null) {
      rules.type(rule, value2, source, errors, options);
      rules.range(rule, value2, source, errors, options);
    }
  }
  callback(errors);
};
var object$2 = function object3(rule, value2, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value2) && !rule.required) {
      return callback();
    }
    rules.required(rule, value2, source, errors, options);
    if (value2 !== void 0) {
      rules.type(rule, value2, source, errors, options);
    }
  }
  callback(errors);
};
var ENUM = "enum";
var enumerable = function enumerable3(rule, value2, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value2) && !rule.required) {
      return callback();
    }
    rules.required(rule, value2, source, errors, options);
    if (value2 !== void 0) {
      rules[ENUM](rule, value2, source, errors, options);
    }
  }
  callback(errors);
};
var pattern$3 = function pattern3(rule, value2, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value2, "string") && !rule.required) {
      return callback();
    }
    rules.required(rule, value2, source, errors, options);
    if (!isEmptyValue(value2, "string")) {
      rules.pattern(rule, value2, source, errors, options);
    }
  }
  callback(errors);
};
var date$1 = function date3(rule, value2, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value2, "date") && !rule.required) {
      return callback();
    }
    rules.required(rule, value2, source, errors, options);
    if (!isEmptyValue(value2, "date")) {
      var dateObject;
      if (value2 instanceof Date) {
        dateObject = value2;
      } else {
        dateObject = new Date(value2);
      }
      rules.type(rule, dateObject, source, errors, options);
      if (dateObject) {
        rules.range(rule, dateObject.getTime(), source, errors, options);
      }
    }
  }
  callback(errors);
};
var required$2 = function required3(rule, value2, callback, source, options) {
  var errors = [];
  var type4 = Array.isArray(value2) ? "array" : typeof value2;
  rules.required(rule, value2, source, errors, options, type4);
  callback(errors);
};
var type = function type3(rule, value2, callback, source, options) {
  var ruleType = rule.type;
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value2, ruleType) && !rule.required) {
      return callback();
    }
    rules.required(rule, value2, source, errors, options, ruleType);
    if (!isEmptyValue(value2, ruleType)) {
      rules.type(rule, value2, source, errors, options);
    }
  }
  callback(errors);
};
var any = function any2(rule, value2, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value2) && !rule.required) {
      return callback();
    }
    rules.required(rule, value2, source, errors, options);
  }
  callback(errors);
};
var validators$2 = {
  string: string$1,
  method,
  number: number$1,
  "boolean": _boolean,
  regexp,
  integer,
  "float": floatFn,
  array: array$1,
  object: object$2,
  "enum": enumerable,
  pattern: pattern$3,
  date: date$1,
  url: type,
  hex: type,
  email: type,
  required: required$2,
  any
};
function newMessages() {
  return {
    "default": "Validation error on field %s",
    required: "%s is required",
    "enum": "%s must be one of %s",
    whitespace: "%s cannot be empty",
    date: {
      format: "%s date %s is invalid for format %s",
      parse: "%s date could not be parsed, %s is invalid ",
      invalid: "%s date %s is invalid"
    },
    types: {
      string: "%s is not a %s",
      method: "%s is not a %s (function)",
      array: "%s is not an %s",
      object: "%s is not an %s",
      number: "%s is not a %s",
      date: "%s is not a %s",
      "boolean": "%s is not a %s",
      integer: "%s is not an %s",
      "float": "%s is not a %s",
      regexp: "%s is not a valid %s",
      email: "%s is not a valid %s",
      url: "%s is not a valid %s",
      hex: "%s is not a valid %s"
    },
    string: {
      len: "%s must be exactly %s characters",
      min: "%s must be at least %s characters",
      max: "%s cannot be longer than %s characters",
      range: "%s must be between %s and %s characters"
    },
    number: {
      len: "%s must equal %s",
      min: "%s cannot be less than %s",
      max: "%s cannot be greater than %s",
      range: "%s must be between %s and %s"
    },
    array: {
      len: "%s must be exactly %s in length",
      min: "%s cannot be less than %s in length",
      max: "%s cannot be greater than %s in length",
      range: "%s must be between %s and %s in length"
    },
    pattern: {
      mismatch: "%s value %s does not match pattern %s"
    },
    clone: function clone3() {
      var cloned = JSON.parse(JSON.stringify(this));
      cloned.clone = this.clone;
      return cloned;
    }
  };
}
var messages = newMessages();
var Schema$1 = /* @__PURE__ */ function() {
  function Schema2(descriptor) {
    this.rules = null;
    this._messages = messages;
    this.define(descriptor);
  }
  var _proto = Schema2.prototype;
  _proto.define = function define2(rules2) {
    var _this = this;
    if (!rules2) {
      throw new Error("Cannot configure a schema with no rules");
    }
    if (typeof rules2 !== "object" || Array.isArray(rules2)) {
      throw new Error("Rules must be an object");
    }
    this.rules = {};
    Object.keys(rules2).forEach(function(name) {
      var item = rules2[name];
      _this.rules[name] = Array.isArray(item) ? item : [item];
    });
  };
  _proto.messages = function messages2(_messages) {
    if (_messages) {
      this._messages = deepMerge(newMessages(), _messages);
    }
    return this._messages;
  };
  _proto.validate = function validate(source_, o2, oc2) {
    var _this2 = this;
    if (o2 === void 0) {
      o2 = {};
    }
    if (oc2 === void 0) {
      oc2 = function oc3() {
      };
    }
    var source = source_;
    var options = o2;
    var callback = oc2;
    if (typeof options === "function") {
      callback = options;
      options = {};
    }
    if (!this.rules || Object.keys(this.rules).length === 0) {
      if (callback) {
        callback(null, source);
      }
      return Promise.resolve(source);
    }
    function complete(results) {
      var errors = [];
      var fields = {};
      function add2(e3) {
        if (Array.isArray(e3)) {
          var _errors;
          errors = (_errors = errors).concat.apply(_errors, e3);
        } else {
          errors.push(e3);
        }
      }
      for (var i2 = 0; i2 < results.length; i2++) {
        add2(results[i2]);
      }
      if (!errors.length) {
        callback(null, source);
      } else {
        fields = convertFieldsError(errors);
        callback(errors, fields);
      }
    }
    if (options.messages) {
      var messages$1 = this.messages();
      if (messages$1 === messages) {
        messages$1 = newMessages();
      }
      deepMerge(messages$1, options.messages);
      options.messages = messages$1;
    } else {
      options.messages = this.messages();
    }
    var series = {};
    var keys2 = options.keys || Object.keys(this.rules);
    keys2.forEach(function(z2) {
      var arr = _this2.rules[z2];
      var value2 = source[z2];
      arr.forEach(function(r2) {
        var rule = r2;
        if (typeof rule.transform === "function") {
          if (source === source_) {
            source = _extends$1({}, source);
          }
          value2 = source[z2] = rule.transform(value2);
        }
        if (typeof rule === "function") {
          rule = {
            validator: rule
          };
        } else {
          rule = _extends$1({}, rule);
        }
        rule.validator = _this2.getValidationMethod(rule);
        if (!rule.validator) {
          return;
        }
        rule.field = z2;
        rule.fullField = rule.fullField || z2;
        rule.type = _this2.getType(rule);
        series[z2] = series[z2] || [];
        series[z2].push({
          rule,
          value: value2,
          source,
          field: z2
        });
      });
    });
    var errorFields = {};
    return asyncMap(series, options, function(data2, doIt) {
      var rule = data2.rule;
      var deep2 = (rule.type === "object" || rule.type === "array") && (typeof rule.fields === "object" || typeof rule.defaultField === "object");
      deep2 = deep2 && (rule.required || !rule.required && data2.value);
      rule.field = data2.field;
      function addFullField(key2, schema2) {
        return _extends$1({}, schema2, {
          fullField: rule.fullField + "." + key2,
          fullFields: rule.fullFields ? [].concat(rule.fullFields, [key2]) : [key2]
        });
      }
      function cb2(e3) {
        if (e3 === void 0) {
          e3 = [];
        }
        var errorList = Array.isArray(e3) ? e3 : [e3];
        if (!options.suppressWarning && errorList.length) {
          Schema2.warning("async-validator:", errorList);
        }
        if (errorList.length && rule.message !== void 0) {
          errorList = [].concat(rule.message);
        }
        var filledErrors = errorList.map(complementError(rule, source));
        if (options.first && filledErrors.length) {
          errorFields[rule.field] = 1;
          return doIt(filledErrors);
        }
        if (!deep2) {
          doIt(filledErrors);
        } else {
          if (rule.required && !data2.value) {
            if (rule.message !== void 0) {
              filledErrors = [].concat(rule.message).map(complementError(rule, source));
            } else if (options.error) {
              filledErrors = [options.error(rule, format$1(options.messages.required, rule.field))];
            }
            return doIt(filledErrors);
          }
          var fieldsSchema = {};
          if (rule.defaultField) {
            Object.keys(data2.value).map(function(key2) {
              fieldsSchema[key2] = rule.defaultField;
            });
          }
          fieldsSchema = _extends$1({}, fieldsSchema, data2.rule.fields);
          var paredFieldsSchema = {};
          Object.keys(fieldsSchema).forEach(function(field2) {
            var fieldSchema = fieldsSchema[field2];
            var fieldSchemaList = Array.isArray(fieldSchema) ? fieldSchema : [fieldSchema];
            paredFieldsSchema[field2] = fieldSchemaList.map(addFullField.bind(null, field2));
          });
          var schema2 = new Schema2(paredFieldsSchema);
          schema2.messages(options.messages);
          if (data2.rule.options) {
            data2.rule.options.messages = options.messages;
            data2.rule.options.error = options.error;
          }
          schema2.validate(data2.value, data2.rule.options || options, function(errs) {
            var finalErrors = [];
            if (filledErrors && filledErrors.length) {
              finalErrors.push.apply(finalErrors, filledErrors);
            }
            if (errs && errs.length) {
              finalErrors.push.apply(finalErrors, errs);
            }
            doIt(finalErrors.length ? finalErrors : null);
          });
        }
      }
      var res;
      if (rule.asyncValidator) {
        res = rule.asyncValidator(rule, data2.value, cb2, data2.source, options);
      } else if (rule.validator) {
        try {
          res = rule.validator(rule, data2.value, cb2, data2.source, options);
        } catch (error) {
          console.error == null ? void 0 : console.error(error);
          if (!options.suppressValidatorError) {
            setTimeout(function() {
              throw error;
            }, 0);
          }
          cb2(error.message);
        }
        if (res === true) {
          cb2();
        } else if (res === false) {
          cb2(typeof rule.message === "function" ? rule.message(rule.fullField || rule.field) : rule.message || (rule.fullField || rule.field) + " fails");
        } else if (res instanceof Array) {
          cb2(res);
        } else if (res instanceof Error) {
          cb2(res.message);
        }
      }
      if (res && res.then) {
        res.then(function() {
          return cb2();
        }, function(e3) {
          return cb2(e3);
        });
      }
    }, function(results) {
      complete(results);
    }, source);
  };
  _proto.getType = function getType3(rule) {
    if (rule.type === void 0 && rule.pattern instanceof RegExp) {
      rule.type = "pattern";
    }
    if (typeof rule.validator !== "function" && rule.type && !validators$2.hasOwnProperty(rule.type)) {
      throw new Error(format$1("Unknown rule type %s", rule.type));
    }
    return rule.type || "string";
  };
  _proto.getValidationMethod = function getValidationMethod(rule) {
    if (typeof rule.validator === "function") {
      return rule.validator;
    }
    var keys2 = Object.keys(rule);
    var messageIndex = keys2.indexOf("message");
    if (messageIndex !== -1) {
      keys2.splice(messageIndex, 1);
    }
    if (keys2.length === 1 && keys2[0] === "required") {
      return validators$2.required;
    }
    return validators$2[this.getType(rule)] || void 0;
  };
  return Schema2;
}();
Schema$1.register = function register2(type4, validator2) {
  if (typeof validator2 !== "function") {
    throw new Error("Cannot register a validator by type, validator is not a function");
  }
  validators$2[type4] = validator2;
};
Schema$1.warning = warning$1;
Schema$1.messages = messages;
Schema$1.validators = validators$2;
var typeTemplate$1 = "'${name}' is not a valid ${type}";
var defaultValidateMessages = {
  default: "Validation error on field '${name}'",
  required: "'${name}' is required",
  enum: "'${name}' must be one of [${enum}]",
  whitespace: "'${name}' cannot be empty",
  date: {
    format: "'${name}' is invalid for format date",
    parse: "'${name}' could not be parsed as date",
    invalid: "'${name}' is invalid date"
  },
  types: {
    string: typeTemplate$1,
    method: typeTemplate$1,
    array: typeTemplate$1,
    object: typeTemplate$1,
    number: typeTemplate$1,
    date: typeTemplate$1,
    boolean: typeTemplate$1,
    integer: typeTemplate$1,
    float: typeTemplate$1,
    regexp: typeTemplate$1,
    email: typeTemplate$1,
    url: typeTemplate$1,
    hex: typeTemplate$1
  },
  string: {
    len: "'${name}' must be exactly ${len} characters",
    min: "'${name}' must be at least ${min} characters",
    max: "'${name}' cannot be longer than ${max} characters",
    range: "'${name}' must be between ${min} and ${max} characters"
  },
  number: {
    len: "'${name}' must equal ${len}",
    min: "'${name}' cannot be less than ${min}",
    max: "'${name}' cannot be greater than ${max}",
    range: "'${name}' must be between ${min} and ${max}"
  },
  array: {
    len: "'${name}' must be exactly ${len} in length",
    min: "'${name}' cannot be less than ${min} in length",
    max: "'${name}' cannot be greater than ${max} in length",
    range: "'${name}' must be between ${min} and ${max} in length"
  },
  pattern: {
    mismatch: "'${name}' does not match pattern ${pattern}"
  }
};
function get$2(entity, path2) {
  var current = entity;
  for (var i2 = 0; i2 < path2.length; i2 += 1) {
    if (current === null || current === void 0) {
      return void 0;
    }
    current = current[path2[i2]];
  }
  return current;
}
function _arrayWithHoles$4(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _nonIterableRest$4() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _toArray(arr) {
  return _arrayWithHoles$4(arr) || _iterableToArray(arr) || _unsupportedIterableToArray$3(arr) || _nonIterableRest$4();
}
function internalSet(entity, paths, value2, removeIfUndefined) {
  if (!paths.length) {
    return value2;
  }
  var _paths = _toArray(paths), path2 = _paths[0], restPath = _paths.slice(1);
  var clone3;
  if (!entity && typeof path2 === "number") {
    clone3 = [];
  } else if (Array.isArray(entity)) {
    clone3 = _toConsumableArray(entity);
  } else {
    clone3 = _objectSpread2$1({}, entity);
  }
  if (removeIfUndefined && value2 === void 0 && restPath.length === 1) {
    delete clone3[path2][restPath[0]];
  } else {
    clone3[path2] = internalSet(clone3[path2], restPath, value2, removeIfUndefined);
  }
  return clone3;
}
function set$1(entity, paths, value2) {
  var removeIfUndefined = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
  if (paths.length && removeIfUndefined && value2 === void 0 && !get$2(entity, paths.slice(0, -1))) {
    return entity;
  }
  return internalSet(entity, paths, value2, removeIfUndefined);
}
function cloneDeep(val) {
  if (Array.isArray(val)) {
    return cloneArrayDeep(val);
  } else if (_typeof$4(val) === "object" && val !== null) {
    return cloneObjectDeep(val);
  }
  return val;
}
function cloneObjectDeep(val) {
  if (Object.getPrototypeOf(val) === Object.prototype) {
    var res = {};
    for (var key2 in val) {
      res[key2] = cloneDeep(val[key2]);
    }
    return res;
  }
  return val;
}
function cloneArrayDeep(val) {
  return val.map(function(item) {
    return cloneDeep(item);
  });
}
function getNamePath(path2) {
  return toArray$4(path2);
}
function getValue$4(store2, namePath) {
  var value2 = get$2(store2, namePath);
  return value2;
}
function setValue(store2, namePath, value2) {
  var removeIfUndefined = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
  var newStore = set$1(store2, namePath, value2, removeIfUndefined);
  return newStore;
}
function cloneByNamePathList(store2, namePathList) {
  var newStore = {};
  namePathList.forEach(function(namePath) {
    var value2 = getValue$4(store2, namePath);
    newStore = setValue(newStore, namePath, value2);
  });
  return newStore;
}
function containsNamePath(namePathList, namePath) {
  return namePathList && namePathList.some(function(path2) {
    return matchNamePath(path2, namePath);
  });
}
function isObject$7(obj) {
  return _typeof$4(obj) === "object" && obj !== null && Object.getPrototypeOf(obj) === Object.prototype;
}
function internalSetValues(store2, values2) {
  var newStore = Array.isArray(store2) ? _toConsumableArray(store2) : _objectSpread2$1({}, store2);
  if (!values2) {
    return newStore;
  }
  Object.keys(values2).forEach(function(key2) {
    var prevValue = newStore[key2];
    var value2 = values2[key2];
    var recursive = isObject$7(prevValue) && isObject$7(value2);
    newStore[key2] = recursive ? internalSetValues(prevValue, value2 || {}) : cloneDeep(value2);
  });
  return newStore;
}
function setValues(store2) {
  for (var _len = arguments.length, restValues = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    restValues[_key - 1] = arguments[_key];
  }
  return restValues.reduce(function(current, newStore) {
    return internalSetValues(current, newStore);
  }, store2);
}
function matchNamePath(namePath, changedNamePath) {
  if (!namePath || !changedNamePath || namePath.length !== changedNamePath.length) {
    return false;
  }
  return namePath.every(function(nameUnit, i2) {
    return changedNamePath[i2] === nameUnit;
  });
}
function isSimilar(source, target) {
  if (source === target) {
    return true;
  }
  if (!source && target || source && !target) {
    return false;
  }
  if (!source || !target || _typeof$4(source) !== "object" || _typeof$4(target) !== "object") {
    return false;
  }
  var sourceKeys = Object.keys(source);
  var targetKeys = Object.keys(target);
  var keys2 = new Set([].concat(sourceKeys, targetKeys));
  return _toConsumableArray(keys2).every(function(key2) {
    var sourceValue = source[key2];
    var targetValue = target[key2];
    if (typeof sourceValue === "function" && typeof targetValue === "function") {
      return true;
    }
    return sourceValue === targetValue;
  });
}
function defaultGetValueFromEvent(valuePropName) {
  var event = arguments.length <= 1 ? void 0 : arguments[1];
  if (event && event.target && _typeof$4(event.target) === "object" && valuePropName in event.target) {
    return event.target[valuePropName];
  }
  return event;
}
function move(array4, moveIndex, toIndex) {
  var length2 = array4.length;
  if (moveIndex < 0 || moveIndex >= length2 || toIndex < 0 || toIndex >= length2) {
    return array4;
  }
  var item = array4[moveIndex];
  var diff2 = moveIndex - toIndex;
  if (diff2 > 0) {
    return [].concat(_toConsumableArray(array4.slice(0, toIndex)), [item], _toConsumableArray(array4.slice(toIndex, moveIndex)), _toConsumableArray(array4.slice(moveIndex + 1, length2)));
  }
  if (diff2 < 0) {
    return [].concat(_toConsumableArray(array4.slice(0, moveIndex)), _toConsumableArray(array4.slice(moveIndex + 1, toIndex + 1)), [item], _toConsumableArray(array4.slice(toIndex + 1, length2)));
  }
  return array4;
}
var AsyncValidator = Schema$1;
function replaceMessage(template2, kv) {
  return template2.replace(/\$\{\w+\}/g, function(str) {
    var key2 = str.slice(2, -1);
    return kv[key2];
  });
}
var CODE_LOGIC_ERROR = "CODE_LOGIC_ERROR";
function validateRule(_x, _x2, _x3, _x4, _x5) {
  return _validateRule.apply(this, arguments);
}
function _validateRule() {
  _validateRule = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee2(name, value2, rule, options, messageVariables) {
    var cloneRule, originValidator, subRuleField, validator2, messages2, result, subResults, kv, fillVariableResult;
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            cloneRule = _objectSpread2$1({}, rule);
            delete cloneRule.ruleIndex;
            if (cloneRule.validator) {
              originValidator = cloneRule.validator;
              cloneRule.validator = function() {
                try {
                  return originValidator.apply(void 0, arguments);
                } catch (error) {
                  console.error(error);
                  return Promise.reject(CODE_LOGIC_ERROR);
                }
              };
            }
            subRuleField = null;
            if (cloneRule && cloneRule.type === "array" && cloneRule.defaultField) {
              subRuleField = cloneRule.defaultField;
              delete cloneRule.defaultField;
            }
            validator2 = new AsyncValidator(_defineProperty$4({}, name, [cloneRule]));
            messages2 = setValues({}, defaultValidateMessages, options.validateMessages);
            validator2.messages(messages2);
            result = [];
            _context2.prev = 9;
            _context2.next = 12;
            return Promise.resolve(validator2.validate(_defineProperty$4({}, name, value2), _objectSpread2$1({}, options)));
          case 12:
            _context2.next = 17;
            break;
          case 14:
            _context2.prev = 14;
            _context2.t0 = _context2["catch"](9);
            if (_context2.t0.errors) {
              result = _context2.t0.errors.map(function(_ref4, index2) {
                var message2 = _ref4.message;
                var mergedMessage = message2 === CODE_LOGIC_ERROR ? messages2.default : message2;
                return /* @__PURE__ */ react.exports.isValidElement(mergedMessage) ? /* @__PURE__ */ react.exports.cloneElement(mergedMessage, {
                  key: "error_".concat(index2)
                }) : mergedMessage;
              });
            }
          case 17:
            if (!(!result.length && subRuleField)) {
              _context2.next = 22;
              break;
            }
            _context2.next = 20;
            return Promise.all(value2.map(function(subValue, i2) {
              return validateRule("".concat(name, ".").concat(i2), subValue, subRuleField, options, messageVariables);
            }));
          case 20:
            subResults = _context2.sent;
            return _context2.abrupt("return", subResults.reduce(function(prev, errors) {
              return [].concat(_toConsumableArray(prev), _toConsumableArray(errors));
            }, []));
          case 22:
            kv = _objectSpread2$1(_objectSpread2$1({}, rule), {}, {
              name,
              enum: (rule.enum || []).join(", ")
            }, messageVariables);
            fillVariableResult = result.map(function(error) {
              if (typeof error === "string") {
                return replaceMessage(error, kv);
              }
              return error;
            });
            return _context2.abrupt("return", fillVariableResult);
          case 25:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, null, [[9, 14]]);
  }));
  return _validateRule.apply(this, arguments);
}
function validateRules(namePath, value2, rules2, options, validateFirst, messageVariables) {
  var name = namePath.join(".");
  var filledRules = rules2.map(function(currentRule, ruleIndex) {
    var originValidatorFunc = currentRule.validator;
    var cloneRule = _objectSpread2$1(_objectSpread2$1({}, currentRule), {}, {
      ruleIndex
    });
    if (originValidatorFunc) {
      cloneRule.validator = function(rule, val, callback) {
        var hasPromise = false;
        var wrappedCallback = function wrappedCallback2() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          Promise.resolve().then(function() {
            warningOnce(!hasPromise, "Your validator function has already return a promise. `callback` will be ignored.");
            if (!hasPromise) {
              callback.apply(void 0, args);
            }
          });
        };
        var promise = originValidatorFunc(rule, val, wrappedCallback);
        hasPromise = promise && typeof promise.then === "function" && typeof promise.catch === "function";
        warningOnce(hasPromise, "`callback` is deprecated. Please return a promise instead.");
        if (hasPromise) {
          promise.then(function() {
            callback();
          }).catch(function(err) {
            callback(err || " ");
          });
        }
      };
    }
    return cloneRule;
  }).sort(function(_ref, _ref2) {
    var w1 = _ref.warningOnly, i1 = _ref.ruleIndex;
    var w2 = _ref2.warningOnly, i2 = _ref2.ruleIndex;
    if (!!w1 === !!w2) {
      return i1 - i2;
    }
    if (w1) {
      return 1;
    }
    return -1;
  });
  var summaryPromise;
  if (validateFirst === true) {
    summaryPromise = new Promise(/* @__PURE__ */ function() {
      var _ref3 = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee(resolve, reject) {
        var i2, rule, errors;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                i2 = 0;
              case 1:
                if (!(i2 < filledRules.length)) {
                  _context.next = 12;
                  break;
                }
                rule = filledRules[i2];
                _context.next = 5;
                return validateRule(name, value2, rule, options, messageVariables);
              case 5:
                errors = _context.sent;
                if (!errors.length) {
                  _context.next = 9;
                  break;
                }
                reject([{
                  errors,
                  rule
                }]);
                return _context.abrupt("return");
              case 9:
                i2 += 1;
                _context.next = 1;
                break;
              case 12:
                resolve([]);
              case 13:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));
      return function(_x6, _x7) {
        return _ref3.apply(this, arguments);
      };
    }());
  } else {
    var rulePromises = filledRules.map(function(rule) {
      return validateRule(name, value2, rule, options, messageVariables).then(function(errors) {
        return {
          errors,
          rule
        };
      });
    });
    summaryPromise = (validateFirst ? finishOnFirstFailed(rulePromises) : finishOnAllFailed(rulePromises)).then(function(errors) {
      return Promise.reject(errors);
    });
  }
  summaryPromise.catch(function(e3) {
    return e3;
  });
  return summaryPromise;
}
function finishOnAllFailed(_x8) {
  return _finishOnAllFailed.apply(this, arguments);
}
function _finishOnAllFailed() {
  _finishOnAllFailed = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee3(rulePromises) {
    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            return _context3.abrupt("return", Promise.all(rulePromises).then(function(errorsList) {
              var _ref5;
              var errors = (_ref5 = []).concat.apply(_ref5, _toConsumableArray(errorsList));
              return errors;
            }));
          case 1:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));
  return _finishOnAllFailed.apply(this, arguments);
}
function finishOnFirstFailed(_x9) {
  return _finishOnFirstFailed.apply(this, arguments);
}
function _finishOnFirstFailed() {
  _finishOnFirstFailed = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee4(rulePromises) {
    var count2;
    return _regeneratorRuntime().wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            count2 = 0;
            return _context4.abrupt("return", new Promise(function(resolve) {
              rulePromises.forEach(function(promise) {
                promise.then(function(ruleError) {
                  if (ruleError.errors.length) {
                    resolve([ruleError]);
                  }
                  count2 += 1;
                  if (count2 === rulePromises.length) {
                    resolve([]);
                  }
                });
              });
            }));
          case 2:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4);
  }));
  return _finishOnFirstFailed.apply(this, arguments);
}
var _excluded$D = ["name"];
var EMPTY_ERRORS = [];
function requireUpdate(shouldUpdate, prev, next, prevValue, nextValue, info) {
  if (typeof shouldUpdate === "function") {
    return shouldUpdate(prev, next, "source" in info ? {
      source: info.source
    } : {});
  }
  return prevValue !== nextValue;
}
var Field = /* @__PURE__ */ function(_React$Component) {
  _inherits$1(Field2, _React$Component);
  var _super = _createSuper$1(Field2);
  function Field2(props) {
    var _this;
    _classCallCheck$2(this, Field2);
    _this = _super.call(this, props);
    _this.state = {
      resetCount: 0
    };
    _this.cancelRegisterFunc = null;
    _this.mounted = false;
    _this.touched = false;
    _this.dirty = false;
    _this.validatePromise = null;
    _this.prevValidating = void 0;
    _this.errors = EMPTY_ERRORS;
    _this.warnings = EMPTY_ERRORS;
    _this.cancelRegister = function() {
      var _this$props = _this.props, preserve = _this$props.preserve, isListField = _this$props.isListField, name = _this$props.name;
      if (_this.cancelRegisterFunc) {
        _this.cancelRegisterFunc(isListField, preserve, getNamePath(name));
      }
      _this.cancelRegisterFunc = null;
    };
    _this.getNamePath = function() {
      var _this$props2 = _this.props, name = _this$props2.name, fieldContext = _this$props2.fieldContext;
      var _fieldContext$prefixN = fieldContext.prefixName, prefixName = _fieldContext$prefixN === void 0 ? [] : _fieldContext$prefixN;
      return name !== void 0 ? [].concat(_toConsumableArray(prefixName), _toConsumableArray(name)) : [];
    };
    _this.getRules = function() {
      var _this$props3 = _this.props, _this$props3$rules = _this$props3.rules, rules2 = _this$props3$rules === void 0 ? [] : _this$props3$rules, fieldContext = _this$props3.fieldContext;
      return rules2.map(function(rule) {
        if (typeof rule === "function") {
          return rule(fieldContext);
        }
        return rule;
      });
    };
    _this.refresh = function() {
      if (!_this.mounted)
        return;
      _this.setState(function(_ref) {
        var resetCount = _ref.resetCount;
        return {
          resetCount: resetCount + 1
        };
      });
    };
    _this.triggerMetaEvent = function(destroy3) {
      var onMetaChange = _this.props.onMetaChange;
      onMetaChange === null || onMetaChange === void 0 ? void 0 : onMetaChange(_objectSpread2$1(_objectSpread2$1({}, _this.getMeta()), {}, {
        destroy: destroy3
      }));
    };
    _this.onStoreChange = function(prevStore, namePathList, info) {
      var _this$props4 = _this.props, shouldUpdate = _this$props4.shouldUpdate, _this$props4$dependen = _this$props4.dependencies, dependencies = _this$props4$dependen === void 0 ? [] : _this$props4$dependen, onReset = _this$props4.onReset;
      var store2 = info.store;
      var namePath = _this.getNamePath();
      var prevValue = _this.getValue(prevStore);
      var curValue = _this.getValue(store2);
      var namePathMatch = namePathList && containsNamePath(namePathList, namePath);
      if (info.type === "valueUpdate" && info.source === "external" && prevValue !== curValue) {
        _this.touched = true;
        _this.dirty = true;
        _this.validatePromise = null;
        _this.errors = EMPTY_ERRORS;
        _this.warnings = EMPTY_ERRORS;
        _this.triggerMetaEvent();
      }
      switch (info.type) {
        case "reset":
          if (!namePathList || namePathMatch) {
            _this.touched = false;
            _this.dirty = false;
            _this.validatePromise = null;
            _this.errors = EMPTY_ERRORS;
            _this.warnings = EMPTY_ERRORS;
            _this.triggerMetaEvent();
            onReset === null || onReset === void 0 ? void 0 : onReset();
            _this.refresh();
            return;
          }
          break;
        case "remove": {
          if (shouldUpdate) {
            _this.reRender();
            return;
          }
          break;
        }
        case "setField": {
          if (namePathMatch) {
            var data2 = info.data;
            if ("touched" in data2) {
              _this.touched = data2.touched;
            }
            if ("validating" in data2 && !("originRCField" in data2)) {
              _this.validatePromise = data2.validating ? Promise.resolve([]) : null;
            }
            if ("errors" in data2) {
              _this.errors = data2.errors || EMPTY_ERRORS;
            }
            if ("warnings" in data2) {
              _this.warnings = data2.warnings || EMPTY_ERRORS;
            }
            _this.dirty = true;
            _this.triggerMetaEvent();
            _this.reRender();
            return;
          }
          if (shouldUpdate && !namePath.length && requireUpdate(shouldUpdate, prevStore, store2, prevValue, curValue, info)) {
            _this.reRender();
            return;
          }
          break;
        }
        case "dependenciesUpdate": {
          var dependencyList = dependencies.map(getNamePath);
          if (dependencyList.some(function(dependency) {
            return containsNamePath(info.relatedFields, dependency);
          })) {
            _this.reRender();
            return;
          }
          break;
        }
        default:
          if (namePathMatch || (!dependencies.length || namePath.length || shouldUpdate) && requireUpdate(shouldUpdate, prevStore, store2, prevValue, curValue, info)) {
            _this.reRender();
            return;
          }
          break;
      }
      if (shouldUpdate === true) {
        _this.reRender();
      }
    };
    _this.validateRules = function(options) {
      var namePath = _this.getNamePath();
      var currentValue = _this.getValue();
      var rootPromise = Promise.resolve().then(function() {
        if (!_this.mounted) {
          return [];
        }
        var _this$props5 = _this.props, _this$props5$validate = _this$props5.validateFirst, validateFirst = _this$props5$validate === void 0 ? false : _this$props5$validate, messageVariables = _this$props5.messageVariables;
        var _ref2 = options || {}, triggerName = _ref2.triggerName;
        var filteredRules = _this.getRules();
        if (triggerName) {
          filteredRules = filteredRules.filter(function(rule) {
            var validateTrigger = rule.validateTrigger;
            if (!validateTrigger) {
              return true;
            }
            var triggerList = toArray$4(validateTrigger);
            return triggerList.includes(triggerName);
          });
        }
        var promise = validateRules(namePath, currentValue, filteredRules, options, validateFirst, messageVariables);
        promise.catch(function(e3) {
          return e3;
        }).then(function() {
          var ruleErrors = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : EMPTY_ERRORS;
          if (_this.validatePromise === rootPromise) {
            var _ruleErrors$forEach;
            _this.validatePromise = null;
            var nextErrors = [];
            var nextWarnings = [];
            (_ruleErrors$forEach = ruleErrors.forEach) === null || _ruleErrors$forEach === void 0 ? void 0 : _ruleErrors$forEach.call(ruleErrors, function(_ref3) {
              var warningOnly = _ref3.rule.warningOnly, _ref3$errors = _ref3.errors, errors = _ref3$errors === void 0 ? EMPTY_ERRORS : _ref3$errors;
              if (warningOnly) {
                nextWarnings.push.apply(nextWarnings, _toConsumableArray(errors));
              } else {
                nextErrors.push.apply(nextErrors, _toConsumableArray(errors));
              }
            });
            _this.errors = nextErrors;
            _this.warnings = nextWarnings;
            _this.triggerMetaEvent();
            _this.reRender();
          }
        });
        return promise;
      });
      _this.validatePromise = rootPromise;
      _this.dirty = true;
      _this.errors = EMPTY_ERRORS;
      _this.warnings = EMPTY_ERRORS;
      _this.triggerMetaEvent();
      _this.reRender();
      return rootPromise;
    };
    _this.isFieldValidating = function() {
      return !!_this.validatePromise;
    };
    _this.isFieldTouched = function() {
      return _this.touched;
    };
    _this.isFieldDirty = function() {
      if (_this.dirty || _this.props.initialValue !== void 0) {
        return true;
      }
      var fieldContext = _this.props.fieldContext;
      var _fieldContext$getInte = fieldContext.getInternalHooks(HOOK_MARK), getInitialValue = _fieldContext$getInte.getInitialValue;
      if (getInitialValue(_this.getNamePath()) !== void 0) {
        return true;
      }
      return false;
    };
    _this.getErrors = function() {
      return _this.errors;
    };
    _this.getWarnings = function() {
      return _this.warnings;
    };
    _this.isListField = function() {
      return _this.props.isListField;
    };
    _this.isList = function() {
      return _this.props.isList;
    };
    _this.isPreserve = function() {
      return _this.props.preserve;
    };
    _this.getMeta = function() {
      _this.prevValidating = _this.isFieldValidating();
      var meta2 = {
        touched: _this.isFieldTouched(),
        validating: _this.prevValidating,
        errors: _this.errors,
        warnings: _this.warnings,
        name: _this.getNamePath()
      };
      return meta2;
    };
    _this.getOnlyChild = function(children) {
      if (typeof children === "function") {
        var meta2 = _this.getMeta();
        return _objectSpread2$1(_objectSpread2$1({}, _this.getOnlyChild(children(_this.getControlled(), meta2, _this.props.fieldContext))), {}, {
          isFunction: true
        });
      }
      var childList = toArray$5(children);
      if (childList.length !== 1 || !/* @__PURE__ */ react.exports.isValidElement(childList[0])) {
        return {
          child: childList,
          isFunction: false
        };
      }
      return {
        child: childList[0],
        isFunction: false
      };
    };
    _this.getValue = function(store2) {
      var getFieldsValue = _this.props.fieldContext.getFieldsValue;
      var namePath = _this.getNamePath();
      return getValue$4(store2 || getFieldsValue(true), namePath);
    };
    _this.getControlled = function() {
      var childProps = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var _this$props6 = _this.props, trigger = _this$props6.trigger, validateTrigger = _this$props6.validateTrigger, getValueFromEvent = _this$props6.getValueFromEvent, normalize2 = _this$props6.normalize, valuePropName = _this$props6.valuePropName, getValueProps = _this$props6.getValueProps, fieldContext = _this$props6.fieldContext;
      var mergedValidateTrigger = validateTrigger !== void 0 ? validateTrigger : fieldContext.validateTrigger;
      var namePath = _this.getNamePath();
      var getInternalHooks3 = fieldContext.getInternalHooks, getFieldsValue = fieldContext.getFieldsValue;
      var _getInternalHooks = getInternalHooks3(HOOK_MARK), dispatch2 = _getInternalHooks.dispatch;
      var value2 = _this.getValue();
      var mergedGetValueProps = getValueProps || function(val) {
        return _defineProperty$4({}, valuePropName, val);
      };
      var originTriggerFunc = childProps[trigger];
      var control = _objectSpread2$1(_objectSpread2$1({}, childProps), mergedGetValueProps(value2));
      control[trigger] = function() {
        _this.touched = true;
        _this.dirty = true;
        _this.triggerMetaEvent();
        var newValue;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        if (getValueFromEvent) {
          newValue = getValueFromEvent.apply(void 0, args);
        } else {
          newValue = defaultGetValueFromEvent.apply(void 0, [valuePropName].concat(args));
        }
        if (normalize2) {
          newValue = normalize2(newValue, value2, getFieldsValue(true));
        }
        dispatch2({
          type: "updateValue",
          namePath,
          value: newValue
        });
        if (originTriggerFunc) {
          originTriggerFunc.apply(void 0, args);
        }
      };
      var validateTriggerList = toArray$4(mergedValidateTrigger || []);
      validateTriggerList.forEach(function(triggerName) {
        var originTrigger = control[triggerName];
        control[triggerName] = function() {
          if (originTrigger) {
            originTrigger.apply(void 0, arguments);
          }
          var rules2 = _this.props.rules;
          if (rules2 && rules2.length) {
            dispatch2({
              type: "validateField",
              namePath,
              triggerName
            });
          }
        };
      });
      return control;
    };
    if (props.fieldContext) {
      var getInternalHooks2 = props.fieldContext.getInternalHooks;
      var _getInternalHooks2 = getInternalHooks2(HOOK_MARK), initEntityValue = _getInternalHooks2.initEntityValue;
      initEntityValue(_assertThisInitialized$1(_this));
    }
    return _this;
  }
  _createClass$2(Field2, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      var _this$props7 = this.props, shouldUpdate = _this$props7.shouldUpdate, fieldContext = _this$props7.fieldContext;
      this.mounted = true;
      if (fieldContext) {
        var getInternalHooks2 = fieldContext.getInternalHooks;
        var _getInternalHooks3 = getInternalHooks2(HOOK_MARK), registerField = _getInternalHooks3.registerField;
        this.cancelRegisterFunc = registerField(this);
      }
      if (shouldUpdate === true) {
        this.reRender();
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.cancelRegister();
      this.triggerMetaEvent(true);
      this.mounted = false;
    }
  }, {
    key: "reRender",
    value: function reRender() {
      if (!this.mounted)
        return;
      this.forceUpdate();
    }
  }, {
    key: "render",
    value: function render2() {
      var resetCount = this.state.resetCount;
      var children = this.props.children;
      var _this$getOnlyChild = this.getOnlyChild(children), child = _this$getOnlyChild.child, isFunction2 = _this$getOnlyChild.isFunction;
      var returnChildNode;
      if (isFunction2) {
        returnChildNode = child;
      } else if (/* @__PURE__ */ react.exports.isValidElement(child)) {
        returnChildNode = /* @__PURE__ */ react.exports.cloneElement(child, this.getControlled(child.props));
      } else {
        warningOnce(!child, "`children` of Field is not validate ReactElement.");
        returnChildNode = child;
      }
      return /* @__PURE__ */ react.exports.createElement(react.exports.Fragment, {
        key: resetCount
      }, returnChildNode);
    }
  }]);
  return Field2;
}(react.exports.Component);
Field.contextType = Context$1;
Field.defaultProps = {
  trigger: "onChange",
  valuePropName: "value"
};
function WrapperField(_ref5) {
  var name = _ref5.name, restProps = _objectWithoutProperties$1(_ref5, _excluded$D);
  var fieldContext = react.exports.useContext(Context$1);
  var namePath = name !== void 0 ? getNamePath(name) : void 0;
  var key2 = "keep";
  if (!restProps.isListField) {
    key2 = "_".concat((namePath || []).join("_"));
  }
  return /* @__PURE__ */ react.exports.createElement(Field, _extends$2({
    key: key2,
    name: namePath
  }, restProps, {
    fieldContext
  }));
}
var ListContext$1 = /* @__PURE__ */ react.exports.createContext(null);
var List$3 = function List2(_ref) {
  var name = _ref.name, initialValue = _ref.initialValue, children = _ref.children, rules2 = _ref.rules, validateTrigger = _ref.validateTrigger;
  var context2 = react.exports.useContext(Context$1);
  var keyRef = react.exports.useRef({
    keys: [],
    id: 0
  });
  var keyManager = keyRef.current;
  var prefixName = react.exports.useMemo(function() {
    var parentPrefixName = getNamePath(context2.prefixName) || [];
    return [].concat(_toConsumableArray(parentPrefixName), _toConsumableArray(getNamePath(name)));
  }, [context2.prefixName, name]);
  var fieldContext = react.exports.useMemo(function() {
    return _objectSpread2$1(_objectSpread2$1({}, context2), {}, {
      prefixName
    });
  }, [context2, prefixName]);
  var listContext = react.exports.useMemo(function() {
    return {
      getKey: function getKey2(namePath) {
        var len = prefixName.length;
        var pathName = namePath[len];
        return [keyManager.keys[pathName], namePath.slice(len + 1)];
      }
    };
  }, [prefixName]);
  if (typeof children !== "function") {
    warningOnce(false, "Form.List only accepts function as children.");
    return null;
  }
  var shouldUpdate = function shouldUpdate2(prevValue, nextValue, _ref2) {
    var source = _ref2.source;
    if (source === "internal") {
      return false;
    }
    return prevValue !== nextValue;
  };
  return /* @__PURE__ */ react.exports.createElement(ListContext$1.Provider, {
    value: listContext
  }, /* @__PURE__ */ react.exports.createElement(Context$1.Provider, {
    value: fieldContext
  }, /* @__PURE__ */ react.exports.createElement(WrapperField, {
    name: [],
    shouldUpdate,
    rules: rules2,
    validateTrigger,
    initialValue,
    isList: true
  }, function(_ref3, meta2) {
    var _ref3$value = _ref3.value, value2 = _ref3$value === void 0 ? [] : _ref3$value, onChange2 = _ref3.onChange;
    var getFieldValue = context2.getFieldValue;
    var getNewValue = function getNewValue2() {
      var values2 = getFieldValue(prefixName || []);
      return values2 || [];
    };
    var operations = {
      add: function add2(defaultValue, index2) {
        var newValue = getNewValue();
        if (index2 >= 0 && index2 <= newValue.length) {
          keyManager.keys = [].concat(_toConsumableArray(keyManager.keys.slice(0, index2)), [keyManager.id], _toConsumableArray(keyManager.keys.slice(index2)));
          onChange2([].concat(_toConsumableArray(newValue.slice(0, index2)), [defaultValue], _toConsumableArray(newValue.slice(index2))));
        } else {
          keyManager.keys = [].concat(_toConsumableArray(keyManager.keys), [keyManager.id]);
          onChange2([].concat(_toConsumableArray(newValue), [defaultValue]));
        }
        keyManager.id += 1;
      },
      remove: function remove2(index2) {
        var newValue = getNewValue();
        var indexSet = new Set(Array.isArray(index2) ? index2 : [index2]);
        if (indexSet.size <= 0) {
          return;
        }
        keyManager.keys = keyManager.keys.filter(function(_2, keysIndex) {
          return !indexSet.has(keysIndex);
        });
        onChange2(newValue.filter(function(_2, valueIndex) {
          return !indexSet.has(valueIndex);
        }));
      },
      move: function move$1(from, to) {
        if (from === to) {
          return;
        }
        var newValue = getNewValue();
        if (from < 0 || from >= newValue.length || to < 0 || to >= newValue.length) {
          return;
        }
        keyManager.keys = move(keyManager.keys, from, to);
        onChange2(move(newValue, from, to));
      }
    };
    var listValue = value2 || [];
    if (!Array.isArray(listValue)) {
      listValue = [];
    }
    return children(listValue.map(function(__, index2) {
      var key2 = keyManager.keys[index2];
      if (key2 === void 0) {
        keyManager.keys[index2] = keyManager.id;
        key2 = keyManager.keys[index2];
        keyManager.id += 1;
      }
      return {
        name: index2,
        key: key2,
        isListField: true
      };
    }), operations, meta2);
  })));
};
function _iterableToArrayLimit$4(arr, i2) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i2 && _arr.length === i2)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _slicedToArray$4(arr, i2) {
  return _arrayWithHoles$4(arr) || _iterableToArrayLimit$4(arr, i2) || _unsupportedIterableToArray$3(arr, i2) || _nonIterableRest$4();
}
function allPromiseFinish(promiseList) {
  var hasError = false;
  var count2 = promiseList.length;
  var results = [];
  if (!promiseList.length) {
    return Promise.resolve([]);
  }
  return new Promise(function(resolve, reject) {
    promiseList.forEach(function(promise, index2) {
      promise.catch(function(e3) {
        hasError = true;
        return e3;
      }).then(function(result) {
        count2 -= 1;
        results[index2] = result;
        if (count2 > 0) {
          return;
        }
        if (hasError) {
          reject(results);
        }
        resolve(results);
      });
    });
  });
}
var SPLIT = "__@field_split__";
function normalize$1(namePath) {
  return namePath.map(function(cell) {
    return "".concat(_typeof$4(cell), ":").concat(cell);
  }).join(SPLIT);
}
var NameMap = /* @__PURE__ */ function() {
  function NameMap2() {
    _classCallCheck$2(this, NameMap2);
    this.kvs = /* @__PURE__ */ new Map();
  }
  _createClass$2(NameMap2, [{
    key: "set",
    value: function set2(key2, value2) {
      this.kvs.set(normalize$1(key2), value2);
    }
  }, {
    key: "get",
    value: function get2(key2) {
      return this.kvs.get(normalize$1(key2));
    }
  }, {
    key: "update",
    value: function update2(key2, updater) {
      var origin = this.get(key2);
      var next = updater(origin);
      if (!next) {
        this.delete(key2);
      } else {
        this.set(key2, next);
      }
    }
  }, {
    key: "delete",
    value: function _delete(key2) {
      this.kvs.delete(normalize$1(key2));
    }
  }, {
    key: "map",
    value: function map2(callback) {
      return _toConsumableArray(this.kvs.entries()).map(function(_ref) {
        var _ref2 = _slicedToArray$4(_ref, 2), key2 = _ref2[0], value2 = _ref2[1];
        var cells = key2.split(SPLIT);
        return callback({
          key: cells.map(function(cell) {
            var _cell$match = cell.match(/^([^:]*):(.*)$/), _cell$match2 = _slicedToArray$4(_cell$match, 3), type4 = _cell$match2[1], unit = _cell$match2[2];
            return type4 === "number" ? Number(unit) : unit;
          }),
          value: value2
        });
      });
    }
  }, {
    key: "toJSON",
    value: function toJSON2() {
      var json = {};
      this.map(function(_ref3) {
        var key2 = _ref3.key, value2 = _ref3.value;
        json[key2.join(".")] = value2;
        return null;
      });
      return json;
    }
  }]);
  return NameMap2;
}();
var _excluded$C = ["name", "errors"];
var FormStore = /* @__PURE__ */ _createClass$2(function FormStore2(forceRootUpdate) {
  var _this = this;
  _classCallCheck$2(this, FormStore2);
  this.formHooked = false;
  this.forceRootUpdate = void 0;
  this.subscribable = true;
  this.store = {};
  this.fieldEntities = [];
  this.initialValues = {};
  this.callbacks = {};
  this.validateMessages = null;
  this.preserve = null;
  this.lastValidatePromise = null;
  this.getForm = function() {
    return {
      getFieldValue: _this.getFieldValue,
      getFieldsValue: _this.getFieldsValue,
      getFieldError: _this.getFieldError,
      getFieldWarning: _this.getFieldWarning,
      getFieldsError: _this.getFieldsError,
      isFieldsTouched: _this.isFieldsTouched,
      isFieldTouched: _this.isFieldTouched,
      isFieldValidating: _this.isFieldValidating,
      isFieldsValidating: _this.isFieldsValidating,
      resetFields: _this.resetFields,
      setFields: _this.setFields,
      setFieldValue: _this.setFieldValue,
      setFieldsValue: _this.setFieldsValue,
      validateFields: _this.validateFields,
      submit: _this.submit,
      _init: true,
      getInternalHooks: _this.getInternalHooks
    };
  };
  this.getInternalHooks = function(key2) {
    if (key2 === HOOK_MARK) {
      _this.formHooked = true;
      return {
        dispatch: _this.dispatch,
        initEntityValue: _this.initEntityValue,
        registerField: _this.registerField,
        useSubscribe: _this.useSubscribe,
        setInitialValues: _this.setInitialValues,
        destroyForm: _this.destroyForm,
        setCallbacks: _this.setCallbacks,
        setValidateMessages: _this.setValidateMessages,
        getFields: _this.getFields,
        setPreserve: _this.setPreserve,
        getInitialValue: _this.getInitialValue,
        registerWatch: _this.registerWatch
      };
    }
    warningOnce(false, "`getInternalHooks` is internal usage. Should not call directly.");
    return null;
  };
  this.useSubscribe = function(subscribable) {
    _this.subscribable = subscribable;
  };
  this.prevWithoutPreserves = null;
  this.setInitialValues = function(initialValues, init) {
    _this.initialValues = initialValues || {};
    if (init) {
      var _this$prevWithoutPres;
      var nextStore = setValues({}, initialValues, _this.store);
      (_this$prevWithoutPres = _this.prevWithoutPreserves) === null || _this$prevWithoutPres === void 0 ? void 0 : _this$prevWithoutPres.map(function(_ref) {
        var namePath = _ref.key;
        nextStore = setValue(nextStore, namePath, getValue$4(initialValues, namePath));
      });
      _this.prevWithoutPreserves = null;
      _this.updateStore(nextStore);
    }
  };
  this.destroyForm = function() {
    var prevWithoutPreserves = new NameMap();
    _this.getFieldEntities(true).forEach(function(entity) {
      if (!_this.isMergedPreserve(entity.isPreserve())) {
        prevWithoutPreserves.set(entity.getNamePath(), true);
      }
    });
    _this.prevWithoutPreserves = prevWithoutPreserves;
  };
  this.getInitialValue = function(namePath) {
    var initValue = getValue$4(_this.initialValues, namePath);
    return namePath.length ? cloneDeep(initValue) : initValue;
  };
  this.setCallbacks = function(callbacks) {
    _this.callbacks = callbacks;
  };
  this.setValidateMessages = function(validateMessages) {
    _this.validateMessages = validateMessages;
  };
  this.setPreserve = function(preserve) {
    _this.preserve = preserve;
  };
  this.watchList = [];
  this.registerWatch = function(callback) {
    _this.watchList.push(callback);
    return function() {
      _this.watchList = _this.watchList.filter(function(fn2) {
        return fn2 !== callback;
      });
    };
  };
  this.notifyWatch = function() {
    var namePath = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    if (_this.watchList.length) {
      var values2 = _this.getFieldsValue();
      _this.watchList.forEach(function(callback) {
        callback(values2, namePath);
      });
    }
  };
  this.timeoutId = null;
  this.warningUnhooked = function() {
  };
  this.updateStore = function(nextStore) {
    _this.store = nextStore;
  };
  this.getFieldEntities = function() {
    var pure = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
    if (!pure) {
      return _this.fieldEntities;
    }
    return _this.fieldEntities.filter(function(field2) {
      return field2.getNamePath().length;
    });
  };
  this.getFieldsMap = function() {
    var pure = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
    var cache2 = new NameMap();
    _this.getFieldEntities(pure).forEach(function(field2) {
      var namePath = field2.getNamePath();
      cache2.set(namePath, field2);
    });
    return cache2;
  };
  this.getFieldEntitiesForNamePathList = function(nameList) {
    if (!nameList) {
      return _this.getFieldEntities(true);
    }
    var cache2 = _this.getFieldsMap(true);
    return nameList.map(function(name) {
      var namePath = getNamePath(name);
      return cache2.get(namePath) || {
        INVALIDATE_NAME_PATH: getNamePath(name)
      };
    });
  };
  this.getFieldsValue = function(nameList, filterFunc) {
    _this.warningUnhooked();
    if (nameList === true && !filterFunc) {
      return _this.store;
    }
    var fieldEntities = _this.getFieldEntitiesForNamePathList(Array.isArray(nameList) ? nameList : null);
    var filteredNameList = [];
    fieldEntities.forEach(function(entity) {
      var _entity$isListField;
      var namePath = "INVALIDATE_NAME_PATH" in entity ? entity.INVALIDATE_NAME_PATH : entity.getNamePath();
      if (!nameList && ((_entity$isListField = entity.isListField) === null || _entity$isListField === void 0 ? void 0 : _entity$isListField.call(entity))) {
        return;
      }
      if (!filterFunc) {
        filteredNameList.push(namePath);
      } else {
        var meta2 = "getMeta" in entity ? entity.getMeta() : null;
        if (filterFunc(meta2)) {
          filteredNameList.push(namePath);
        }
      }
    });
    return cloneByNamePathList(_this.store, filteredNameList.map(getNamePath));
  };
  this.getFieldValue = function(name) {
    _this.warningUnhooked();
    var namePath = getNamePath(name);
    return getValue$4(_this.store, namePath);
  };
  this.getFieldsError = function(nameList) {
    _this.warningUnhooked();
    var fieldEntities = _this.getFieldEntitiesForNamePathList(nameList);
    return fieldEntities.map(function(entity, index2) {
      if (entity && !("INVALIDATE_NAME_PATH" in entity)) {
        return {
          name: entity.getNamePath(),
          errors: entity.getErrors(),
          warnings: entity.getWarnings()
        };
      }
      return {
        name: getNamePath(nameList[index2]),
        errors: [],
        warnings: []
      };
    });
  };
  this.getFieldError = function(name) {
    _this.warningUnhooked();
    var namePath = getNamePath(name);
    var fieldError = _this.getFieldsError([namePath])[0];
    return fieldError.errors;
  };
  this.getFieldWarning = function(name) {
    _this.warningUnhooked();
    var namePath = getNamePath(name);
    var fieldError = _this.getFieldsError([namePath])[0];
    return fieldError.warnings;
  };
  this.isFieldsTouched = function() {
    _this.warningUnhooked();
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    var arg0 = args[0], arg1 = args[1];
    var namePathList;
    var isAllFieldsTouched = false;
    if (args.length === 0) {
      namePathList = null;
    } else if (args.length === 1) {
      if (Array.isArray(arg0)) {
        namePathList = arg0.map(getNamePath);
        isAllFieldsTouched = false;
      } else {
        namePathList = null;
        isAllFieldsTouched = arg0;
      }
    } else {
      namePathList = arg0.map(getNamePath);
      isAllFieldsTouched = arg1;
    }
    var fieldEntities = _this.getFieldEntities(true);
    var isFieldTouched = function isFieldTouched2(field2) {
      return field2.isFieldTouched();
    };
    if (!namePathList) {
      return isAllFieldsTouched ? fieldEntities.every(isFieldTouched) : fieldEntities.some(isFieldTouched);
    }
    var map2 = new NameMap();
    namePathList.forEach(function(shortNamePath) {
      map2.set(shortNamePath, []);
    });
    fieldEntities.forEach(function(field2) {
      var fieldNamePath = field2.getNamePath();
      namePathList.forEach(function(shortNamePath) {
        if (shortNamePath.every(function(nameUnit, i2) {
          return fieldNamePath[i2] === nameUnit;
        })) {
          map2.update(shortNamePath, function(list) {
            return [].concat(_toConsumableArray(list), [field2]);
          });
        }
      });
    });
    var isNamePathListTouched = function isNamePathListTouched2(entities) {
      return entities.some(isFieldTouched);
    };
    var namePathListEntities = map2.map(function(_ref2) {
      var value2 = _ref2.value;
      return value2;
    });
    return isAllFieldsTouched ? namePathListEntities.every(isNamePathListTouched) : namePathListEntities.some(isNamePathListTouched);
  };
  this.isFieldTouched = function(name) {
    _this.warningUnhooked();
    return _this.isFieldsTouched([name]);
  };
  this.isFieldsValidating = function(nameList) {
    _this.warningUnhooked();
    var fieldEntities = _this.getFieldEntities();
    if (!nameList) {
      return fieldEntities.some(function(testField) {
        return testField.isFieldValidating();
      });
    }
    var namePathList = nameList.map(getNamePath);
    return fieldEntities.some(function(testField) {
      var fieldNamePath = testField.getNamePath();
      return containsNamePath(namePathList, fieldNamePath) && testField.isFieldValidating();
    });
  };
  this.isFieldValidating = function(name) {
    _this.warningUnhooked();
    return _this.isFieldsValidating([name]);
  };
  this.resetWithFieldInitialValue = function() {
    var info = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var cache2 = new NameMap();
    var fieldEntities = _this.getFieldEntities(true);
    fieldEntities.forEach(function(field2) {
      var initialValue = field2.props.initialValue;
      var namePath = field2.getNamePath();
      if (initialValue !== void 0) {
        var records = cache2.get(namePath) || /* @__PURE__ */ new Set();
        records.add({
          entity: field2,
          value: initialValue
        });
        cache2.set(namePath, records);
      }
    });
    var resetWithFields = function resetWithFields2(entities) {
      entities.forEach(function(field2) {
        var initialValue = field2.props.initialValue;
        if (initialValue !== void 0) {
          var namePath = field2.getNamePath();
          var formInitialValue = _this.getInitialValue(namePath);
          if (formInitialValue !== void 0) {
            warningOnce(false, "Form already set 'initialValues' with path '".concat(namePath.join("."), "'. Field can not overwrite it."));
          } else {
            var records = cache2.get(namePath);
            if (records && records.size > 1) {
              warningOnce(false, "Multiple Field with path '".concat(namePath.join("."), "' set 'initialValue'. Can not decide which one to pick."));
            } else if (records) {
              var originValue = _this.getFieldValue(namePath);
              if (!info.skipExist || originValue === void 0) {
                _this.updateStore(setValue(_this.store, namePath, _toConsumableArray(records)[0].value));
              }
            }
          }
        }
      });
    };
    var requiredFieldEntities;
    if (info.entities) {
      requiredFieldEntities = info.entities;
    } else if (info.namePathList) {
      requiredFieldEntities = [];
      info.namePathList.forEach(function(namePath) {
        var records = cache2.get(namePath);
        if (records) {
          var _requiredFieldEntitie;
          (_requiredFieldEntitie = requiredFieldEntities).push.apply(_requiredFieldEntitie, _toConsumableArray(_toConsumableArray(records).map(function(r2) {
            return r2.entity;
          })));
        }
      });
    } else {
      requiredFieldEntities = fieldEntities;
    }
    resetWithFields(requiredFieldEntities);
  };
  this.resetFields = function(nameList) {
    _this.warningUnhooked();
    var prevStore = _this.store;
    if (!nameList) {
      _this.updateStore(setValues({}, _this.initialValues));
      _this.resetWithFieldInitialValue();
      _this.notifyObservers(prevStore, null, {
        type: "reset"
      });
      _this.notifyWatch();
      return;
    }
    var namePathList = nameList.map(getNamePath);
    namePathList.forEach(function(namePath) {
      var initialValue = _this.getInitialValue(namePath);
      _this.updateStore(setValue(_this.store, namePath, initialValue));
    });
    _this.resetWithFieldInitialValue({
      namePathList
    });
    _this.notifyObservers(prevStore, namePathList, {
      type: "reset"
    });
    _this.notifyWatch(namePathList);
  };
  this.setFields = function(fields) {
    _this.warningUnhooked();
    var prevStore = _this.store;
    var namePathList = [];
    fields.forEach(function(fieldData) {
      var name = fieldData.name;
      fieldData.errors;
      var data2 = _objectWithoutProperties$1(fieldData, _excluded$C);
      var namePath = getNamePath(name);
      namePathList.push(namePath);
      if ("value" in data2) {
        _this.updateStore(setValue(_this.store, namePath, data2.value));
      }
      _this.notifyObservers(prevStore, [namePath], {
        type: "setField",
        data: fieldData
      });
    });
    _this.notifyWatch(namePathList);
  };
  this.getFields = function() {
    var entities = _this.getFieldEntities(true);
    var fields = entities.map(function(field2) {
      var namePath = field2.getNamePath();
      var meta2 = field2.getMeta();
      var fieldData = _objectSpread2$1(_objectSpread2$1({}, meta2), {}, {
        name: namePath,
        value: _this.getFieldValue(namePath)
      });
      Object.defineProperty(fieldData, "originRCField", {
        value: true
      });
      return fieldData;
    });
    return fields;
  };
  this.initEntityValue = function(entity) {
    var initialValue = entity.props.initialValue;
    if (initialValue !== void 0) {
      var namePath = entity.getNamePath();
      var prevValue = getValue$4(_this.store, namePath);
      if (prevValue === void 0) {
        _this.updateStore(setValue(_this.store, namePath, initialValue));
      }
    }
  };
  this.isMergedPreserve = function(fieldPreserve) {
    var mergedPreserve = fieldPreserve !== void 0 ? fieldPreserve : _this.preserve;
    return mergedPreserve !== null && mergedPreserve !== void 0 ? mergedPreserve : true;
  };
  this.registerField = function(entity) {
    _this.fieldEntities.push(entity);
    var namePath = entity.getNamePath();
    _this.notifyWatch([namePath]);
    if (entity.props.initialValue !== void 0) {
      var prevStore = _this.store;
      _this.resetWithFieldInitialValue({
        entities: [entity],
        skipExist: true
      });
      _this.notifyObservers(prevStore, [entity.getNamePath()], {
        type: "valueUpdate",
        source: "internal"
      });
    }
    return function(isListField, preserve) {
      var subNamePath = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
      _this.fieldEntities = _this.fieldEntities.filter(function(item) {
        return item !== entity;
      });
      if (!_this.isMergedPreserve(preserve) && (!isListField || subNamePath.length > 1)) {
        var defaultValue = isListField ? void 0 : _this.getInitialValue(namePath);
        if (namePath.length && _this.getFieldValue(namePath) !== defaultValue && _this.fieldEntities.every(function(field2) {
          return !matchNamePath(field2.getNamePath(), namePath);
        })) {
          var _prevStore = _this.store;
          _this.updateStore(setValue(_prevStore, namePath, defaultValue, true));
          _this.notifyObservers(_prevStore, [namePath], {
            type: "remove"
          });
          _this.triggerDependenciesUpdate(_prevStore, namePath);
        }
      }
      _this.notifyWatch([namePath]);
    };
  };
  this.dispatch = function(action) {
    switch (action.type) {
      case "updateValue": {
        var namePath = action.namePath, value2 = action.value;
        _this.updateValue(namePath, value2);
        break;
      }
      case "validateField": {
        var _namePath = action.namePath, triggerName = action.triggerName;
        _this.validateFields([_namePath], {
          triggerName
        });
        break;
      }
    }
  };
  this.notifyObservers = function(prevStore, namePathList, info) {
    if (_this.subscribable) {
      var mergedInfo = _objectSpread2$1(_objectSpread2$1({}, info), {}, {
        store: _this.getFieldsValue(true)
      });
      _this.getFieldEntities().forEach(function(_ref3) {
        var onStoreChange = _ref3.onStoreChange;
        onStoreChange(prevStore, namePathList, mergedInfo);
      });
    } else {
      _this.forceRootUpdate();
    }
  };
  this.triggerDependenciesUpdate = function(prevStore, namePath) {
    var childrenFields = _this.getDependencyChildrenFields(namePath);
    if (childrenFields.length) {
      _this.validateFields(childrenFields);
    }
    _this.notifyObservers(prevStore, childrenFields, {
      type: "dependenciesUpdate",
      relatedFields: [namePath].concat(_toConsumableArray(childrenFields))
    });
    return childrenFields;
  };
  this.updateValue = function(name, value2) {
    var namePath = getNamePath(name);
    var prevStore = _this.store;
    _this.updateStore(setValue(_this.store, namePath, value2));
    _this.notifyObservers(prevStore, [namePath], {
      type: "valueUpdate",
      source: "internal"
    });
    _this.notifyWatch([namePath]);
    var childrenFields = _this.triggerDependenciesUpdate(prevStore, namePath);
    var onValuesChange = _this.callbacks.onValuesChange;
    if (onValuesChange) {
      var changedValues = cloneByNamePathList(_this.store, [namePath]);
      onValuesChange(changedValues, _this.getFieldsValue());
    }
    _this.triggerOnFieldsChange([namePath].concat(_toConsumableArray(childrenFields)));
  };
  this.setFieldsValue = function(store2) {
    _this.warningUnhooked();
    var prevStore = _this.store;
    if (store2) {
      var nextStore = setValues(_this.store, store2);
      _this.updateStore(nextStore);
    }
    _this.notifyObservers(prevStore, null, {
      type: "valueUpdate",
      source: "external"
    });
    _this.notifyWatch();
  };
  this.setFieldValue = function(name, value2) {
    _this.setFields([{
      name,
      value: value2
    }]);
  };
  this.getDependencyChildrenFields = function(rootNamePath) {
    var children = /* @__PURE__ */ new Set();
    var childrenFields = [];
    var dependencies2fields = new NameMap();
    _this.getFieldEntities().forEach(function(field2) {
      var dependencies = field2.props.dependencies;
      (dependencies || []).forEach(function(dependency) {
        var dependencyNamePath = getNamePath(dependency);
        dependencies2fields.update(dependencyNamePath, function() {
          var fields = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : /* @__PURE__ */ new Set();
          fields.add(field2);
          return fields;
        });
      });
    });
    var fillChildren = function fillChildren2(namePath) {
      var fields = dependencies2fields.get(namePath) || /* @__PURE__ */ new Set();
      fields.forEach(function(field2) {
        if (!children.has(field2)) {
          children.add(field2);
          var fieldNamePath = field2.getNamePath();
          if (field2.isFieldDirty() && fieldNamePath.length) {
            childrenFields.push(fieldNamePath);
            fillChildren2(fieldNamePath);
          }
        }
      });
    };
    fillChildren(rootNamePath);
    return childrenFields;
  };
  this.triggerOnFieldsChange = function(namePathList, filedErrors) {
    var onFieldsChange = _this.callbacks.onFieldsChange;
    if (onFieldsChange) {
      var fields = _this.getFields();
      if (filedErrors) {
        var cache2 = new NameMap();
        filedErrors.forEach(function(_ref4) {
          var name = _ref4.name, errors = _ref4.errors;
          cache2.set(name, errors);
        });
        fields.forEach(function(field2) {
          field2.errors = cache2.get(field2.name) || field2.errors;
        });
      }
      var changedFields = fields.filter(function(_ref5) {
        var fieldName = _ref5.name;
        return containsNamePath(namePathList, fieldName);
      });
      onFieldsChange(changedFields, fields);
    }
  };
  this.validateFields = function(nameList, options) {
    _this.warningUnhooked();
    var provideNameList = !!nameList;
    var namePathList = provideNameList ? nameList.map(getNamePath) : [];
    var promiseList = [];
    _this.getFieldEntities(true).forEach(function(field2) {
      if (!provideNameList) {
        namePathList.push(field2.getNamePath());
      }
      if ((options === null || options === void 0 ? void 0 : options.recursive) && provideNameList) {
        var namePath = field2.getNamePath();
        if (namePath.every(function(nameUnit, i2) {
          return nameList[i2] === nameUnit || nameList[i2] === void 0;
        })) {
          namePathList.push(namePath);
        }
      }
      if (!field2.props.rules || !field2.props.rules.length) {
        return;
      }
      var fieldNamePath = field2.getNamePath();
      if (!provideNameList || containsNamePath(namePathList, fieldNamePath)) {
        var promise = field2.validateRules(_objectSpread2$1({
          validateMessages: _objectSpread2$1(_objectSpread2$1({}, defaultValidateMessages), _this.validateMessages)
        }, options));
        promiseList.push(promise.then(function() {
          return {
            name: fieldNamePath,
            errors: [],
            warnings: []
          };
        }).catch(function(ruleErrors) {
          var _ruleErrors$forEach;
          var mergedErrors = [];
          var mergedWarnings = [];
          (_ruleErrors$forEach = ruleErrors.forEach) === null || _ruleErrors$forEach === void 0 ? void 0 : _ruleErrors$forEach.call(ruleErrors, function(_ref6) {
            var warningOnly = _ref6.rule.warningOnly, errors = _ref6.errors;
            if (warningOnly) {
              mergedWarnings.push.apply(mergedWarnings, _toConsumableArray(errors));
            } else {
              mergedErrors.push.apply(mergedErrors, _toConsumableArray(errors));
            }
          });
          if (mergedErrors.length) {
            return Promise.reject({
              name: fieldNamePath,
              errors: mergedErrors,
              warnings: mergedWarnings
            });
          }
          return {
            name: fieldNamePath,
            errors: mergedErrors,
            warnings: mergedWarnings
          };
        }));
      }
    });
    var summaryPromise = allPromiseFinish(promiseList);
    _this.lastValidatePromise = summaryPromise;
    summaryPromise.catch(function(results) {
      return results;
    }).then(function(results) {
      var resultNamePathList = results.map(function(_ref7) {
        var name = _ref7.name;
        return name;
      });
      _this.notifyObservers(_this.store, resultNamePathList, {
        type: "validateFinish"
      });
      _this.triggerOnFieldsChange(resultNamePathList, results);
    });
    var returnPromise = summaryPromise.then(function() {
      if (_this.lastValidatePromise === summaryPromise) {
        return Promise.resolve(_this.getFieldsValue(namePathList));
      }
      return Promise.reject([]);
    }).catch(function(results) {
      var errorList = results.filter(function(result) {
        return result && result.errors.length;
      });
      return Promise.reject({
        values: _this.getFieldsValue(namePathList),
        errorFields: errorList,
        outOfDate: _this.lastValidatePromise !== summaryPromise
      });
    });
    returnPromise.catch(function(e3) {
      return e3;
    });
    return returnPromise;
  };
  this.submit = function() {
    _this.warningUnhooked();
    _this.validateFields().then(function(values2) {
      var onFinish = _this.callbacks.onFinish;
      if (onFinish) {
        try {
          onFinish(values2);
        } catch (err) {
          console.error(err);
        }
      }
    }).catch(function(e3) {
      var onFinishFailed = _this.callbacks.onFinishFailed;
      if (onFinishFailed) {
        onFinishFailed(e3);
      }
    });
  };
  this.forceRootUpdate = forceRootUpdate;
});
function useForm(form) {
  var formRef = react.exports.useRef();
  var _React$useState = react.exports.useState({}), _React$useState2 = _slicedToArray$4(_React$useState, 2), forceUpdate = _React$useState2[1];
  if (!formRef.current) {
    if (form) {
      formRef.current = form;
    } else {
      var forceReRender = function forceReRender2() {
        forceUpdate({});
      };
      var formStore = new FormStore(forceReRender);
      formRef.current = formStore.getForm();
    }
  }
  return [formRef.current];
}
var FormContext = /* @__PURE__ */ react.exports.createContext({
  triggerFormChange: function triggerFormChange() {
  },
  triggerFormFinish: function triggerFormFinish() {
  },
  registerForm: function registerForm() {
  },
  unregisterForm: function unregisterForm() {
  }
});
var FormProvider = function FormProvider2(_ref) {
  var validateMessages = _ref.validateMessages, onFormChange = _ref.onFormChange, onFormFinish = _ref.onFormFinish, children = _ref.children;
  var formContext = react.exports.useContext(FormContext);
  var formsRef = react.exports.useRef({});
  return /* @__PURE__ */ react.exports.createElement(FormContext.Provider, {
    value: _objectSpread2$1(_objectSpread2$1({}, formContext), {}, {
      validateMessages: _objectSpread2$1(_objectSpread2$1({}, formContext.validateMessages), validateMessages),
      triggerFormChange: function triggerFormChange2(name, changedFields) {
        if (onFormChange) {
          onFormChange(name, {
            changedFields,
            forms: formsRef.current
          });
        }
        formContext.triggerFormChange(name, changedFields);
      },
      triggerFormFinish: function triggerFormFinish2(name, values2) {
        if (onFormFinish) {
          onFormFinish(name, {
            values: values2,
            forms: formsRef.current
          });
        }
        formContext.triggerFormFinish(name, values2);
      },
      registerForm: function registerForm2(name, form) {
        if (name) {
          formsRef.current = _objectSpread2$1(_objectSpread2$1({}, formsRef.current), {}, _defineProperty$4({}, name, form));
        }
        formContext.registerForm(name, form);
      },
      unregisterForm: function unregisterForm2(name) {
        var newForms = _objectSpread2$1({}, formsRef.current);
        delete newForms[name];
        formsRef.current = newForms;
        formContext.unregisterForm(name);
      }
    })
  }, children);
};
var _excluded$B = ["name", "initialValues", "fields", "form", "preserve", "children", "component", "validateMessages", "validateTrigger", "onValuesChange", "onFieldsChange", "onFinish", "onFinishFailed"];
var Form = function Form2(_ref, ref) {
  var name = _ref.name, initialValues = _ref.initialValues, fields = _ref.fields, form = _ref.form, preserve = _ref.preserve, children = _ref.children, _ref$component = _ref.component, Component2 = _ref$component === void 0 ? "form" : _ref$component, validateMessages = _ref.validateMessages, _ref$validateTrigger = _ref.validateTrigger, validateTrigger = _ref$validateTrigger === void 0 ? "onChange" : _ref$validateTrigger, onValuesChange = _ref.onValuesChange, _onFieldsChange = _ref.onFieldsChange, _onFinish = _ref.onFinish, onFinishFailed = _ref.onFinishFailed, restProps = _objectWithoutProperties$1(_ref, _excluded$B);
  var formContext = react.exports.useContext(FormContext);
  var _useForm = useForm(form), _useForm2 = _slicedToArray$4(_useForm, 1), formInstance = _useForm2[0];
  var _formInstance$getInte = formInstance.getInternalHooks(HOOK_MARK), useSubscribe = _formInstance$getInte.useSubscribe, setInitialValues = _formInstance$getInte.setInitialValues, setCallbacks = _formInstance$getInte.setCallbacks, setValidateMessages = _formInstance$getInte.setValidateMessages, setPreserve = _formInstance$getInte.setPreserve, destroyForm = _formInstance$getInte.destroyForm;
  react.exports.useImperativeHandle(ref, function() {
    return formInstance;
  });
  react.exports.useEffect(function() {
    formContext.registerForm(name, formInstance);
    return function() {
      formContext.unregisterForm(name);
    };
  }, [formContext, formInstance, name]);
  setValidateMessages(_objectSpread2$1(_objectSpread2$1({}, formContext.validateMessages), validateMessages));
  setCallbacks({
    onValuesChange,
    onFieldsChange: function onFieldsChange(changedFields) {
      formContext.triggerFormChange(name, changedFields);
      if (_onFieldsChange) {
        for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          rest[_key - 1] = arguments[_key];
        }
        _onFieldsChange.apply(void 0, [changedFields].concat(rest));
      }
    },
    onFinish: function onFinish(values3) {
      formContext.triggerFormFinish(name, values3);
      if (_onFinish) {
        _onFinish(values3);
      }
    },
    onFinishFailed
  });
  setPreserve(preserve);
  var mountRef = react.exports.useRef(null);
  setInitialValues(initialValues, !mountRef.current);
  if (!mountRef.current) {
    mountRef.current = true;
  }
  react.exports.useEffect(
    function() {
      return destroyForm;
    },
    []
  );
  var childrenNode;
  var childrenRenderProps = typeof children === "function";
  if (childrenRenderProps) {
    var values2 = formInstance.getFieldsValue(true);
    childrenNode = children(values2, formInstance);
  } else {
    childrenNode = children;
  }
  useSubscribe(!childrenRenderProps);
  var prevFieldsRef = react.exports.useRef();
  react.exports.useEffect(function() {
    if (!isSimilar(prevFieldsRef.current || [], fields || [])) {
      formInstance.setFields(fields || []);
    }
    prevFieldsRef.current = fields;
  }, [fields, formInstance]);
  var formContextValue = react.exports.useMemo(function() {
    return _objectSpread2$1(_objectSpread2$1({}, formInstance), {}, {
      validateTrigger
    });
  }, [formInstance, validateTrigger]);
  var wrapperNode = /* @__PURE__ */ react.exports.createElement(Context$1.Provider, {
    value: formContextValue
  }, childrenNode);
  if (Component2 === false) {
    return wrapperNode;
  }
  return /* @__PURE__ */ react.exports.createElement(Component2, _extends$2({}, restProps, {
    onSubmit: function onSubmit(event) {
      event.preventDefault();
      event.stopPropagation();
      formInstance.submit();
    },
    onReset: function onReset(event) {
      var _restProps$onReset;
      event.preventDefault();
      formInstance.resetFields();
      (_restProps$onReset = restProps.onReset) === null || _restProps$onReset === void 0 ? void 0 : _restProps$onReset.call(restProps, event);
    }
  }), wrapperNode);
};
function stringify(value2) {
  try {
    return JSON.stringify(value2);
  } catch (err) {
    return Math.random();
  }
}
function useWatch() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  var _args$ = args[0], dependencies = _args$ === void 0 ? [] : _args$, form = args[1];
  var _useState = react.exports.useState(), _useState2 = _slicedToArray$4(_useState, 2), value2 = _useState2[0], setValue2 = _useState2[1];
  var valueStr = react.exports.useMemo(function() {
    return stringify(value2);
  }, [value2]);
  var valueStrRef = react.exports.useRef(valueStr);
  valueStrRef.current = valueStr;
  var fieldContext = react.exports.useContext(Context$1);
  var formInstance = form || fieldContext;
  var isValidForm = formInstance && formInstance._init;
  var namePath = getNamePath(dependencies);
  var namePathRef = react.exports.useRef(namePath);
  namePathRef.current = namePath;
  react.exports.useEffect(
    function() {
      if (!isValidForm) {
        return;
      }
      var getFieldsValue = formInstance.getFieldsValue, getInternalHooks2 = formInstance.getInternalHooks;
      var _getInternalHooks = getInternalHooks2(HOOK_MARK), registerWatch = _getInternalHooks.registerWatch;
      var cancelRegister = registerWatch(function(store2) {
        var newValue = getValue$4(store2, namePathRef.current);
        var nextValueStr = stringify(newValue);
        if (valueStrRef.current !== nextValueStr) {
          valueStrRef.current = nextValueStr;
          setValue2(newValue);
        }
      });
      var initialValue = getValue$4(getFieldsValue(), namePathRef.current);
      setValue2(initialValue);
      return cancelRegister;
    },
    [isValidForm]
  );
  return value2;
}
var InternalForm = /* @__PURE__ */ react.exports.forwardRef(Form);
var RefForm = InternalForm;
RefForm.FormProvider = FormProvider;
RefForm.Field = WrapperField;
RefForm.List = List$3;
RefForm.useForm = useForm;
RefForm.useWatch = useWatch;
var safeIsNaN = Number.isNaN || function ponyfill(value2) {
  return typeof value2 === "number" && value2 !== value2;
};
function isEqual$3(first, second) {
  if (first === second) {
    return true;
  }
  if (safeIsNaN(first) && safeIsNaN(second)) {
    return true;
  }
  return false;
}
function areInputsEqual(newInputs, lastInputs) {
  if (newInputs.length !== lastInputs.length) {
    return false;
  }
  for (var i2 = 0; i2 < newInputs.length; i2++) {
    if (!isEqual$3(newInputs[i2], lastInputs[i2])) {
      return false;
    }
  }
  return true;
}
function memoizeOne(resultFn, isEqual2) {
  if (isEqual2 === void 0) {
    isEqual2 = areInputsEqual;
  }
  var cache2 = null;
  function memoized() {
    var newArgs = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      newArgs[_i] = arguments[_i];
    }
    if (cache2 && cache2.lastThis === this && isEqual2(newArgs, cache2.lastArgs)) {
      return cache2.lastResult;
    }
    var lastResult = resultFn.apply(this, newArgs);
    cache2 = {
      lastResult,
      lastArgs: newArgs,
      lastThis: this
    };
    return lastResult;
  }
  memoized.clear = function clear3() {
    cache2 = null;
  };
  return memoized;
}
var enUS$1 = {
  items_per_page: "/ page",
  jump_to: "Go to",
  jump_to_confirm: "confirm",
  page: "Page",
  prev_page: "Previous Page",
  next_page: "Next Page",
  prev_5: "Previous 5 Pages",
  next_5: "Next 5 Pages",
  prev_3: "Previous 3 Pages",
  next_3: "Next 3 Pages",
  page_size: "Page Size"
};
var locale$2 = {
  locale: "en_US",
  today: "Today",
  now: "Now",
  backToToday: "Back to today",
  ok: "OK",
  clear: "Clear",
  month: "Month",
  year: "Year",
  timeSelect: "select time",
  dateSelect: "select date",
  weekSelect: "Choose a week",
  monthSelect: "Choose a month",
  yearSelect: "Choose a year",
  decadeSelect: "Choose a decade",
  yearFormat: "YYYY",
  dateFormat: "M/D/YYYY",
  dayFormat: "D",
  dateTimeFormat: "M/D/YYYY HH:mm:ss",
  monthBeforeYear: true,
  previousMonth: "Previous month (PageUp)",
  nextMonth: "Next month (PageDown)",
  previousYear: "Last year (Control + left)",
  nextYear: "Next year (Control + right)",
  previousDecade: "Last decade",
  nextDecade: "Next decade",
  previousCentury: "Last century",
  nextCentury: "Next century"
};
var locale$1 = {
  placeholder: "Select time",
  rangePlaceholder: ["Start time", "End time"]
};
var TimePicker = locale$1;
var locale = {
  lang: _extends$2({
    placeholder: "Select date",
    yearPlaceholder: "Select year",
    quarterPlaceholder: "Select quarter",
    monthPlaceholder: "Select month",
    weekPlaceholder: "Select week",
    rangePlaceholder: ["Start date", "End date"],
    rangeYearPlaceholder: ["Start year", "End year"],
    rangeQuarterPlaceholder: ["Start quarter", "End quarter"],
    rangeMonthPlaceholder: ["Start month", "End month"],
    rangeWeekPlaceholder: ["Start week", "End week"]
  }, locale$2),
  timePickerLocale: _extends$2({}, TimePicker)
};
var enUS = locale;
var typeTemplate = "${label} is not a valid ${type}";
var localeValues = {
  locale: "en",
  Pagination: enUS$1,
  DatePicker: enUS,
  TimePicker,
  Calendar: enUS,
  global: {
    placeholder: "Please select"
  },
  Table: {
    filterTitle: "Filter menu",
    filterConfirm: "OK",
    filterReset: "Reset",
    filterEmptyText: "No filters",
    filterCheckall: "Select all items",
    filterSearchPlaceholder: "Search in filters",
    emptyText: "No data",
    selectAll: "Select current page",
    selectInvert: "Invert current page",
    selectNone: "Clear all data",
    selectionAll: "Select all data",
    sortTitle: "Sort",
    expand: "Expand row",
    collapse: "Collapse row",
    triggerDesc: "Click to sort descending",
    triggerAsc: "Click to sort ascending",
    cancelSort: "Click to cancel sorting"
  },
  Modal: {
    okText: "OK",
    cancelText: "Cancel",
    justOkText: "OK"
  },
  Popconfirm: {
    okText: "OK",
    cancelText: "Cancel"
  },
  Transfer: {
    titles: ["", ""],
    searchPlaceholder: "Search here",
    itemUnit: "item",
    itemsUnit: "items",
    remove: "Remove",
    selectCurrent: "Select current page",
    removeCurrent: "Remove current page",
    selectAll: "Select all data",
    removeAll: "Remove all data",
    selectInvert: "Invert current page"
  },
  Upload: {
    uploading: "Uploading...",
    removeFile: "Remove file",
    uploadError: "Upload error",
    previewFile: "Preview file",
    downloadFile: "Download file"
  },
  Empty: {
    description: "No Data"
  },
  Icon: {
    icon: "icon"
  },
  Text: {
    edit: "Edit",
    copy: "Copy",
    copied: "Copied",
    expand: "Expand"
  },
  PageHeader: {
    back: "Back"
  },
  Form: {
    optional: "(optional)",
    defaultValidateMessages: {
      "default": "Field validation error for ${label}",
      required: "Please enter ${label}",
      "enum": "${label} must be one of [${enum}]",
      whitespace: "${label} cannot be a blank character",
      date: {
        format: "${label} date format is invalid",
        parse: "${label} cannot be converted to a date",
        invalid: "${label} is an invalid date"
      },
      types: {
        string: typeTemplate,
        method: typeTemplate,
        array: typeTemplate,
        object: typeTemplate,
        number: typeTemplate,
        date: typeTemplate,
        "boolean": typeTemplate,
        integer: typeTemplate,
        "float": typeTemplate,
        regexp: typeTemplate,
        email: typeTemplate,
        url: typeTemplate,
        hex: typeTemplate
      },
      string: {
        len: "${label} must be ${len} characters",
        min: "${label} must be at least ${min} characters",
        max: "${label} must be up to ${max} characters",
        range: "${label} must be between ${min}-${max} characters"
      },
      number: {
        len: "${label} must be equal to ${len}",
        min: "${label} must be minimum ${min}",
        max: "${label} must be maximum ${max}",
        range: "${label} must be between ${min}-${max}"
      },
      array: {
        len: "Must be ${len} ${label}",
        min: "At least ${min} ${label}",
        max: "At most ${max} ${label}",
        range: "The amount of ${label} must be between ${min}-${max}"
      },
      pattern: {
        mismatch: "${label} does not match the pattern ${pattern}"
      }
    }
  },
  Image: {
    preview: "Preview"
  }
};
var defaultLocale = localeValues;
var runtimeLocale = _extends$2({}, defaultLocale.Modal);
function changeConfirmLocale(newLocale) {
  if (newLocale) {
    runtimeLocale = _extends$2(_extends$2({}, runtimeLocale), newLocale);
  } else {
    runtimeLocale = _extends$2({}, defaultLocale.Modal);
  }
}
var LocaleContext = /* @__PURE__ */ react.exports.createContext(void 0);
var LocaleContext$1 = LocaleContext;
var ANT_MARK = "internalMark";
var LocaleProvider = /* @__PURE__ */ function(_React$Component) {
  _inherits$1(LocaleProvider2, _React$Component);
  var _super = _createSuper$1(LocaleProvider2);
  function LocaleProvider2(props) {
    var _this;
    _classCallCheck$2(this, LocaleProvider2);
    _this = _super.call(this, props);
    _this.getMemoizedContextValue = memoizeOne(function(localeValue) {
      return _extends$2(_extends$2({}, localeValue), {
        exist: true
      });
    });
    changeConfirmLocale(props.locale && props.locale.Modal);
    return _this;
  }
  _createClass$2(LocaleProvider2, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      changeConfirmLocale(this.props.locale && this.props.locale.Modal);
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      var locale2 = this.props.locale;
      if (prevProps.locale !== locale2) {
        changeConfirmLocale(locale2 && locale2.Modal);
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      changeConfirmLocale();
    }
  }, {
    key: "render",
    value: function render2() {
      var _this$props = this.props, locale2 = _this$props.locale, children = _this$props.children;
      var contextValue = this.getMemoizedContextValue(locale2);
      return /* @__PURE__ */ react.exports.createElement(LocaleContext$1.Provider, {
        value: contextValue
      }, children);
    }
  }]);
  return LocaleProvider2;
}(react.exports.Component);
LocaleProvider.defaultProps = {
  locale: {}
};
var LocaleReceiver = /* @__PURE__ */ function(_React$Component) {
  _inherits$1(LocaleReceiver2, _React$Component);
  var _super = _createSuper$1(LocaleReceiver2);
  function LocaleReceiver2() {
    _classCallCheck$2(this, LocaleReceiver2);
    return _super.apply(this, arguments);
  }
  _createClass$2(LocaleReceiver2, [{
    key: "getLocale",
    value: function getLocale2() {
      var _this$props = this.props, componentName = _this$props.componentName, defaultLocale$1 = _this$props.defaultLocale;
      var locale2 = defaultLocale$1 || defaultLocale[componentName !== null && componentName !== void 0 ? componentName : "global"];
      var antLocale = this.context;
      var localeFromContext = componentName && antLocale ? antLocale[componentName] : {};
      return _extends$2(_extends$2({}, locale2 instanceof Function ? locale2() : locale2), localeFromContext || {});
    }
  }, {
    key: "getLocaleCode",
    value: function getLocaleCode() {
      var antLocale = this.context;
      var localeCode = antLocale && antLocale.locale;
      if (antLocale && antLocale.exist && !localeCode) {
        return defaultLocale.locale;
      }
      return localeCode;
    }
  }, {
    key: "render",
    value: function render2() {
      return this.props.children(this.getLocale(), this.getLocaleCode(), this.context);
    }
  }]);
  return LocaleReceiver2;
}(react.exports.Component);
LocaleReceiver.defaultProps = {
  componentName: "global"
};
LocaleReceiver.contextType = LocaleContext$1;
var CheckCircleFilled$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm193.5 301.7l-210.6 292a31.8 31.8 0 01-51.7 0L318.5 484.9c-3.8-5.3 0-12.7 6.5-12.7h46.9c10.2 0 19.9 4.9 25.9 13.3l71.2 98.8 157.2-218c6-8.3 15.6-13.3 25.9-13.3H699c6.5 0 10.3 7.4 6.5 12.7z" } }] }, "name": "check-circle", "theme": "filled" };
var CheckCircleFilledSvg = CheckCircleFilled$2;
function bound01(n2, max2) {
  if (isOnePointZero(n2)) {
    n2 = "100%";
  }
  var isPercent = isPercentage(n2);
  n2 = max2 === 360 ? n2 : Math.min(max2, Math.max(0, parseFloat(n2)));
  if (isPercent) {
    n2 = parseInt(String(n2 * max2), 10) / 100;
  }
  if (Math.abs(n2 - max2) < 1e-6) {
    return 1;
  }
  if (max2 === 360) {
    n2 = (n2 < 0 ? n2 % max2 + max2 : n2 % max2) / parseFloat(String(max2));
  } else {
    n2 = n2 % max2 / parseFloat(String(max2));
  }
  return n2;
}
function clamp01(val) {
  return Math.min(1, Math.max(0, val));
}
function isOnePointZero(n2) {
  return typeof n2 === "string" && n2.indexOf(".") !== -1 && parseFloat(n2) === 1;
}
function isPercentage(n2) {
  return typeof n2 === "string" && n2.indexOf("%") !== -1;
}
function boundAlpha(a2) {
  a2 = parseFloat(a2);
  if (isNaN(a2) || a2 < 0 || a2 > 1) {
    a2 = 1;
  }
  return a2;
}
function convertToPercentage(n2) {
  if (n2 <= 1) {
    return "".concat(Number(n2) * 100, "%");
  }
  return n2;
}
function pad2(c2) {
  return c2.length === 1 ? "0" + c2 : String(c2);
}
function rgbToRgb(r2, g2, b10) {
  return {
    r: bound01(r2, 255) * 255,
    g: bound01(g2, 255) * 255,
    b: bound01(b10, 255) * 255
  };
}
function rgbToHsl(r2, g2, b10) {
  r2 = bound01(r2, 255);
  g2 = bound01(g2, 255);
  b10 = bound01(b10, 255);
  var max2 = Math.max(r2, g2, b10);
  var min2 = Math.min(r2, g2, b10);
  var h2 = 0;
  var s2 = 0;
  var l2 = (max2 + min2) / 2;
  if (max2 === min2) {
    s2 = 0;
    h2 = 0;
  } else {
    var d2 = max2 - min2;
    s2 = l2 > 0.5 ? d2 / (2 - max2 - min2) : d2 / (max2 + min2);
    switch (max2) {
      case r2:
        h2 = (g2 - b10) / d2 + (g2 < b10 ? 6 : 0);
        break;
      case g2:
        h2 = (b10 - r2) / d2 + 2;
        break;
      case b10:
        h2 = (r2 - g2) / d2 + 4;
        break;
    }
    h2 /= 6;
  }
  return { h: h2, s: s2, l: l2 };
}
function hue2rgb(p2, q2, t2) {
  if (t2 < 0) {
    t2 += 1;
  }
  if (t2 > 1) {
    t2 -= 1;
  }
  if (t2 < 1 / 6) {
    return p2 + (q2 - p2) * (6 * t2);
  }
  if (t2 < 1 / 2) {
    return q2;
  }
  if (t2 < 2 / 3) {
    return p2 + (q2 - p2) * (2 / 3 - t2) * 6;
  }
  return p2;
}
function hslToRgb(h2, s2, l2) {
  var r2;
  var g2;
  var b10;
  h2 = bound01(h2, 360);
  s2 = bound01(s2, 100);
  l2 = bound01(l2, 100);
  if (s2 === 0) {
    g2 = l2;
    b10 = l2;
    r2 = l2;
  } else {
    var q2 = l2 < 0.5 ? l2 * (1 + s2) : l2 + s2 - l2 * s2;
    var p2 = 2 * l2 - q2;
    r2 = hue2rgb(p2, q2, h2 + 1 / 3);
    g2 = hue2rgb(p2, q2, h2);
    b10 = hue2rgb(p2, q2, h2 - 1 / 3);
  }
  return { r: r2 * 255, g: g2 * 255, b: b10 * 255 };
}
function rgbToHsv(r2, g2, b10) {
  r2 = bound01(r2, 255);
  g2 = bound01(g2, 255);
  b10 = bound01(b10, 255);
  var max2 = Math.max(r2, g2, b10);
  var min2 = Math.min(r2, g2, b10);
  var h2 = 0;
  var v2 = max2;
  var d2 = max2 - min2;
  var s2 = max2 === 0 ? 0 : d2 / max2;
  if (max2 === min2) {
    h2 = 0;
  } else {
    switch (max2) {
      case r2:
        h2 = (g2 - b10) / d2 + (g2 < b10 ? 6 : 0);
        break;
      case g2:
        h2 = (b10 - r2) / d2 + 2;
        break;
      case b10:
        h2 = (r2 - g2) / d2 + 4;
        break;
    }
    h2 /= 6;
  }
  return { h: h2, s: s2, v: v2 };
}
function hsvToRgb(h2, s2, v2) {
  h2 = bound01(h2, 360) * 6;
  s2 = bound01(s2, 100);
  v2 = bound01(v2, 100);
  var i2 = Math.floor(h2);
  var f2 = h2 - i2;
  var p2 = v2 * (1 - s2);
  var q2 = v2 * (1 - f2 * s2);
  var t2 = v2 * (1 - (1 - f2) * s2);
  var mod2 = i2 % 6;
  var r2 = [v2, q2, p2, p2, t2, v2][mod2];
  var g2 = [t2, v2, v2, q2, p2, p2][mod2];
  var b10 = [p2, p2, t2, v2, v2, q2][mod2];
  return { r: r2 * 255, g: g2 * 255, b: b10 * 255 };
}
function rgbToHex(r2, g2, b10, allow3Char) {
  var hex3 = [
    pad2(Math.round(r2).toString(16)),
    pad2(Math.round(g2).toString(16)),
    pad2(Math.round(b10).toString(16))
  ];
  if (allow3Char && hex3[0].startsWith(hex3[0].charAt(1)) && hex3[1].startsWith(hex3[1].charAt(1)) && hex3[2].startsWith(hex3[2].charAt(1))) {
    return hex3[0].charAt(0) + hex3[1].charAt(0) + hex3[2].charAt(0);
  }
  return hex3.join("");
}
function rgbaToHex(r2, g2, b10, a2, allow4Char) {
  var hex3 = [
    pad2(Math.round(r2).toString(16)),
    pad2(Math.round(g2).toString(16)),
    pad2(Math.round(b10).toString(16)),
    pad2(convertDecimalToHex(a2))
  ];
  if (allow4Char && hex3[0].startsWith(hex3[0].charAt(1)) && hex3[1].startsWith(hex3[1].charAt(1)) && hex3[2].startsWith(hex3[2].charAt(1)) && hex3[3].startsWith(hex3[3].charAt(1))) {
    return hex3[0].charAt(0) + hex3[1].charAt(0) + hex3[2].charAt(0) + hex3[3].charAt(0);
  }
  return hex3.join("");
}
function convertDecimalToHex(d2) {
  return Math.round(parseFloat(d2) * 255).toString(16);
}
function convertHexToDecimal(h2) {
  return parseIntFromHex(h2) / 255;
}
function parseIntFromHex(val) {
  return parseInt(val, 16);
}
function numberInputToObject(color2) {
  return {
    r: color2 >> 16,
    g: (color2 & 65280) >> 8,
    b: color2 & 255
  };
}
var names = {
  aliceblue: "#f0f8ff",
  antiquewhite: "#faebd7",
  aqua: "#00ffff",
  aquamarine: "#7fffd4",
  azure: "#f0ffff",
  beige: "#f5f5dc",
  bisque: "#ffe4c4",
  black: "#000000",
  blanchedalmond: "#ffebcd",
  blue: "#0000ff",
  blueviolet: "#8a2be2",
  brown: "#a52a2a",
  burlywood: "#deb887",
  cadetblue: "#5f9ea0",
  chartreuse: "#7fff00",
  chocolate: "#d2691e",
  coral: "#ff7f50",
  cornflowerblue: "#6495ed",
  cornsilk: "#fff8dc",
  crimson: "#dc143c",
  cyan: "#00ffff",
  darkblue: "#00008b",
  darkcyan: "#008b8b",
  darkgoldenrod: "#b8860b",
  darkgray: "#a9a9a9",
  darkgreen: "#006400",
  darkgrey: "#a9a9a9",
  darkkhaki: "#bdb76b",
  darkmagenta: "#8b008b",
  darkolivegreen: "#556b2f",
  darkorange: "#ff8c00",
  darkorchid: "#9932cc",
  darkred: "#8b0000",
  darksalmon: "#e9967a",
  darkseagreen: "#8fbc8f",
  darkslateblue: "#483d8b",
  darkslategray: "#2f4f4f",
  darkslategrey: "#2f4f4f",
  darkturquoise: "#00ced1",
  darkviolet: "#9400d3",
  deeppink: "#ff1493",
  deepskyblue: "#00bfff",
  dimgray: "#696969",
  dimgrey: "#696969",
  dodgerblue: "#1e90ff",
  firebrick: "#b22222",
  floralwhite: "#fffaf0",
  forestgreen: "#228b22",
  fuchsia: "#ff00ff",
  gainsboro: "#dcdcdc",
  ghostwhite: "#f8f8ff",
  goldenrod: "#daa520",
  gold: "#ffd700",
  gray: "#808080",
  green: "#008000",
  greenyellow: "#adff2f",
  grey: "#808080",
  honeydew: "#f0fff0",
  hotpink: "#ff69b4",
  indianred: "#cd5c5c",
  indigo: "#4b0082",
  ivory: "#fffff0",
  khaki: "#f0e68c",
  lavenderblush: "#fff0f5",
  lavender: "#e6e6fa",
  lawngreen: "#7cfc00",
  lemonchiffon: "#fffacd",
  lightblue: "#add8e6",
  lightcoral: "#f08080",
  lightcyan: "#e0ffff",
  lightgoldenrodyellow: "#fafad2",
  lightgray: "#d3d3d3",
  lightgreen: "#90ee90",
  lightgrey: "#d3d3d3",
  lightpink: "#ffb6c1",
  lightsalmon: "#ffa07a",
  lightseagreen: "#20b2aa",
  lightskyblue: "#87cefa",
  lightslategray: "#778899",
  lightslategrey: "#778899",
  lightsteelblue: "#b0c4de",
  lightyellow: "#ffffe0",
  lime: "#00ff00",
  limegreen: "#32cd32",
  linen: "#faf0e6",
  magenta: "#ff00ff",
  maroon: "#800000",
  mediumaquamarine: "#66cdaa",
  mediumblue: "#0000cd",
  mediumorchid: "#ba55d3",
  mediumpurple: "#9370db",
  mediumseagreen: "#3cb371",
  mediumslateblue: "#7b68ee",
  mediumspringgreen: "#00fa9a",
  mediumturquoise: "#48d1cc",
  mediumvioletred: "#c71585",
  midnightblue: "#191970",
  mintcream: "#f5fffa",
  mistyrose: "#ffe4e1",
  moccasin: "#ffe4b5",
  navajowhite: "#ffdead",
  navy: "#000080",
  oldlace: "#fdf5e6",
  olive: "#808000",
  olivedrab: "#6b8e23",
  orange: "#ffa500",
  orangered: "#ff4500",
  orchid: "#da70d6",
  palegoldenrod: "#eee8aa",
  palegreen: "#98fb98",
  paleturquoise: "#afeeee",
  palevioletred: "#db7093",
  papayawhip: "#ffefd5",
  peachpuff: "#ffdab9",
  peru: "#cd853f",
  pink: "#ffc0cb",
  plum: "#dda0dd",
  powderblue: "#b0e0e6",
  purple: "#800080",
  rebeccapurple: "#663399",
  red: "#ff0000",
  rosybrown: "#bc8f8f",
  royalblue: "#4169e1",
  saddlebrown: "#8b4513",
  salmon: "#fa8072",
  sandybrown: "#f4a460",
  seagreen: "#2e8b57",
  seashell: "#fff5ee",
  sienna: "#a0522d",
  silver: "#c0c0c0",
  skyblue: "#87ceeb",
  slateblue: "#6a5acd",
  slategray: "#708090",
  slategrey: "#708090",
  snow: "#fffafa",
  springgreen: "#00ff7f",
  steelblue: "#4682b4",
  tan: "#d2b48c",
  teal: "#008080",
  thistle: "#d8bfd8",
  tomato: "#ff6347",
  turquoise: "#40e0d0",
  violet: "#ee82ee",
  wheat: "#f5deb3",
  white: "#ffffff",
  whitesmoke: "#f5f5f5",
  yellow: "#ffff00",
  yellowgreen: "#9acd32"
};
function inputToRGB(color2) {
  var rgb2 = { r: 0, g: 0, b: 0 };
  var a2 = 1;
  var s2 = null;
  var v2 = null;
  var l2 = null;
  var ok2 = false;
  var format2 = false;
  if (typeof color2 === "string") {
    color2 = stringInputToObject(color2);
  }
  if (typeof color2 === "object") {
    if (isValidCSSUnit(color2.r) && isValidCSSUnit(color2.g) && isValidCSSUnit(color2.b)) {
      rgb2 = rgbToRgb(color2.r, color2.g, color2.b);
      ok2 = true;
      format2 = String(color2.r).substr(-1) === "%" ? "prgb" : "rgb";
    } else if (isValidCSSUnit(color2.h) && isValidCSSUnit(color2.s) && isValidCSSUnit(color2.v)) {
      s2 = convertToPercentage(color2.s);
      v2 = convertToPercentage(color2.v);
      rgb2 = hsvToRgb(color2.h, s2, v2);
      ok2 = true;
      format2 = "hsv";
    } else if (isValidCSSUnit(color2.h) && isValidCSSUnit(color2.s) && isValidCSSUnit(color2.l)) {
      s2 = convertToPercentage(color2.s);
      l2 = convertToPercentage(color2.l);
      rgb2 = hslToRgb(color2.h, s2, l2);
      ok2 = true;
      format2 = "hsl";
    }
    if (Object.prototype.hasOwnProperty.call(color2, "a")) {
      a2 = color2.a;
    }
  }
  a2 = boundAlpha(a2);
  return {
    ok: ok2,
    format: color2.format || format2,
    r: Math.min(255, Math.max(rgb2.r, 0)),
    g: Math.min(255, Math.max(rgb2.g, 0)),
    b: Math.min(255, Math.max(rgb2.b, 0)),
    a: a2
  };
}
var CSS_INTEGER = "[-\\+]?\\d+%?";
var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";
var CSS_UNIT = "(?:".concat(CSS_NUMBER, ")|(?:").concat(CSS_INTEGER, ")");
var PERMISSIVE_MATCH3 = "[\\s|\\(]+(".concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")\\s*\\)?");
var PERMISSIVE_MATCH4 = "[\\s|\\(]+(".concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")\\s*\\)?");
var matchers = {
  CSS_UNIT: new RegExp(CSS_UNIT),
  rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
  rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
  hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
  hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
  hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
  hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
  hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
  hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
  hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
  hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
};
function stringInputToObject(color2) {
  color2 = color2.trim().toLowerCase();
  if (color2.length === 0) {
    return false;
  }
  var named2 = false;
  if (names[color2]) {
    color2 = names[color2];
    named2 = true;
  } else if (color2 === "transparent") {
    return { r: 0, g: 0, b: 0, a: 0, format: "name" };
  }
  var match2 = matchers.rgb.exec(color2);
  if (match2) {
    return { r: match2[1], g: match2[2], b: match2[3] };
  }
  match2 = matchers.rgba.exec(color2);
  if (match2) {
    return { r: match2[1], g: match2[2], b: match2[3], a: match2[4] };
  }
  match2 = matchers.hsl.exec(color2);
  if (match2) {
    return { h: match2[1], s: match2[2], l: match2[3] };
  }
  match2 = matchers.hsla.exec(color2);
  if (match2) {
    return { h: match2[1], s: match2[2], l: match2[3], a: match2[4] };
  }
  match2 = matchers.hsv.exec(color2);
  if (match2) {
    return { h: match2[1], s: match2[2], v: match2[3] };
  }
  match2 = matchers.hsva.exec(color2);
  if (match2) {
    return { h: match2[1], s: match2[2], v: match2[3], a: match2[4] };
  }
  match2 = matchers.hex8.exec(color2);
  if (match2) {
    return {
      r: parseIntFromHex(match2[1]),
      g: parseIntFromHex(match2[2]),
      b: parseIntFromHex(match2[3]),
      a: convertHexToDecimal(match2[4]),
      format: named2 ? "name" : "hex8"
    };
  }
  match2 = matchers.hex6.exec(color2);
  if (match2) {
    return {
      r: parseIntFromHex(match2[1]),
      g: parseIntFromHex(match2[2]),
      b: parseIntFromHex(match2[3]),
      format: named2 ? "name" : "hex"
    };
  }
  match2 = matchers.hex4.exec(color2);
  if (match2) {
    return {
      r: parseIntFromHex(match2[1] + match2[1]),
      g: parseIntFromHex(match2[2] + match2[2]),
      b: parseIntFromHex(match2[3] + match2[3]),
      a: convertHexToDecimal(match2[4] + match2[4]),
      format: named2 ? "name" : "hex8"
    };
  }
  match2 = matchers.hex3.exec(color2);
  if (match2) {
    return {
      r: parseIntFromHex(match2[1] + match2[1]),
      g: parseIntFromHex(match2[2] + match2[2]),
      b: parseIntFromHex(match2[3] + match2[3]),
      format: named2 ? "name" : "hex"
    };
  }
  return false;
}
function isValidCSSUnit(color2) {
  return Boolean(matchers.CSS_UNIT.exec(String(color2)));
}
var TinyColor = function() {
  function TinyColor2(color2, opts) {
    if (color2 === void 0) {
      color2 = "";
    }
    if (opts === void 0) {
      opts = {};
    }
    var _a2;
    if (color2 instanceof TinyColor2) {
      return color2;
    }
    if (typeof color2 === "number") {
      color2 = numberInputToObject(color2);
    }
    this.originalInput = color2;
    var rgb2 = inputToRGB(color2);
    this.originalInput = color2;
    this.r = rgb2.r;
    this.g = rgb2.g;
    this.b = rgb2.b;
    this.a = rgb2.a;
    this.roundA = Math.round(100 * this.a) / 100;
    this.format = (_a2 = opts.format) !== null && _a2 !== void 0 ? _a2 : rgb2.format;
    this.gradientType = opts.gradientType;
    if (this.r < 1) {
      this.r = Math.round(this.r);
    }
    if (this.g < 1) {
      this.g = Math.round(this.g);
    }
    if (this.b < 1) {
      this.b = Math.round(this.b);
    }
    this.isValid = rgb2.ok;
  }
  TinyColor2.prototype.isDark = function() {
    return this.getBrightness() < 128;
  };
  TinyColor2.prototype.isLight = function() {
    return !this.isDark();
  };
  TinyColor2.prototype.getBrightness = function() {
    var rgb2 = this.toRgb();
    return (rgb2.r * 299 + rgb2.g * 587 + rgb2.b * 114) / 1e3;
  };
  TinyColor2.prototype.getLuminance = function() {
    var rgb2 = this.toRgb();
    var R2;
    var G2;
    var B2;
    var RsRGB = rgb2.r / 255;
    var GsRGB = rgb2.g / 255;
    var BsRGB = rgb2.b / 255;
    if (RsRGB <= 0.03928) {
      R2 = RsRGB / 12.92;
    } else {
      R2 = Math.pow((RsRGB + 0.055) / 1.055, 2.4);
    }
    if (GsRGB <= 0.03928) {
      G2 = GsRGB / 12.92;
    } else {
      G2 = Math.pow((GsRGB + 0.055) / 1.055, 2.4);
    }
    if (BsRGB <= 0.03928) {
      B2 = BsRGB / 12.92;
    } else {
      B2 = Math.pow((BsRGB + 0.055) / 1.055, 2.4);
    }
    return 0.2126 * R2 + 0.7152 * G2 + 0.0722 * B2;
  };
  TinyColor2.prototype.getAlpha = function() {
    return this.a;
  };
  TinyColor2.prototype.setAlpha = function(alpha) {
    this.a = boundAlpha(alpha);
    this.roundA = Math.round(100 * this.a) / 100;
    return this;
  };
  TinyColor2.prototype.toHsv = function() {
    var hsv = rgbToHsv(this.r, this.g, this.b);
    return { h: hsv.h * 360, s: hsv.s, v: hsv.v, a: this.a };
  };
  TinyColor2.prototype.toHsvString = function() {
    var hsv = rgbToHsv(this.r, this.g, this.b);
    var h2 = Math.round(hsv.h * 360);
    var s2 = Math.round(hsv.s * 100);
    var v2 = Math.round(hsv.v * 100);
    return this.a === 1 ? "hsv(".concat(h2, ", ").concat(s2, "%, ").concat(v2, "%)") : "hsva(".concat(h2, ", ").concat(s2, "%, ").concat(v2, "%, ").concat(this.roundA, ")");
  };
  TinyColor2.prototype.toHsl = function() {
    var hsl2 = rgbToHsl(this.r, this.g, this.b);
    return { h: hsl2.h * 360, s: hsl2.s, l: hsl2.l, a: this.a };
  };
  TinyColor2.prototype.toHslString = function() {
    var hsl2 = rgbToHsl(this.r, this.g, this.b);
    var h2 = Math.round(hsl2.h * 360);
    var s2 = Math.round(hsl2.s * 100);
    var l2 = Math.round(hsl2.l * 100);
    return this.a === 1 ? "hsl(".concat(h2, ", ").concat(s2, "%, ").concat(l2, "%)") : "hsla(".concat(h2, ", ").concat(s2, "%, ").concat(l2, "%, ").concat(this.roundA, ")");
  };
  TinyColor2.prototype.toHex = function(allow3Char) {
    if (allow3Char === void 0) {
      allow3Char = false;
    }
    return rgbToHex(this.r, this.g, this.b, allow3Char);
  };
  TinyColor2.prototype.toHexString = function(allow3Char) {
    if (allow3Char === void 0) {
      allow3Char = false;
    }
    return "#" + this.toHex(allow3Char);
  };
  TinyColor2.prototype.toHex8 = function(allow4Char) {
    if (allow4Char === void 0) {
      allow4Char = false;
    }
    return rgbaToHex(this.r, this.g, this.b, this.a, allow4Char);
  };
  TinyColor2.prototype.toHex8String = function(allow4Char) {
    if (allow4Char === void 0) {
      allow4Char = false;
    }
    return "#" + this.toHex8(allow4Char);
  };
  TinyColor2.prototype.toRgb = function() {
    return {
      r: Math.round(this.r),
      g: Math.round(this.g),
      b: Math.round(this.b),
      a: this.a
    };
  };
  TinyColor2.prototype.toRgbString = function() {
    var r2 = Math.round(this.r);
    var g2 = Math.round(this.g);
    var b10 = Math.round(this.b);
    return this.a === 1 ? "rgb(".concat(r2, ", ").concat(g2, ", ").concat(b10, ")") : "rgba(".concat(r2, ", ").concat(g2, ", ").concat(b10, ", ").concat(this.roundA, ")");
  };
  TinyColor2.prototype.toPercentageRgb = function() {
    var fmt = function(x2) {
      return "".concat(Math.round(bound01(x2, 255) * 100), "%");
    };
    return {
      r: fmt(this.r),
      g: fmt(this.g),
      b: fmt(this.b),
      a: this.a
    };
  };
  TinyColor2.prototype.toPercentageRgbString = function() {
    var rnd = function(x2) {
      return Math.round(bound01(x2, 255) * 100);
    };
    return this.a === 1 ? "rgb(".concat(rnd(this.r), "%, ").concat(rnd(this.g), "%, ").concat(rnd(this.b), "%)") : "rgba(".concat(rnd(this.r), "%, ").concat(rnd(this.g), "%, ").concat(rnd(this.b), "%, ").concat(this.roundA, ")");
  };
  TinyColor2.prototype.toName = function() {
    if (this.a === 0) {
      return "transparent";
    }
    if (this.a < 1) {
      return false;
    }
    var hex3 = "#" + rgbToHex(this.r, this.g, this.b, false);
    for (var _i = 0, _a2 = Object.entries(names); _i < _a2.length; _i++) {
      var _b = _a2[_i], key2 = _b[0], value2 = _b[1];
      if (hex3 === value2) {
        return key2;
      }
    }
    return false;
  };
  TinyColor2.prototype.toString = function(format2) {
    var formatSet = Boolean(format2);
    format2 = format2 !== null && format2 !== void 0 ? format2 : this.format;
    var formattedString = false;
    var hasAlpha = this.a < 1 && this.a >= 0;
    var needsAlphaFormat = !formatSet && hasAlpha && (format2.startsWith("hex") || format2 === "name");
    if (needsAlphaFormat) {
      if (format2 === "name" && this.a === 0) {
        return this.toName();
      }
      return this.toRgbString();
    }
    if (format2 === "rgb") {
      formattedString = this.toRgbString();
    }
    if (format2 === "prgb") {
      formattedString = this.toPercentageRgbString();
    }
    if (format2 === "hex" || format2 === "hex6") {
      formattedString = this.toHexString();
    }
    if (format2 === "hex3") {
      formattedString = this.toHexString(true);
    }
    if (format2 === "hex4") {
      formattedString = this.toHex8String(true);
    }
    if (format2 === "hex8") {
      formattedString = this.toHex8String();
    }
    if (format2 === "name") {
      formattedString = this.toName();
    }
    if (format2 === "hsl") {
      formattedString = this.toHslString();
    }
    if (format2 === "hsv") {
      formattedString = this.toHsvString();
    }
    return formattedString || this.toHexString();
  };
  TinyColor2.prototype.toNumber = function() {
    return (Math.round(this.r) << 16) + (Math.round(this.g) << 8) + Math.round(this.b);
  };
  TinyColor2.prototype.clone = function() {
    return new TinyColor2(this.toString());
  };
  TinyColor2.prototype.lighten = function(amount) {
    if (amount === void 0) {
      amount = 10;
    }
    var hsl2 = this.toHsl();
    hsl2.l += amount / 100;
    hsl2.l = clamp01(hsl2.l);
    return new TinyColor2(hsl2);
  };
  TinyColor2.prototype.brighten = function(amount) {
    if (amount === void 0) {
      amount = 10;
    }
    var rgb2 = this.toRgb();
    rgb2.r = Math.max(0, Math.min(255, rgb2.r - Math.round(255 * -(amount / 100))));
    rgb2.g = Math.max(0, Math.min(255, rgb2.g - Math.round(255 * -(amount / 100))));
    rgb2.b = Math.max(0, Math.min(255, rgb2.b - Math.round(255 * -(amount / 100))));
    return new TinyColor2(rgb2);
  };
  TinyColor2.prototype.darken = function(amount) {
    if (amount === void 0) {
      amount = 10;
    }
    var hsl2 = this.toHsl();
    hsl2.l -= amount / 100;
    hsl2.l = clamp01(hsl2.l);
    return new TinyColor2(hsl2);
  };
  TinyColor2.prototype.tint = function(amount) {
    if (amount === void 0) {
      amount = 10;
    }
    return this.mix("white", amount);
  };
  TinyColor2.prototype.shade = function(amount) {
    if (amount === void 0) {
      amount = 10;
    }
    return this.mix("black", amount);
  };
  TinyColor2.prototype.desaturate = function(amount) {
    if (amount === void 0) {
      amount = 10;
    }
    var hsl2 = this.toHsl();
    hsl2.s -= amount / 100;
    hsl2.s = clamp01(hsl2.s);
    return new TinyColor2(hsl2);
  };
  TinyColor2.prototype.saturate = function(amount) {
    if (amount === void 0) {
      amount = 10;
    }
    var hsl2 = this.toHsl();
    hsl2.s += amount / 100;
    hsl2.s = clamp01(hsl2.s);
    return new TinyColor2(hsl2);
  };
  TinyColor2.prototype.greyscale = function() {
    return this.desaturate(100);
  };
  TinyColor2.prototype.spin = function(amount) {
    var hsl2 = this.toHsl();
    var hue = (hsl2.h + amount) % 360;
    hsl2.h = hue < 0 ? 360 + hue : hue;
    return new TinyColor2(hsl2);
  };
  TinyColor2.prototype.mix = function(color2, amount) {
    if (amount === void 0) {
      amount = 50;
    }
    var rgb1 = this.toRgb();
    var rgb2 = new TinyColor2(color2).toRgb();
    var p2 = amount / 100;
    var rgba2 = {
      r: (rgb2.r - rgb1.r) * p2 + rgb1.r,
      g: (rgb2.g - rgb1.g) * p2 + rgb1.g,
      b: (rgb2.b - rgb1.b) * p2 + rgb1.b,
      a: (rgb2.a - rgb1.a) * p2 + rgb1.a
    };
    return new TinyColor2(rgba2);
  };
  TinyColor2.prototype.analogous = function(results, slices) {
    if (results === void 0) {
      results = 6;
    }
    if (slices === void 0) {
      slices = 30;
    }
    var hsl2 = this.toHsl();
    var part = 360 / slices;
    var ret = [this];
    for (hsl2.h = (hsl2.h - (part * results >> 1) + 720) % 360; --results; ) {
      hsl2.h = (hsl2.h + part) % 360;
      ret.push(new TinyColor2(hsl2));
    }
    return ret;
  };
  TinyColor2.prototype.complement = function() {
    var hsl2 = this.toHsl();
    hsl2.h = (hsl2.h + 180) % 360;
    return new TinyColor2(hsl2);
  };
  TinyColor2.prototype.monochromatic = function(results) {
    if (results === void 0) {
      results = 6;
    }
    var hsv = this.toHsv();
    var h2 = hsv.h;
    var s2 = hsv.s;
    var v2 = hsv.v;
    var res = [];
    var modification = 1 / results;
    while (results--) {
      res.push(new TinyColor2({ h: h2, s: s2, v: v2 }));
      v2 = (v2 + modification) % 1;
    }
    return res;
  };
  TinyColor2.prototype.splitcomplement = function() {
    var hsl2 = this.toHsl();
    var h2 = hsl2.h;
    return [
      this,
      new TinyColor2({ h: (h2 + 72) % 360, s: hsl2.s, l: hsl2.l }),
      new TinyColor2({ h: (h2 + 216) % 360, s: hsl2.s, l: hsl2.l })
    ];
  };
  TinyColor2.prototype.onBackground = function(background) {
    var fg2 = this.toRgb();
    var bg2 = new TinyColor2(background).toRgb();
    return new TinyColor2({
      r: bg2.r + (fg2.r - bg2.r) * fg2.a,
      g: bg2.g + (fg2.g - bg2.g) * fg2.a,
      b: bg2.b + (fg2.b - bg2.b) * fg2.a
    });
  };
  TinyColor2.prototype.triad = function() {
    return this.polyad(3);
  };
  TinyColor2.prototype.tetrad = function() {
    return this.polyad(4);
  };
  TinyColor2.prototype.polyad = function(n2) {
    var hsl2 = this.toHsl();
    var h2 = hsl2.h;
    var result = [this];
    var increment = 360 / n2;
    for (var i2 = 1; i2 < n2; i2++) {
      result.push(new TinyColor2({ h: (h2 + i2 * increment) % 360, s: hsl2.s, l: hsl2.l }));
    }
    return result;
  };
  TinyColor2.prototype.equals = function(color2) {
    return this.toRgbString() === new TinyColor2(color2).toRgbString();
  };
  return TinyColor2;
}();
var hueStep = 2;
var saturationStep = 0.16;
var saturationStep2 = 0.05;
var brightnessStep1 = 0.05;
var brightnessStep2 = 0.15;
var lightColorCount = 5;
var darkColorCount = 4;
var darkColorMap = [{
  index: 7,
  opacity: 0.15
}, {
  index: 6,
  opacity: 0.25
}, {
  index: 5,
  opacity: 0.3
}, {
  index: 5,
  opacity: 0.45
}, {
  index: 5,
  opacity: 0.65
}, {
  index: 5,
  opacity: 0.85
}, {
  index: 4,
  opacity: 0.9
}, {
  index: 3,
  opacity: 0.95
}, {
  index: 2,
  opacity: 0.97
}, {
  index: 1,
  opacity: 0.98
}];
function toHsv(_ref) {
  var r2 = _ref.r, g2 = _ref.g, b10 = _ref.b;
  var hsv = rgbToHsv(r2, g2, b10);
  return {
    h: hsv.h * 360,
    s: hsv.s,
    v: hsv.v
  };
}
function toHex$1(_ref2) {
  var r2 = _ref2.r, g2 = _ref2.g, b10 = _ref2.b;
  return "#".concat(rgbToHex(r2, g2, b10, false));
}
function mix$2(rgb1, rgb2, amount) {
  var p2 = amount / 100;
  var rgb3 = {
    r: (rgb2.r - rgb1.r) * p2 + rgb1.r,
    g: (rgb2.g - rgb1.g) * p2 + rgb1.g,
    b: (rgb2.b - rgb1.b) * p2 + rgb1.b
  };
  return rgb3;
}
function getHue(hsv, i2, light) {
  var hue;
  if (Math.round(hsv.h) >= 60 && Math.round(hsv.h) <= 240) {
    hue = light ? Math.round(hsv.h) - hueStep * i2 : Math.round(hsv.h) + hueStep * i2;
  } else {
    hue = light ? Math.round(hsv.h) + hueStep * i2 : Math.round(hsv.h) - hueStep * i2;
  }
  if (hue < 0) {
    hue += 360;
  } else if (hue >= 360) {
    hue -= 360;
  }
  return hue;
}
function getSaturation(hsv, i2, light) {
  if (hsv.h === 0 && hsv.s === 0) {
    return hsv.s;
  }
  var saturation;
  if (light) {
    saturation = hsv.s - saturationStep * i2;
  } else if (i2 === darkColorCount) {
    saturation = hsv.s + saturationStep;
  } else {
    saturation = hsv.s + saturationStep2 * i2;
  }
  if (saturation > 1) {
    saturation = 1;
  }
  if (light && i2 === lightColorCount && saturation > 0.1) {
    saturation = 0.1;
  }
  if (saturation < 0.06) {
    saturation = 0.06;
  }
  return Number(saturation.toFixed(2));
}
function getValue$3(hsv, i2, light) {
  var value2;
  if (light) {
    value2 = hsv.v + brightnessStep1 * i2;
  } else {
    value2 = hsv.v - brightnessStep2 * i2;
  }
  if (value2 > 1) {
    value2 = 1;
  }
  return Number(value2.toFixed(2));
}
function generate$1(color2) {
  var opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var patterns = [];
  var pColor = inputToRGB(color2);
  for (var i2 = lightColorCount; i2 > 0; i2 -= 1) {
    var hsv = toHsv(pColor);
    var colorString = toHex$1(inputToRGB({
      h: getHue(hsv, i2, true),
      s: getSaturation(hsv, i2, true),
      v: getValue$3(hsv, i2, true)
    }));
    patterns.push(colorString);
  }
  patterns.push(toHex$1(pColor));
  for (var _i = 1; _i <= darkColorCount; _i += 1) {
    var _hsv = toHsv(pColor);
    var _colorString = toHex$1(inputToRGB({
      h: getHue(_hsv, _i),
      s: getSaturation(_hsv, _i),
      v: getValue$3(_hsv, _i)
    }));
    patterns.push(_colorString);
  }
  if (opts.theme === "dark") {
    return darkColorMap.map(function(_ref3) {
      var index2 = _ref3.index, opacity = _ref3.opacity;
      var darkColorString = toHex$1(mix$2(inputToRGB(opts.backgroundColor || "#141414"), inputToRGB(patterns[index2]), opacity * 100));
      return darkColorString;
    });
  }
  return patterns;
}
var presetPrimaryColors = {
  red: "#F5222D",
  volcano: "#FA541C",
  orange: "#FA8C16",
  gold: "#FAAD14",
  yellow: "#FADB14",
  lime: "#A0D911",
  green: "#52C41A",
  cyan: "#13C2C2",
  blue: "#1890FF",
  geekblue: "#2F54EB",
  purple: "#722ED1",
  magenta: "#EB2F96",
  grey: "#666666"
};
var presetPalettes = {};
var presetDarkPalettes = {};
Object.keys(presetPrimaryColors).forEach(function(key2) {
  presetPalettes[key2] = generate$1(presetPrimaryColors[key2]);
  presetPalettes[key2].primary = presetPalettes[key2][5];
  presetDarkPalettes[key2] = generate$1(presetPrimaryColors[key2], {
    theme: "dark",
    backgroundColor: "#141414"
  });
  presetDarkPalettes[key2].primary = presetDarkPalettes[key2][5];
});
function canUseDom() {
  return !!(typeof window !== "undefined" && window.document && window.document.createElement);
}
function contains$1(root2, n2) {
  if (!root2) {
    return false;
  }
  if (root2.contains) {
    return root2.contains(n2);
  }
  var node = n2;
  while (node) {
    if (node === root2) {
      return true;
    }
    node = node.parentNode;
  }
  return false;
}
var APPEND_ORDER = "data-rc-order";
var MARK_KEY = "rc-util-key";
var containerCache = /* @__PURE__ */ new Map();
function getMark() {
  var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, mark = _ref.mark;
  if (mark) {
    return mark.startsWith("data-") ? mark : "data-".concat(mark);
  }
  return MARK_KEY;
}
function getContainer$1(option) {
  if (option.attachTo) {
    return option.attachTo;
  }
  var head2 = document.querySelector("head");
  return head2 || document.body;
}
function getOrder(prepend) {
  if (prepend === "queue") {
    return "prependQueue";
  }
  return prepend ? "prepend" : "append";
}
function findStyles(container) {
  return Array.from((containerCache.get(container) || container).children).filter(function(node) {
    return node.tagName === "STYLE";
  });
}
function injectCSS(css2) {
  var option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  if (!canUseDom()) {
    return null;
  }
  var csp = option.csp, prepend = option.prepend;
  var styleNode = document.createElement("style");
  styleNode.setAttribute(APPEND_ORDER, getOrder(prepend));
  if (csp === null || csp === void 0 ? void 0 : csp.nonce) {
    styleNode.nonce = csp === null || csp === void 0 ? void 0 : csp.nonce;
  }
  styleNode.innerHTML = css2;
  var container = getContainer$1(option);
  var firstChild = container.firstChild;
  if (prepend) {
    if (prepend === "queue") {
      var existStyle = findStyles(container).filter(function(node) {
        return ["prepend", "prependQueue"].includes(node.getAttribute(APPEND_ORDER));
      });
      if (existStyle.length) {
        container.insertBefore(styleNode, existStyle[existStyle.length - 1].nextSibling);
        return styleNode;
      }
    }
    container.insertBefore(styleNode, firstChild);
  } else {
    container.appendChild(styleNode);
  }
  return styleNode;
}
function findExistNode(key2) {
  var option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var container = getContainer$1(option);
  return findStyles(container).find(function(node) {
    return node.getAttribute(getMark(option)) === key2;
  });
}
function syncRealContainer(container, option) {
  var cachedRealContainer = containerCache.get(container);
  if (!cachedRealContainer || !contains$1(document, cachedRealContainer)) {
    var placeholderStyle = injectCSS("", option);
    var parentNode = placeholderStyle.parentNode;
    containerCache.set(container, parentNode);
    parentNode.removeChild(placeholderStyle);
  }
}
function updateCSS(css2, key2) {
  var option = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  var container = getContainer$1(option);
  syncRealContainer(container, option);
  var existNode = findExistNode(key2, option);
  if (existNode) {
    var _option$csp, _option$csp2;
    if (((_option$csp = option.csp) === null || _option$csp === void 0 ? void 0 : _option$csp.nonce) && existNode.nonce !== ((_option$csp2 = option.csp) === null || _option$csp2 === void 0 ? void 0 : _option$csp2.nonce)) {
      var _option$csp3;
      existNode.nonce = (_option$csp3 = option.csp) === null || _option$csp3 === void 0 ? void 0 : _option$csp3.nonce;
    }
    if (existNode.innerHTML !== css2) {
      existNode.innerHTML = css2;
    }
    return existNode;
  }
  var newNode = injectCSS(css2, option);
  newNode.setAttribute(getMark(option), key2);
  return newNode;
}
function warning(valid, message2) {
  warningOnce(valid, "[@ant-design/icons] ".concat(message2));
}
function isIconDefinition(target) {
  return _typeof$4(target) === "object" && typeof target.name === "string" && typeof target.theme === "string" && (_typeof$4(target.icon) === "object" || typeof target.icon === "function");
}
function normalizeAttrs() {
  var attrs = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  return Object.keys(attrs).reduce(function(acc, key2) {
    var val = attrs[key2];
    switch (key2) {
      case "class":
        acc.className = val;
        delete acc.class;
        break;
      default:
        acc[key2] = val;
    }
    return acc;
  }, {});
}
function generate(node, key2, rootProps) {
  if (!rootProps) {
    return /* @__PURE__ */ React.createElement(node.tag, _objectSpread2$1({
      key: key2
    }, normalizeAttrs(node.attrs)), (node.children || []).map(function(child, index2) {
      return generate(child, "".concat(key2, "-").concat(node.tag, "-").concat(index2));
    }));
  }
  return /* @__PURE__ */ React.createElement(node.tag, _objectSpread2$1(_objectSpread2$1({
    key: key2
  }, normalizeAttrs(node.attrs)), rootProps), (node.children || []).map(function(child, index2) {
    return generate(child, "".concat(key2, "-").concat(node.tag, "-").concat(index2));
  }));
}
function getSecondaryColor(primaryColor) {
  return generate$1(primaryColor)[0];
}
function normalizeTwoToneColors(twoToneColor) {
  if (!twoToneColor) {
    return [];
  }
  return Array.isArray(twoToneColor) ? twoToneColor : [twoToneColor];
}
var iconStyles = "\n.anticon {\n  display: inline-block;\n  color: inherit;\n  font-style: normal;\n  line-height: 0;\n  text-align: center;\n  text-transform: none;\n  vertical-align: -0.125em;\n  text-rendering: optimizeLegibility;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n}\n\n.anticon > * {\n  line-height: 1;\n}\n\n.anticon svg {\n  display: inline-block;\n}\n\n.anticon::before {\n  display: none;\n}\n\n.anticon .anticon-icon {\n  display: block;\n}\n\n.anticon[tabindex] {\n  cursor: pointer;\n}\n\n.anticon-spin::before,\n.anticon-spin {\n  display: inline-block;\n  -webkit-animation: loadingCircle 1s infinite linear;\n  animation: loadingCircle 1s infinite linear;\n}\n\n@-webkit-keyframes loadingCircle {\n  100% {\n    -webkit-transform: rotate(360deg);\n    transform: rotate(360deg);\n  }\n}\n\n@keyframes loadingCircle {\n  100% {\n    -webkit-transform: rotate(360deg);\n    transform: rotate(360deg);\n  }\n}\n";
var useInsertStyles = function useInsertStyles2() {
  var styleStr = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : iconStyles;
  var _useContext = react.exports.useContext(Context$2), csp = _useContext.csp;
  react.exports.useEffect(function() {
    updateCSS(styleStr, "@ant-design-icons", {
      prepend: true,
      csp
    });
  }, []);
};
var _excluded$A = ["icon", "className", "onClick", "style", "primaryColor", "secondaryColor"];
var twoToneColorPalette = {
  primaryColor: "#333",
  secondaryColor: "#E6E6E6",
  calculated: false
};
function setTwoToneColors(_ref) {
  var primaryColor = _ref.primaryColor, secondaryColor = _ref.secondaryColor;
  twoToneColorPalette.primaryColor = primaryColor;
  twoToneColorPalette.secondaryColor = secondaryColor || getSecondaryColor(primaryColor);
  twoToneColorPalette.calculated = !!secondaryColor;
}
function getTwoToneColors() {
  return _objectSpread2$1({}, twoToneColorPalette);
}
var IconBase = function IconBase2(props) {
  var icon = props.icon, className = props.className, onClick = props.onClick, style2 = props.style, primaryColor = props.primaryColor, secondaryColor = props.secondaryColor, restProps = _objectWithoutProperties$1(props, _excluded$A);
  var colors = twoToneColorPalette;
  if (primaryColor) {
    colors = {
      primaryColor,
      secondaryColor: secondaryColor || getSecondaryColor(primaryColor)
    };
  }
  useInsertStyles();
  warning(isIconDefinition(icon), "icon should be icon definiton, but got ".concat(icon));
  if (!isIconDefinition(icon)) {
    return null;
  }
  var target = icon;
  if (target && typeof target.icon === "function") {
    target = _objectSpread2$1(_objectSpread2$1({}, target), {}, {
      icon: target.icon(colors.primaryColor, colors.secondaryColor)
    });
  }
  return generate(target.icon, "svg-".concat(target.name), _objectSpread2$1({
    className,
    onClick,
    style: style2,
    "data-icon": target.name,
    width: "1em",
    height: "1em",
    fill: "currentColor",
    "aria-hidden": "true"
  }, restProps));
};
IconBase.displayName = "IconReact";
IconBase.getTwoToneColors = getTwoToneColors;
IconBase.setTwoToneColors = setTwoToneColors;
var ReactIcon = IconBase;
function setTwoToneColor(twoToneColor) {
  var _normalizeTwoToneColo = normalizeTwoToneColors(twoToneColor), _normalizeTwoToneColo2 = _slicedToArray$4(_normalizeTwoToneColo, 2), primaryColor = _normalizeTwoToneColo2[0], secondaryColor = _normalizeTwoToneColo2[1];
  return ReactIcon.setTwoToneColors({
    primaryColor,
    secondaryColor
  });
}
function getTwoToneColor() {
  var colors = ReactIcon.getTwoToneColors();
  if (!colors.calculated) {
    return colors.primaryColor;
  }
  return [colors.primaryColor, colors.secondaryColor];
}
var _excluded$z = ["className", "icon", "spin", "rotate", "tabIndex", "onClick", "twoToneColor"];
setTwoToneColor("#1890ff");
var Icon$1 = /* @__PURE__ */ react.exports.forwardRef(function(props, ref) {
  var _classNames;
  var className = props.className, icon = props.icon, spin = props.spin, rotate2 = props.rotate, tabIndex = props.tabIndex, onClick = props.onClick, twoToneColor = props.twoToneColor, restProps = _objectWithoutProperties$1(props, _excluded$z);
  var _React$useContext = react.exports.useContext(Context$2), _React$useContext$pre = _React$useContext.prefixCls, prefixCls = _React$useContext$pre === void 0 ? "anticon" : _React$useContext$pre;
  var classString = classNames(prefixCls, (_classNames = {}, _defineProperty$4(_classNames, "".concat(prefixCls, "-").concat(icon.name), !!icon.name), _defineProperty$4(_classNames, "".concat(prefixCls, "-spin"), !!spin || icon.name === "loading"), _classNames), className);
  var iconTabIndex = tabIndex;
  if (iconTabIndex === void 0 && onClick) {
    iconTabIndex = -1;
  }
  var svgStyle = rotate2 ? {
    msTransform: "rotate(".concat(rotate2, "deg)"),
    transform: "rotate(".concat(rotate2, "deg)")
  } : void 0;
  var _normalizeTwoToneColo = normalizeTwoToneColors(twoToneColor), _normalizeTwoToneColo2 = _slicedToArray$4(_normalizeTwoToneColo, 2), primaryColor = _normalizeTwoToneColo2[0], secondaryColor = _normalizeTwoToneColo2[1];
  return /* @__PURE__ */ react.exports.createElement("span", _objectSpread2$1(_objectSpread2$1({
    role: "img",
    "aria-label": icon.name
  }, restProps), {}, {
    ref,
    tabIndex: iconTabIndex,
    onClick,
    className: classString
  }), /* @__PURE__ */ react.exports.createElement(ReactIcon, {
    icon,
    primaryColor,
    secondaryColor,
    style: svgStyle
  }));
});
Icon$1.displayName = "AntdIcon";
Icon$1.getTwoToneColor = getTwoToneColor;
Icon$1.setTwoToneColor = setTwoToneColor;
var AntdIcon = Icon$1;
var CheckCircleFilled = function CheckCircleFilled2(props, ref) {
  return /* @__PURE__ */ react.exports.createElement(AntdIcon, _objectSpread2$1(_objectSpread2$1({}, props), {}, {
    ref,
    icon: CheckCircleFilledSvg
  }));
};
CheckCircleFilled.displayName = "CheckCircleFilled";
var CheckCircleFilled$1 = /* @__PURE__ */ react.exports.forwardRef(CheckCircleFilled);
var CloseCircleFilled$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm165.4 618.2l-66-.3L512 563.4l-99.3 118.4-66.1.3c-4.4 0-8-3.5-8-8 0-1.9.7-3.7 1.9-5.2l130.1-155L340.5 359a8.32 8.32 0 01-1.9-5.2c0-4.4 3.6-8 8-8l66.1.3L512 464.6l99.3-118.4 66-.3c4.4 0 8 3.5 8 8 0 1.9-.7 3.7-1.9 5.2L553.5 514l130 155c1.2 1.5 1.9 3.3 1.9 5.2 0 4.4-3.6 8-8 8z" } }] }, "name": "close-circle", "theme": "filled" };
var CloseCircleFilledSvg = CloseCircleFilled$2;
var CloseCircleFilled = function CloseCircleFilled2(props, ref) {
  return /* @__PURE__ */ react.exports.createElement(AntdIcon, _objectSpread2$1(_objectSpread2$1({}, props), {}, {
    ref,
    icon: CloseCircleFilledSvg
  }));
};
CloseCircleFilled.displayName = "CloseCircleFilled";
var CloseCircleFilled$1 = /* @__PURE__ */ react.exports.forwardRef(CloseCircleFilled);
var ExclamationCircleFilled$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm-32 232c0-4.4 3.6-8 8-8h48c4.4 0 8 3.6 8 8v272c0 4.4-3.6 8-8 8h-48c-4.4 0-8-3.6-8-8V296zm32 440a48.01 48.01 0 010-96 48.01 48.01 0 010 96z" } }] }, "name": "exclamation-circle", "theme": "filled" };
var ExclamationCircleFilledSvg = ExclamationCircleFilled$2;
var ExclamationCircleFilled = function ExclamationCircleFilled2(props, ref) {
  return /* @__PURE__ */ react.exports.createElement(AntdIcon, _objectSpread2$1(_objectSpread2$1({}, props), {}, {
    ref,
    icon: ExclamationCircleFilledSvg
  }));
};
ExclamationCircleFilled.displayName = "ExclamationCircleFilled";
var ExclamationCircleFilled$1 = /* @__PURE__ */ react.exports.forwardRef(ExclamationCircleFilled);
var InfoCircleFilled$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm32 664c0 4.4-3.6 8-8 8h-48c-4.4 0-8-3.6-8-8V456c0-4.4 3.6-8 8-8h48c4.4 0 8 3.6 8 8v272zm-32-344a48.01 48.01 0 010-96 48.01 48.01 0 010 96z" } }] }, "name": "info-circle", "theme": "filled" };
var InfoCircleFilledSvg = InfoCircleFilled$2;
var InfoCircleFilled = function InfoCircleFilled2(props, ref) {
  return /* @__PURE__ */ react.exports.createElement(AntdIcon, _objectSpread2$1(_objectSpread2$1({}, props), {}, {
    ref,
    icon: InfoCircleFilledSvg
  }));
};
InfoCircleFilled.displayName = "InfoCircleFilled";
var InfoCircleFilled$1 = /* @__PURE__ */ react.exports.forwardRef(InfoCircleFilled);
var LoadingOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "0 0 1024 1024", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M988 548c-19.9 0-36-16.1-36-36 0-59.4-11.6-117-34.6-171.3a440.45 440.45 0 00-94.3-139.9 437.71 437.71 0 00-139.9-94.3C629 83.6 571.4 72 512 72c-19.9 0-36-16.1-36-36s16.1-36 36-36c69.1 0 136.2 13.5 199.3 40.3C772.3 66 827 103 874 150c47 47 83.9 101.8 109.7 162.7 26.7 63.1 40.2 130.2 40.2 199.3.1 19.9-16 36-35.9 36z" } }] }, "name": "loading", "theme": "outlined" };
var LoadingOutlinedSvg = LoadingOutlined$2;
var LoadingOutlined = function LoadingOutlined2(props, ref) {
  return /* @__PURE__ */ react.exports.createElement(AntdIcon, _objectSpread2$1(_objectSpread2$1({}, props), {}, {
    ref,
    icon: LoadingOutlinedSvg
  }));
};
LoadingOutlined.displayName = "LoadingOutlined";
var LoadingOutlined$1 = /* @__PURE__ */ react.exports.forwardRef(LoadingOutlined);
var fullClone$1 = _objectSpread2$1({}, ReactDOM$1);
var version$3 = fullClone$1.version, reactRender$1 = fullClone$1.render, unmountComponentAtNode = fullClone$1.unmountComponentAtNode;
var createRoot$1;
try {
  var mainVersion$1 = Number((version$3 || "").split(".")[0]);
  if (mainVersion$1 >= 18) {
    createRoot$1 = fullClone$1.createRoot;
  }
} catch (e3) {
}
function toggleWarning$1(skip) {
  var __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = fullClone$1.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
  if (__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED && _typeof$4(__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED) === "object") {
    __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.usingClientEntryPoint = skip;
  }
}
var MARK$1 = "__rc_react_root__";
function modernRender$1(node, container) {
  toggleWarning$1(true);
  var root2 = container[MARK$1] || createRoot$1(container);
  toggleWarning$1(false);
  root2.render(node);
  container[MARK$1] = root2;
}
function legacyRender$1(node, container) {
  reactRender$1(node, container);
}
function render$1(node, container) {
  if (createRoot$1) {
    modernRender$1(node, container);
    return;
  }
  legacyRender$1(node, container);
}
function modernUnmount(_x) {
  return _modernUnmount.apply(this, arguments);
}
function _modernUnmount() {
  _modernUnmount = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee(container) {
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            return _context.abrupt("return", Promise.resolve().then(function() {
              var _container$MARK;
              (_container$MARK = container[MARK$1]) === null || _container$MARK === void 0 ? void 0 : _container$MARK.unmount();
              delete container[MARK$1];
            }));
          case 1:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _modernUnmount.apply(this, arguments);
}
function legacyUnmount(container) {
  unmountComponentAtNode(container);
}
function unmount(_x2) {
  return _unmount.apply(this, arguments);
}
function _unmount() {
  _unmount = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee2(container) {
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            if (!(createRoot$1 !== void 0)) {
              _context2.next = 2;
              break;
            }
            return _context2.abrupt("return", modernUnmount(container));
          case 2:
            legacyUnmount(container);
          case 3:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _unmount.apply(this, arguments);
}
function makePrefixMap(styleProp, eventName) {
  var prefixes = {};
  prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
  prefixes["Webkit".concat(styleProp)] = "webkit".concat(eventName);
  prefixes["Moz".concat(styleProp)] = "moz".concat(eventName);
  prefixes["ms".concat(styleProp)] = "MS".concat(eventName);
  prefixes["O".concat(styleProp)] = "o".concat(eventName.toLowerCase());
  return prefixes;
}
function getVendorPrefixes(domSupport, win) {
  var prefixes = {
    animationend: makePrefixMap("Animation", "AnimationEnd"),
    transitionend: makePrefixMap("Transition", "TransitionEnd")
  };
  if (domSupport) {
    if (!("AnimationEvent" in win)) {
      delete prefixes.animationend.animation;
    }
    if (!("TransitionEvent" in win)) {
      delete prefixes.transitionend.transition;
    }
  }
  return prefixes;
}
var vendorPrefixes = getVendorPrefixes(canUseDom(), typeof window !== "undefined" ? window : {});
var style = {};
if (canUseDom()) {
  var _document$createEleme = document.createElement("div");
  style = _document$createEleme.style;
}
var prefixedEventNames = {};
function getVendorPrefixedEventName(eventName) {
  if (prefixedEventNames[eventName]) {
    return prefixedEventNames[eventName];
  }
  var prefixMap = vendorPrefixes[eventName];
  if (prefixMap) {
    var stylePropList = Object.keys(prefixMap);
    var len = stylePropList.length;
    for (var i2 = 0; i2 < len; i2 += 1) {
      var styleProp = stylePropList[i2];
      if (Object.prototype.hasOwnProperty.call(prefixMap, styleProp) && styleProp in style) {
        prefixedEventNames[eventName] = prefixMap[styleProp];
        return prefixedEventNames[eventName];
      }
    }
  }
  return "";
}
var internalAnimationEndName = getVendorPrefixedEventName("animationend");
var internalTransitionEndName = getVendorPrefixedEventName("transitionend");
var supportTransition = !!(internalAnimationEndName && internalTransitionEndName);
var animationEndName = internalAnimationEndName || "animationend";
var transitionEndName = internalTransitionEndName || "transitionend";
function getTransitionName$2(transitionName2, transitionType) {
  if (!transitionName2)
    return null;
  if (_typeof$4(transitionName2) === "object") {
    var type4 = transitionType.replace(/-\w/g, function(match2) {
      return match2[1].toUpperCase();
    });
    return transitionName2[type4];
  }
  return "".concat(transitionName2, "-").concat(transitionType);
}
var STATUS_NONE = "none";
var STATUS_APPEAR = "appear";
var STATUS_ENTER = "enter";
var STATUS_LEAVE = "leave";
var STEP_NONE = "none";
var STEP_PREPARE = "prepare";
var STEP_START = "start";
var STEP_ACTIVE = "active";
var STEP_ACTIVATED = "end";
function useSafeState(defaultValue) {
  var destroyRef = react.exports.useRef(false);
  var _React$useState = react.exports.useState(defaultValue), _React$useState2 = _slicedToArray$4(_React$useState, 2), value2 = _React$useState2[0], setValue2 = _React$useState2[1];
  react.exports.useEffect(function() {
    destroyRef.current = false;
    return function() {
      destroyRef.current = true;
    };
  }, []);
  function safeSetState(updater, ignoreDestroy) {
    if (ignoreDestroy && destroyRef.current) {
      return;
    }
    setValue2(updater);
  }
  return [value2, safeSetState];
}
var raf = function raf2(callback) {
  return +setTimeout(callback, 16);
};
var caf = function caf2(num) {
  return clearTimeout(num);
};
if (typeof window !== "undefined" && "requestAnimationFrame" in window) {
  raf = function raf3(callback) {
    return window.requestAnimationFrame(callback);
  };
  caf = function caf3(handle) {
    return window.cancelAnimationFrame(handle);
  };
}
var rafUUID = 0;
var rafIds = /* @__PURE__ */ new Map();
function cleanup(id2) {
  rafIds.delete(id2);
}
function wrapperRaf$1(callback) {
  var times = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
  rafUUID += 1;
  var id2 = rafUUID;
  function callRef(leftTimes) {
    if (leftTimes === 0) {
      cleanup(id2);
      callback();
    } else {
      var realId = raf(function() {
        callRef(leftTimes - 1);
      });
      rafIds.set(id2, realId);
    }
  }
  callRef(times);
  return id2;
}
wrapperRaf$1.cancel = function(id2) {
  var realId = rafIds.get(id2);
  cleanup(realId);
  return caf(realId);
};
var useNextFrame = function() {
  var nextFrameRef = react.exports.useRef(null);
  function cancelNextFrame() {
    wrapperRaf$1.cancel(nextFrameRef.current);
  }
  function nextFrame(callback) {
    var delay = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 2;
    cancelNextFrame();
    var nextFrameId = wrapperRaf$1(function() {
      if (delay <= 1) {
        callback({
          isCanceled: function isCanceled() {
            return nextFrameId !== nextFrameRef.current;
          }
        });
      } else {
        nextFrame(callback, delay - 1);
      }
    });
    nextFrameRef.current = nextFrameId;
  }
  react.exports.useEffect(function() {
    return function() {
      cancelNextFrame();
    };
  }, []);
  return [nextFrame, cancelNextFrame];
};
var useIsomorphicLayoutEffect = canUseDom() ? react.exports.useLayoutEffect : react.exports.useEffect;
var STEP_QUEUE = [STEP_PREPARE, STEP_START, STEP_ACTIVE, STEP_ACTIVATED];
var SkipStep = false;
var DoStep = true;
function isActive(step) {
  return step === STEP_ACTIVE || step === STEP_ACTIVATED;
}
var useStepQueue = function(status, callback) {
  var _useState = useSafeState(STEP_NONE), _useState2 = _slicedToArray$4(_useState, 2), step = _useState2[0], setStep = _useState2[1];
  var _useNextFrame = useNextFrame(), _useNextFrame2 = _slicedToArray$4(_useNextFrame, 2), nextFrame = _useNextFrame2[0], cancelNextFrame = _useNextFrame2[1];
  function startQueue() {
    setStep(STEP_PREPARE, true);
  }
  useIsomorphicLayoutEffect(function() {
    if (step !== STEP_NONE && step !== STEP_ACTIVATED) {
      var index2 = STEP_QUEUE.indexOf(step);
      var nextStep = STEP_QUEUE[index2 + 1];
      var result = callback(step);
      if (result === SkipStep) {
        setStep(nextStep, true);
      } else {
        nextFrame(function(info) {
          function doNext() {
            if (info.isCanceled())
              return;
            setStep(nextStep, true);
          }
          if (result === true) {
            doNext();
          } else {
            Promise.resolve(result).then(doNext);
          }
        });
      }
    }
  }, [status, step]);
  react.exports.useEffect(function() {
    return function() {
      cancelNextFrame();
    };
  }, []);
  return [startQueue, step];
};
var useDomMotionEvents = function(callback) {
  var cacheElementRef = react.exports.useRef();
  var callbackRef = react.exports.useRef(callback);
  callbackRef.current = callback;
  var onInternalMotionEnd = react.exports.useCallback(function(event) {
    callbackRef.current(event);
  }, []);
  function removeMotionEvents(element) {
    if (element) {
      element.removeEventListener(transitionEndName, onInternalMotionEnd);
      element.removeEventListener(animationEndName, onInternalMotionEnd);
    }
  }
  function patchMotionEvents(element) {
    if (cacheElementRef.current && cacheElementRef.current !== element) {
      removeMotionEvents(cacheElementRef.current);
    }
    if (element && element !== cacheElementRef.current) {
      element.addEventListener(transitionEndName, onInternalMotionEnd);
      element.addEventListener(animationEndName, onInternalMotionEnd);
      cacheElementRef.current = element;
    }
  }
  react.exports.useEffect(function() {
    return function() {
      removeMotionEvents(cacheElementRef.current);
    };
  }, []);
  return [patchMotionEvents, removeMotionEvents];
};
function useStatus(supportMotion, visible, getElement2, _ref) {
  var _ref$motionEnter = _ref.motionEnter, motionEnter = _ref$motionEnter === void 0 ? true : _ref$motionEnter, _ref$motionAppear = _ref.motionAppear, motionAppear = _ref$motionAppear === void 0 ? true : _ref$motionAppear, _ref$motionLeave = _ref.motionLeave, motionLeave = _ref$motionLeave === void 0 ? true : _ref$motionLeave, motionDeadline = _ref.motionDeadline, motionLeaveImmediately = _ref.motionLeaveImmediately, onAppearPrepare = _ref.onAppearPrepare, onEnterPrepare = _ref.onEnterPrepare, onLeavePrepare = _ref.onLeavePrepare, onAppearStart = _ref.onAppearStart, onEnterStart = _ref.onEnterStart, onLeaveStart = _ref.onLeaveStart, onAppearActive = _ref.onAppearActive, onEnterActive = _ref.onEnterActive, onLeaveActive = _ref.onLeaveActive, onAppearEnd = _ref.onAppearEnd, onEnterEnd = _ref.onEnterEnd, onLeaveEnd = _ref.onLeaveEnd, onVisibleChanged = _ref.onVisibleChanged;
  var _useState = useSafeState(), _useState2 = _slicedToArray$4(_useState, 2), asyncVisible = _useState2[0], setAsyncVisible = _useState2[1];
  var _useState3 = useSafeState(STATUS_NONE), _useState4 = _slicedToArray$4(_useState3, 2), status = _useState4[0], setStatus = _useState4[1];
  var _useState5 = useSafeState(null), _useState6 = _slicedToArray$4(_useState5, 2), style2 = _useState6[0], setStyle2 = _useState6[1];
  var mountedRef = react.exports.useRef(false);
  var deadlineRef = react.exports.useRef(null);
  function getDomElement() {
    return getElement2();
  }
  var activeRef = react.exports.useRef(false);
  function onInternalMotionEnd(event) {
    var element = getDomElement();
    if (event && !event.deadline && event.target !== element) {
      return;
    }
    var currentActive = activeRef.current;
    var canEnd;
    if (status === STATUS_APPEAR && currentActive) {
      canEnd = onAppearEnd === null || onAppearEnd === void 0 ? void 0 : onAppearEnd(element, event);
    } else if (status === STATUS_ENTER && currentActive) {
      canEnd = onEnterEnd === null || onEnterEnd === void 0 ? void 0 : onEnterEnd(element, event);
    } else if (status === STATUS_LEAVE && currentActive) {
      canEnd = onLeaveEnd === null || onLeaveEnd === void 0 ? void 0 : onLeaveEnd(element, event);
    }
    if (status !== STATUS_NONE && currentActive && canEnd !== false) {
      setStatus(STATUS_NONE, true);
      setStyle2(null, true);
    }
  }
  var _useDomMotionEvents = useDomMotionEvents(onInternalMotionEnd), _useDomMotionEvents2 = _slicedToArray$4(_useDomMotionEvents, 1), patchMotionEvents = _useDomMotionEvents2[0];
  var eventHandlers = react.exports.useMemo(function() {
    var _ref2, _ref3, _ref4;
    switch (status) {
      case STATUS_APPEAR:
        return _ref2 = {}, _defineProperty$4(_ref2, STEP_PREPARE, onAppearPrepare), _defineProperty$4(_ref2, STEP_START, onAppearStart), _defineProperty$4(_ref2, STEP_ACTIVE, onAppearActive), _ref2;
      case STATUS_ENTER:
        return _ref3 = {}, _defineProperty$4(_ref3, STEP_PREPARE, onEnterPrepare), _defineProperty$4(_ref3, STEP_START, onEnterStart), _defineProperty$4(_ref3, STEP_ACTIVE, onEnterActive), _ref3;
      case STATUS_LEAVE:
        return _ref4 = {}, _defineProperty$4(_ref4, STEP_PREPARE, onLeavePrepare), _defineProperty$4(_ref4, STEP_START, onLeaveStart), _defineProperty$4(_ref4, STEP_ACTIVE, onLeaveActive), _ref4;
      default:
        return {};
    }
  }, [status]);
  var _useStepQueue = useStepQueue(status, function(newStep) {
    if (newStep === STEP_PREPARE) {
      var onPrepare = eventHandlers[STEP_PREPARE];
      if (!onPrepare) {
        return SkipStep;
      }
      return onPrepare(getDomElement());
    }
    if (step in eventHandlers) {
      var _eventHandlers$step;
      setStyle2(((_eventHandlers$step = eventHandlers[step]) === null || _eventHandlers$step === void 0 ? void 0 : _eventHandlers$step.call(eventHandlers, getDomElement(), null)) || null);
    }
    if (step === STEP_ACTIVE) {
      patchMotionEvents(getDomElement());
      if (motionDeadline > 0) {
        clearTimeout(deadlineRef.current);
        deadlineRef.current = setTimeout(function() {
          onInternalMotionEnd({
            deadline: true
          });
        }, motionDeadline);
      }
    }
    return DoStep;
  }), _useStepQueue2 = _slicedToArray$4(_useStepQueue, 2), startStep = _useStepQueue2[0], step = _useStepQueue2[1];
  var active = isActive(step);
  activeRef.current = active;
  useIsomorphicLayoutEffect(function() {
    setAsyncVisible(visible);
    var isMounted = mountedRef.current;
    mountedRef.current = true;
    if (!supportMotion) {
      return;
    }
    var nextStatus;
    if (!isMounted && visible && motionAppear) {
      nextStatus = STATUS_APPEAR;
    }
    if (isMounted && visible && motionEnter) {
      nextStatus = STATUS_ENTER;
    }
    if (isMounted && !visible && motionLeave || !isMounted && motionLeaveImmediately && !visible && motionLeave) {
      nextStatus = STATUS_LEAVE;
    }
    if (nextStatus) {
      setStatus(nextStatus);
      startStep();
    }
  }, [visible]);
  react.exports.useEffect(function() {
    if (status === STATUS_APPEAR && !motionAppear || status === STATUS_ENTER && !motionEnter || status === STATUS_LEAVE && !motionLeave) {
      setStatus(STATUS_NONE);
    }
  }, [motionAppear, motionEnter, motionLeave]);
  react.exports.useEffect(function() {
    return function() {
      mountedRef.current = false;
      clearTimeout(deadlineRef.current);
    };
  }, []);
  var firstMountChangeRef = react.exports.useRef(false);
  react.exports.useEffect(function() {
    if (asyncVisible) {
      firstMountChangeRef.current = true;
    }
    if (asyncVisible !== void 0 && status === STATUS_NONE) {
      if (firstMountChangeRef.current || asyncVisible) {
        onVisibleChanged === null || onVisibleChanged === void 0 ? void 0 : onVisibleChanged(asyncVisible);
      }
      firstMountChangeRef.current = true;
    }
  }, [asyncVisible, status]);
  var mergedStyle = style2;
  if (eventHandlers[STEP_PREPARE] && step === STEP_START) {
    mergedStyle = _objectSpread2$1({
      transition: "none"
    }, mergedStyle);
  }
  return [status, step, mergedStyle, asyncVisible !== null && asyncVisible !== void 0 ? asyncVisible : visible];
}
var DomWrapper = /* @__PURE__ */ function(_React$Component) {
  _inherits$1(DomWrapper2, _React$Component);
  var _super = _createSuper$1(DomWrapper2);
  function DomWrapper2() {
    _classCallCheck$2(this, DomWrapper2);
    return _super.apply(this, arguments);
  }
  _createClass$2(DomWrapper2, [{
    key: "render",
    value: function render2() {
      return this.props.children;
    }
  }]);
  return DomWrapper2;
}(react.exports.Component);
function genCSSMotion(config) {
  var transitionSupport = config;
  if (_typeof$4(config) === "object") {
    transitionSupport = config.transitionSupport;
  }
  function isSupportTransition(props) {
    return !!(props.motionName && transitionSupport);
  }
  var CSSMotion2 = /* @__PURE__ */ react.exports.forwardRef(function(props, ref) {
    var _props$visible = props.visible, visible = _props$visible === void 0 ? true : _props$visible, _props$removeOnLeave = props.removeOnLeave, removeOnLeave = _props$removeOnLeave === void 0 ? true : _props$removeOnLeave, forceRender = props.forceRender, children = props.children, motionName = props.motionName, leavedClassName = props.leavedClassName, eventProps = props.eventProps;
    var supportMotion = isSupportTransition(props);
    var nodeRef = react.exports.useRef();
    var wrapperNodeRef = react.exports.useRef();
    function getDomElement() {
      try {
        return nodeRef.current instanceof HTMLElement ? nodeRef.current : findDOMNode(wrapperNodeRef.current);
      } catch (e3) {
        return null;
      }
    }
    var _useStatus = useStatus(supportMotion, visible, getDomElement, props), _useStatus2 = _slicedToArray$4(_useStatus, 4), status = _useStatus2[0], statusStep = _useStatus2[1], statusStyle = _useStatus2[2], mergedVisible = _useStatus2[3];
    var renderedRef = react.exports.useRef(mergedVisible);
    if (mergedVisible) {
      renderedRef.current = true;
    }
    var setNodeRef = react.exports.useCallback(function(node) {
      nodeRef.current = node;
      fillRef(ref, node);
    }, [ref]);
    var motionChildren;
    var mergedProps = _objectSpread2$1(_objectSpread2$1({}, eventProps), {}, {
      visible
    });
    if (!children) {
      motionChildren = null;
    } else if (status === STATUS_NONE || !isSupportTransition(props)) {
      if (mergedVisible) {
        motionChildren = children(_objectSpread2$1({}, mergedProps), setNodeRef);
      } else if (!removeOnLeave && renderedRef.current) {
        motionChildren = children(_objectSpread2$1(_objectSpread2$1({}, mergedProps), {}, {
          className: leavedClassName
        }), setNodeRef);
      } else if (forceRender) {
        motionChildren = children(_objectSpread2$1(_objectSpread2$1({}, mergedProps), {}, {
          style: {
            display: "none"
          }
        }), setNodeRef);
      } else {
        motionChildren = null;
      }
    } else {
      var _classNames;
      var statusSuffix;
      if (statusStep === STEP_PREPARE) {
        statusSuffix = "prepare";
      } else if (isActive(statusStep)) {
        statusSuffix = "active";
      } else if (statusStep === STEP_START) {
        statusSuffix = "start";
      }
      motionChildren = children(_objectSpread2$1(_objectSpread2$1({}, mergedProps), {}, {
        className: classNames(getTransitionName$2(motionName, status), (_classNames = {}, _defineProperty$4(_classNames, getTransitionName$2(motionName, "".concat(status, "-").concat(statusSuffix)), statusSuffix), _defineProperty$4(_classNames, motionName, typeof motionName === "string"), _classNames)),
        style: statusStyle
      }), setNodeRef);
    }
    if (/* @__PURE__ */ react.exports.isValidElement(motionChildren) && supportRef(motionChildren)) {
      var _motionChildren = motionChildren, originNodeRef = _motionChildren.ref;
      if (!originNodeRef) {
        motionChildren = /* @__PURE__ */ react.exports.cloneElement(motionChildren, {
          ref: setNodeRef
        });
      }
    }
    return /* @__PURE__ */ react.exports.createElement(DomWrapper, {
      ref: wrapperNodeRef
    }, motionChildren);
  });
  CSSMotion2.displayName = "CSSMotion";
  return CSSMotion2;
}
var CSSMotion = genCSSMotion(supportTransition);
var STATUS_ADD = "add";
var STATUS_KEEP = "keep";
var STATUS_REMOVE = "remove";
var STATUS_REMOVED = "removed";
function wrapKeyToObject(key2) {
  var keyObj;
  if (key2 && _typeof$4(key2) === "object" && "key" in key2) {
    keyObj = key2;
  } else {
    keyObj = {
      key: key2
    };
  }
  return _objectSpread2$1(_objectSpread2$1({}, keyObj), {}, {
    key: String(keyObj.key)
  });
}
function parseKeys() {
  var keys2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  return keys2.map(wrapKeyToObject);
}
function diffKeys() {
  var prevKeys = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  var currentKeys = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  var list = [];
  var currentIndex = 0;
  var currentLen = currentKeys.length;
  var prevKeyObjects = parseKeys(prevKeys);
  var currentKeyObjects = parseKeys(currentKeys);
  prevKeyObjects.forEach(function(keyObj) {
    var hit = false;
    for (var i2 = currentIndex; i2 < currentLen; i2 += 1) {
      var currentKeyObj = currentKeyObjects[i2];
      if (currentKeyObj.key === keyObj.key) {
        if (currentIndex < i2) {
          list = list.concat(currentKeyObjects.slice(currentIndex, i2).map(function(obj) {
            return _objectSpread2$1(_objectSpread2$1({}, obj), {}, {
              status: STATUS_ADD
            });
          }));
          currentIndex = i2;
        }
        list.push(_objectSpread2$1(_objectSpread2$1({}, currentKeyObj), {}, {
          status: STATUS_KEEP
        }));
        currentIndex += 1;
        hit = true;
        break;
      }
    }
    if (!hit) {
      list.push(_objectSpread2$1(_objectSpread2$1({}, keyObj), {}, {
        status: STATUS_REMOVE
      }));
    }
  });
  if (currentIndex < currentLen) {
    list = list.concat(currentKeyObjects.slice(currentIndex).map(function(obj) {
      return _objectSpread2$1(_objectSpread2$1({}, obj), {}, {
        status: STATUS_ADD
      });
    }));
  }
  var keys2 = {};
  list.forEach(function(_ref) {
    var key2 = _ref.key;
    keys2[key2] = (keys2[key2] || 0) + 1;
  });
  var duplicatedKeys = Object.keys(keys2).filter(function(key2) {
    return keys2[key2] > 1;
  });
  duplicatedKeys.forEach(function(matchKey) {
    list = list.filter(function(_ref2) {
      var key2 = _ref2.key, status = _ref2.status;
      return key2 !== matchKey || status !== STATUS_REMOVE;
    });
    list.forEach(function(node) {
      if (node.key === matchKey) {
        node.status = STATUS_KEEP;
      }
    });
  });
  return list;
}
var _excluded$y = ["component", "children", "onVisibleChanged", "onAllRemoved"], _excluded2$7 = ["status"];
var MOTION_PROP_NAMES = ["eventProps", "visible", "children", "motionName", "motionAppear", "motionEnter", "motionLeave", "motionLeaveImmediately", "motionDeadline", "removeOnLeave", "leavedClassName", "onAppearStart", "onAppearActive", "onAppearEnd", "onEnterStart", "onEnterActive", "onEnterEnd", "onLeaveStart", "onLeaveActive", "onLeaveEnd"];
function genCSSMotionList(transitionSupport) {
  var CSSMotion$1 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : CSSMotion;
  var CSSMotionList2 = /* @__PURE__ */ function(_React$Component) {
    _inherits$1(CSSMotionList3, _React$Component);
    var _super = _createSuper$1(CSSMotionList3);
    function CSSMotionList3() {
      var _this;
      _classCallCheck$2(this, CSSMotionList3);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      _this.state = {
        keyEntities: []
      };
      _this.removeKey = function(removeKey) {
        var keyEntities = _this.state.keyEntities;
        var nextKeyEntities = keyEntities.map(function(entity) {
          if (entity.key !== removeKey)
            return entity;
          return _objectSpread2$1(_objectSpread2$1({}, entity), {}, {
            status: STATUS_REMOVED
          });
        });
        _this.setState({
          keyEntities: nextKeyEntities
        });
        return nextKeyEntities.filter(function(_ref) {
          var status = _ref.status;
          return status !== STATUS_REMOVED;
        }).length;
      };
      return _this;
    }
    _createClass$2(CSSMotionList3, [{
      key: "render",
      value: function render2() {
        var _this2 = this;
        var keyEntities = this.state.keyEntities;
        var _this$props = this.props, component2 = _this$props.component, children = _this$props.children, _onVisibleChanged = _this$props.onVisibleChanged, onAllRemoved = _this$props.onAllRemoved, restProps = _objectWithoutProperties$1(_this$props, _excluded$y);
        var Component2 = component2 || react.exports.Fragment;
        var motionProps = {};
        MOTION_PROP_NAMES.forEach(function(prop) {
          motionProps[prop] = restProps[prop];
          delete restProps[prop];
        });
        delete restProps.keys;
        return /* @__PURE__ */ react.exports.createElement(Component2, restProps, keyEntities.map(function(_ref2) {
          var status = _ref2.status, eventProps = _objectWithoutProperties$1(_ref2, _excluded2$7);
          var visible = status === STATUS_ADD || status === STATUS_KEEP;
          return /* @__PURE__ */ react.exports.createElement(CSSMotion$1, _extends$2({}, motionProps, {
            key: eventProps.key,
            visible,
            eventProps,
            onVisibleChanged: function onVisibleChanged(changedVisible) {
              _onVisibleChanged === null || _onVisibleChanged === void 0 ? void 0 : _onVisibleChanged(changedVisible, {
                key: eventProps.key
              });
              if (!changedVisible) {
                var restKeysCount = _this2.removeKey(eventProps.key);
                if (restKeysCount === 0 && onAllRemoved) {
                  onAllRemoved();
                }
              }
            }
          }), children);
        }));
      }
    }], [{
      key: "getDerivedStateFromProps",
      value: function getDerivedStateFromProps(_ref3, _ref4) {
        var keys2 = _ref3.keys;
        var keyEntities = _ref4.keyEntities;
        var parsedKeyObjects = parseKeys(keys2);
        var mixedKeyEntities = diffKeys(keyEntities, parsedKeyObjects);
        return {
          keyEntities: mixedKeyEntities.filter(function(entity) {
            var prevEntity = keyEntities.find(function(_ref5) {
              var key2 = _ref5.key;
              return entity.key === key2;
            });
            if (prevEntity && prevEntity.status === STATUS_REMOVED && entity.status === STATUS_REMOVE) {
              return false;
            }
            return true;
          })
        };
      }
    }]);
    return CSSMotionList3;
  }(react.exports.Component);
  CSSMotionList2.defaultProps = {
    component: "div"
  };
  return CSSMotionList2;
}
var CSSMotionList = genCSSMotionList(supportTransition);
var Notice = /* @__PURE__ */ function(_Component) {
  _inherits$1(Notice2, _Component);
  var _super = _createSuper$1(Notice2);
  function Notice2() {
    var _this;
    _classCallCheck$2(this, Notice2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _this.closeTimer = null;
    _this.close = function(e3) {
      if (e3) {
        e3.stopPropagation();
      }
      _this.clearCloseTimer();
      var _this$props = _this.props, onClose2 = _this$props.onClose, noticeKey = _this$props.noticeKey;
      if (onClose2) {
        onClose2(noticeKey);
      }
    };
    _this.startCloseTimer = function() {
      if (_this.props.duration) {
        _this.closeTimer = window.setTimeout(function() {
          _this.close();
        }, _this.props.duration * 1e3);
      }
    };
    _this.clearCloseTimer = function() {
      if (_this.closeTimer) {
        clearTimeout(_this.closeTimer);
        _this.closeTimer = null;
      }
    };
    return _this;
  }
  _createClass$2(Notice2, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this.startCloseTimer();
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      if (this.props.duration !== prevProps.duration || this.props.updateMark !== prevProps.updateMark || this.props.visible !== prevProps.visible && this.props.visible) {
        this.restartCloseTimer();
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.clearCloseTimer();
    }
  }, {
    key: "restartCloseTimer",
    value: function restartCloseTimer() {
      this.clearCloseTimer();
      this.startCloseTimer();
    }
  }, {
    key: "render",
    value: function render2() {
      var _this2 = this;
      var _this$props2 = this.props, prefixCls = _this$props2.prefixCls, className = _this$props2.className, closable = _this$props2.closable, closeIcon = _this$props2.closeIcon, style2 = _this$props2.style, onClick = _this$props2.onClick, children = _this$props2.children, holder = _this$props2.holder;
      var componentClass = "".concat(prefixCls, "-notice");
      var dataOrAriaAttributeProps = Object.keys(this.props).reduce(function(acc, key2) {
        if (key2.substr(0, 5) === "data-" || key2.substr(0, 5) === "aria-" || key2 === "role") {
          acc[key2] = _this2.props[key2];
        }
        return acc;
      }, {});
      var node = /* @__PURE__ */ react.exports.createElement("div", _extends$2({
        className: classNames(componentClass, className, _defineProperty$4({}, "".concat(componentClass, "-closable"), closable)),
        style: style2,
        onMouseEnter: this.clearCloseTimer,
        onMouseLeave: this.startCloseTimer,
        onClick
      }, dataOrAriaAttributeProps), /* @__PURE__ */ react.exports.createElement("div", {
        className: "".concat(componentClass, "-content")
      }, children), closable ? /* @__PURE__ */ react.exports.createElement("a", {
        tabIndex: 0,
        onClick: this.close,
        className: "".concat(componentClass, "-close")
      }, closeIcon || /* @__PURE__ */ react.exports.createElement("span", {
        className: "".concat(componentClass, "-close-x")
      })) : null);
      if (holder) {
        return /* @__PURE__ */ ReactDOM.createPortal(node, holder);
      }
      return node;
    }
  }]);
  return Notice2;
}(react.exports.Component);
Notice.defaultProps = {
  onClose: function onClose() {
  },
  duration: 1.5
};
function useNotification(notificationInstance2) {
  var createdRef = react.exports.useRef({});
  var _React$useState = react.exports.useState([]), _React$useState2 = _slicedToArray$4(_React$useState, 2), elements = _React$useState2[0], setElements = _React$useState2[1];
  function notify(noticeProps) {
    var firstMount = true;
    notificationInstance2.add(noticeProps, function(div, props) {
      var key2 = props.key;
      if (div && (!createdRef.current[key2] || firstMount)) {
        var noticeEle = /* @__PURE__ */ react.exports.createElement(Notice, _extends$2({}, props, {
          holder: div
        }));
        createdRef.current[key2] = noticeEle;
        setElements(function(originElements) {
          var index2 = originElements.findIndex(function(ele) {
            return ele.key === props.key;
          });
          if (index2 === -1) {
            return [].concat(_toConsumableArray(originElements), [noticeEle]);
          }
          var cloneList = _toConsumableArray(originElements);
          cloneList[index2] = noticeEle;
          return cloneList;
        });
      }
      firstMount = false;
    });
  }
  return [notify, /* @__PURE__ */ react.exports.createElement(react.exports.Fragment, null, elements)];
}
var _excluded$x = ["getContainer"];
var seed = 0;
var now$3 = Date.now();
function getUuid() {
  var id2 = seed;
  seed += 1;
  return "rcNotification_".concat(now$3, "_").concat(id2);
}
var Notification = /* @__PURE__ */ function(_Component) {
  _inherits$1(Notification2, _Component);
  var _super = _createSuper$1(Notification2);
  function Notification2() {
    var _this;
    _classCallCheck$2(this, Notification2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _this.state = {
      notices: []
    };
    _this.hookRefs = /* @__PURE__ */ new Map();
    _this.add = function(originNotice, holderCallback) {
      var key2 = originNotice.key || getUuid();
      var notice2 = _objectSpread2$1(_objectSpread2$1({}, originNotice), {}, {
        key: key2
      });
      var maxCount2 = _this.props.maxCount;
      _this.setState(function(previousState) {
        var notices = previousState.notices;
        var noticeIndex = notices.map(function(v2) {
          return v2.notice.key;
        }).indexOf(key2);
        var updatedNotices = notices.concat();
        if (noticeIndex !== -1) {
          updatedNotices.splice(noticeIndex, 1, {
            notice: notice2,
            holderCallback
          });
        } else {
          if (maxCount2 && notices.length >= maxCount2) {
            notice2.key = updatedNotices[0].notice.key;
            notice2.updateMark = getUuid();
            notice2.userPassKey = key2;
            updatedNotices.shift();
          }
          updatedNotices.push({
            notice: notice2,
            holderCallback
          });
        }
        return {
          notices: updatedNotices
        };
      });
    };
    _this.remove = function(removeKey) {
      _this.setState(function(_ref) {
        var notices = _ref.notices;
        return {
          notices: notices.filter(function(_ref2) {
            var _ref2$notice = _ref2.notice, key2 = _ref2$notice.key, userPassKey = _ref2$notice.userPassKey;
            var mergedKey = userPassKey || key2;
            return mergedKey !== removeKey;
          })
        };
      });
    };
    _this.noticePropsMap = {};
    return _this;
  }
  _createClass$2(Notification2, [{
    key: "getTransitionName",
    value: function getTransitionName3() {
      var _this$props = this.props, prefixCls = _this$props.prefixCls, animation2 = _this$props.animation;
      var transitionName2 = this.props.transitionName;
      if (!transitionName2 && animation2) {
        transitionName2 = "".concat(prefixCls, "-").concat(animation2);
      }
      return transitionName2;
    }
  }, {
    key: "render",
    value: function render2() {
      var _this2 = this;
      var notices = this.state.notices;
      var _this$props2 = this.props, prefixCls = _this$props2.prefixCls, className = _this$props2.className, closeIcon = _this$props2.closeIcon, style2 = _this$props2.style;
      var noticeKeys = [];
      notices.forEach(function(_ref3, index2) {
        var notice2 = _ref3.notice, holderCallback = _ref3.holderCallback;
        var updateMark = index2 === notices.length - 1 ? notice2.updateMark : void 0;
        var key2 = notice2.key, userPassKey = notice2.userPassKey;
        var noticeProps = _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({
          prefixCls,
          closeIcon
        }, notice2), notice2.props), {}, {
          key: key2,
          noticeKey: userPassKey || key2,
          updateMark,
          onClose: function onClose2(noticeKey) {
            var _notice$onClose;
            _this2.remove(noticeKey);
            (_notice$onClose = notice2.onClose) === null || _notice$onClose === void 0 ? void 0 : _notice$onClose.call(notice2);
          },
          onClick: notice2.onClick,
          children: notice2.content
        });
        noticeKeys.push(key2);
        _this2.noticePropsMap[key2] = {
          props: noticeProps,
          holderCallback
        };
      });
      return /* @__PURE__ */ react.exports.createElement("div", {
        className: classNames(prefixCls, className),
        style: style2
      }, /* @__PURE__ */ react.exports.createElement(CSSMotionList, {
        keys: noticeKeys,
        motionName: this.getTransitionName(),
        onVisibleChanged: function onVisibleChanged(changedVisible, _ref4) {
          var key2 = _ref4.key;
          if (!changedVisible) {
            delete _this2.noticePropsMap[key2];
          }
        }
      }, function(_ref5) {
        var key2 = _ref5.key, motionClassName = _ref5.className, motionStyle = _ref5.style, visible = _ref5.visible;
        var _this2$noticePropsMap = _this2.noticePropsMap[key2], noticeProps = _this2$noticePropsMap.props, holderCallback = _this2$noticePropsMap.holderCallback;
        if (holderCallback) {
          return /* @__PURE__ */ react.exports.createElement("div", {
            key: key2,
            className: classNames(motionClassName, "".concat(prefixCls, "-hook-holder")),
            style: _objectSpread2$1({}, motionStyle),
            ref: function ref(div) {
              if (typeof key2 === "undefined") {
                return;
              }
              if (div) {
                _this2.hookRefs.set(key2, div);
                holderCallback(div, noticeProps);
              } else {
                _this2.hookRefs.delete(key2);
              }
            }
          });
        }
        return /* @__PURE__ */ react.exports.createElement(Notice, _extends$2({}, noticeProps, {
          className: classNames(motionClassName, noticeProps === null || noticeProps === void 0 ? void 0 : noticeProps.className),
          style: _objectSpread2$1(_objectSpread2$1({}, motionStyle), noticeProps === null || noticeProps === void 0 ? void 0 : noticeProps.style),
          visible
        }));
      }));
    }
  }]);
  return Notification2;
}(react.exports.Component);
Notification.newInstance = void 0;
Notification.defaultProps = {
  prefixCls: "rc-notification",
  animation: "fade",
  style: {
    top: 65,
    left: "50%"
  }
};
Notification.newInstance = function newNotificationInstance(properties, callback) {
  var _ref6 = properties || {}, getContainer2 = _ref6.getContainer, props = _objectWithoutProperties$1(_ref6, _excluded$x);
  var div = document.createElement("div");
  if (getContainer2) {
    var root2 = getContainer2();
    root2.appendChild(div);
  } else {
    document.body.appendChild(div);
  }
  var called = false;
  function ref(notification2) {
    if (called) {
      return;
    }
    called = true;
    callback({
      notice: function notice2(noticeProps) {
        notification2.add(noticeProps);
      },
      removeNotice: function removeNotice(key2) {
        notification2.remove(key2);
      },
      component: notification2,
      destroy: function destroy3() {
        unmount(div);
        if (div.parentNode) {
          div.parentNode.removeChild(div);
        }
      },
      useNotification: function useNotification$1() {
        return useNotification(notification2);
      }
    });
  }
  render$1(/* @__PURE__ */ react.exports.createElement(Notification, _extends$2({}, props, {
    ref
  })), div);
};
function createUseMessage(getRcNotificationInstance, getRCNoticeProps2) {
  var useMessage = function useMessage2() {
    var getPrefixCls;
    var getPopupContainer;
    var innerInstance = null;
    var proxy = {
      add: function add2(noticeProps, holderCallback) {
        innerInstance === null || innerInstance === void 0 ? void 0 : innerInstance.component.add(noticeProps, holderCallback);
      }
    };
    var _useRCNotification = useNotification(proxy), _useRCNotification2 = _slicedToArray$4(_useRCNotification, 2), hookNotify = _useRCNotification2[0], holder = _useRCNotification2[1];
    function notify(args) {
      var customizePrefixCls = args.prefixCls;
      var mergedPrefixCls = getPrefixCls("message", customizePrefixCls);
      var rootPrefixCls = getPrefixCls();
      var target = args.key || getKeyThenIncreaseKey();
      var closePromise = new Promise(function(resolve) {
        var callback = function callback2() {
          if (typeof args.onClose === "function") {
            args.onClose();
          }
          return resolve(true);
        };
        getRcNotificationInstance(_extends$2(_extends$2({}, args), {
          prefixCls: mergedPrefixCls,
          rootPrefixCls,
          getPopupContainer
        }), function(_ref) {
          var prefixCls = _ref.prefixCls, instance = _ref.instance;
          innerInstance = instance;
          hookNotify(getRCNoticeProps2(_extends$2(_extends$2({}, args), {
            key: target,
            onClose: callback
          }), prefixCls));
        });
      });
      var result = function result2() {
        if (innerInstance) {
          innerInstance.removeNotice(target);
        }
      };
      result.then = function(filled, rejected) {
        return closePromise.then(filled, rejected);
      };
      result.promise = closePromise;
      return result;
    }
    var hookApiRef = react.exports.useRef({});
    hookApiRef.current.open = notify;
    typeList.forEach(function(type4) {
      return attachTypeApi(hookApiRef.current, type4);
    });
    return [hookApiRef.current, /* @__PURE__ */ react.exports.createElement(ConfigConsumer, {
      key: "holder"
    }, function(context2) {
      getPrefixCls = context2.getPrefixCls;
      getPopupContainer = context2.getPopupContainer;
      return holder;
    })];
  };
  return useMessage;
}
var messageInstance;
var defaultDuration$1 = 3;
var defaultTop$1;
var key = 1;
var localPrefixCls = "";
var transitionName = "move-up";
var hasTransitionName = false;
var getContainer;
var maxCount$1;
var rtl$1 = false;
function getKeyThenIncreaseKey() {
  return key++;
}
function setMessageConfig(options) {
  if (options.top !== void 0) {
    defaultTop$1 = options.top;
    messageInstance = null;
  }
  if (options.duration !== void 0) {
    defaultDuration$1 = options.duration;
  }
  if (options.prefixCls !== void 0) {
    localPrefixCls = options.prefixCls;
  }
  if (options.getContainer !== void 0) {
    getContainer = options.getContainer;
    messageInstance = null;
  }
  if (options.transitionName !== void 0) {
    transitionName = options.transitionName;
    messageInstance = null;
    hasTransitionName = true;
  }
  if (options.maxCount !== void 0) {
    maxCount$1 = options.maxCount;
    messageInstance = null;
  }
  if (options.rtl !== void 0) {
    rtl$1 = options.rtl;
  }
}
function getRCNotificationInstance(args, callback) {
  var customizePrefixCls = args.prefixCls, getContextPopupContainer = args.getPopupContainer;
  var _globalConfig = globalConfig(), getPrefixCls = _globalConfig.getPrefixCls, getRootPrefixCls = _globalConfig.getRootPrefixCls, getIconPrefixCls = _globalConfig.getIconPrefixCls;
  var prefixCls = getPrefixCls("message", customizePrefixCls || localPrefixCls);
  var rootPrefixCls = getRootPrefixCls(args.rootPrefixCls, prefixCls);
  var iconPrefixCls = getIconPrefixCls();
  if (messageInstance) {
    callback({
      prefixCls,
      rootPrefixCls,
      iconPrefixCls,
      instance: messageInstance
    });
    return;
  }
  var instanceConfig = {
    prefixCls,
    transitionName: hasTransitionName ? transitionName : "".concat(rootPrefixCls, "-").concat(transitionName),
    style: {
      top: defaultTop$1
    },
    getContainer: getContainer || getContextPopupContainer,
    maxCount: maxCount$1
  };
  Notification.newInstance(instanceConfig, function(instance) {
    if (messageInstance) {
      callback({
        prefixCls,
        rootPrefixCls,
        iconPrefixCls,
        instance: messageInstance
      });
      return;
    }
    messageInstance = instance;
    callback({
      prefixCls,
      rootPrefixCls,
      iconPrefixCls,
      instance
    });
  });
}
var typeToIcon$1 = {
  info: InfoCircleFilled$1,
  success: CheckCircleFilled$1,
  error: CloseCircleFilled$1,
  warning: ExclamationCircleFilled$1,
  loading: LoadingOutlined$1
};
var typeList = Object.keys(typeToIcon$1);
function getRCNoticeProps$1(args, prefixCls, iconPrefixCls) {
  var _classNames;
  var duration = args.duration !== void 0 ? args.duration : defaultDuration$1;
  var IconComponent = typeToIcon$1[args.type];
  var messageClass = classNames("".concat(prefixCls, "-custom-content"), (_classNames = {}, _defineProperty$4(_classNames, "".concat(prefixCls, "-").concat(args.type), args.type), _defineProperty$4(_classNames, "".concat(prefixCls, "-rtl"), rtl$1 === true), _classNames));
  return {
    key: args.key,
    duration,
    style: args.style || {},
    className: args.className,
    content: /* @__PURE__ */ react.exports.createElement(ConfigProvider, {
      iconPrefixCls
    }, /* @__PURE__ */ react.exports.createElement("div", {
      className: messageClass
    }, args.icon || IconComponent && /* @__PURE__ */ react.exports.createElement(IconComponent, null), /* @__PURE__ */ react.exports.createElement("span", null, args.content))),
    onClose: args.onClose,
    onClick: args.onClick
  };
}
function notice$1(args) {
  var target = args.key || getKeyThenIncreaseKey();
  var closePromise = new Promise(function(resolve) {
    var callback = function callback2() {
      if (typeof args.onClose === "function") {
        args.onClose();
      }
      return resolve(true);
    };
    getRCNotificationInstance(args, function(_ref) {
      var prefixCls = _ref.prefixCls, iconPrefixCls = _ref.iconPrefixCls, instance = _ref.instance;
      instance.notice(getRCNoticeProps$1(_extends$2(_extends$2({}, args), {
        key: target,
        onClose: callback
      }), prefixCls, iconPrefixCls));
    });
  });
  var result = function result2() {
    if (messageInstance) {
      messageInstance.removeNotice(target);
    }
  };
  result.then = function(filled, rejected) {
    return closePromise.then(filled, rejected);
  };
  result.promise = closePromise;
  return result;
}
function isArgsProps(content) {
  return Object.prototype.toString.call(content) === "[object Object]" && !!content.content;
}
var api$1 = {
  open: notice$1,
  config: setMessageConfig,
  destroy: function destroy(messageKey) {
    if (messageInstance) {
      if (messageKey) {
        var _messageInstance = messageInstance, removeNotice = _messageInstance.removeNotice;
        removeNotice(messageKey);
      } else {
        var _messageInstance2 = messageInstance, destroy3 = _messageInstance2.destroy;
        destroy3();
        messageInstance = null;
      }
    }
  }
};
function attachTypeApi(originalApi, type4) {
  originalApi[type4] = function(content, duration, onClose2) {
    if (isArgsProps(content)) {
      return originalApi.open(_extends$2(_extends$2({}, content), {
        type: type4
      }));
    }
    if (typeof duration === "function") {
      onClose2 = duration;
      duration = void 0;
    }
    return originalApi.open({
      content,
      duration,
      type: type4,
      onClose: onClose2
    });
  };
}
typeList.forEach(function(type4) {
  return attachTypeApi(api$1, type4);
});
api$1.warn = api$1.warning;
api$1.useMessage = createUseMessage(getRCNotificationInstance, getRCNoticeProps$1);
var message = api$1;
var CheckCircleOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M699 353h-46.9c-10.2 0-19.9 4.9-25.9 13.3L469 584.3l-71.2-98.8c-6-8.3-15.6-13.3-25.9-13.3H325c-6.5 0-10.3 7.4-6.5 12.7l124.6 172.8a31.8 31.8 0 0051.7 0l210.6-292c3.9-5.3.1-12.7-6.4-12.7z" } }, { "tag": "path", "attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z" } }] }, "name": "check-circle", "theme": "outlined" };
var CheckCircleOutlinedSvg = CheckCircleOutlined$2;
var CheckCircleOutlined = function CheckCircleOutlined2(props, ref) {
  return /* @__PURE__ */ react.exports.createElement(AntdIcon, _objectSpread2$1(_objectSpread2$1({}, props), {}, {
    ref,
    icon: CheckCircleOutlinedSvg
  }));
};
CheckCircleOutlined.displayName = "CheckCircleOutlined";
var CheckCircleOutlined$1 = /* @__PURE__ */ react.exports.forwardRef(CheckCircleOutlined);
var CloseCircleOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M685.4 354.8c0-4.4-3.6-8-8-8l-66 .3L512 465.6l-99.3-118.4-66.1-.3c-4.4 0-8 3.5-8 8 0 1.9.7 3.7 1.9 5.2l130.1 155L340.5 670a8.32 8.32 0 00-1.9 5.2c0 4.4 3.6 8 8 8l66.1-.3L512 564.4l99.3 118.4 66 .3c4.4 0 8-3.5 8-8 0-1.9-.7-3.7-1.9-5.2L553.5 515l130.1-155c1.2-1.4 1.8-3.3 1.8-5.2z" } }, { "tag": "path", "attrs": { "d": "M512 65C264.6 65 64 265.6 64 513s200.6 448 448 448 448-200.6 448-448S759.4 65 512 65zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z" } }] }, "name": "close-circle", "theme": "outlined" };
var CloseCircleOutlinedSvg = CloseCircleOutlined$2;
var CloseCircleOutlined = function CloseCircleOutlined2(props, ref) {
  return /* @__PURE__ */ react.exports.createElement(AntdIcon, _objectSpread2$1(_objectSpread2$1({}, props), {}, {
    ref,
    icon: CloseCircleOutlinedSvg
  }));
};
CloseCircleOutlined.displayName = "CloseCircleOutlined";
var CloseCircleOutlined$1 = /* @__PURE__ */ react.exports.forwardRef(CloseCircleOutlined);
var CloseOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M563.8 512l262.5-312.9c4.4-5.2.7-13.1-6.1-13.1h-79.8c-4.7 0-9.2 2.1-12.3 5.7L511.6 449.8 295.1 191.7c-3-3.6-7.5-5.7-12.3-5.7H203c-6.8 0-10.5 7.9-6.1 13.1L459.4 512 196.9 824.9A7.95 7.95 0 00203 838h79.8c4.7 0 9.2-2.1 12.3-5.7l216.5-258.1 216.5 258.1c3 3.6 7.5 5.7 12.3 5.7h79.8c6.8 0 10.5-7.9 6.1-13.1L563.8 512z" } }] }, "name": "close", "theme": "outlined" };
var CloseOutlinedSvg = CloseOutlined$2;
var CloseOutlined = function CloseOutlined2(props, ref) {
  return /* @__PURE__ */ react.exports.createElement(AntdIcon, _objectSpread2$1(_objectSpread2$1({}, props), {}, {
    ref,
    icon: CloseOutlinedSvg
  }));
};
CloseOutlined.displayName = "CloseOutlined";
var CloseOutlined$1 = /* @__PURE__ */ react.exports.forwardRef(CloseOutlined);
var ExclamationCircleOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z" } }, { "tag": "path", "attrs": { "d": "M464 688a48 48 0 1096 0 48 48 0 10-96 0zm24-112h48c4.4 0 8-3.6 8-8V296c0-4.4-3.6-8-8-8h-48c-4.4 0-8 3.6-8 8v272c0 4.4 3.6 8 8 8z" } }] }, "name": "exclamation-circle", "theme": "outlined" };
var ExclamationCircleOutlinedSvg = ExclamationCircleOutlined$2;
var ExclamationCircleOutlined = function ExclamationCircleOutlined2(props, ref) {
  return /* @__PURE__ */ react.exports.createElement(AntdIcon, _objectSpread2$1(_objectSpread2$1({}, props), {}, {
    ref,
    icon: ExclamationCircleOutlinedSvg
  }));
};
ExclamationCircleOutlined.displayName = "ExclamationCircleOutlined";
var ExclamationCircleOutlined$1 = /* @__PURE__ */ react.exports.forwardRef(ExclamationCircleOutlined);
var InfoCircleOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z" } }, { "tag": "path", "attrs": { "d": "M464 336a48 48 0 1096 0 48 48 0 10-96 0zm72 112h-48c-4.4 0-8 3.6-8 8v272c0 4.4 3.6 8 8 8h48c4.4 0 8-3.6 8-8V456c0-4.4-3.6-8-8-8z" } }] }, "name": "info-circle", "theme": "outlined" };
var InfoCircleOutlinedSvg = InfoCircleOutlined$2;
var InfoCircleOutlined = function InfoCircleOutlined2(props, ref) {
  return /* @__PURE__ */ react.exports.createElement(AntdIcon, _objectSpread2$1(_objectSpread2$1({}, props), {}, {
    ref,
    icon: InfoCircleOutlinedSvg
  }));
};
InfoCircleOutlined.displayName = "InfoCircleOutlined";
var InfoCircleOutlined$1 = /* @__PURE__ */ react.exports.forwardRef(InfoCircleOutlined);
function createUseNotification(getNotificationInstance2, getRCNoticeProps2) {
  var useNotification$1 = function useNotification$12() {
    var getPrefixCls;
    var innerInstance = null;
    var proxy = {
      add: function add2(noticeProps, holderCallback) {
        innerInstance === null || innerInstance === void 0 ? void 0 : innerInstance.component.add(noticeProps, holderCallback);
      }
    };
    var _useRCNotification = useNotification(proxy), _useRCNotification2 = _slicedToArray$4(_useRCNotification, 2), hookNotify = _useRCNotification2[0], holder = _useRCNotification2[1];
    function notify(args) {
      var customizePrefixCls = args.prefixCls;
      var mergedPrefixCls = getPrefixCls("notification", customizePrefixCls);
      getNotificationInstance2(_extends$2(_extends$2({}, args), {
        prefixCls: mergedPrefixCls
      }), function(_ref) {
        var prefixCls = _ref.prefixCls, instance = _ref.instance;
        innerInstance = instance;
        hookNotify(getRCNoticeProps2(args, prefixCls));
      });
    }
    var hookApiRef = react.exports.useRef({});
    hookApiRef.current.open = notify;
    ["success", "info", "warning", "error"].forEach(function(type4) {
      hookApiRef.current[type4] = function(args) {
        return hookApiRef.current.open(_extends$2(_extends$2({}, args), {
          type: type4
        }));
      };
    });
    return [hookApiRef.current, /* @__PURE__ */ react.exports.createElement(ConfigConsumer, {
      key: "holder"
    }, function(context2) {
      getPrefixCls = context2.getPrefixCls;
      return holder;
    })];
  };
  return useNotification$1;
}
globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value2) {
    return value2 instanceof P2 ? value2 : new P2(function(resolve) {
      resolve(value2);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value2) {
      try {
        step(generator.next(value2));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value2) {
      try {
        step(generator["throw"](value2));
      } catch (e3) {
        reject(e3);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var notificationInstance = {};
var defaultDuration = 4.5;
var defaultTop = 24;
var defaultBottom = 24;
var defaultPrefixCls$1 = "";
var defaultPlacement = "topRight";
var defaultGetContainer;
var defaultCloseIcon;
var rtl = false;
var maxCount;
function setNotificationConfig(options) {
  var duration = options.duration, placement = options.placement, bottom = options.bottom, top = options.top, getContainer2 = options.getContainer, closeIcon = options.closeIcon, prefixCls = options.prefixCls;
  if (prefixCls !== void 0) {
    defaultPrefixCls$1 = prefixCls;
  }
  if (duration !== void 0) {
    defaultDuration = duration;
  }
  if (placement !== void 0) {
    defaultPlacement = placement;
  } else if (options.rtl) {
    defaultPlacement = "topLeft";
  }
  if (bottom !== void 0) {
    defaultBottom = bottom;
  }
  if (top !== void 0) {
    defaultTop = top;
  }
  if (getContainer2 !== void 0) {
    defaultGetContainer = getContainer2;
  }
  if (closeIcon !== void 0) {
    defaultCloseIcon = closeIcon;
  }
  if (options.rtl !== void 0) {
    rtl = options.rtl;
  }
  if (options.maxCount !== void 0) {
    maxCount = options.maxCount;
  }
}
function getPlacementStyle(placement) {
  var top = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : defaultTop;
  var bottom = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : defaultBottom;
  var style2;
  switch (placement) {
    case "top":
      style2 = {
        left: "50%",
        transform: "translateX(-50%)",
        right: "auto",
        top,
        bottom: "auto"
      };
      break;
    case "topLeft":
      style2 = {
        left: 0,
        top,
        bottom: "auto"
      };
      break;
    case "topRight":
      style2 = {
        right: 0,
        top,
        bottom: "auto"
      };
      break;
    case "bottom":
      style2 = {
        left: "50%",
        transform: "translateX(-50%)",
        right: "auto",
        top: "auto",
        bottom
      };
      break;
    case "bottomLeft":
      style2 = {
        left: 0,
        top: "auto",
        bottom
      };
      break;
    default:
      style2 = {
        right: 0,
        top: "auto",
        bottom
      };
      break;
  }
  return style2;
}
function getNotificationInstance(args, callback) {
  var _args$placement = args.placement, placement = _args$placement === void 0 ? defaultPlacement : _args$placement, top = args.top, bottom = args.bottom, _args$getContainer = args.getContainer, getContainer2 = _args$getContainer === void 0 ? defaultGetContainer : _args$getContainer, customizePrefixCls = args.prefixCls;
  var _globalConfig = globalConfig(), getPrefixCls = _globalConfig.getPrefixCls, getIconPrefixCls = _globalConfig.getIconPrefixCls;
  var prefixCls = getPrefixCls("notification", customizePrefixCls || defaultPrefixCls$1);
  var iconPrefixCls = getIconPrefixCls();
  var cacheKey = "".concat(prefixCls, "-").concat(placement);
  var cacheInstance = notificationInstance[cacheKey];
  if (cacheInstance) {
    Promise.resolve(cacheInstance).then(function(instance) {
      callback({
        prefixCls: "".concat(prefixCls, "-notice"),
        iconPrefixCls,
        instance
      });
    });
    return;
  }
  var notificationClass = classNames("".concat(prefixCls, "-").concat(placement), _defineProperty$4({}, "".concat(prefixCls, "-rtl"), rtl === true));
  notificationInstance[cacheKey] = new Promise(function(resolve) {
    Notification.newInstance({
      prefixCls,
      className: notificationClass,
      style: getPlacementStyle(placement, top, bottom),
      getContainer: getContainer2,
      maxCount
    }, function(notification2) {
      resolve(notification2);
      callback({
        prefixCls: "".concat(prefixCls, "-notice"),
        iconPrefixCls,
        instance: notification2
      });
    });
  });
}
var typeToIcon = {
  success: CheckCircleOutlined$1,
  info: InfoCircleOutlined$1,
  error: CloseCircleOutlined$1,
  warning: ExclamationCircleOutlined$1
};
function getRCNoticeProps(args, prefixCls, iconPrefixCls) {
  var durationArg = args.duration, icon = args.icon, type4 = args.type, description = args.description, message2 = args.message, btn = args.btn, onClose2 = args.onClose, onClick = args.onClick, key2 = args.key, style2 = args.style, className = args.className, _args$closeIcon = args.closeIcon, closeIcon = _args$closeIcon === void 0 ? defaultCloseIcon : _args$closeIcon;
  var duration = durationArg === void 0 ? defaultDuration : durationArg;
  var iconNode = null;
  if (icon) {
    iconNode = /* @__PURE__ */ react.exports.createElement("span", {
      className: "".concat(prefixCls, "-icon")
    }, args.icon);
  } else if (type4) {
    iconNode = /* @__PURE__ */ react.exports.createElement(typeToIcon[type4] || null, {
      className: "".concat(prefixCls, "-icon ").concat(prefixCls, "-icon-").concat(type4)
    });
  }
  var closeIconToRender = /* @__PURE__ */ react.exports.createElement("span", {
    className: "".concat(prefixCls, "-close-x")
  }, closeIcon || /* @__PURE__ */ react.exports.createElement(CloseOutlined$1, {
    className: "".concat(prefixCls, "-close-icon")
  }));
  var autoMarginTag = !description && iconNode ? /* @__PURE__ */ react.exports.createElement("span", {
    className: "".concat(prefixCls, "-message-single-line-auto-margin")
  }) : null;
  return {
    content: /* @__PURE__ */ react.exports.createElement(ConfigProvider, {
      iconPrefixCls
    }, /* @__PURE__ */ react.exports.createElement("div", {
      className: iconNode ? "".concat(prefixCls, "-with-icon") : "",
      role: "alert"
    }, iconNode, /* @__PURE__ */ react.exports.createElement("div", {
      className: "".concat(prefixCls, "-message")
    }, autoMarginTag, message2), /* @__PURE__ */ react.exports.createElement("div", {
      className: "".concat(prefixCls, "-description")
    }, description), btn ? /* @__PURE__ */ react.exports.createElement("span", {
      className: "".concat(prefixCls, "-btn")
    }, btn) : null)),
    duration,
    closable: true,
    closeIcon: closeIconToRender,
    onClose: onClose2,
    onClick,
    key: key2,
    style: style2 || {},
    className: classNames(className, _defineProperty$4({}, "".concat(prefixCls, "-").concat(type4), !!type4))
  };
}
function notice(args) {
  getNotificationInstance(args, function(_ref) {
    var prefixCls = _ref.prefixCls, iconPrefixCls = _ref.iconPrefixCls, instance = _ref.instance;
    instance.notice(getRCNoticeProps(args, prefixCls, iconPrefixCls));
  });
}
var api = {
  open: notice,
  close: function close(key2) {
    Object.keys(notificationInstance).forEach(function(cacheKey) {
      return Promise.resolve(notificationInstance[cacheKey]).then(function(instance) {
        instance.removeNotice(key2);
      });
    });
  },
  config: setNotificationConfig,
  destroy: function destroy2() {
    Object.keys(notificationInstance).forEach(function(cacheKey) {
      Promise.resolve(notificationInstance[cacheKey]).then(function(instance) {
        instance.destroy();
      });
      delete notificationInstance[cacheKey];
    });
  }
};
["success", "info", "warning", "error"].forEach(function(type4) {
  api[type4] = function(args) {
    return api.open(_extends$2(_extends$2({}, args), {
      type: type4
    }));
  };
});
api.warn = api.warning;
api.useNotification = createUseNotification(getNotificationInstance, getRCNoticeProps);
var notification = api;
var defaultGetPrefixCls = function defaultGetPrefixCls2(suffixCls, customizePrefixCls) {
  if (customizePrefixCls)
    return customizePrefixCls;
  return suffixCls ? "ant-".concat(suffixCls) : "ant";
};
var ConfigContext = /* @__PURE__ */ react.exports.createContext({
  getPrefixCls: defaultGetPrefixCls
});
var ConfigConsumer = ConfigContext.Consumer;
var dynamicStyleMark = "-ant-".concat(Date.now(), "-").concat(Math.random());
function getStyle$2(globalPrefixCls2, theme2) {
  var variables = {};
  var formatColor = function formatColor2(color2, updater) {
    var clone3 = color2.clone();
    clone3 = (updater === null || updater === void 0 ? void 0 : updater(clone3)) || clone3;
    return clone3.toRgbString();
  };
  var fillColor = function fillColor2(colorVal, type4) {
    var baseColor = new TinyColor(colorVal);
    var colorPalettes = generate$1(baseColor.toRgbString());
    variables["".concat(type4, "-color")] = formatColor(baseColor);
    variables["".concat(type4, "-color-disabled")] = colorPalettes[1];
    variables["".concat(type4, "-color-hover")] = colorPalettes[4];
    variables["".concat(type4, "-color-active")] = colorPalettes[6];
    variables["".concat(type4, "-color-outline")] = baseColor.clone().setAlpha(0.2).toRgbString();
    variables["".concat(type4, "-color-deprecated-bg")] = colorPalettes[0];
    variables["".concat(type4, "-color-deprecated-border")] = colorPalettes[2];
  };
  if (theme2.primaryColor) {
    fillColor(theme2.primaryColor, "primary");
    var primaryColor = new TinyColor(theme2.primaryColor);
    var primaryColors = generate$1(primaryColor.toRgbString());
    primaryColors.forEach(function(color2, index2) {
      variables["primary-".concat(index2 + 1)] = color2;
    });
    variables["primary-color-deprecated-l-35"] = formatColor(primaryColor, function(c2) {
      return c2.lighten(35);
    });
    variables["primary-color-deprecated-l-20"] = formatColor(primaryColor, function(c2) {
      return c2.lighten(20);
    });
    variables["primary-color-deprecated-t-20"] = formatColor(primaryColor, function(c2) {
      return c2.tint(20);
    });
    variables["primary-color-deprecated-t-50"] = formatColor(primaryColor, function(c2) {
      return c2.tint(50);
    });
    variables["primary-color-deprecated-f-12"] = formatColor(primaryColor, function(c2) {
      return c2.setAlpha(c2.getAlpha() * 0.12);
    });
    var primaryActiveColor = new TinyColor(primaryColors[0]);
    variables["primary-color-active-deprecated-f-30"] = formatColor(primaryActiveColor, function(c2) {
      return c2.setAlpha(c2.getAlpha() * 0.3);
    });
    variables["primary-color-active-deprecated-d-02"] = formatColor(primaryActiveColor, function(c2) {
      return c2.darken(2);
    });
  }
  if (theme2.successColor) {
    fillColor(theme2.successColor, "success");
  }
  if (theme2.warningColor) {
    fillColor(theme2.warningColor, "warning");
  }
  if (theme2.errorColor) {
    fillColor(theme2.errorColor, "error");
  }
  if (theme2.infoColor) {
    fillColor(theme2.infoColor, "info");
  }
  var cssList = Object.keys(variables).map(function(key2) {
    return "--".concat(globalPrefixCls2, "-").concat(key2, ": ").concat(variables[key2], ";");
  });
  return "\n  :root {\n    ".concat(cssList.join("\n"), "\n  }\n  ").trim();
}
function registerTheme$1(globalPrefixCls2, theme2) {
  var style2 = getStyle$2(globalPrefixCls2, theme2);
  if (canUseDom()) {
    updateCSS(style2, "".concat(dynamicStyleMark, "-dynamic-theme"));
  }
}
var DisabledContext = /* @__PURE__ */ react.exports.createContext(false);
var DisabledContextProvider = function DisabledContextProvider2(_ref) {
  var children = _ref.children, disabled = _ref.disabled;
  var originDisabled = react.exports.useContext(DisabledContext);
  return /* @__PURE__ */ react.exports.createElement(DisabledContext.Provider, {
    value: disabled || originDisabled
  }, children);
};
var DisabledContext$1 = DisabledContext;
var SizeContext = /* @__PURE__ */ react.exports.createContext(void 0);
var SizeContextProvider = function SizeContextProvider2(_ref) {
  var children = _ref.children, size2 = _ref.size;
  return /* @__PURE__ */ react.exports.createElement(SizeContext.Consumer, null, function(originSize) {
    return /* @__PURE__ */ react.exports.createElement(SizeContext.Provider, {
      value: size2 || originSize
    }, children);
  });
};
var SizeContext$1 = SizeContext;
var PASSED_PROPS = ["getTargetContainer", "getPopupContainer", "renderEmpty", "pageHeader", "input", "pagination", "form"];
var defaultPrefixCls = "ant";
var defaultIconPrefixCls = "anticon";
var globalPrefixCls;
var globalIconPrefixCls;
function getGlobalPrefixCls() {
  return globalPrefixCls || defaultPrefixCls;
}
function getGlobalIconPrefixCls() {
  return globalIconPrefixCls || defaultIconPrefixCls;
}
var setGlobalConfig = function setGlobalConfig2(_ref) {
  var prefixCls = _ref.prefixCls, iconPrefixCls = _ref.iconPrefixCls, theme2 = _ref.theme;
  if (prefixCls !== void 0) {
    globalPrefixCls = prefixCls;
  }
  if (iconPrefixCls !== void 0) {
    globalIconPrefixCls = iconPrefixCls;
  }
  if (theme2) {
    registerTheme$1(getGlobalPrefixCls(), theme2);
  }
};
var globalConfig = function globalConfig2() {
  return {
    getPrefixCls: function getPrefixCls(suffixCls, customizePrefixCls) {
      if (customizePrefixCls)
        return customizePrefixCls;
      return suffixCls ? "".concat(getGlobalPrefixCls(), "-").concat(suffixCls) : getGlobalPrefixCls();
    },
    getIconPrefixCls: getGlobalIconPrefixCls,
    getRootPrefixCls: function getRootPrefixCls(rootPrefixCls, customizePrefixCls) {
      if (rootPrefixCls) {
        return rootPrefixCls;
      }
      if (globalPrefixCls) {
        return globalPrefixCls;
      }
      if (customizePrefixCls && customizePrefixCls.includes("-")) {
        return customizePrefixCls.replace(/^(.*)-[^-]*$/, "$1");
      }
      return getGlobalPrefixCls();
    }
  };
};
var ProviderChildren = function ProviderChildren2(props) {
  var _a2, _b;
  var children = props.children, csp = props.csp, autoInsertSpaceInButton = props.autoInsertSpaceInButton, form = props.form, locale2 = props.locale, componentSize = props.componentSize, direction2 = props.direction, space = props.space, virtual = props.virtual, dropdownMatchSelectWidth = props.dropdownMatchSelectWidth, legacyLocale = props.legacyLocale, parentContext = props.parentContext, iconPrefixCls = props.iconPrefixCls, componentDisabled = props.componentDisabled;
  var getPrefixCls = react.exports.useCallback(function(suffixCls, customizePrefixCls) {
    var prefixCls = props.prefixCls;
    if (customizePrefixCls)
      return customizePrefixCls;
    var mergedPrefixCls = prefixCls || parentContext.getPrefixCls("");
    return suffixCls ? "".concat(mergedPrefixCls, "-").concat(suffixCls) : mergedPrefixCls;
  }, [parentContext.getPrefixCls, props.prefixCls]);
  var config = _extends$2(_extends$2({}, parentContext), {
    csp,
    autoInsertSpaceInButton,
    locale: locale2 || legacyLocale,
    direction: direction2,
    space,
    virtual,
    dropdownMatchSelectWidth,
    getPrefixCls
  });
  PASSED_PROPS.forEach(function(propName) {
    var propValue = props[propName];
    if (propValue) {
      config[propName] = propValue;
    }
  });
  var memoedConfig = useMemo(function() {
    return config;
  }, config, function(prevConfig, currentConfig) {
    var prevKeys = Object.keys(prevConfig);
    var currentKeys = Object.keys(currentConfig);
    return prevKeys.length !== currentKeys.length || prevKeys.some(function(key2) {
      return prevConfig[key2] !== currentConfig[key2];
    });
  });
  var memoIconContextValue = react.exports.useMemo(function() {
    return {
      prefixCls: iconPrefixCls,
      csp
    };
  }, [iconPrefixCls, csp]);
  var childNode = children;
  var validateMessages = {};
  if (locale2) {
    validateMessages = ((_a2 = locale2.Form) === null || _a2 === void 0 ? void 0 : _a2.defaultValidateMessages) || ((_b = defaultLocale.Form) === null || _b === void 0 ? void 0 : _b.defaultValidateMessages) || {};
  }
  if (form && form.validateMessages) {
    validateMessages = _extends$2(_extends$2({}, validateMessages), form.validateMessages);
  }
  if (Object.keys(validateMessages).length > 0) {
    childNode = /* @__PURE__ */ react.exports.createElement(FormProvider, {
      validateMessages
    }, children);
  }
  if (locale2) {
    childNode = /* @__PURE__ */ react.exports.createElement(LocaleProvider, {
      locale: locale2,
      _ANT_MARK__: ANT_MARK
    }, childNode);
  }
  if (iconPrefixCls || csp) {
    childNode = /* @__PURE__ */ react.exports.createElement(Context$2.Provider, {
      value: memoIconContextValue
    }, childNode);
  }
  if (componentSize) {
    childNode = /* @__PURE__ */ react.exports.createElement(SizeContextProvider, {
      size: componentSize
    }, childNode);
  }
  if (componentDisabled !== void 0) {
    childNode = /* @__PURE__ */ react.exports.createElement(DisabledContextProvider, {
      disabled: componentDisabled
    }, childNode);
  }
  return /* @__PURE__ */ react.exports.createElement(ConfigContext.Provider, {
    value: memoedConfig
  }, childNode);
};
var ConfigProvider = function ConfigProvider2(props) {
  react.exports.useEffect(function() {
    if (props.direction) {
      message.config({
        rtl: props.direction === "rtl"
      });
      notification.config({
        rtl: props.direction === "rtl"
      });
    }
  }, [props.direction]);
  return /* @__PURE__ */ react.exports.createElement(LocaleReceiver, null, function(_2, __, legacyLocale) {
    return /* @__PURE__ */ react.exports.createElement(ConfigConsumer, null, function(context2) {
      return /* @__PURE__ */ react.exports.createElement(ProviderChildren, _extends$2({
        parentContext: context2,
        legacyLocale
      }, props));
    });
  });
};
ConfigProvider.ConfigContext = ConfigContext;
ConfigProvider.SizeContext = SizeContext$1;
ConfigProvider.config = setGlobalConfig;
function addEventListenerWrap(target, eventType, cb2, option) {
  var callback = ReactDOM.unstable_batchedUpdates ? function run(e3) {
    ReactDOM.unstable_batchedUpdates(cb2, e3);
  } : cb2;
  if (target.addEventListener) {
    target.addEventListener(eventType, callback, option);
  }
  return {
    remove: function remove2() {
      if (target.removeEventListener) {
        target.removeEventListener(eventType, callback, option);
      }
    }
  };
}
function getDataOrAriaProps(props) {
  return Object.keys(props).reduce(function(prev, key2) {
    if ((key2.startsWith("data-") || key2.startsWith("aria-") || key2 === "role") && !key2.startsWith("data-__")) {
      prev[key2] = props[key2];
    }
    return prev;
  }, {});
}
var isValidElement = react.exports.isValidElement;
function isFragment(child) {
  return child && child.type === react.exports.Fragment;
}
function replaceElement(element, replacement, props) {
  if (!isValidElement(element)) {
    return replacement;
  }
  return /* @__PURE__ */ react.exports.cloneElement(element, typeof props === "function" ? props(element.props || {}) : props);
}
function cloneElement(element, props) {
  return replaceElement(element, element, props);
}
function isWindow$1(obj) {
  return obj !== null && obj !== void 0 && obj === obj.window;
}
function getScroll$2(target, top) {
  var _a2, _b;
  if (typeof window === "undefined") {
    return 0;
  }
  var method4 = top ? "scrollTop" : "scrollLeft";
  var result = 0;
  if (isWindow$1(target)) {
    result = target[top ? "pageYOffset" : "pageXOffset"];
  } else if (target instanceof Document) {
    result = target.documentElement[method4];
  } else if (target instanceof HTMLElement) {
    result = target[method4];
  } else if (target) {
    result = target[method4];
  }
  if (target && !isWindow$1(target) && typeof result !== "number") {
    result = (_b = ((_a2 = target.ownerDocument) !== null && _a2 !== void 0 ? _a2 : target).documentElement) === null || _b === void 0 ? void 0 : _b[method4];
  }
  return result;
}
function easeInOutCubic(t2, b10, c2, d2) {
  var cc2 = c2 - b10;
  t2 /= d2 / 2;
  if (t2 < 1) {
    return cc2 / 2 * t2 * t2 * t2 + b10;
  }
  return cc2 / 2 * ((t2 -= 2) * t2 * t2 + 2) + b10;
}
function scrollTo(y2) {
  var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var _options$getContainer = options.getContainer, getContainer2 = _options$getContainer === void 0 ? function() {
    return window;
  } : _options$getContainer, callback = options.callback, _options$duration = options.duration, duration = _options$duration === void 0 ? 450 : _options$duration;
  var container = getContainer2();
  var scrollTop = getScroll$2(container, true);
  var startTime = Date.now();
  var frameFunc = function frameFunc2() {
    var timestamp = Date.now();
    var time = timestamp - startTime;
    var nextScrollTop = easeInOutCubic(time > duration ? duration : time, scrollTop, y2, duration);
    if (isWindow$1(container)) {
      container.scrollTo(window.pageXOffset, nextScrollTop);
    } else if (container instanceof HTMLDocument || container.constructor.name === "HTMLDocument") {
      container.documentElement.scrollTop = nextScrollTop;
    } else {
      container.scrollTop = nextScrollTop;
    }
    if (time < duration) {
      wrapperRaf$1(frameFunc2);
    } else if (typeof callback === "function") {
      callback();
    }
  };
  wrapperRaf$1(frameFunc);
}
function useEvent(callback) {
  var fnRef = react.exports.useRef();
  fnRef.current = callback;
  var memoFn = react.exports.useCallback(function() {
    var _fnRef$current;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return (_fnRef$current = fnRef.current) === null || _fnRef$current === void 0 ? void 0 : _fnRef$current.call.apply(_fnRef$current, [fnRef].concat(args));
  }, []);
  return memoFn;
}
var useLayoutEffect$1 = canUseDom() ? react.exports.useLayoutEffect : react.exports.useEffect;
var useLayoutUpdateEffect = function useLayoutUpdateEffect2(callback, deps) {
  var firstMountRef = react.exports.useRef(true);
  useLayoutEffect$1(function() {
    if (!firstMountRef.current) {
      return callback();
    }
  }, deps);
  useLayoutEffect$1(function() {
    firstMountRef.current = false;
    return function() {
      firstMountRef.current = true;
    };
  }, []);
};
var Source;
(function(Source2) {
  Source2[Source2["INNER"] = 0] = "INNER";
  Source2[Source2["PROP"] = 1] = "PROP";
})(Source || (Source = {}));
function hasValue$1(value2) {
  return value2 !== void 0;
}
function useMergedState(defaultStateValue, option) {
  var _ref = option || {}, defaultValue = _ref.defaultValue, value2 = _ref.value, onChange2 = _ref.onChange, postState = _ref.postState;
  var _useState = useSafeState(function() {
    var finalValue = void 0;
    var source;
    if (hasValue$1(value2)) {
      finalValue = value2;
      source = Source.PROP;
    } else if (hasValue$1(defaultValue)) {
      finalValue = typeof defaultValue === "function" ? defaultValue() : defaultValue;
      source = Source.PROP;
    } else {
      finalValue = typeof defaultStateValue === "function" ? defaultStateValue() : defaultStateValue;
      source = Source.INNER;
    }
    return [finalValue, source, finalValue];
  }), _useState2 = _slicedToArray$4(_useState, 2), mergedValue = _useState2[0], setMergedValue = _useState2[1];
  var chosenValue = hasValue$1(value2) ? value2 : mergedValue[0];
  var postMergedValue = postState ? postState(chosenValue) : chosenValue;
  useLayoutUpdateEffect(function() {
    setMergedValue(function(_ref2) {
      var _ref3 = _slicedToArray$4(_ref2, 1), prevValue = _ref3[0];
      return [value2, Source.PROP, prevValue];
    });
  }, [value2]);
  var changeEventPrevRef = react.exports.useRef();
  var triggerChange = useEvent(function(updater, ignoreDestroy) {
    setMergedValue(function(prev) {
      var _prev = _slicedToArray$4(prev, 3), prevValue = _prev[0], prevSource = _prev[1], prevPrevValue = _prev[2];
      var nextValue = typeof updater === "function" ? updater(prevValue) : updater;
      if (nextValue === prevValue) {
        return prev;
      }
      var overridePrevValue = prevSource === Source.INNER && changeEventPrevRef.current !== prevPrevValue ? prevPrevValue : prevValue;
      return [nextValue, Source.INNER, overridePrevValue];
    }, ignoreDestroy);
  });
  var onChangeFn = useEvent(onChange2);
  useLayoutEffect$1(function() {
    var _mergedValue = _slicedToArray$4(mergedValue, 3), current = _mergedValue[0], source = _mergedValue[1], prev = _mergedValue[2];
    if (current !== prev && source === Source.INNER) {
      onChangeFn(current, prev);
      changeEventPrevRef.current = prev;
    }
  }, [mergedValue]);
  return [postMergedValue, triggerChange];
}
var KeyCode = {
  MAC_ENTER: 3,
  BACKSPACE: 8,
  TAB: 9,
  NUM_CENTER: 12,
  ENTER: 13,
  SHIFT: 16,
  CTRL: 17,
  ALT: 18,
  PAUSE: 19,
  CAPS_LOCK: 20,
  ESC: 27,
  SPACE: 32,
  PAGE_UP: 33,
  PAGE_DOWN: 34,
  END: 35,
  HOME: 36,
  LEFT: 37,
  UP: 38,
  RIGHT: 39,
  DOWN: 40,
  PRINT_SCREEN: 44,
  INSERT: 45,
  DELETE: 46,
  ZERO: 48,
  ONE: 49,
  TWO: 50,
  THREE: 51,
  FOUR: 52,
  FIVE: 53,
  SIX: 54,
  SEVEN: 55,
  EIGHT: 56,
  NINE: 57,
  QUESTION_MARK: 63,
  A: 65,
  B: 66,
  C: 67,
  D: 68,
  E: 69,
  F: 70,
  G: 71,
  H: 72,
  I: 73,
  J: 74,
  K: 75,
  L: 76,
  M: 77,
  N: 78,
  O: 79,
  P: 80,
  Q: 81,
  R: 82,
  S: 83,
  T: 84,
  U: 85,
  V: 86,
  W: 87,
  X: 88,
  Y: 89,
  Z: 90,
  META: 91,
  WIN_KEY_RIGHT: 92,
  CONTEXT_MENU: 93,
  NUM_ZERO: 96,
  NUM_ONE: 97,
  NUM_TWO: 98,
  NUM_THREE: 99,
  NUM_FOUR: 100,
  NUM_FIVE: 101,
  NUM_SIX: 102,
  NUM_SEVEN: 103,
  NUM_EIGHT: 104,
  NUM_NINE: 105,
  NUM_MULTIPLY: 106,
  NUM_PLUS: 107,
  NUM_MINUS: 109,
  NUM_PERIOD: 110,
  NUM_DIVISION: 111,
  F1: 112,
  F2: 113,
  F3: 114,
  F4: 115,
  F5: 116,
  F6: 117,
  F7: 118,
  F8: 119,
  F9: 120,
  F10: 121,
  F11: 122,
  F12: 123,
  NUMLOCK: 144,
  SEMICOLON: 186,
  DASH: 189,
  EQUALS: 187,
  COMMA: 188,
  PERIOD: 190,
  SLASH: 191,
  APOSTROPHE: 192,
  SINGLE_QUOTE: 222,
  OPEN_SQUARE_BRACKET: 219,
  BACKSLASH: 220,
  CLOSE_SQUARE_BRACKET: 221,
  WIN_KEY: 224,
  MAC_FF_META: 224,
  WIN_IME: 229,
  isTextModifyingKeyEvent: function isTextModifyingKeyEvent(e3) {
    var keyCode = e3.keyCode;
    if (e3.altKey && !e3.ctrlKey || e3.metaKey || keyCode >= KeyCode.F1 && keyCode <= KeyCode.F12) {
      return false;
    }
    switch (keyCode) {
      case KeyCode.ALT:
      case KeyCode.CAPS_LOCK:
      case KeyCode.CONTEXT_MENU:
      case KeyCode.CTRL:
      case KeyCode.DOWN:
      case KeyCode.END:
      case KeyCode.ESC:
      case KeyCode.HOME:
      case KeyCode.INSERT:
      case KeyCode.LEFT:
      case KeyCode.MAC_FF_META:
      case KeyCode.META:
      case KeyCode.NUMLOCK:
      case KeyCode.NUM_CENTER:
      case KeyCode.PAGE_DOWN:
      case KeyCode.PAGE_UP:
      case KeyCode.PAUSE:
      case KeyCode.PRINT_SCREEN:
      case KeyCode.RIGHT:
      case KeyCode.SHIFT:
      case KeyCode.UP:
      case KeyCode.WIN_KEY:
      case KeyCode.WIN_KEY_RIGHT:
        return false;
      default:
        return true;
    }
  },
  isCharacterKey: function isCharacterKey(keyCode) {
    if (keyCode >= KeyCode.ZERO && keyCode <= KeyCode.NINE) {
      return true;
    }
    if (keyCode >= KeyCode.NUM_ZERO && keyCode <= KeyCode.NUM_MULTIPLY) {
      return true;
    }
    if (keyCode >= KeyCode.A && keyCode <= KeyCode.Z) {
      return true;
    }
    if (window.navigator.userAgent.indexOf("WebKit") !== -1 && keyCode === 0) {
      return true;
    }
    switch (keyCode) {
      case KeyCode.SPACE:
      case KeyCode.QUESTION_MARK:
      case KeyCode.NUM_PLUS:
      case KeyCode.NUM_MINUS:
      case KeyCode.NUM_PERIOD:
      case KeyCode.NUM_DIVISION:
      case KeyCode.SEMICOLON:
      case KeyCode.DASH:
      case KeyCode.EQUALS:
      case KeyCode.COMMA:
      case KeyCode.PERIOD:
      case KeyCode.SLASH:
      case KeyCode.APOSTROPHE:
      case KeyCode.SINGLE_QUOTE:
      case KeyCode.OPEN_SQUARE_BRACKET:
      case KeyCode.BACKSLASH:
      case KeyCode.CLOSE_SQUARE_BRACKET:
        return true;
      default:
        return false;
    }
  }
};
var isMobile = function() {
  if (typeof navigator === "undefined" || typeof window === "undefined") {
    return false;
  }
  var agent = navigator.userAgent || navigator.vendor || window.opera;
  return /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(agent) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw-(n|u)|c55\/|capi|ccwa|cdm-|cell|chtm|cldc|cmd-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc-s|devi|dica|dmob|do(c|p)o|ds(12|-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(-|_)|g1 u|g560|gene|gf-5|g-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd-(m|p|t)|hei-|hi(pt|ta)|hp( i|ip)|hs-c|ht(c(-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i-(20|go|ma)|i230|iac( |-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|-[a-w])|libw|lynx|m1-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|-([1-8]|c))|phil|pire|pl(ay|uc)|pn-2|po(ck|rt|se)|prox|psio|pt-g|qa-a|qc(07|12|21|32|60|-[2-7]|i-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h-|oo|p-)|sdk\/|se(c(-|0|1)|47|mc|nd|ri)|sgh-|shar|sie(-|m)|sk-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h-|v-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl-|tdg-|tel(i|m)|tim-|t-mo|to(pl|sh)|ts(70|m-|m3|m5)|tx-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas-|your|zeto|zte-/i.test(agent === null || agent === void 0 ? void 0 : agent.substr(0, 4));
};
function getKey$1(data2, index2) {
  var key2 = data2.key;
  var value2;
  if ("value" in data2) {
    value2 = data2.value;
  }
  if (key2 !== null && key2 !== void 0) {
    return key2;
  }
  if (value2 !== void 0) {
    return value2;
  }
  return "rc-index-key-".concat(index2);
}
function fillFieldNames$1(fieldNames, childrenAsData) {
  var _ref = fieldNames || {}, label2 = _ref.label, value2 = _ref.value, options = _ref.options;
  return {
    label: label2 || (childrenAsData ? "children" : "label"),
    value: value2 || "value",
    options: options || "options"
  };
}
function flattenOptions(options) {
  var _ref2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, fieldNames = _ref2.fieldNames, childrenAsData = _ref2.childrenAsData;
  var flattenList = [];
  var _fillFieldNames = fillFieldNames$1(fieldNames, false), fieldLabel = _fillFieldNames.label, fieldValue = _fillFieldNames.value, fieldOptions = _fillFieldNames.options;
  function dig(list, isGroupOption) {
    list.forEach(function(data2) {
      var label2 = data2[fieldLabel];
      if (isGroupOption || !(fieldOptions in data2)) {
        var value2 = data2[fieldValue];
        flattenList.push({
          key: getKey$1(data2, flattenList.length),
          groupOption: isGroupOption,
          data: data2,
          label: label2,
          value: value2
        });
      } else {
        var grpLabel = label2;
        if (grpLabel === void 0 && childrenAsData) {
          grpLabel = data2.label;
        }
        flattenList.push({
          key: getKey$1(data2, flattenList.length),
          group: true,
          data: data2,
          label: grpLabel
        });
        dig(data2[fieldOptions], true);
      }
    });
  }
  dig(options, false);
  return flattenList;
}
function injectPropsWithOption(option) {
  var newOption = _objectSpread2$1({}, option);
  if (!("props" in newOption)) {
    Object.defineProperty(newOption, "props", {
      get: function get2() {
        warningOnce(false, "Return type is option instead of Option instance. Please read value directly instead of reading from `props`.");
        return newOption;
      }
    });
  }
  return newOption;
}
function getSeparatedContent(text2, tokens) {
  if (!tokens || !tokens.length) {
    return null;
  }
  var match2 = false;
  function separate(str, _ref3) {
    var _ref4 = _toArray(_ref3), token2 = _ref4[0], restTokens = _ref4.slice(1);
    if (!token2) {
      return [str];
    }
    var list2 = str.split(token2);
    match2 = match2 || list2.length > 1;
    return list2.reduce(function(prevList, unitStr) {
      return [].concat(_toConsumableArray(prevList), _toConsumableArray(separate(unitStr, restTokens)));
    }, []).filter(function(unit) {
      return unit;
    });
  }
  var list = separate(text2, tokens);
  return match2 ? list : null;
}
var Portal = /* @__PURE__ */ react.exports.forwardRef(function(props, ref) {
  var didUpdate = props.didUpdate, getContainer2 = props.getContainer, children = props.children;
  var parentRef = react.exports.useRef();
  var containerRef = react.exports.useRef();
  react.exports.useImperativeHandle(ref, function() {
    return {};
  });
  var initRef = react.exports.useRef(false);
  if (!initRef.current && canUseDom()) {
    containerRef.current = getContainer2();
    parentRef.current = containerRef.current.parentNode;
    initRef.current = true;
  }
  react.exports.useEffect(function() {
    didUpdate === null || didUpdate === void 0 ? void 0 : didUpdate(props);
  });
  react.exports.useEffect(function() {
    if (containerRef.current.parentNode === null && parentRef.current !== null) {
      parentRef.current.appendChild(containerRef.current);
    }
    return function() {
      var _containerRef$current, _containerRef$current2;
      (_containerRef$current = containerRef.current) === null || _containerRef$current === void 0 ? void 0 : (_containerRef$current2 = _containerRef$current.parentNode) === null || _containerRef$current2 === void 0 ? void 0 : _containerRef$current2.removeChild(containerRef.current);
    };
  }, []);
  return containerRef.current ? /* @__PURE__ */ ReactDOM.createPortal(children, containerRef.current) : null;
});
function isPointsEq(a1, a2, isAlignPoint) {
  if (isAlignPoint) {
    return a1[0] === a2[0];
  }
  return a1[0] === a2[0] && a1[1] === a2[1];
}
function getAlignFromPlacement(builtinPlacements, placementStr, align) {
  var baseAlign = builtinPlacements[placementStr] || {};
  return _objectSpread2$1(_objectSpread2$1({}, baseAlign), align);
}
function getAlignPopupClassName(builtinPlacements, prefixCls, align, isAlignPoint) {
  var points2 = align.points;
  var placements2 = Object.keys(builtinPlacements);
  for (var i2 = 0; i2 < placements2.length; i2 += 1) {
    var placement = placements2[i2];
    if (isPointsEq(builtinPlacements[placement].points, points2, isAlignPoint)) {
      return "".concat(prefixCls, "-placement-").concat(placement);
    }
  }
  return "";
}
function getMotion$1(_ref) {
  var prefixCls = _ref.prefixCls, motion = _ref.motion, animation2 = _ref.animation, transitionName2 = _ref.transitionName;
  if (motion) {
    return motion;
  }
  if (animation2) {
    return {
      motionName: "".concat(prefixCls, "-").concat(animation2)
    };
  }
  if (transitionName2) {
    return {
      motionName: transitionName2
    };
  }
  return null;
}
function Mask$1(props) {
  var prefixCls = props.prefixCls, visible = props.visible, zIndex = props.zIndex, mask = props.mask, maskMotion = props.maskMotion, maskAnimation = props.maskAnimation, maskTransitionName = props.maskTransitionName;
  if (!mask) {
    return null;
  }
  var motion = {};
  if (maskMotion || maskTransitionName || maskAnimation) {
    motion = _objectSpread2$1({
      motionAppear: true
    }, getMotion$1({
      motion: maskMotion,
      prefixCls,
      transitionName: maskTransitionName,
      animation: maskAnimation
    }));
  }
  return /* @__PURE__ */ react.exports.createElement(CSSMotion, _extends$2({}, motion, {
    visible,
    removeOnLeave: true
  }), function(_ref) {
    var className = _ref.className;
    return /* @__PURE__ */ react.exports.createElement("div", {
      style: {
        zIndex
      },
      className: classNames("".concat(prefixCls, "-mask"), className)
    });
  });
}
var isVisible = function(element) {
  if (!element) {
    return false;
  }
  if (element instanceof HTMLElement && element.offsetParent) {
    return true;
  }
  if (element instanceof SVGGraphicsElement && element.getBBox) {
    var _element$getBBox = element.getBBox(), width = _element$getBBox.width, height = _element$getBBox.height;
    if (width || height) {
      return true;
    }
  }
  if (element instanceof HTMLElement && element.getBoundingClientRect) {
    var _element$getBoundingC = element.getBoundingClientRect(), _width = _element$getBoundingC.width, _height = _element$getBoundingC.height;
    if (_width || _height) {
      return true;
    }
  }
  return false;
};
function ownKeys$2(object4, enumerableOnly) {
  var keys2 = Object.keys(object4);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object4);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object4, sym).enumerable;
      });
    }
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread2(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys$2(Object(source), true).forEach(function(key2) {
        _defineProperty$3(target, key2, source[key2]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$2(Object(source)).forEach(function(key2) {
        Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source, key2));
      });
    }
  }
  return target;
}
function _typeof$3(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$3 = function(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$3 = function(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$3(obj);
}
function _defineProperty$3(obj, key2, value2) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, {
      value: value2,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key2] = value2;
  }
  return obj;
}
var vendorPrefix;
var jsCssMap = {
  Webkit: "-webkit-",
  Moz: "-moz-",
  ms: "-ms-",
  O: "-o-"
};
function getVendorPrefix() {
  if (vendorPrefix !== void 0) {
    return vendorPrefix;
  }
  vendorPrefix = "";
  var style2 = document.createElement("p").style;
  var testProp = "Transform";
  for (var key2 in jsCssMap) {
    if (key2 + testProp in style2) {
      vendorPrefix = key2;
    }
  }
  return vendorPrefix;
}
function getTransitionName$1() {
  return getVendorPrefix() ? "".concat(getVendorPrefix(), "TransitionProperty") : "transitionProperty";
}
function getTransformName() {
  return getVendorPrefix() ? "".concat(getVendorPrefix(), "Transform") : "transform";
}
function setTransitionProperty(node, value2) {
  var name = getTransitionName$1();
  if (name) {
    node.style[name] = value2;
    if (name !== "transitionProperty") {
      node.style.transitionProperty = value2;
    }
  }
}
function setTransform$1(node, value2) {
  var name = getTransformName();
  if (name) {
    node.style[name] = value2;
    if (name !== "transform") {
      node.style.transform = value2;
    }
  }
}
function getTransitionProperty(node) {
  return node.style.transitionProperty || node.style[getTransitionName$1()];
}
function getTransformXY(node) {
  var style2 = window.getComputedStyle(node, null);
  var transform2 = style2.getPropertyValue("transform") || style2.getPropertyValue(getTransformName());
  if (transform2 && transform2 !== "none") {
    var matrix = transform2.replace(/[^0-9\-.,]/g, "").split(",");
    return {
      x: parseFloat(matrix[12] || matrix[4], 0),
      y: parseFloat(matrix[13] || matrix[5], 0)
    };
  }
  return {
    x: 0,
    y: 0
  };
}
var matrix2d = /matrix\((.*)\)/;
var matrix3d = /matrix3d\((.*)\)/;
function setTransformXY(node, xy) {
  var style2 = window.getComputedStyle(node, null);
  var transform2 = style2.getPropertyValue("transform") || style2.getPropertyValue(getTransformName());
  if (transform2 && transform2 !== "none") {
    var arr;
    var match2d = transform2.match(matrix2d);
    if (match2d) {
      match2d = match2d[1];
      arr = match2d.split(",").map(function(item) {
        return parseFloat(item, 10);
      });
      arr[4] = xy.x;
      arr[5] = xy.y;
      setTransform$1(node, "matrix(".concat(arr.join(","), ")"));
    } else {
      var match3d = transform2.match(matrix3d)[1];
      arr = match3d.split(",").map(function(item) {
        return parseFloat(item, 10);
      });
      arr[12] = xy.x;
      arr[13] = xy.y;
      setTransform$1(node, "matrix3d(".concat(arr.join(","), ")"));
    }
  } else {
    setTransform$1(node, "translateX(".concat(xy.x, "px) translateY(").concat(xy.y, "px) translateZ(0)"));
  }
}
var RE_NUM = /[\-+]?(?:\d*\.|)\d+(?:[eE][\-+]?\d+|)/.source;
var getComputedStyleX;
function forceRelayout(elem) {
  var originalStyle = elem.style.display;
  elem.style.display = "none";
  elem.offsetHeight;
  elem.style.display = originalStyle;
}
function css(el, name, v2) {
  var value2 = v2;
  if (_typeof$3(name) === "object") {
    for (var i2 in name) {
      if (name.hasOwnProperty(i2)) {
        css(el, i2, name[i2]);
      }
    }
    return void 0;
  }
  if (typeof value2 !== "undefined") {
    if (typeof value2 === "number") {
      value2 = "".concat(value2, "px");
    }
    el.style[name] = value2;
    return void 0;
  }
  return getComputedStyleX(el, name);
}
function getClientPosition(elem) {
  var box2;
  var x2;
  var y2;
  var doc = elem.ownerDocument;
  var body = doc.body;
  var docElem = doc && doc.documentElement;
  box2 = elem.getBoundingClientRect();
  x2 = Math.floor(box2.left);
  y2 = Math.floor(box2.top);
  x2 -= docElem.clientLeft || body.clientLeft || 0;
  y2 -= docElem.clientTop || body.clientTop || 0;
  return {
    left: x2,
    top: y2
  };
}
function getScroll$1(w2, top) {
  var ret = w2["page".concat(top ? "Y" : "X", "Offset")];
  var method4 = "scroll".concat(top ? "Top" : "Left");
  if (typeof ret !== "number") {
    var d2 = w2.document;
    ret = d2.documentElement[method4];
    if (typeof ret !== "number") {
      ret = d2.body[method4];
    }
  }
  return ret;
}
function getScrollLeft(w2) {
  return getScroll$1(w2);
}
function getScrollTop(w2) {
  return getScroll$1(w2, true);
}
function getOffset$2(el) {
  var pos = getClientPosition(el);
  var doc = el.ownerDocument;
  var w2 = doc.defaultView || doc.parentWindow;
  pos.left += getScrollLeft(w2);
  pos.top += getScrollTop(w2);
  return pos;
}
function isWindow(obj) {
  return obj !== null && obj !== void 0 && obj == obj.window;
}
function getDocument(node) {
  if (isWindow(node)) {
    return node.document;
  }
  if (node.nodeType === 9) {
    return node;
  }
  return node.ownerDocument;
}
function _getComputedStyle(elem, name, cs) {
  var computedStyle = cs;
  var val = "";
  var d2 = getDocument(elem);
  computedStyle = computedStyle || d2.defaultView.getComputedStyle(elem, null);
  if (computedStyle) {
    val = computedStyle.getPropertyValue(name) || computedStyle[name];
  }
  return val;
}
var _RE_NUM_NO_PX = new RegExp("^(".concat(RE_NUM, ")(?!px)[a-z%]+$"), "i");
var RE_POS = /^(top|right|bottom|left)$/;
var CURRENT_STYLE = "currentStyle";
var RUNTIME_STYLE = "runtimeStyle";
var LEFT$1 = "left";
var PX = "px";
function _getComputedStyleIE(elem, name) {
  var ret = elem[CURRENT_STYLE] && elem[CURRENT_STYLE][name];
  if (_RE_NUM_NO_PX.test(ret) && !RE_POS.test(name)) {
    var style2 = elem.style;
    var left2 = style2[LEFT$1];
    var rsLeft = elem[RUNTIME_STYLE][LEFT$1];
    elem[RUNTIME_STYLE][LEFT$1] = elem[CURRENT_STYLE][LEFT$1];
    style2[LEFT$1] = name === "fontSize" ? "1em" : ret || 0;
    ret = style2.pixelLeft + PX;
    style2[LEFT$1] = left2;
    elem[RUNTIME_STYLE][LEFT$1] = rsLeft;
  }
  return ret === "" ? "auto" : ret;
}
if (typeof window !== "undefined") {
  getComputedStyleX = window.getComputedStyle ? _getComputedStyle : _getComputedStyleIE;
}
function getOffsetDirection(dir, option) {
  if (dir === "left") {
    return option.useCssRight ? "right" : dir;
  }
  return option.useCssBottom ? "bottom" : dir;
}
function oppositeOffsetDirection(dir) {
  if (dir === "left") {
    return "right";
  } else if (dir === "right") {
    return "left";
  } else if (dir === "top") {
    return "bottom";
  } else if (dir === "bottom") {
    return "top";
  }
}
function setLeftTop(elem, offset3, option) {
  if (css(elem, "position") === "static") {
    elem.style.position = "relative";
  }
  var presetH = -999;
  var presetV = -999;
  var horizontalProperty = getOffsetDirection("left", option);
  var verticalProperty = getOffsetDirection("top", option);
  var oppositeHorizontalProperty = oppositeOffsetDirection(horizontalProperty);
  var oppositeVerticalProperty = oppositeOffsetDirection(verticalProperty);
  if (horizontalProperty !== "left") {
    presetH = 999;
  }
  if (verticalProperty !== "top") {
    presetV = 999;
  }
  var originalTransition = "";
  var originalOffset = getOffset$2(elem);
  if ("left" in offset3 || "top" in offset3) {
    originalTransition = getTransitionProperty(elem) || "";
    setTransitionProperty(elem, "none");
  }
  if ("left" in offset3) {
    elem.style[oppositeHorizontalProperty] = "";
    elem.style[horizontalProperty] = "".concat(presetH, "px");
  }
  if ("top" in offset3) {
    elem.style[oppositeVerticalProperty] = "";
    elem.style[verticalProperty] = "".concat(presetV, "px");
  }
  forceRelayout(elem);
  var old = getOffset$2(elem);
  var originalStyle = {};
  for (var key2 in offset3) {
    if (offset3.hasOwnProperty(key2)) {
      var dir = getOffsetDirection(key2, option);
      var preset2 = key2 === "left" ? presetH : presetV;
      var off = originalOffset[key2] - old[key2];
      if (dir === key2) {
        originalStyle[dir] = preset2 + off;
      } else {
        originalStyle[dir] = preset2 - off;
      }
    }
  }
  css(elem, originalStyle);
  forceRelayout(elem);
  if ("left" in offset3 || "top" in offset3) {
    setTransitionProperty(elem, originalTransition);
  }
  var ret = {};
  for (var _key in offset3) {
    if (offset3.hasOwnProperty(_key)) {
      var _dir = getOffsetDirection(_key, option);
      var _off = offset3[_key] - originalOffset[_key];
      if (_key === _dir) {
        ret[_dir] = originalStyle[_dir] + _off;
      } else {
        ret[_dir] = originalStyle[_dir] - _off;
      }
    }
  }
  css(elem, ret);
}
function setTransform$1$1(elem, offset3) {
  var originalOffset = getOffset$2(elem);
  var originalXY = getTransformXY(elem);
  var resultXY = {
    x: originalXY.x,
    y: originalXY.y
  };
  if ("left" in offset3) {
    resultXY.x = originalXY.x + offset3.left - originalOffset.left;
  }
  if ("top" in offset3) {
    resultXY.y = originalXY.y + offset3.top - originalOffset.top;
  }
  setTransformXY(elem, resultXY);
}
function setOffset(elem, offset3, option) {
  if (option.ignoreShake) {
    var oriOffset = getOffset$2(elem);
    var oLeft = oriOffset.left.toFixed(0);
    var oTop = oriOffset.top.toFixed(0);
    var tLeft = offset3.left.toFixed(0);
    var tTop = offset3.top.toFixed(0);
    if (oLeft === tLeft && oTop === tTop) {
      return;
    }
  }
  if (option.useCssRight || option.useCssBottom) {
    setLeftTop(elem, offset3, option);
  } else if (option.useCssTransform && getTransformName() in document.body.style) {
    setTransform$1$1(elem, offset3);
  } else {
    setLeftTop(elem, offset3, option);
  }
}
function each$2(arr, fn2) {
  for (var i2 = 0; i2 < arr.length; i2++) {
    fn2(arr[i2]);
  }
}
function isBorderBoxFn(elem) {
  return getComputedStyleX(elem, "boxSizing") === "border-box";
}
var BOX_MODELS = ["margin", "border", "padding"];
var CONTENT_INDEX = -1;
var PADDING_INDEX = 2;
var BORDER_INDEX = 1;
var MARGIN_INDEX = 0;
function swap$2(elem, options, callback) {
  var old = {};
  var style2 = elem.style;
  var name;
  for (name in options) {
    if (options.hasOwnProperty(name)) {
      old[name] = style2[name];
      style2[name] = options[name];
    }
  }
  callback.call(elem);
  for (name in options) {
    if (options.hasOwnProperty(name)) {
      style2[name] = old[name];
    }
  }
}
function getPBMWidth(elem, props, which) {
  var value2 = 0;
  var prop;
  var j2;
  var i2;
  for (j2 = 0; j2 < props.length; j2++) {
    prop = props[j2];
    if (prop) {
      for (i2 = 0; i2 < which.length; i2++) {
        var cssProp = void 0;
        if (prop === "border") {
          cssProp = "".concat(prop).concat(which[i2], "Width");
        } else {
          cssProp = prop + which[i2];
        }
        value2 += parseFloat(getComputedStyleX(elem, cssProp)) || 0;
      }
    }
  }
  return value2;
}
var domUtils = {
  getParent: function getParent2(element) {
    var parent = element;
    do {
      if (parent.nodeType === 11 && parent.host) {
        parent = parent.host;
      } else {
        parent = parent.parentNode;
      }
    } while (parent && parent.nodeType !== 1 && parent.nodeType !== 9);
    return parent;
  }
};
each$2(["Width", "Height"], function(name) {
  domUtils["doc".concat(name)] = function(refWin) {
    var d2 = refWin.document;
    return Math.max(
      d2.documentElement["scroll".concat(name)],
      d2.body["scroll".concat(name)],
      domUtils["viewport".concat(name)](d2)
    );
  };
  domUtils["viewport".concat(name)] = function(win) {
    var prop = "client".concat(name);
    var doc = win.document;
    var body = doc.body;
    var documentElement = doc.documentElement;
    var documentElementProp = documentElement[prop];
    return doc.compatMode === "CSS1Compat" && documentElementProp || body && body[prop] || documentElementProp;
  };
});
function getWH(elem, name, ex) {
  var extra = ex;
  if (isWindow(elem)) {
    return name === "width" ? domUtils.viewportWidth(elem) : domUtils.viewportHeight(elem);
  } else if (elem.nodeType === 9) {
    return name === "width" ? domUtils.docWidth(elem) : domUtils.docHeight(elem);
  }
  var which = name === "width" ? ["Left", "Right"] : ["Top", "Bottom"];
  var borderBoxValue = name === "width" ? Math.floor(elem.getBoundingClientRect().width) : Math.floor(elem.getBoundingClientRect().height);
  var isBorderBox = isBorderBoxFn(elem);
  var cssBoxValue = 0;
  if (borderBoxValue === null || borderBoxValue === void 0 || borderBoxValue <= 0) {
    borderBoxValue = void 0;
    cssBoxValue = getComputedStyleX(elem, name);
    if (cssBoxValue === null || cssBoxValue === void 0 || Number(cssBoxValue) < 0) {
      cssBoxValue = elem.style[name] || 0;
    }
    cssBoxValue = parseFloat(cssBoxValue) || 0;
  }
  if (extra === void 0) {
    extra = isBorderBox ? BORDER_INDEX : CONTENT_INDEX;
  }
  var borderBoxValueOrIsBorderBox = borderBoxValue !== void 0 || isBorderBox;
  var val = borderBoxValue || cssBoxValue;
  if (extra === CONTENT_INDEX) {
    if (borderBoxValueOrIsBorderBox) {
      return val - getPBMWidth(elem, ["border", "padding"], which);
    }
    return cssBoxValue;
  } else if (borderBoxValueOrIsBorderBox) {
    if (extra === BORDER_INDEX) {
      return val;
    }
    return val + (extra === PADDING_INDEX ? -getPBMWidth(elem, ["border"], which) : getPBMWidth(elem, ["margin"], which));
  }
  return cssBoxValue + getPBMWidth(elem, BOX_MODELS.slice(extra), which);
}
var cssShow = {
  position: "absolute",
  visibility: "hidden",
  display: "block"
};
function getWHIgnoreDisplay() {
  for (var _len = arguments.length, args = new Array(_len), _key2 = 0; _key2 < _len; _key2++) {
    args[_key2] = arguments[_key2];
  }
  var val;
  var elem = args[0];
  if (elem.offsetWidth !== 0) {
    val = getWH.apply(void 0, args);
  } else {
    swap$2(elem, cssShow, function() {
      val = getWH.apply(void 0, args);
    });
  }
  return val;
}
each$2(["width", "height"], function(name) {
  var first = name.charAt(0).toUpperCase() + name.slice(1);
  domUtils["outer".concat(first)] = function(el, includeMargin) {
    return el && getWHIgnoreDisplay(el, name, includeMargin ? MARGIN_INDEX : BORDER_INDEX);
  };
  var which = name === "width" ? ["Left", "Right"] : ["Top", "Bottom"];
  domUtils[name] = function(elem, v2) {
    var val = v2;
    if (val !== void 0) {
      if (elem) {
        var isBorderBox = isBorderBoxFn(elem);
        if (isBorderBox) {
          val += getPBMWidth(elem, ["padding", "border"], which);
        }
        return css(elem, name, val);
      }
      return void 0;
    }
    return elem && getWHIgnoreDisplay(elem, name, CONTENT_INDEX);
  };
});
function mix$1(to, from) {
  for (var i2 in from) {
    if (from.hasOwnProperty(i2)) {
      to[i2] = from[i2];
    }
  }
  return to;
}
var utils$1 = {
  getWindow: function getWindow(node) {
    if (node && node.document && node.setTimeout) {
      return node;
    }
    var doc = node.ownerDocument || node;
    return doc.defaultView || doc.parentWindow;
  },
  getDocument,
  offset: function offset2(el, value2, option) {
    if (typeof value2 !== "undefined") {
      setOffset(el, value2, option || {});
    } else {
      return getOffset$2(el);
    }
  },
  isWindow,
  each: each$2,
  css,
  clone: function clone2(obj) {
    var i2;
    var ret = {};
    for (i2 in obj) {
      if (obj.hasOwnProperty(i2)) {
        ret[i2] = obj[i2];
      }
    }
    var overflow = obj.overflow;
    if (overflow) {
      for (i2 in obj) {
        if (obj.hasOwnProperty(i2)) {
          ret.overflow[i2] = obj.overflow[i2];
        }
      }
    }
    return ret;
  },
  mix: mix$1,
  getWindowScrollLeft: function getWindowScrollLeft(w2) {
    return getScrollLeft(w2);
  },
  getWindowScrollTop: function getWindowScrollTop(w2) {
    return getScrollTop(w2);
  },
  merge: function merge2() {
    var ret = {};
    for (var i2 = 0; i2 < arguments.length; i2++) {
      utils$1.mix(ret, i2 < 0 || arguments.length <= i2 ? void 0 : arguments[i2]);
    }
    return ret;
  },
  viewportWidth: 0,
  viewportHeight: 0
};
mix$1(utils$1, domUtils);
var getParent$1 = utils$1.getParent;
function getOffsetParent(element) {
  if (utils$1.isWindow(element) || element.nodeType === 9) {
    return null;
  }
  var doc = utils$1.getDocument(element);
  var body = doc.body;
  var parent;
  var positionStyle = utils$1.css(element, "position");
  var skipStatic = positionStyle === "fixed" || positionStyle === "absolute";
  if (!skipStatic) {
    return element.nodeName.toLowerCase() === "html" ? null : getParent$1(element);
  }
  for (parent = getParent$1(element); parent && parent !== body && parent.nodeType !== 9; parent = getParent$1(parent)) {
    positionStyle = utils$1.css(parent, "position");
    if (positionStyle !== "static") {
      return parent;
    }
  }
  return null;
}
var getParent$1$1 = utils$1.getParent;
function isAncestorFixed(element) {
  if (utils$1.isWindow(element) || element.nodeType === 9) {
    return false;
  }
  var doc = utils$1.getDocument(element);
  var body = doc.body;
  var parent = null;
  for (parent = getParent$1$1(element); parent && parent !== body && parent !== doc; parent = getParent$1$1(parent)) {
    var positionStyle = utils$1.css(parent, "position");
    if (positionStyle === "fixed") {
      return true;
    }
  }
  return false;
}
function getVisibleRectForElement(element, alwaysByViewport) {
  var visibleRect = {
    left: 0,
    right: Infinity,
    top: 0,
    bottom: Infinity
  };
  var el = getOffsetParent(element);
  var doc = utils$1.getDocument(element);
  var win = doc.defaultView || doc.parentWindow;
  var body = doc.body;
  var documentElement = doc.documentElement;
  while (el) {
    if ((navigator.userAgent.indexOf("MSIE") === -1 || el.clientWidth !== 0) && el !== body && el !== documentElement && utils$1.css(el, "overflow") !== "visible") {
      var pos = utils$1.offset(el);
      pos.left += el.clientLeft;
      pos.top += el.clientTop;
      visibleRect.top = Math.max(visibleRect.top, pos.top);
      visibleRect.right = Math.min(
        visibleRect.right,
        pos.left + el.clientWidth
      );
      visibleRect.bottom = Math.min(visibleRect.bottom, pos.top + el.clientHeight);
      visibleRect.left = Math.max(visibleRect.left, pos.left);
    } else if (el === body || el === documentElement) {
      break;
    }
    el = getOffsetParent(el);
  }
  var originalPosition = null;
  if (!utils$1.isWindow(element) && element.nodeType !== 9) {
    originalPosition = element.style.position;
    var position = utils$1.css(element, "position");
    if (position === "absolute") {
      element.style.position = "fixed";
    }
  }
  var scrollX = utils$1.getWindowScrollLeft(win);
  var scrollY = utils$1.getWindowScrollTop(win);
  var viewportWidth = utils$1.viewportWidth(win);
  var viewportHeight = utils$1.viewportHeight(win);
  var documentWidth = documentElement.scrollWidth;
  var documentHeight = documentElement.scrollHeight;
  var bodyStyle = window.getComputedStyle(body);
  if (bodyStyle.overflowX === "hidden") {
    documentWidth = win.innerWidth;
  }
  if (bodyStyle.overflowY === "hidden") {
    documentHeight = win.innerHeight;
  }
  if (element.style) {
    element.style.position = originalPosition;
  }
  if (alwaysByViewport || isAncestorFixed(element)) {
    visibleRect.left = Math.max(visibleRect.left, scrollX);
    visibleRect.top = Math.max(visibleRect.top, scrollY);
    visibleRect.right = Math.min(visibleRect.right, scrollX + viewportWidth);
    visibleRect.bottom = Math.min(visibleRect.bottom, scrollY + viewportHeight);
  } else {
    var maxVisibleWidth = Math.max(documentWidth, scrollX + viewportWidth);
    visibleRect.right = Math.min(visibleRect.right, maxVisibleWidth);
    var maxVisibleHeight = Math.max(documentHeight, scrollY + viewportHeight);
    visibleRect.bottom = Math.min(visibleRect.bottom, maxVisibleHeight);
  }
  return visibleRect.top >= 0 && visibleRect.left >= 0 && visibleRect.bottom > visibleRect.top && visibleRect.right > visibleRect.left ? visibleRect : null;
}
function adjustForViewport(elFuturePos, elRegion, visibleRect, overflow) {
  var pos = utils$1.clone(elFuturePos);
  var size2 = {
    width: elRegion.width,
    height: elRegion.height
  };
  if (overflow.adjustX && pos.left < visibleRect.left) {
    pos.left = visibleRect.left;
  }
  if (overflow.resizeWidth && pos.left >= visibleRect.left && pos.left + size2.width > visibleRect.right) {
    size2.width -= pos.left + size2.width - visibleRect.right;
  }
  if (overflow.adjustX && pos.left + size2.width > visibleRect.right) {
    pos.left = Math.max(visibleRect.right - size2.width, visibleRect.left);
  }
  if (overflow.adjustY && pos.top < visibleRect.top) {
    pos.top = visibleRect.top;
  }
  if (overflow.resizeHeight && pos.top >= visibleRect.top && pos.top + size2.height > visibleRect.bottom) {
    size2.height -= pos.top + size2.height - visibleRect.bottom;
  }
  if (overflow.adjustY && pos.top + size2.height > visibleRect.bottom) {
    pos.top = Math.max(visibleRect.bottom - size2.height, visibleRect.top);
  }
  return utils$1.mix(pos, size2);
}
function getRegion(node) {
  var offset3;
  var w2;
  var h2;
  if (!utils$1.isWindow(node) && node.nodeType !== 9) {
    offset3 = utils$1.offset(node);
    w2 = utils$1.outerWidth(node);
    h2 = utils$1.outerHeight(node);
  } else {
    var win = utils$1.getWindow(node);
    offset3 = {
      left: utils$1.getWindowScrollLeft(win),
      top: utils$1.getWindowScrollTop(win)
    };
    w2 = utils$1.viewportWidth(win);
    h2 = utils$1.viewportHeight(win);
  }
  offset3.width = w2;
  offset3.height = h2;
  return offset3;
}
function getAlignOffset(region, align) {
  var V2 = align.charAt(0);
  var H2 = align.charAt(1);
  var w2 = region.width;
  var h2 = region.height;
  var x2 = region.left;
  var y2 = region.top;
  if (V2 === "c") {
    y2 += h2 / 2;
  } else if (V2 === "b") {
    y2 += h2;
  }
  if (H2 === "c") {
    x2 += w2 / 2;
  } else if (H2 === "r") {
    x2 += w2;
  }
  return {
    left: x2,
    top: y2
  };
}
function getElFuturePos(elRegion, refNodeRegion, points2, offset3, targetOffset2) {
  var p1 = getAlignOffset(refNodeRegion, points2[1]);
  var p2 = getAlignOffset(elRegion, points2[0]);
  var diff2 = [p2.left - p1.left, p2.top - p1.top];
  return {
    left: Math.round(elRegion.left - diff2[0] + offset3[0] - targetOffset2[0]),
    top: Math.round(elRegion.top - diff2[1] + offset3[1] - targetOffset2[1])
  };
}
function isFailX(elFuturePos, elRegion, visibleRect) {
  return elFuturePos.left < visibleRect.left || elFuturePos.left + elRegion.width > visibleRect.right;
}
function isFailY(elFuturePos, elRegion, visibleRect) {
  return elFuturePos.top < visibleRect.top || elFuturePos.top + elRegion.height > visibleRect.bottom;
}
function isCompleteFailX(elFuturePos, elRegion, visibleRect) {
  return elFuturePos.left > visibleRect.right || elFuturePos.left + elRegion.width < visibleRect.left;
}
function isCompleteFailY(elFuturePos, elRegion, visibleRect) {
  return elFuturePos.top > visibleRect.bottom || elFuturePos.top + elRegion.height < visibleRect.top;
}
function flip(points2, reg, map2) {
  var ret = [];
  utils$1.each(points2, function(p2) {
    ret.push(p2.replace(reg, function(m2) {
      return map2[m2];
    }));
  });
  return ret;
}
function flipOffset(offset3, index2) {
  offset3[index2] = -offset3[index2];
  return offset3;
}
function convertOffset(str, offsetLen) {
  var n2;
  if (/%$/.test(str)) {
    n2 = parseInt(str.substring(0, str.length - 1), 10) / 100 * offsetLen;
  } else {
    n2 = parseInt(str, 10);
  }
  return n2 || 0;
}
function normalizeOffset(offset3, el) {
  offset3[0] = convertOffset(offset3[0], el.width);
  offset3[1] = convertOffset(offset3[1], el.height);
}
function doAlign(el, tgtRegion, align, isTgtRegionVisible) {
  var points2 = align.points;
  var offset3 = align.offset || [0, 0];
  var targetOffset2 = align.targetOffset || [0, 0];
  var overflow = align.overflow;
  var source = align.source || el;
  offset3 = [].concat(offset3);
  targetOffset2 = [].concat(targetOffset2);
  overflow = overflow || {};
  var newOverflowCfg = {};
  var fail = 0;
  var alwaysByViewport = !!(overflow && overflow.alwaysByViewport);
  var visibleRect = getVisibleRectForElement(source, alwaysByViewport);
  var elRegion = getRegion(source);
  normalizeOffset(offset3, elRegion);
  normalizeOffset(targetOffset2, tgtRegion);
  var elFuturePos = getElFuturePos(elRegion, tgtRegion, points2, offset3, targetOffset2);
  var newElRegion = utils$1.merge(elRegion, elFuturePos);
  if (visibleRect && (overflow.adjustX || overflow.adjustY) && isTgtRegionVisible) {
    if (overflow.adjustX) {
      if (isFailX(elFuturePos, elRegion, visibleRect)) {
        var newPoints = flip(points2, /[lr]/gi, {
          l: "r",
          r: "l"
        });
        var newOffset = flipOffset(offset3, 0);
        var newTargetOffset = flipOffset(targetOffset2, 0);
        var newElFuturePos = getElFuturePos(elRegion, tgtRegion, newPoints, newOffset, newTargetOffset);
        if (!isCompleteFailX(newElFuturePos, elRegion, visibleRect)) {
          fail = 1;
          points2 = newPoints;
          offset3 = newOffset;
          targetOffset2 = newTargetOffset;
        }
      }
    }
    if (overflow.adjustY) {
      if (isFailY(elFuturePos, elRegion, visibleRect)) {
        var _newPoints = flip(points2, /[tb]/gi, {
          t: "b",
          b: "t"
        });
        var _newOffset = flipOffset(offset3, 1);
        var _newTargetOffset = flipOffset(targetOffset2, 1);
        var _newElFuturePos = getElFuturePos(elRegion, tgtRegion, _newPoints, _newOffset, _newTargetOffset);
        if (!isCompleteFailY(_newElFuturePos, elRegion, visibleRect)) {
          fail = 1;
          points2 = _newPoints;
          offset3 = _newOffset;
          targetOffset2 = _newTargetOffset;
        }
      }
    }
    if (fail) {
      elFuturePos = getElFuturePos(elRegion, tgtRegion, points2, offset3, targetOffset2);
      utils$1.mix(newElRegion, elFuturePos);
    }
    var isStillFailX = isFailX(elFuturePos, elRegion, visibleRect);
    var isStillFailY = isFailY(elFuturePos, elRegion, visibleRect);
    if (isStillFailX || isStillFailY) {
      var _newPoints2 = points2;
      if (isStillFailX) {
        _newPoints2 = flip(points2, /[lr]/gi, {
          l: "r",
          r: "l"
        });
      }
      if (isStillFailY) {
        _newPoints2 = flip(points2, /[tb]/gi, {
          t: "b",
          b: "t"
        });
      }
      points2 = _newPoints2;
      offset3 = align.offset || [0, 0];
      targetOffset2 = align.targetOffset || [0, 0];
    }
    newOverflowCfg.adjustX = overflow.adjustX && isStillFailX;
    newOverflowCfg.adjustY = overflow.adjustY && isStillFailY;
    if (newOverflowCfg.adjustX || newOverflowCfg.adjustY) {
      newElRegion = adjustForViewport(elFuturePos, elRegion, visibleRect, newOverflowCfg);
    }
  }
  if (newElRegion.width !== elRegion.width) {
    utils$1.css(source, "width", utils$1.width(source) + newElRegion.width - elRegion.width);
  }
  if (newElRegion.height !== elRegion.height) {
    utils$1.css(source, "height", utils$1.height(source) + newElRegion.height - elRegion.height);
  }
  utils$1.offset(source, {
    left: newElRegion.left,
    top: newElRegion.top
  }, {
    useCssRight: align.useCssRight,
    useCssBottom: align.useCssBottom,
    useCssTransform: align.useCssTransform,
    ignoreShake: align.ignoreShake
  });
  return {
    points: points2,
    offset: offset3,
    targetOffset: targetOffset2,
    overflow: newOverflowCfg
  };
}
function isOutOfVisibleRect(target, alwaysByViewport) {
  var visibleRect = getVisibleRectForElement(target, alwaysByViewport);
  var targetRegion = getRegion(target);
  return !visibleRect || targetRegion.left + targetRegion.width <= visibleRect.left || targetRegion.top + targetRegion.height <= visibleRect.top || targetRegion.left >= visibleRect.right || targetRegion.top >= visibleRect.bottom;
}
function alignElement(el, refNode, align) {
  var target = align.target || refNode;
  var refNodeRegion = getRegion(target);
  var isTargetNotOutOfVisible = !isOutOfVisibleRect(target, align.overflow && align.overflow.alwaysByViewport);
  return doAlign(el, refNodeRegion, align, isTargetNotOutOfVisible);
}
alignElement.__getOffsetParent = getOffsetParent;
alignElement.__getVisibleRectForElement = getVisibleRectForElement;
function alignPoint(el, tgtPoint, align) {
  var pageX;
  var pageY;
  var doc = utils$1.getDocument(el);
  var win = doc.defaultView || doc.parentWindow;
  var scrollX = utils$1.getWindowScrollLeft(win);
  var scrollY = utils$1.getWindowScrollTop(win);
  var viewportWidth = utils$1.viewportWidth(win);
  var viewportHeight = utils$1.viewportHeight(win);
  if ("pageX" in tgtPoint) {
    pageX = tgtPoint.pageX;
  } else {
    pageX = scrollX + tgtPoint.clientX;
  }
  if ("pageY" in tgtPoint) {
    pageY = tgtPoint.pageY;
  } else {
    pageY = scrollY + tgtPoint.clientY;
  }
  var tgtRegion = {
    left: pageX,
    top: pageY,
    width: 0,
    height: 0
  };
  var pointInView = pageX >= 0 && pageX <= scrollX + viewportWidth && pageY >= 0 && pageY <= scrollY + viewportHeight;
  var points2 = [align.points[0], "cc"];
  return doAlign(el, tgtRegion, _objectSpread2(_objectSpread2({}, align), {}, {
    points: points2
  }), pointInView);
}
function listCacheClear$1() {
  this.__data__ = [];
  this.size = 0;
}
var _listCacheClear = listCacheClear$1;
function eq$2(value2, other2) {
  return value2 === other2 || value2 !== value2 && other2 !== other2;
}
var eq_1 = eq$2;
var eq$1 = eq_1;
function assocIndexOf$4(array4, key2) {
  var length2 = array4.length;
  while (length2--) {
    if (eq$1(array4[length2][0], key2)) {
      return length2;
    }
  }
  return -1;
}
var _assocIndexOf = assocIndexOf$4;
var assocIndexOf$3 = _assocIndexOf;
var arrayProto = Array.prototype;
var splice$1 = arrayProto.splice;
function listCacheDelete$1(key2) {
  var data2 = this.__data__, index2 = assocIndexOf$3(data2, key2);
  if (index2 < 0) {
    return false;
  }
  var lastIndex = data2.length - 1;
  if (index2 == lastIndex) {
    data2.pop();
  } else {
    splice$1.call(data2, index2, 1);
  }
  --this.size;
  return true;
}
var _listCacheDelete = listCacheDelete$1;
var assocIndexOf$2 = _assocIndexOf;
function listCacheGet$1(key2) {
  var data2 = this.__data__, index2 = assocIndexOf$2(data2, key2);
  return index2 < 0 ? void 0 : data2[index2][1];
}
var _listCacheGet = listCacheGet$1;
var assocIndexOf$1 = _assocIndexOf;
function listCacheHas$1(key2) {
  return assocIndexOf$1(this.__data__, key2) > -1;
}
var _listCacheHas = listCacheHas$1;
var assocIndexOf = _assocIndexOf;
function listCacheSet$1(key2, value2) {
  var data2 = this.__data__, index2 = assocIndexOf(data2, key2);
  if (index2 < 0) {
    ++this.size;
    data2.push([key2, value2]);
  } else {
    data2[index2][1] = value2;
  }
  return this;
}
var _listCacheSet = listCacheSet$1;
var listCacheClear = _listCacheClear, listCacheDelete = _listCacheDelete, listCacheGet = _listCacheGet, listCacheHas = _listCacheHas, listCacheSet = _listCacheSet;
function ListCache$4(entries) {
  var index2 = -1, length2 = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length2) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
ListCache$4.prototype.clear = listCacheClear;
ListCache$4.prototype["delete"] = listCacheDelete;
ListCache$4.prototype.get = listCacheGet;
ListCache$4.prototype.has = listCacheHas;
ListCache$4.prototype.set = listCacheSet;
var _ListCache = ListCache$4;
var ListCache$3 = _ListCache;
function stackClear$1() {
  this.__data__ = new ListCache$3();
  this.size = 0;
}
var _stackClear = stackClear$1;
function stackDelete$1(key2) {
  var data2 = this.__data__, result = data2["delete"](key2);
  this.size = data2.size;
  return result;
}
var _stackDelete = stackDelete$1;
function stackGet$1(key2) {
  return this.__data__.get(key2);
}
var _stackGet = stackGet$1;
function stackHas$1(key2) {
  return this.__data__.has(key2);
}
var _stackHas = stackHas$1;
var freeGlobal$1 = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
var _freeGlobal = freeGlobal$1;
var freeGlobal = _freeGlobal;
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root$9 = freeGlobal || freeSelf || Function("return this")();
var _root = root$9;
var root$8 = _root;
var Symbol$4 = root$8.Symbol;
var _Symbol = Symbol$4;
var Symbol$3 = _Symbol;
var objectProto$c = Object.prototype;
var hasOwnProperty$c = objectProto$c.hasOwnProperty;
var nativeObjectToString$1 = objectProto$c.toString;
var symToStringTag$1 = Symbol$3 ? Symbol$3.toStringTag : void 0;
function getRawTag$1(value2) {
  var isOwn = hasOwnProperty$c.call(value2, symToStringTag$1), tag = value2[symToStringTag$1];
  try {
    value2[symToStringTag$1] = void 0;
    var unmasked = true;
  } catch (e3) {
  }
  var result = nativeObjectToString$1.call(value2);
  if (unmasked) {
    if (isOwn) {
      value2[symToStringTag$1] = tag;
    } else {
      delete value2[symToStringTag$1];
    }
  }
  return result;
}
var _getRawTag = getRawTag$1;
var objectProto$b = Object.prototype;
var nativeObjectToString = objectProto$b.toString;
function objectToString$1(value2) {
  return nativeObjectToString.call(value2);
}
var _objectToString = objectToString$1;
var Symbol$2 = _Symbol, getRawTag = _getRawTag, objectToString = _objectToString;
var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
var symToStringTag = Symbol$2 ? Symbol$2.toStringTag : void 0;
function baseGetTag$5(value2) {
  if (value2 == null) {
    return value2 === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag && symToStringTag in Object(value2) ? getRawTag(value2) : objectToString(value2);
}
var _baseGetTag = baseGetTag$5;
function isObject$6(value2) {
  var type4 = typeof value2;
  return value2 != null && (type4 == "object" || type4 == "function");
}
var isObject_1 = isObject$6;
var baseGetTag$4 = _baseGetTag, isObject$5 = isObject_1;
var asyncTag = "[object AsyncFunction]", funcTag$1 = "[object Function]", genTag = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
function isFunction$4(value2) {
  if (!isObject$5(value2)) {
    return false;
  }
  var tag = baseGetTag$4(value2);
  return tag == funcTag$1 || tag == genTag || tag == asyncTag || tag == proxyTag;
}
var isFunction_1 = isFunction$4;
var root$7 = _root;
var coreJsData$1 = root$7["__core-js_shared__"];
var _coreJsData = coreJsData$1;
var coreJsData = _coreJsData;
var maskSrcKey = function() {
  var uid2 = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
  return uid2 ? "Symbol(src)_1." + uid2 : "";
}();
function isMasked$1(func) {
  return !!maskSrcKey && maskSrcKey in func;
}
var _isMasked = isMasked$1;
var funcProto$1 = Function.prototype;
var funcToString$1 = funcProto$1.toString;
function toSource$2(func) {
  if (func != null) {
    try {
      return funcToString$1.call(func);
    } catch (e3) {
    }
    try {
      return func + "";
    } catch (e3) {
    }
  }
  return "";
}
var _toSource = toSource$2;
var isFunction$3 = isFunction_1, isMasked = _isMasked, isObject$4 = isObject_1, toSource$1 = _toSource;
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var funcProto = Function.prototype, objectProto$a = Object.prototype;
var funcToString = funcProto.toString;
var hasOwnProperty$b = objectProto$a.hasOwnProperty;
var reIsNative = RegExp(
  "^" + funcToString.call(hasOwnProperty$b).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function baseIsNative$1(value2) {
  if (!isObject$4(value2) || isMasked(value2)) {
    return false;
  }
  var pattern4 = isFunction$3(value2) ? reIsNative : reIsHostCtor;
  return pattern4.test(toSource$1(value2));
}
var _baseIsNative = baseIsNative$1;
function getValue$2(object4, key2) {
  return object4 == null ? void 0 : object4[key2];
}
var _getValue = getValue$2;
var baseIsNative = _baseIsNative, getValue$1 = _getValue;
function getNative$6(object4, key2) {
  var value2 = getValue$1(object4, key2);
  return baseIsNative(value2) ? value2 : void 0;
}
var _getNative = getNative$6;
var getNative$5 = _getNative, root$6 = _root;
var Map$4 = getNative$5(root$6, "Map");
var _Map = Map$4;
var getNative$4 = _getNative;
var nativeCreate$4 = getNative$4(Object, "create");
var _nativeCreate = nativeCreate$4;
var nativeCreate$3 = _nativeCreate;
function hashClear$1() {
  this.__data__ = nativeCreate$3 ? nativeCreate$3(null) : {};
  this.size = 0;
}
var _hashClear = hashClear$1;
function hashDelete$1(key2) {
  var result = this.has(key2) && delete this.__data__[key2];
  this.size -= result ? 1 : 0;
  return result;
}
var _hashDelete = hashDelete$1;
var nativeCreate$2 = _nativeCreate;
var HASH_UNDEFINED$2 = "__lodash_hash_undefined__";
var objectProto$9 = Object.prototype;
var hasOwnProperty$a = objectProto$9.hasOwnProperty;
function hashGet$1(key2) {
  var data2 = this.__data__;
  if (nativeCreate$2) {
    var result = data2[key2];
    return result === HASH_UNDEFINED$2 ? void 0 : result;
  }
  return hasOwnProperty$a.call(data2, key2) ? data2[key2] : void 0;
}
var _hashGet = hashGet$1;
var nativeCreate$1 = _nativeCreate;
var objectProto$8 = Object.prototype;
var hasOwnProperty$9 = objectProto$8.hasOwnProperty;
function hashHas$1(key2) {
  var data2 = this.__data__;
  return nativeCreate$1 ? data2[key2] !== void 0 : hasOwnProperty$9.call(data2, key2);
}
var _hashHas = hashHas$1;
var nativeCreate = _nativeCreate;
var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
function hashSet$1(key2, value2) {
  var data2 = this.__data__;
  this.size += this.has(key2) ? 0 : 1;
  data2[key2] = nativeCreate && value2 === void 0 ? HASH_UNDEFINED$1 : value2;
  return this;
}
var _hashSet = hashSet$1;
var hashClear = _hashClear, hashDelete = _hashDelete, hashGet = _hashGet, hashHas = _hashHas, hashSet = _hashSet;
function Hash$1(entries) {
  var index2 = -1, length2 = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length2) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
Hash$1.prototype.clear = hashClear;
Hash$1.prototype["delete"] = hashDelete;
Hash$1.prototype.get = hashGet;
Hash$1.prototype.has = hashHas;
Hash$1.prototype.set = hashSet;
var _Hash = Hash$1;
var Hash = _Hash, ListCache$2 = _ListCache, Map$3 = _Map;
function mapCacheClear$1() {
  this.size = 0;
  this.__data__ = {
    "hash": new Hash(),
    "map": new (Map$3 || ListCache$2)(),
    "string": new Hash()
  };
}
var _mapCacheClear = mapCacheClear$1;
function isKeyable$1(value2) {
  var type4 = typeof value2;
  return type4 == "string" || type4 == "number" || type4 == "symbol" || type4 == "boolean" ? value2 !== "__proto__" : value2 === null;
}
var _isKeyable = isKeyable$1;
var isKeyable = _isKeyable;
function getMapData$4(map2, key2) {
  var data2 = map2.__data__;
  return isKeyable(key2) ? data2[typeof key2 == "string" ? "string" : "hash"] : data2.map;
}
var _getMapData = getMapData$4;
var getMapData$3 = _getMapData;
function mapCacheDelete$1(key2) {
  var result = getMapData$3(this, key2)["delete"](key2);
  this.size -= result ? 1 : 0;
  return result;
}
var _mapCacheDelete = mapCacheDelete$1;
var getMapData$2 = _getMapData;
function mapCacheGet$1(key2) {
  return getMapData$2(this, key2).get(key2);
}
var _mapCacheGet = mapCacheGet$1;
var getMapData$1 = _getMapData;
function mapCacheHas$1(key2) {
  return getMapData$1(this, key2).has(key2);
}
var _mapCacheHas = mapCacheHas$1;
var getMapData = _getMapData;
function mapCacheSet$1(key2, value2) {
  var data2 = getMapData(this, key2), size2 = data2.size;
  data2.set(key2, value2);
  this.size += data2.size == size2 ? 0 : 1;
  return this;
}
var _mapCacheSet = mapCacheSet$1;
var mapCacheClear = _mapCacheClear, mapCacheDelete = _mapCacheDelete, mapCacheGet = _mapCacheGet, mapCacheHas = _mapCacheHas, mapCacheSet = _mapCacheSet;
function MapCache$2(entries) {
  var index2 = -1, length2 = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length2) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
MapCache$2.prototype.clear = mapCacheClear;
MapCache$2.prototype["delete"] = mapCacheDelete;
MapCache$2.prototype.get = mapCacheGet;
MapCache$2.prototype.has = mapCacheHas;
MapCache$2.prototype.set = mapCacheSet;
var _MapCache = MapCache$2;
var ListCache$1 = _ListCache, Map$2 = _Map, MapCache$1 = _MapCache;
var LARGE_ARRAY_SIZE = 200;
function stackSet$1(key2, value2) {
  var data2 = this.__data__;
  if (data2 instanceof ListCache$1) {
    var pairs = data2.__data__;
    if (!Map$2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
      pairs.push([key2, value2]);
      this.size = ++data2.size;
      return this;
    }
    data2 = this.__data__ = new MapCache$1(pairs);
  }
  data2.set(key2, value2);
  this.size = data2.size;
  return this;
}
var _stackSet = stackSet$1;
var ListCache = _ListCache, stackClear = _stackClear, stackDelete = _stackDelete, stackGet = _stackGet, stackHas = _stackHas, stackSet = _stackSet;
function Stack$2(entries) {
  var data2 = this.__data__ = new ListCache(entries);
  this.size = data2.size;
}
Stack$2.prototype.clear = stackClear;
Stack$2.prototype["delete"] = stackDelete;
Stack$2.prototype.get = stackGet;
Stack$2.prototype.has = stackHas;
Stack$2.prototype.set = stackSet;
var _Stack = Stack$2;
var HASH_UNDEFINED = "__lodash_hash_undefined__";
function setCacheAdd$1(value2) {
  this.__data__.set(value2, HASH_UNDEFINED);
  return this;
}
var _setCacheAdd = setCacheAdd$1;
function setCacheHas$1(value2) {
  return this.__data__.has(value2);
}
var _setCacheHas = setCacheHas$1;
var MapCache = _MapCache, setCacheAdd = _setCacheAdd, setCacheHas = _setCacheHas;
function SetCache$1(values2) {
  var index2 = -1, length2 = values2 == null ? 0 : values2.length;
  this.__data__ = new MapCache();
  while (++index2 < length2) {
    this.add(values2[index2]);
  }
}
SetCache$1.prototype.add = SetCache$1.prototype.push = setCacheAdd;
SetCache$1.prototype.has = setCacheHas;
var _SetCache = SetCache$1;
function arraySome$1(array4, predicate) {
  var index2 = -1, length2 = array4 == null ? 0 : array4.length;
  while (++index2 < length2) {
    if (predicate(array4[index2], index2, array4)) {
      return true;
    }
  }
  return false;
}
var _arraySome = arraySome$1;
function cacheHas$1(cache2, key2) {
  return cache2.has(key2);
}
var _cacheHas = cacheHas$1;
var SetCache = _SetCache, arraySome = _arraySome, cacheHas = _cacheHas;
var COMPARE_PARTIAL_FLAG$3 = 1, COMPARE_UNORDERED_FLAG$1 = 2;
function equalArrays$2(array4, other2, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3, arrLength = array4.length, othLength = other2.length;
  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  var arrStacked = stack.get(array4);
  var othStacked = stack.get(other2);
  if (arrStacked && othStacked) {
    return arrStacked == other2 && othStacked == array4;
  }
  var index2 = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG$1 ? new SetCache() : void 0;
  stack.set(array4, other2);
  stack.set(other2, array4);
  while (++index2 < arrLength) {
    var arrValue = array4[index2], othValue = other2[index2];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, arrValue, index2, other2, array4, stack) : customizer(arrValue, othValue, index2, array4, other2, stack);
    }
    if (compared !== void 0) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    if (seen) {
      if (!arraySome(other2, function(othValue2, othIndex) {
        if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
          return seen.push(othIndex);
        }
      })) {
        result = false;
        break;
      }
    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
      result = false;
      break;
    }
  }
  stack["delete"](array4);
  stack["delete"](other2);
  return result;
}
var _equalArrays = equalArrays$2;
var root$5 = _root;
var Uint8Array$2 = root$5.Uint8Array;
var _Uint8Array = Uint8Array$2;
function mapToArray$1(map2) {
  var index2 = -1, result = Array(map2.size);
  map2.forEach(function(value2, key2) {
    result[++index2] = [key2, value2];
  });
  return result;
}
var _mapToArray = mapToArray$1;
function setToArray$1(set2) {
  var index2 = -1, result = Array(set2.size);
  set2.forEach(function(value2) {
    result[++index2] = value2;
  });
  return result;
}
var _setToArray = setToArray$1;
var Symbol$1 = _Symbol, Uint8Array$1 = _Uint8Array, eq = eq_1, equalArrays$1 = _equalArrays, mapToArray = _mapToArray, setToArray = _setToArray;
var COMPARE_PARTIAL_FLAG$2 = 1, COMPARE_UNORDERED_FLAG = 2;
var boolTag$1 = "[object Boolean]", dateTag$1 = "[object Date]", errorTag$1 = "[object Error]", mapTag$2 = "[object Map]", numberTag$1 = "[object Number]", regexpTag$1 = "[object RegExp]", setTag$2 = "[object Set]", stringTag$1 = "[object String]", symbolTag$1 = "[object Symbol]";
var arrayBufferTag$1 = "[object ArrayBuffer]", dataViewTag$2 = "[object DataView]";
var symbolProto = Symbol$1 ? Symbol$1.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
function equalByTag$1(object4, other2, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag$2:
      if (object4.byteLength != other2.byteLength || object4.byteOffset != other2.byteOffset) {
        return false;
      }
      object4 = object4.buffer;
      other2 = other2.buffer;
    case arrayBufferTag$1:
      if (object4.byteLength != other2.byteLength || !equalFunc(new Uint8Array$1(object4), new Uint8Array$1(other2))) {
        return false;
      }
      return true;
    case boolTag$1:
    case dateTag$1:
    case numberTag$1:
      return eq(+object4, +other2);
    case errorTag$1:
      return object4.name == other2.name && object4.message == other2.message;
    case regexpTag$1:
    case stringTag$1:
      return object4 == other2 + "";
    case mapTag$2:
      var convert = mapToArray;
    case setTag$2:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$2;
      convert || (convert = setToArray);
      if (object4.size != other2.size && !isPartial) {
        return false;
      }
      var stacked = stack.get(object4);
      if (stacked) {
        return stacked == other2;
      }
      bitmask |= COMPARE_UNORDERED_FLAG;
      stack.set(object4, other2);
      var result = equalArrays$1(convert(object4), convert(other2), bitmask, customizer, equalFunc, stack);
      stack["delete"](object4);
      return result;
    case symbolTag$1:
      if (symbolValueOf) {
        return symbolValueOf.call(object4) == symbolValueOf.call(other2);
      }
  }
  return false;
}
var _equalByTag = equalByTag$1;
function arrayPush$1(array4, values2) {
  var index2 = -1, length2 = values2.length, offset3 = array4.length;
  while (++index2 < length2) {
    array4[offset3 + index2] = values2[index2];
  }
  return array4;
}
var _arrayPush = arrayPush$1;
var isArray$6 = Array.isArray;
var isArray_1 = isArray$6;
var arrayPush = _arrayPush, isArray$5 = isArray_1;
function baseGetAllKeys$1(object4, keysFunc, symbolsFunc) {
  var result = keysFunc(object4);
  return isArray$5(object4) ? result : arrayPush(result, symbolsFunc(object4));
}
var _baseGetAllKeys = baseGetAllKeys$1;
function arrayFilter$1(array4, predicate) {
  var index2 = -1, length2 = array4 == null ? 0 : array4.length, resIndex = 0, result = [];
  while (++index2 < length2) {
    var value2 = array4[index2];
    if (predicate(value2, index2, array4)) {
      result[resIndex++] = value2;
    }
  }
  return result;
}
var _arrayFilter = arrayFilter$1;
function stubArray$1() {
  return [];
}
var stubArray_1 = stubArray$1;
var arrayFilter = _arrayFilter, stubArray = stubArray_1;
var objectProto$7 = Object.prototype;
var propertyIsEnumerable$1 = objectProto$7.propertyIsEnumerable;
var nativeGetSymbols = Object.getOwnPropertySymbols;
var getSymbols$1 = !nativeGetSymbols ? stubArray : function(object4) {
  if (object4 == null) {
    return [];
  }
  object4 = Object(object4);
  return arrayFilter(nativeGetSymbols(object4), function(symbol) {
    return propertyIsEnumerable$1.call(object4, symbol);
  });
};
var _getSymbols = getSymbols$1;
function baseTimes$1(n2, iteratee) {
  var index2 = -1, result = Array(n2);
  while (++index2 < n2) {
    result[index2] = iteratee(index2);
  }
  return result;
}
var _baseTimes = baseTimes$1;
function isObjectLike$7(value2) {
  return value2 != null && typeof value2 == "object";
}
var isObjectLike_1 = isObjectLike$7;
var baseGetTag$3 = _baseGetTag, isObjectLike$6 = isObjectLike_1;
var argsTag$2 = "[object Arguments]";
function baseIsArguments$1(value2) {
  return isObjectLike$6(value2) && baseGetTag$3(value2) == argsTag$2;
}
var _baseIsArguments = baseIsArguments$1;
var baseIsArguments = _baseIsArguments, isObjectLike$5 = isObjectLike_1;
var objectProto$6 = Object.prototype;
var hasOwnProperty$8 = objectProto$6.hasOwnProperty;
var propertyIsEnumerable = objectProto$6.propertyIsEnumerable;
var isArguments$1 = baseIsArguments(function() {
  return arguments;
}()) ? baseIsArguments : function(value2) {
  return isObjectLike$5(value2) && hasOwnProperty$8.call(value2, "callee") && !propertyIsEnumerable.call(value2, "callee");
};
var isArguments_1 = isArguments$1;
var isBuffer$3 = { exports: {} };
function stubFalse() {
  return false;
}
var stubFalse_1 = stubFalse;
(function(module, exports) {
  var root2 = _root, stubFalse2 = stubFalse_1;
  var freeExports = exports && !exports.nodeType && exports;
  var freeModule = freeExports && true && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var Buffer2 = moduleExports ? root2.Buffer : void 0;
  var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
  var isBuffer2 = nativeIsBuffer || stubFalse2;
  module.exports = isBuffer2;
})(isBuffer$3, isBuffer$3.exports);
var MAX_SAFE_INTEGER$1 = 9007199254740991;
var reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex$1(value2, length2) {
  var type4 = typeof value2;
  length2 = length2 == null ? MAX_SAFE_INTEGER$1 : length2;
  return !!length2 && (type4 == "number" || type4 != "symbol" && reIsUint.test(value2)) && (value2 > -1 && value2 % 1 == 0 && value2 < length2);
}
var _isIndex = isIndex$1;
var MAX_SAFE_INTEGER = 9007199254740991;
function isLength$2(value2) {
  return typeof value2 == "number" && value2 > -1 && value2 % 1 == 0 && value2 <= MAX_SAFE_INTEGER;
}
var isLength_1 = isLength$2;
var baseGetTag$2 = _baseGetTag, isLength$1 = isLength_1, isObjectLike$4 = isObjectLike_1;
var argsTag$1 = "[object Arguments]", arrayTag$1 = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", mapTag$1 = "[object Map]", numberTag = "[object Number]", objectTag$2 = "[object Object]", regexpTag = "[object RegExp]", setTag$1 = "[object Set]", stringTag = "[object String]", weakMapTag$1 = "[object WeakMap]";
var arrayBufferTag = "[object ArrayBuffer]", dataViewTag$1 = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag$1] = typedArrayTags[arrayTag$1] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag$1] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag$1] = typedArrayTags[numberTag] = typedArrayTags[objectTag$2] = typedArrayTags[regexpTag] = typedArrayTags[setTag$1] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag$1] = false;
function baseIsTypedArray$1(value2) {
  return isObjectLike$4(value2) && isLength$1(value2.length) && !!typedArrayTags[baseGetTag$2(value2)];
}
var _baseIsTypedArray = baseIsTypedArray$1;
function baseUnary$1(func) {
  return function(value2) {
    return func(value2);
  };
}
var _baseUnary = baseUnary$1;
var _nodeUtil = { exports: {} };
(function(module, exports) {
  var freeGlobal2 = _freeGlobal;
  var freeExports = exports && !exports.nodeType && exports;
  var freeModule = freeExports && true && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var freeProcess = moduleExports && freeGlobal2.process;
  var nodeUtil2 = function() {
    try {
      var types2 = freeModule && freeModule.require && freeModule.require("util").types;
      if (types2) {
        return types2;
      }
      return freeProcess && freeProcess.binding && freeProcess.binding("util");
    } catch (e3) {
    }
  }();
  module.exports = nodeUtil2;
})(_nodeUtil, _nodeUtil.exports);
var baseIsTypedArray = _baseIsTypedArray, baseUnary = _baseUnary, nodeUtil = _nodeUtil.exports;
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
var isTypedArray$3 = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
var isTypedArray_1 = isTypedArray$3;
var baseTimes = _baseTimes, isArguments = isArguments_1, isArray$4 = isArray_1, isBuffer$2 = isBuffer$3.exports, isIndex = _isIndex, isTypedArray$2 = isTypedArray_1;
var objectProto$5 = Object.prototype;
var hasOwnProperty$7 = objectProto$5.hasOwnProperty;
function arrayLikeKeys$1(value2, inherited) {
  var isArr = isArray$4(value2), isArg = !isArr && isArguments(value2), isBuff = !isArr && !isArg && isBuffer$2(value2), isType2 = !isArr && !isArg && !isBuff && isTypedArray$2(value2), skipIndexes = isArr || isArg || isBuff || isType2, result = skipIndexes ? baseTimes(value2.length, String) : [], length2 = result.length;
  for (var key2 in value2) {
    if ((inherited || hasOwnProperty$7.call(value2, key2)) && !(skipIndexes && (key2 == "length" || isBuff && (key2 == "offset" || key2 == "parent") || isType2 && (key2 == "buffer" || key2 == "byteLength" || key2 == "byteOffset") || isIndex(key2, length2)))) {
      result.push(key2);
    }
  }
  return result;
}
var _arrayLikeKeys = arrayLikeKeys$1;
var objectProto$4 = Object.prototype;
function isPrototype$2(value2) {
  var Ctor = value2 && value2.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$4;
  return value2 === proto;
}
var _isPrototype = isPrototype$2;
function overArg$1(func, transform2) {
  return function(arg) {
    return func(transform2(arg));
  };
}
var _overArg = overArg$1;
var overArg = _overArg;
var nativeKeys$1 = overArg(Object.keys, Object);
var _nativeKeys = nativeKeys$1;
var isPrototype$1 = _isPrototype, nativeKeys = _nativeKeys;
var objectProto$3 = Object.prototype;
var hasOwnProperty$6 = objectProto$3.hasOwnProperty;
function baseKeys$1(object4) {
  if (!isPrototype$1(object4)) {
    return nativeKeys(object4);
  }
  var result = [];
  for (var key2 in Object(object4)) {
    if (hasOwnProperty$6.call(object4, key2) && key2 != "constructor") {
      result.push(key2);
    }
  }
  return result;
}
var _baseKeys = baseKeys$1;
var isFunction$2 = isFunction_1, isLength = isLength_1;
function isArrayLike$2(value2) {
  return value2 != null && isLength(value2.length) && !isFunction$2(value2);
}
var isArrayLike_1 = isArrayLike$2;
var arrayLikeKeys = _arrayLikeKeys, baseKeys = _baseKeys, isArrayLike$1 = isArrayLike_1;
function keys$2(object4) {
  return isArrayLike$1(object4) ? arrayLikeKeys(object4) : baseKeys(object4);
}
var keys_1 = keys$2;
var baseGetAllKeys = _baseGetAllKeys, getSymbols = _getSymbols, keys$1 = keys_1;
function getAllKeys$1(object4) {
  return baseGetAllKeys(object4, keys$1, getSymbols);
}
var _getAllKeys = getAllKeys$1;
var getAllKeys = _getAllKeys;
var COMPARE_PARTIAL_FLAG$1 = 1;
var objectProto$2 = Object.prototype;
var hasOwnProperty$5 = objectProto$2.hasOwnProperty;
function equalObjects$1(object4, other2, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$1, objProps = getAllKeys(object4), objLength = objProps.length, othProps = getAllKeys(other2), othLength = othProps.length;
  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index2 = objLength;
  while (index2--) {
    var key2 = objProps[index2];
    if (!(isPartial ? key2 in other2 : hasOwnProperty$5.call(other2, key2))) {
      return false;
    }
  }
  var objStacked = stack.get(object4);
  var othStacked = stack.get(other2);
  if (objStacked && othStacked) {
    return objStacked == other2 && othStacked == object4;
  }
  var result = true;
  stack.set(object4, other2);
  stack.set(other2, object4);
  var skipCtor = isPartial;
  while (++index2 < objLength) {
    key2 = objProps[index2];
    var objValue = object4[key2], othValue = other2[key2];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, objValue, key2, other2, object4, stack) : customizer(objValue, othValue, key2, object4, other2, stack);
    }
    if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key2 == "constructor");
  }
  if (result && !skipCtor) {
    var objCtor = object4.constructor, othCtor = other2.constructor;
    if (objCtor != othCtor && ("constructor" in object4 && "constructor" in other2) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack["delete"](object4);
  stack["delete"](other2);
  return result;
}
var _equalObjects = equalObjects$1;
var getNative$3 = _getNative, root$4 = _root;
var DataView$2 = getNative$3(root$4, "DataView");
var _DataView = DataView$2;
var getNative$2 = _getNative, root$3 = _root;
var Promise$2 = getNative$2(root$3, "Promise");
var _Promise = Promise$2;
var getNative$1 = _getNative, root$2 = _root;
var Set$2 = getNative$1(root$2, "Set");
var _Set = Set$2;
var getNative = _getNative, root$1 = _root;
var WeakMap$2 = getNative(root$1, "WeakMap");
var _WeakMap = WeakMap$2;
var DataView$1 = _DataView, Map$1 = _Map, Promise$1 = _Promise, Set$1 = _Set, WeakMap$1 = _WeakMap, baseGetTag$1 = _baseGetTag, toSource = _toSource;
var mapTag = "[object Map]", objectTag$1 = "[object Object]", promiseTag = "[object Promise]", setTag = "[object Set]", weakMapTag = "[object WeakMap]";
var dataViewTag = "[object DataView]";
var dataViewCtorString = toSource(DataView$1), mapCtorString = toSource(Map$1), promiseCtorString = toSource(Promise$1), setCtorString = toSource(Set$1), weakMapCtorString = toSource(WeakMap$1);
var getTag$1 = baseGetTag$1;
if (DataView$1 && getTag$1(new DataView$1(new ArrayBuffer(1))) != dataViewTag || Map$1 && getTag$1(new Map$1()) != mapTag || Promise$1 && getTag$1(Promise$1.resolve()) != promiseTag || Set$1 && getTag$1(new Set$1()) != setTag || WeakMap$1 && getTag$1(new WeakMap$1()) != weakMapTag) {
  getTag$1 = function(value2) {
    var result = baseGetTag$1(value2), Ctor = result == objectTag$1 ? value2.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag;
        case mapCtorString:
          return mapTag;
        case promiseCtorString:
          return promiseTag;
        case setCtorString:
          return setTag;
        case weakMapCtorString:
          return weakMapTag;
      }
    }
    return result;
  };
}
var _getTag = getTag$1;
var Stack$1 = _Stack, equalArrays = _equalArrays, equalByTag = _equalByTag, equalObjects = _equalObjects, getTag = _getTag, isArray$3 = isArray_1, isBuffer$1 = isBuffer$3.exports, isTypedArray$1 = isTypedArray_1;
var COMPARE_PARTIAL_FLAG = 1;
var argsTag = "[object Arguments]", arrayTag = "[object Array]", objectTag = "[object Object]";
var objectProto$1 = Object.prototype;
var hasOwnProperty$4 = objectProto$1.hasOwnProperty;
function baseIsEqualDeep$1(object4, other2, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray$3(object4), othIsArr = isArray$3(other2), objTag = objIsArr ? arrayTag : getTag(object4), othTag = othIsArr ? arrayTag : getTag(other2);
  objTag = objTag == argsTag ? objectTag : objTag;
  othTag = othTag == argsTag ? objectTag : othTag;
  var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
  if (isSameTag && isBuffer$1(object4)) {
    if (!isBuffer$1(other2)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack$1());
    return objIsArr || isTypedArray$1(object4) ? equalArrays(object4, other2, bitmask, customizer, equalFunc, stack) : equalByTag(object4, other2, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
    var objIsWrapped = objIsObj && hasOwnProperty$4.call(object4, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty$4.call(other2, "__wrapped__");
    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object4.value() : object4, othUnwrapped = othIsWrapped ? other2.value() : other2;
      stack || (stack = new Stack$1());
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack$1());
  return equalObjects(object4, other2, bitmask, customizer, equalFunc, stack);
}
var _baseIsEqualDeep = baseIsEqualDeep$1;
var baseIsEqualDeep = _baseIsEqualDeep, isObjectLike$3 = isObjectLike_1;
function baseIsEqual$1(value2, other2, bitmask, customizer, stack) {
  if (value2 === other2) {
    return true;
  }
  if (value2 == null || other2 == null || !isObjectLike$3(value2) && !isObjectLike$3(other2)) {
    return value2 !== value2 && other2 !== other2;
  }
  return baseIsEqualDeep(value2, other2, bitmask, customizer, baseIsEqual$1, stack);
}
var _baseIsEqual = baseIsEqual$1;
var baseIsEqual = _baseIsEqual;
function isEqual$2(value2, other2) {
  return baseIsEqual(value2, other2);
}
var isEqual_1 = isEqual$2;
function isSamePoint$2(prev, next) {
  if (prev === next)
    return true;
  if (!prev || !next)
    return false;
  if ("pageX" in next && "pageY" in next) {
    return prev.pageX === next.pageX && prev.pageY === next.pageY;
  }
  if ("clientX" in next && "clientY" in next) {
    return prev.clientX === next.clientX && prev.clientY === next.clientY;
  }
  return false;
}
function restoreFocus(activeElement, container) {
  if (activeElement !== document.activeElement && contains$1(container, activeElement) && typeof activeElement.focus === "function") {
    activeElement.focus();
  }
}
function monitorResize(element, callback) {
  var prevWidth = null;
  var prevHeight = null;
  function onResize2(_ref) {
    var _ref2 = _slicedToArray$4(_ref, 1), target = _ref2[0].target;
    if (!document.documentElement.contains(target))
      return;
    var _target$getBoundingCl = target.getBoundingClientRect(), width = _target$getBoundingCl.width, height = _target$getBoundingCl.height;
    var fixedWidth = Math.floor(width);
    var fixedHeight = Math.floor(height);
    if (prevWidth !== fixedWidth || prevHeight !== fixedHeight) {
      Promise.resolve().then(function() {
        callback({
          width: fixedWidth,
          height: fixedHeight
        });
      });
    }
    prevWidth = fixedWidth;
    prevHeight = fixedHeight;
  }
  var resizeObserver2 = new index$d(onResize2);
  if (element) {
    resizeObserver2.observe(element);
  }
  return function() {
    resizeObserver2.disconnect();
  };
}
var useBuffer = function(callback, buffer) {
  var calledRef = React.useRef(false);
  var timeoutRef = React.useRef(null);
  function cancelTrigger() {
    window.clearTimeout(timeoutRef.current);
  }
  function trigger(force) {
    cancelTrigger();
    if (!calledRef.current || force === true) {
      if (callback() === false) {
        return;
      }
      calledRef.current = true;
      timeoutRef.current = window.setTimeout(function() {
        calledRef.current = false;
      }, buffer);
    } else {
      timeoutRef.current = window.setTimeout(function() {
        calledRef.current = false;
        trigger();
      }, buffer);
    }
  }
  return [trigger, function() {
    calledRef.current = false;
    cancelTrigger();
  }];
};
function getElement(func) {
  if (typeof func !== "function")
    return null;
  return func();
}
function getPoint$1(point2) {
  if (_typeof$4(point2) !== "object" || !point2)
    return null;
  return point2;
}
var Align = function Align2(_ref, ref) {
  var children = _ref.children, disabled = _ref.disabled, target = _ref.target, align = _ref.align, onAlign = _ref.onAlign, monitorWindowResize = _ref.monitorWindowResize, _ref$monitorBufferTim = _ref.monitorBufferTime, monitorBufferTime = _ref$monitorBufferTim === void 0 ? 0 : _ref$monitorBufferTim;
  var cacheRef = React.useRef({});
  var nodeRef = React.useRef();
  var childNode = React.Children.only(children);
  var forceAlignPropsRef = React.useRef({});
  forceAlignPropsRef.current.disabled = disabled;
  forceAlignPropsRef.current.target = target;
  forceAlignPropsRef.current.align = align;
  forceAlignPropsRef.current.onAlign = onAlign;
  var _useBuffer = useBuffer(function() {
    var _forceAlignPropsRef$c = forceAlignPropsRef.current, latestDisabled = _forceAlignPropsRef$c.disabled, latestTarget = _forceAlignPropsRef$c.target, latestAlign = _forceAlignPropsRef$c.align, latestOnAlign = _forceAlignPropsRef$c.onAlign;
    if (!latestDisabled && latestTarget) {
      var source = nodeRef.current;
      var result;
      var element = getElement(latestTarget);
      var point2 = getPoint$1(latestTarget);
      cacheRef.current.element = element;
      cacheRef.current.point = point2;
      cacheRef.current.align = latestAlign;
      var _document = document, activeElement = _document.activeElement;
      if (element && isVisible(element)) {
        result = alignElement(source, element, latestAlign);
      } else if (point2) {
        result = alignPoint(source, point2, latestAlign);
      }
      restoreFocus(activeElement, source);
      if (latestOnAlign && result) {
        latestOnAlign(source, result);
      }
      return true;
    }
    return false;
  }, monitorBufferTime), _useBuffer2 = _slicedToArray$4(_useBuffer, 2), _forceAlign = _useBuffer2[0], cancelForceAlign = _useBuffer2[1];
  var resizeMonitor = React.useRef({
    cancel: function cancel2() {
    }
  });
  var sourceResizeMonitor = React.useRef({
    cancel: function cancel2() {
    }
  });
  React.useEffect(function() {
    var element = getElement(target);
    var point2 = getPoint$1(target);
    if (nodeRef.current !== sourceResizeMonitor.current.element) {
      sourceResizeMonitor.current.cancel();
      sourceResizeMonitor.current.element = nodeRef.current;
      sourceResizeMonitor.current.cancel = monitorResize(nodeRef.current, _forceAlign);
    }
    if (cacheRef.current.element !== element || !isSamePoint$2(cacheRef.current.point, point2) || !isEqual_1(cacheRef.current.align, align)) {
      _forceAlign();
      if (resizeMonitor.current.element !== element) {
        resizeMonitor.current.cancel();
        resizeMonitor.current.element = element;
        resizeMonitor.current.cancel = monitorResize(element, _forceAlign);
      }
    }
  });
  React.useEffect(function() {
    if (!disabled) {
      _forceAlign();
    } else {
      cancelForceAlign();
    }
  }, [disabled]);
  var winResizeRef = React.useRef(null);
  React.useEffect(function() {
    if (monitorWindowResize) {
      if (!winResizeRef.current) {
        winResizeRef.current = addEventListenerWrap(window, "resize", _forceAlign);
      }
    } else if (winResizeRef.current) {
      winResizeRef.current.remove();
      winResizeRef.current = null;
    }
  }, [monitorWindowResize]);
  React.useEffect(function() {
    return function() {
      resizeMonitor.current.cancel();
      sourceResizeMonitor.current.cancel();
      if (winResizeRef.current)
        winResizeRef.current.remove();
      cancelForceAlign();
    };
  }, []);
  React.useImperativeHandle(ref, function() {
    return {
      forceAlign: function forceAlign() {
        return _forceAlign(true);
      }
    };
  });
  if (/* @__PURE__ */ React.isValidElement(childNode)) {
    childNode = /* @__PURE__ */ React.cloneElement(childNode, {
      ref: composeRef(childNode.ref, nodeRef)
    });
  }
  return childNode;
};
var RcAlign = /* @__PURE__ */ React.forwardRef(Align);
RcAlign.displayName = "Align";
var StatusQueue = ["measure", "alignPre", "align", null, "motion"];
var useVisibleStatus = function(visible, doMeasure) {
  var _useState = useSafeState(null), _useState2 = _slicedToArray$4(_useState, 2), status = _useState2[0], setInternalStatus = _useState2[1];
  var rafRef = react.exports.useRef();
  function setStatus(nextStatus) {
    setInternalStatus(nextStatus, true);
  }
  function cancelRaf() {
    wrapperRaf$1.cancel(rafRef.current);
  }
  function goNextStatus(callback) {
    cancelRaf();
    rafRef.current = wrapperRaf$1(function() {
      setStatus(function(prev) {
        switch (status) {
          case "align":
            return "motion";
          case "motion":
            return "stable";
        }
        return prev;
      });
      callback === null || callback === void 0 ? void 0 : callback();
    });
  }
  react.exports.useEffect(function() {
    setStatus("measure");
  }, [visible]);
  react.exports.useEffect(function() {
    switch (status) {
      case "measure":
        doMeasure();
        break;
    }
    if (status) {
      rafRef.current = wrapperRaf$1(/* @__PURE__ */ _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee() {
        var index2, nextStatus;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                index2 = StatusQueue.indexOf(status);
                nextStatus = StatusQueue[index2 + 1];
                if (nextStatus && index2 !== -1) {
                  setStatus(nextStatus);
                }
              case 3:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      })));
    }
  }, [status]);
  react.exports.useEffect(function() {
    return function() {
      cancelRaf();
    };
  }, []);
  return [status, goNextStatus];
};
var useStretchStyle = function(stretch) {
  var _React$useState = react.exports.useState({
    width: 0,
    height: 0
  }), _React$useState2 = _slicedToArray$4(_React$useState, 2), targetSize = _React$useState2[0], setTargetSize = _React$useState2[1];
  function measureStretch(element) {
    setTargetSize({
      width: element.offsetWidth,
      height: element.offsetHeight
    });
  }
  var style2 = react.exports.useMemo(function() {
    var sizeStyle = {};
    if (stretch) {
      var width = targetSize.width, height = targetSize.height;
      if (stretch.indexOf("height") !== -1 && height) {
        sizeStyle.height = height;
      } else if (stretch.indexOf("minHeight") !== -1 && height) {
        sizeStyle.minHeight = height;
      }
      if (stretch.indexOf("width") !== -1 && width) {
        sizeStyle.width = width;
      } else if (stretch.indexOf("minWidth") !== -1 && width) {
        sizeStyle.minWidth = width;
      }
    }
    return sizeStyle;
  }, [stretch, targetSize]);
  return [style2, measureStretch];
};
var PopupInner = /* @__PURE__ */ react.exports.forwardRef(function(props, ref) {
  var visible = props.visible, prefixCls = props.prefixCls, className = props.className, style2 = props.style, children = props.children, zIndex = props.zIndex, stretch = props.stretch, destroyPopupOnHide = props.destroyPopupOnHide, forceRender = props.forceRender, align = props.align, point2 = props.point, getRootDomNode = props.getRootDomNode, getClassNameFromAlign = props.getClassNameFromAlign, onAlign = props.onAlign, onMouseEnter = props.onMouseEnter, onMouseLeave = props.onMouseLeave, onMouseDown = props.onMouseDown, onTouchStart = props.onTouchStart, onClick = props.onClick;
  var alignRef = react.exports.useRef();
  var elementRef = react.exports.useRef();
  var _useState = react.exports.useState(), _useState2 = _slicedToArray$4(_useState, 2), alignedClassName = _useState2[0], setAlignedClassName = _useState2[1];
  var _useStretchStyle = useStretchStyle(stretch), _useStretchStyle2 = _slicedToArray$4(_useStretchStyle, 2), stretchStyle = _useStretchStyle2[0], measureStretchStyle = _useStretchStyle2[1];
  function doMeasure() {
    if (stretch) {
      measureStretchStyle(getRootDomNode());
    }
  }
  var _useVisibleStatus = useVisibleStatus(visible, doMeasure), _useVisibleStatus2 = _slicedToArray$4(_useVisibleStatus, 2), status = _useVisibleStatus2[0], goNextStatus = _useVisibleStatus2[1];
  var _useState3 = react.exports.useState(0), _useState4 = _slicedToArray$4(_useState3, 2), alignTimes = _useState4[0], setAlignTimes = _useState4[1];
  var prepareResolveRef = react.exports.useRef();
  useLayoutEffect$1(function() {
    if (status === "alignPre") {
      setAlignTimes(0);
    }
  }, [status]);
  function getAlignTarget() {
    if (point2) {
      return point2;
    }
    return getRootDomNode;
  }
  function forceAlign() {
    var _alignRef$current;
    (_alignRef$current = alignRef.current) === null || _alignRef$current === void 0 ? void 0 : _alignRef$current.forceAlign();
  }
  function onInternalAlign(popupDomNode, matchAlign) {
    var nextAlignedClassName = getClassNameFromAlign(matchAlign);
    if (alignedClassName !== nextAlignedClassName) {
      setAlignedClassName(nextAlignedClassName);
    }
    setAlignTimes(function(val) {
      return val + 1;
    });
    if (status === "align") {
      onAlign === null || onAlign === void 0 ? void 0 : onAlign(popupDomNode, matchAlign);
    }
  }
  useLayoutEffect$1(function() {
    if (status === "align") {
      if (alignTimes < 2) {
        forceAlign();
      } else {
        goNextStatus(function() {
          var _prepareResolveRef$cu;
          (_prepareResolveRef$cu = prepareResolveRef.current) === null || _prepareResolveRef$cu === void 0 ? void 0 : _prepareResolveRef$cu.call(prepareResolveRef);
        });
      }
    }
  }, [alignTimes]);
  var motion = _objectSpread2$1({}, getMotion$1(props));
  ["onAppearEnd", "onEnterEnd", "onLeaveEnd"].forEach(function(eventName) {
    var originHandler = motion[eventName];
    motion[eventName] = function(element, event) {
      goNextStatus();
      return originHandler === null || originHandler === void 0 ? void 0 : originHandler(element, event);
    };
  });
  function onShowPrepare() {
    return new Promise(function(resolve) {
      prepareResolveRef.current = resolve;
    });
  }
  react.exports.useEffect(function() {
    if (!motion.motionName && status === "motion") {
      goNextStatus();
    }
  }, [motion.motionName, status]);
  react.exports.useImperativeHandle(ref, function() {
    return {
      forceAlign,
      getElement: function getElement2() {
        return elementRef.current;
      }
    };
  });
  var mergedStyle = _objectSpread2$1(_objectSpread2$1({}, stretchStyle), {}, {
    zIndex,
    opacity: status === "motion" || status === "stable" || !visible ? void 0 : 0,
    pointerEvents: !visible && status !== "stable" ? "none" : void 0
  }, style2);
  var alignDisabled = true;
  if ((align === null || align === void 0 ? void 0 : align.points) && (status === "align" || status === "stable")) {
    alignDisabled = false;
  }
  var childNode = children;
  if (react.exports.Children.count(children) > 1) {
    childNode = /* @__PURE__ */ react.exports.createElement("div", {
      className: "".concat(prefixCls, "-content")
    }, children);
  }
  return /* @__PURE__ */ react.exports.createElement(CSSMotion, _extends$2({
    visible,
    ref: elementRef,
    leavedClassName: "".concat(prefixCls, "-hidden")
  }, motion, {
    onAppearPrepare: onShowPrepare,
    onEnterPrepare: onShowPrepare,
    removeOnLeave: destroyPopupOnHide,
    forceRender
  }), function(_ref, motionRef) {
    var motionClassName = _ref.className, motionStyle = _ref.style;
    var mergedClassName = classNames(prefixCls, className, alignedClassName, motionClassName);
    return /* @__PURE__ */ react.exports.createElement(RcAlign, {
      target: getAlignTarget(),
      key: "popup",
      ref: alignRef,
      monitorWindowResize: true,
      disabled: alignDisabled,
      align,
      onAlign: onInternalAlign
    }, /* @__PURE__ */ react.exports.createElement("div", {
      ref: motionRef,
      className: mergedClassName,
      onMouseEnter,
      onMouseLeave,
      onMouseDownCapture: onMouseDown,
      onTouchStartCapture: onTouchStart,
      onClick,
      style: _objectSpread2$1(_objectSpread2$1({}, motionStyle), mergedStyle)
    }, childNode));
  });
});
PopupInner.displayName = "PopupInner";
var MobilePopupInner = /* @__PURE__ */ react.exports.forwardRef(function(props, ref) {
  var prefixCls = props.prefixCls, visible = props.visible, zIndex = props.zIndex, children = props.children, _props$mobile = props.mobile;
  _props$mobile = _props$mobile === void 0 ? {} : _props$mobile;
  var popupClassName = _props$mobile.popupClassName, popupStyle = _props$mobile.popupStyle, _props$mobile$popupMo = _props$mobile.popupMotion, popupMotion = _props$mobile$popupMo === void 0 ? {} : _props$mobile$popupMo, popupRender = _props$mobile.popupRender, onClick = props.onClick;
  var elementRef = react.exports.useRef();
  react.exports.useImperativeHandle(ref, function() {
    return {
      forceAlign: function forceAlign() {
      },
      getElement: function getElement2() {
        return elementRef.current;
      }
    };
  });
  var mergedStyle = _objectSpread2$1({
    zIndex
  }, popupStyle);
  var childNode = children;
  if (react.exports.Children.count(children) > 1) {
    childNode = /* @__PURE__ */ react.exports.createElement("div", {
      className: "".concat(prefixCls, "-content")
    }, children);
  }
  if (popupRender) {
    childNode = popupRender(childNode);
  }
  return /* @__PURE__ */ react.exports.createElement(CSSMotion, _extends$2({
    visible,
    ref: elementRef,
    removeOnLeave: true
  }, popupMotion), function(_ref, motionRef) {
    var motionClassName = _ref.className, motionStyle = _ref.style;
    var mergedClassName = classNames(prefixCls, popupClassName, motionClassName);
    return /* @__PURE__ */ react.exports.createElement("div", {
      ref: motionRef,
      className: mergedClassName,
      onClick,
      style: _objectSpread2$1(_objectSpread2$1({}, motionStyle), mergedStyle)
    }, childNode);
  });
});
MobilePopupInner.displayName = "MobilePopupInner";
var _excluded$w = ["visible", "mobile"];
var Popup$1 = /* @__PURE__ */ react.exports.forwardRef(function(_ref, ref) {
  var visible = _ref.visible, mobile = _ref.mobile, props = _objectWithoutProperties$1(_ref, _excluded$w);
  var _useState = react.exports.useState(visible), _useState2 = _slicedToArray$4(_useState, 2), innerVisible = _useState2[0], serInnerVisible = _useState2[1];
  var _useState3 = react.exports.useState(false), _useState4 = _slicedToArray$4(_useState3, 2), inMobile = _useState4[0], setInMobile = _useState4[1];
  var cloneProps = _objectSpread2$1(_objectSpread2$1({}, props), {}, {
    visible: innerVisible
  });
  react.exports.useEffect(function() {
    serInnerVisible(visible);
    if (visible && mobile) {
      setInMobile(isMobile());
    }
  }, [visible, mobile]);
  var popupNode = inMobile ? /* @__PURE__ */ react.exports.createElement(MobilePopupInner, _extends$2({}, cloneProps, {
    mobile,
    ref
  })) : /* @__PURE__ */ react.exports.createElement(PopupInner, _extends$2({}, cloneProps, {
    ref
  }));
  return /* @__PURE__ */ react.exports.createElement("div", null, /* @__PURE__ */ react.exports.createElement(Mask$1, cloneProps), popupNode);
});
Popup$1.displayName = "Popup";
var TriggerContext = /* @__PURE__ */ react.exports.createContext(null);
function noop$4() {
}
function returnEmptyString() {
  return "";
}
function returnDocument(element) {
  if (element) {
    return element.ownerDocument;
  }
  return window.document;
}
var ALL_HANDLERS = ["onClick", "onMouseDown", "onTouchStart", "onMouseEnter", "onMouseLeave", "onFocus", "onBlur", "onContextMenu"];
function generateTrigger(PortalComponent) {
  var Trigger2 = /* @__PURE__ */ function(_React$Component) {
    _inherits$1(Trigger3, _React$Component);
    var _super = _createSuper$1(Trigger3);
    function Trigger3(props) {
      var _this;
      _classCallCheck$2(this, Trigger3);
      _this = _super.call(this, props);
      _this.popupRef = /* @__PURE__ */ react.exports.createRef();
      _this.triggerRef = /* @__PURE__ */ react.exports.createRef();
      _this.portalContainer = void 0;
      _this.attachId = void 0;
      _this.clickOutsideHandler = void 0;
      _this.touchOutsideHandler = void 0;
      _this.contextMenuOutsideHandler1 = void 0;
      _this.contextMenuOutsideHandler2 = void 0;
      _this.mouseDownTimeout = void 0;
      _this.focusTime = void 0;
      _this.preClickTime = void 0;
      _this.preTouchTime = void 0;
      _this.delayTimer = void 0;
      _this.hasPopupMouseDown = void 0;
      _this.onMouseEnter = function(e3) {
        var mouseEnterDelay = _this.props.mouseEnterDelay;
        _this.fireEvents("onMouseEnter", e3);
        _this.delaySetPopupVisible(true, mouseEnterDelay, mouseEnterDelay ? null : e3);
      };
      _this.onMouseMove = function(e3) {
        _this.fireEvents("onMouseMove", e3);
        _this.setPoint(e3);
      };
      _this.onMouseLeave = function(e3) {
        _this.fireEvents("onMouseLeave", e3);
        _this.delaySetPopupVisible(false, _this.props.mouseLeaveDelay);
      };
      _this.onPopupMouseEnter = function() {
        _this.clearDelayTimer();
      };
      _this.onPopupMouseLeave = function(e3) {
        var _this$popupRef$curren;
        if (e3.relatedTarget && !e3.relatedTarget.setTimeout && contains$1((_this$popupRef$curren = _this.popupRef.current) === null || _this$popupRef$curren === void 0 ? void 0 : _this$popupRef$curren.getElement(), e3.relatedTarget)) {
          return;
        }
        _this.delaySetPopupVisible(false, _this.props.mouseLeaveDelay);
      };
      _this.onFocus = function(e3) {
        _this.fireEvents("onFocus", e3);
        _this.clearDelayTimer();
        if (_this.isFocusToShow()) {
          _this.focusTime = Date.now();
          _this.delaySetPopupVisible(true, _this.props.focusDelay);
        }
      };
      _this.onMouseDown = function(e3) {
        _this.fireEvents("onMouseDown", e3);
        _this.preClickTime = Date.now();
      };
      _this.onTouchStart = function(e3) {
        _this.fireEvents("onTouchStart", e3);
        _this.preTouchTime = Date.now();
      };
      _this.onBlur = function(e3) {
        _this.fireEvents("onBlur", e3);
        _this.clearDelayTimer();
        if (_this.isBlurToHide()) {
          _this.delaySetPopupVisible(false, _this.props.blurDelay);
        }
      };
      _this.onContextMenu = function(e3) {
        e3.preventDefault();
        _this.fireEvents("onContextMenu", e3);
        _this.setPopupVisible(true, e3);
      };
      _this.onContextMenuClose = function() {
        if (_this.isContextMenuToShow()) {
          _this.close();
        }
      };
      _this.onClick = function(event) {
        _this.fireEvents("onClick", event);
        if (_this.focusTime) {
          var preTime;
          if (_this.preClickTime && _this.preTouchTime) {
            preTime = Math.min(_this.preClickTime, _this.preTouchTime);
          } else if (_this.preClickTime) {
            preTime = _this.preClickTime;
          } else if (_this.preTouchTime) {
            preTime = _this.preTouchTime;
          }
          if (Math.abs(preTime - _this.focusTime) < 20) {
            return;
          }
          _this.focusTime = 0;
        }
        _this.preClickTime = 0;
        _this.preTouchTime = 0;
        if (_this.isClickToShow() && (_this.isClickToHide() || _this.isBlurToHide()) && event && event.preventDefault) {
          event.preventDefault();
        }
        var nextVisible = !_this.state.popupVisible;
        if (_this.isClickToHide() && !nextVisible || nextVisible && _this.isClickToShow()) {
          _this.setPopupVisible(!_this.state.popupVisible, event);
        }
      };
      _this.onPopupMouseDown = function() {
        _this.hasPopupMouseDown = true;
        clearTimeout(_this.mouseDownTimeout);
        _this.mouseDownTimeout = window.setTimeout(function() {
          _this.hasPopupMouseDown = false;
        }, 0);
        if (_this.context) {
          var _this$context;
          (_this$context = _this.context).onPopupMouseDown.apply(_this$context, arguments);
        }
      };
      _this.onDocumentClick = function(event) {
        if (_this.props.mask && !_this.props.maskClosable) {
          return;
        }
        var target = event.target;
        var root2 = _this.getRootDomNode();
        var popupNode = _this.getPopupDomNode();
        if ((!contains$1(root2, target) || _this.isContextMenuOnly()) && !contains$1(popupNode, target) && !_this.hasPopupMouseDown) {
          _this.close();
        }
      };
      _this.getRootDomNode = function() {
        var getTriggerDOMNode = _this.props.getTriggerDOMNode;
        if (getTriggerDOMNode) {
          return getTriggerDOMNode(_this.triggerRef.current);
        }
        try {
          var domNode = findDOMNode(_this.triggerRef.current);
          if (domNode) {
            return domNode;
          }
        } catch (err) {
        }
        return ReactDOM.findDOMNode(_assertThisInitialized$1(_this));
      };
      _this.getPopupClassNameFromAlign = function(align) {
        var className = [];
        var _this$props = _this.props, popupPlacement = _this$props.popupPlacement, builtinPlacements = _this$props.builtinPlacements, prefixCls = _this$props.prefixCls, alignPoint2 = _this$props.alignPoint, getPopupClassNameFromAlign = _this$props.getPopupClassNameFromAlign;
        if (popupPlacement && builtinPlacements) {
          className.push(getAlignPopupClassName(builtinPlacements, prefixCls, align, alignPoint2));
        }
        if (getPopupClassNameFromAlign) {
          className.push(getPopupClassNameFromAlign(align));
        }
        return className.join(" ");
      };
      _this.getComponent = function() {
        var _this$props2 = _this.props, prefixCls = _this$props2.prefixCls, destroyPopupOnHide = _this$props2.destroyPopupOnHide, popupClassName = _this$props2.popupClassName, onPopupAlign = _this$props2.onPopupAlign, popupMotion = _this$props2.popupMotion, popupAnimation = _this$props2.popupAnimation, popupTransitionName = _this$props2.popupTransitionName, popupStyle = _this$props2.popupStyle, mask = _this$props2.mask, maskAnimation = _this$props2.maskAnimation, maskTransitionName = _this$props2.maskTransitionName, maskMotion = _this$props2.maskMotion, zIndex = _this$props2.zIndex, popup = _this$props2.popup, stretch = _this$props2.stretch, alignPoint2 = _this$props2.alignPoint, mobile = _this$props2.mobile, forceRender = _this$props2.forceRender, onPopupClick = _this$props2.onPopupClick;
        var _this$state = _this.state, popupVisible = _this$state.popupVisible, point2 = _this$state.point;
        var align = _this.getPopupAlign();
        var mouseProps = {};
        if (_this.isMouseEnterToShow()) {
          mouseProps.onMouseEnter = _this.onPopupMouseEnter;
        }
        if (_this.isMouseLeaveToHide()) {
          mouseProps.onMouseLeave = _this.onPopupMouseLeave;
        }
        mouseProps.onMouseDown = _this.onPopupMouseDown;
        mouseProps.onTouchStart = _this.onPopupMouseDown;
        return /* @__PURE__ */ react.exports.createElement(Popup$1, _extends$2({
          prefixCls,
          destroyPopupOnHide,
          visible: popupVisible,
          point: alignPoint2 && point2,
          className: popupClassName,
          align,
          onAlign: onPopupAlign,
          animation: popupAnimation,
          getClassNameFromAlign: _this.getPopupClassNameFromAlign
        }, mouseProps, {
          stretch,
          getRootDomNode: _this.getRootDomNode,
          style: popupStyle,
          mask,
          zIndex,
          transitionName: popupTransitionName,
          maskAnimation,
          maskTransitionName,
          maskMotion,
          ref: _this.popupRef,
          motion: popupMotion,
          mobile,
          forceRender,
          onClick: onPopupClick
        }), typeof popup === "function" ? popup() : popup);
      };
      _this.attachParent = function(popupContainer) {
        wrapperRaf$1.cancel(_this.attachId);
        var _this$props3 = _this.props, getPopupContainer = _this$props3.getPopupContainer, getDocument2 = _this$props3.getDocument;
        var domNode = _this.getRootDomNode();
        var mountNode;
        if (!getPopupContainer) {
          mountNode = getDocument2(_this.getRootDomNode()).body;
        } else if (domNode || getPopupContainer.length === 0) {
          mountNode = getPopupContainer(domNode);
        }
        if (mountNode) {
          mountNode.appendChild(popupContainer);
        } else {
          _this.attachId = wrapperRaf$1(function() {
            _this.attachParent(popupContainer);
          });
        }
      };
      _this.getContainer = function() {
        if (!_this.portalContainer) {
          var getDocument2 = _this.props.getDocument;
          var popupContainer = getDocument2(_this.getRootDomNode()).createElement("div");
          popupContainer.style.position = "absolute";
          popupContainer.style.top = "0";
          popupContainer.style.left = "0";
          popupContainer.style.width = "100%";
          _this.portalContainer = popupContainer;
        }
        _this.attachParent(_this.portalContainer);
        return _this.portalContainer;
      };
      _this.setPoint = function(point2) {
        var alignPoint2 = _this.props.alignPoint;
        if (!alignPoint2 || !point2)
          return;
        _this.setState({
          point: {
            pageX: point2.pageX,
            pageY: point2.pageY
          }
        });
      };
      _this.handlePortalUpdate = function() {
        if (_this.state.prevPopupVisible !== _this.state.popupVisible) {
          _this.props.afterPopupVisibleChange(_this.state.popupVisible);
        }
      };
      _this.triggerContextValue = {
        onPopupMouseDown: _this.onPopupMouseDown
      };
      var _popupVisible;
      if ("popupVisible" in props) {
        _popupVisible = !!props.popupVisible;
      } else {
        _popupVisible = !!props.defaultPopupVisible;
      }
      _this.state = {
        prevPopupVisible: _popupVisible,
        popupVisible: _popupVisible
      };
      ALL_HANDLERS.forEach(function(h2) {
        _this["fire".concat(h2)] = function(e3) {
          _this.fireEvents(h2, e3);
        };
      });
      return _this;
    }
    _createClass$2(Trigger3, [{
      key: "componentDidMount",
      value: function componentDidMount() {
        this.componentDidUpdate();
      }
    }, {
      key: "componentDidUpdate",
      value: function componentDidUpdate() {
        var props = this.props;
        var state2 = this.state;
        if (state2.popupVisible) {
          var currentDocument;
          if (!this.clickOutsideHandler && (this.isClickToHide() || this.isContextMenuToShow())) {
            currentDocument = props.getDocument(this.getRootDomNode());
            this.clickOutsideHandler = addEventListenerWrap(currentDocument, "mousedown", this.onDocumentClick);
          }
          if (!this.touchOutsideHandler) {
            currentDocument = currentDocument || props.getDocument(this.getRootDomNode());
            this.touchOutsideHandler = addEventListenerWrap(currentDocument, "touchstart", this.onDocumentClick);
          }
          if (!this.contextMenuOutsideHandler1 && this.isContextMenuToShow()) {
            currentDocument = currentDocument || props.getDocument(this.getRootDomNode());
            this.contextMenuOutsideHandler1 = addEventListenerWrap(currentDocument, "scroll", this.onContextMenuClose);
          }
          if (!this.contextMenuOutsideHandler2 && this.isContextMenuToShow()) {
            this.contextMenuOutsideHandler2 = addEventListenerWrap(window, "blur", this.onContextMenuClose);
          }
          return;
        }
        this.clearOutsideHandler();
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        this.clearDelayTimer();
        this.clearOutsideHandler();
        clearTimeout(this.mouseDownTimeout);
        wrapperRaf$1.cancel(this.attachId);
      }
    }, {
      key: "getPopupDomNode",
      value: function getPopupDomNode() {
        var _this$popupRef$curren2;
        return ((_this$popupRef$curren2 = this.popupRef.current) === null || _this$popupRef$curren2 === void 0 ? void 0 : _this$popupRef$curren2.getElement()) || null;
      }
    }, {
      key: "getPopupAlign",
      value: function getPopupAlign() {
        var props = this.props;
        var popupPlacement = props.popupPlacement, popupAlign = props.popupAlign, builtinPlacements = props.builtinPlacements;
        if (popupPlacement && builtinPlacements) {
          return getAlignFromPlacement(builtinPlacements, popupPlacement, popupAlign);
        }
        return popupAlign;
      }
    }, {
      key: "setPopupVisible",
      value: function setPopupVisible(popupVisible, event) {
        var alignPoint2 = this.props.alignPoint;
        var prevPopupVisible = this.state.popupVisible;
        this.clearDelayTimer();
        if (prevPopupVisible !== popupVisible) {
          if (!("popupVisible" in this.props)) {
            this.setState({
              popupVisible,
              prevPopupVisible
            });
          }
          this.props.onPopupVisibleChange(popupVisible);
        }
        if (alignPoint2 && event && popupVisible) {
          this.setPoint(event);
        }
      }
    }, {
      key: "delaySetPopupVisible",
      value: function delaySetPopupVisible(visible, delayS, event) {
        var _this2 = this;
        var delay = delayS * 1e3;
        this.clearDelayTimer();
        if (delay) {
          var point2 = event ? {
            pageX: event.pageX,
            pageY: event.pageY
          } : null;
          this.delayTimer = window.setTimeout(function() {
            _this2.setPopupVisible(visible, point2);
            _this2.clearDelayTimer();
          }, delay);
        } else {
          this.setPopupVisible(visible, event);
        }
      }
    }, {
      key: "clearDelayTimer",
      value: function clearDelayTimer() {
        if (this.delayTimer) {
          clearTimeout(this.delayTimer);
          this.delayTimer = null;
        }
      }
    }, {
      key: "clearOutsideHandler",
      value: function clearOutsideHandler() {
        if (this.clickOutsideHandler) {
          this.clickOutsideHandler.remove();
          this.clickOutsideHandler = null;
        }
        if (this.contextMenuOutsideHandler1) {
          this.contextMenuOutsideHandler1.remove();
          this.contextMenuOutsideHandler1 = null;
        }
        if (this.contextMenuOutsideHandler2) {
          this.contextMenuOutsideHandler2.remove();
          this.contextMenuOutsideHandler2 = null;
        }
        if (this.touchOutsideHandler) {
          this.touchOutsideHandler.remove();
          this.touchOutsideHandler = null;
        }
      }
    }, {
      key: "createTwoChains",
      value: function createTwoChains(event) {
        var childPros = this.props.children.props;
        var props = this.props;
        if (childPros[event] && props[event]) {
          return this["fire".concat(event)];
        }
        return childPros[event] || props[event];
      }
    }, {
      key: "isClickToShow",
      value: function isClickToShow() {
        var _this$props4 = this.props, action = _this$props4.action, showAction = _this$props4.showAction;
        return action.indexOf("click") !== -1 || showAction.indexOf("click") !== -1;
      }
    }, {
      key: "isContextMenuOnly",
      value: function isContextMenuOnly() {
        var action = this.props.action;
        return action === "contextMenu" || action.length === 1 && action[0] === "contextMenu";
      }
    }, {
      key: "isContextMenuToShow",
      value: function isContextMenuToShow() {
        var _this$props5 = this.props, action = _this$props5.action, showAction = _this$props5.showAction;
        return action.indexOf("contextMenu") !== -1 || showAction.indexOf("contextMenu") !== -1;
      }
    }, {
      key: "isClickToHide",
      value: function isClickToHide() {
        var _this$props6 = this.props, action = _this$props6.action, hideAction = _this$props6.hideAction;
        return action.indexOf("click") !== -1 || hideAction.indexOf("click") !== -1;
      }
    }, {
      key: "isMouseEnterToShow",
      value: function isMouseEnterToShow() {
        var _this$props7 = this.props, action = _this$props7.action, showAction = _this$props7.showAction;
        return action.indexOf("hover") !== -1 || showAction.indexOf("mouseEnter") !== -1;
      }
    }, {
      key: "isMouseLeaveToHide",
      value: function isMouseLeaveToHide() {
        var _this$props8 = this.props, action = _this$props8.action, hideAction = _this$props8.hideAction;
        return action.indexOf("hover") !== -1 || hideAction.indexOf("mouseLeave") !== -1;
      }
    }, {
      key: "isFocusToShow",
      value: function isFocusToShow() {
        var _this$props9 = this.props, action = _this$props9.action, showAction = _this$props9.showAction;
        return action.indexOf("focus") !== -1 || showAction.indexOf("focus") !== -1;
      }
    }, {
      key: "isBlurToHide",
      value: function isBlurToHide() {
        var _this$props10 = this.props, action = _this$props10.action, hideAction = _this$props10.hideAction;
        return action.indexOf("focus") !== -1 || hideAction.indexOf("blur") !== -1;
      }
    }, {
      key: "forcePopupAlign",
      value: function forcePopupAlign() {
        if (this.state.popupVisible) {
          var _this$popupRef$curren3;
          (_this$popupRef$curren3 = this.popupRef.current) === null || _this$popupRef$curren3 === void 0 ? void 0 : _this$popupRef$curren3.forceAlign();
        }
      }
    }, {
      key: "fireEvents",
      value: function fireEvents(type4, e3) {
        var childCallback = this.props.children.props[type4];
        if (childCallback) {
          childCallback(e3);
        }
        var callback = this.props[type4];
        if (callback) {
          callback(e3);
        }
      }
    }, {
      key: "close",
      value: function close2() {
        this.setPopupVisible(false);
      }
    }, {
      key: "render",
      value: function render2() {
        var popupVisible = this.state.popupVisible;
        var _this$props11 = this.props, children = _this$props11.children, forceRender = _this$props11.forceRender, alignPoint2 = _this$props11.alignPoint, className = _this$props11.className, autoDestroy = _this$props11.autoDestroy;
        var child = react.exports.Children.only(children);
        var newChildProps = {
          key: "trigger"
        };
        if (this.isContextMenuToShow()) {
          newChildProps.onContextMenu = this.onContextMenu;
        } else {
          newChildProps.onContextMenu = this.createTwoChains("onContextMenu");
        }
        if (this.isClickToHide() || this.isClickToShow()) {
          newChildProps.onClick = this.onClick;
          newChildProps.onMouseDown = this.onMouseDown;
          newChildProps.onTouchStart = this.onTouchStart;
        } else {
          newChildProps.onClick = this.createTwoChains("onClick");
          newChildProps.onMouseDown = this.createTwoChains("onMouseDown");
          newChildProps.onTouchStart = this.createTwoChains("onTouchStart");
        }
        if (this.isMouseEnterToShow()) {
          newChildProps.onMouseEnter = this.onMouseEnter;
          if (alignPoint2) {
            newChildProps.onMouseMove = this.onMouseMove;
          }
        } else {
          newChildProps.onMouseEnter = this.createTwoChains("onMouseEnter");
        }
        if (this.isMouseLeaveToHide()) {
          newChildProps.onMouseLeave = this.onMouseLeave;
        } else {
          newChildProps.onMouseLeave = this.createTwoChains("onMouseLeave");
        }
        if (this.isFocusToShow() || this.isBlurToHide()) {
          newChildProps.onFocus = this.onFocus;
          newChildProps.onBlur = this.onBlur;
        } else {
          newChildProps.onFocus = this.createTwoChains("onFocus");
          newChildProps.onBlur = this.createTwoChains("onBlur");
        }
        var childrenClassName = classNames(child && child.props && child.props.className, className);
        if (childrenClassName) {
          newChildProps.className = childrenClassName;
        }
        var cloneProps = _objectSpread2$1({}, newChildProps);
        if (supportRef(child)) {
          cloneProps.ref = composeRef(this.triggerRef, child.ref);
        }
        var trigger = /* @__PURE__ */ react.exports.cloneElement(child, cloneProps);
        var portal;
        if (popupVisible || this.popupRef.current || forceRender) {
          portal = /* @__PURE__ */ react.exports.createElement(PortalComponent, {
            key: "portal",
            getContainer: this.getContainer,
            didUpdate: this.handlePortalUpdate
          }, this.getComponent());
        }
        if (!popupVisible && autoDestroy) {
          portal = null;
        }
        return /* @__PURE__ */ react.exports.createElement(TriggerContext.Provider, {
          value: this.triggerContextValue
        }, trigger, portal);
      }
    }], [{
      key: "getDerivedStateFromProps",
      value: function getDerivedStateFromProps(_ref, prevState) {
        var popupVisible = _ref.popupVisible;
        var newState = {};
        if (popupVisible !== void 0 && prevState.popupVisible !== popupVisible) {
          newState.popupVisible = popupVisible;
          newState.prevPopupVisible = prevState.popupVisible;
        }
        return newState;
      }
    }]);
    return Trigger3;
  }(react.exports.Component);
  Trigger2.contextType = TriggerContext;
  Trigger2.defaultProps = {
    prefixCls: "rc-trigger-popup",
    getPopupClassNameFromAlign: returnEmptyString,
    getDocument: returnDocument,
    onPopupVisibleChange: noop$4,
    afterPopupVisibleChange: noop$4,
    onPopupAlign: noop$4,
    popupClassName: "",
    mouseEnterDelay: 0,
    mouseLeaveDelay: 0.1,
    focusDelay: 0,
    blurDelay: 0.15,
    popupStyle: {},
    destroyPopupOnHide: false,
    popupAlign: {},
    defaultPopupVisible: false,
    mask: false,
    maskClosable: true,
    action: [],
    showAction: [],
    hideAction: [],
    autoDestroy: false
  };
  return Trigger2;
}
var Trigger = generateTrigger(Portal);
var _excluded$v = ["prefixCls", "disabled", "visible", "children", "popupElement", "containerWidth", "animation", "transitionName", "dropdownStyle", "dropdownClassName", "direction", "placement", "dropdownMatchSelectWidth", "dropdownRender", "dropdownAlign", "getPopupContainer", "empty", "getTriggerDOMNode", "onPopupVisibleChange", "onPopupMouseEnter"];
var getBuiltInPlacements = function getBuiltInPlacements2(dropdownMatchSelectWidth) {
  var adjustX = dropdownMatchSelectWidth === true ? 0 : 1;
  return {
    bottomLeft: {
      points: ["tl", "bl"],
      offset: [0, 4],
      overflow: {
        adjustX,
        adjustY: 1
      }
    },
    bottomRight: {
      points: ["tr", "br"],
      offset: [0, 4],
      overflow: {
        adjustX,
        adjustY: 1
      }
    },
    topLeft: {
      points: ["bl", "tl"],
      offset: [0, -4],
      overflow: {
        adjustX,
        adjustY: 1
      }
    },
    topRight: {
      points: ["br", "tr"],
      offset: [0, -4],
      overflow: {
        adjustX,
        adjustY: 1
      }
    }
  };
};
var SelectTrigger = function SelectTrigger2(props, ref) {
  var prefixCls = props.prefixCls;
  props.disabled;
  var visible = props.visible, children = props.children, popupElement = props.popupElement, containerWidth = props.containerWidth, animation2 = props.animation, transitionName2 = props.transitionName, dropdownStyle = props.dropdownStyle, dropdownClassName = props.dropdownClassName, _props$direction = props.direction, direction2 = _props$direction === void 0 ? "ltr" : _props$direction, placement = props.placement, dropdownMatchSelectWidth = props.dropdownMatchSelectWidth, dropdownRender = props.dropdownRender, dropdownAlign = props.dropdownAlign, getPopupContainer = props.getPopupContainer, empty = props.empty, getTriggerDOMNode = props.getTriggerDOMNode, onPopupVisibleChange = props.onPopupVisibleChange, onPopupMouseEnter = props.onPopupMouseEnter, restProps = _objectWithoutProperties$1(props, _excluded$v);
  var dropdownPrefixCls = "".concat(prefixCls, "-dropdown");
  var popupNode = popupElement;
  if (dropdownRender) {
    popupNode = dropdownRender(popupElement);
  }
  var builtInPlacements = react.exports.useMemo(function() {
    return getBuiltInPlacements(dropdownMatchSelectWidth);
  }, [dropdownMatchSelectWidth]);
  var mergedTransitionName = animation2 ? "".concat(dropdownPrefixCls, "-").concat(animation2) : transitionName2;
  var popupRef = react.exports.useRef(null);
  react.exports.useImperativeHandle(ref, function() {
    return {
      getPopupElement: function getPopupElement() {
        return popupRef.current;
      }
    };
  });
  var popupStyle = _objectSpread2$1({
    minWidth: containerWidth
  }, dropdownStyle);
  if (typeof dropdownMatchSelectWidth === "number") {
    popupStyle.width = dropdownMatchSelectWidth;
  } else if (dropdownMatchSelectWidth) {
    popupStyle.width = containerWidth;
  }
  return /* @__PURE__ */ react.exports.createElement(Trigger, _extends$2({}, restProps, {
    showAction: onPopupVisibleChange ? ["click"] : [],
    hideAction: onPopupVisibleChange ? ["click"] : [],
    popupPlacement: placement || (direction2 === "rtl" ? "bottomRight" : "bottomLeft"),
    builtinPlacements: builtInPlacements,
    prefixCls: dropdownPrefixCls,
    popupTransitionName: mergedTransitionName,
    popup: /* @__PURE__ */ react.exports.createElement("div", {
      ref: popupRef,
      onMouseEnter: onPopupMouseEnter
    }, popupNode),
    popupAlign: dropdownAlign,
    popupVisible: visible,
    getPopupContainer,
    popupClassName: classNames(dropdownClassName, _defineProperty$4({}, "".concat(dropdownPrefixCls, "-empty"), empty)),
    popupStyle,
    getTriggerDOMNode,
    onPopupVisibleChange
  }), children);
};
var RefSelectTrigger = /* @__PURE__ */ react.exports.forwardRef(SelectTrigger);
RefSelectTrigger.displayName = "SelectTrigger";
var attributes = "accept acceptCharset accessKey action allowFullScreen allowTransparency\n    alt async autoComplete autoFocus autoPlay capture cellPadding cellSpacing challenge\n    charSet checked classID className colSpan cols content contentEditable contextMenu\n    controls coords crossOrigin data dateTime default defer dir disabled download draggable\n    encType form formAction formEncType formMethod formNoValidate formTarget frameBorder\n    headers height hidden high href hrefLang htmlFor httpEquiv icon id inputMode integrity\n    is keyParams keyType kind label lang list loop low manifest marginHeight marginWidth max maxLength media\n    mediaGroup method min minLength multiple muted name noValidate nonce open\n    optimum pattern placeholder poster preload radioGroup readOnly rel required\n    reversed role rowSpan rows sandbox scope scoped scrolling seamless selected\n    shape size sizes span spellCheck src srcDoc srcLang srcSet start step style\n    summary tabIndex target title type useMap value width wmode wrap";
var eventsName = "onCopy onCut onPaste onCompositionEnd onCompositionStart onCompositionUpdate onKeyDown\n    onKeyPress onKeyUp onFocus onBlur onChange onInput onSubmit onClick onContextMenu onDoubleClick\n    onDrag onDragEnd onDragEnter onDragExit onDragLeave onDragOver onDragStart onDrop onMouseDown\n    onMouseEnter onMouseLeave onMouseMove onMouseOut onMouseOver onMouseUp onSelect onTouchCancel\n    onTouchEnd onTouchMove onTouchStart onScroll onWheel onAbort onCanPlay onCanPlayThrough\n    onDurationChange onEmptied onEncrypted onEnded onError onLoadedData onLoadedMetadata\n    onLoadStart onPause onPlay onPlaying onProgress onRateChange onSeeked onSeeking onStalled onSuspend onTimeUpdate onVolumeChange onWaiting onLoad onError";
var propList = "".concat(attributes, " ").concat(eventsName).split(/[\s\n]+/);
var ariaPrefix = "aria-";
var dataPrefix = "data-";
function match(key2, prefix) {
  return key2.indexOf(prefix) === 0;
}
function pickAttrs(props) {
  var ariaOnly = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  var mergedConfig;
  if (ariaOnly === false) {
    mergedConfig = {
      aria: true,
      data: true,
      attr: true
    };
  } else if (ariaOnly === true) {
    mergedConfig = {
      aria: true
    };
  } else {
    mergedConfig = _objectSpread2$1({}, ariaOnly);
  }
  var attrs = {};
  Object.keys(props).forEach(function(key2) {
    if (mergedConfig.aria && (key2 === "role" || match(key2, ariaPrefix)) || mergedConfig.data && match(key2, dataPrefix) || mergedConfig.attr && propList.includes(key2)) {
      attrs[key2] = props[key2];
    }
  });
  return attrs;
}
var _excluded$u = ["prefixCls", "invalidate", "item", "renderItem", "responsive", "responsiveDisabled", "registerSize", "itemKey", "className", "style", "children", "display", "order", "component"];
var UNDEFINED = void 0;
function InternalItem$1(props, ref) {
  var prefixCls = props.prefixCls, invalidate = props.invalidate, item = props.item, renderItem = props.renderItem, responsive = props.responsive, responsiveDisabled = props.responsiveDisabled, registerSize = props.registerSize, itemKey2 = props.itemKey, className = props.className, style2 = props.style, children = props.children, display = props.display, order = props.order, _props$component = props.component, Component2 = _props$component === void 0 ? "div" : _props$component, restProps = _objectWithoutProperties$1(props, _excluded$u);
  var mergedHidden = responsive && !display;
  function internalRegisterSize(width) {
    registerSize(itemKey2, width);
  }
  react.exports.useEffect(function() {
    return function() {
      internalRegisterSize(null);
    };
  }, []);
  var childNode = renderItem && item !== UNDEFINED ? renderItem(item) : children;
  var overflowStyle;
  if (!invalidate) {
    overflowStyle = {
      opacity: mergedHidden ? 0 : 1,
      height: mergedHidden ? 0 : UNDEFINED,
      overflowY: mergedHidden ? "hidden" : UNDEFINED,
      order: responsive ? order : UNDEFINED,
      pointerEvents: mergedHidden ? "none" : UNDEFINED,
      position: mergedHidden ? "absolute" : UNDEFINED
    };
  }
  var overflowProps = {};
  if (mergedHidden) {
    overflowProps["aria-hidden"] = true;
  }
  var itemNode = /* @__PURE__ */ react.exports.createElement(Component2, _extends$2({
    className: classNames(!invalidate && prefixCls, className),
    style: _objectSpread2$1(_objectSpread2$1({}, overflowStyle), style2)
  }, overflowProps, restProps, {
    ref
  }), childNode);
  if (responsive) {
    itemNode = /* @__PURE__ */ react.exports.createElement(ResizeObserver$1, {
      onResize: function onResize2(_ref) {
        var offsetWidth = _ref.offsetWidth;
        internalRegisterSize(offsetWidth);
      },
      disabled: responsiveDisabled
    }, itemNode);
  }
  return itemNode;
}
var Item$3 = /* @__PURE__ */ react.exports.forwardRef(InternalItem$1);
Item$3.displayName = "Item";
function useBatchFrameState() {
  var _useState = useSafeState({}), _useState2 = _slicedToArray$4(_useState, 2), forceUpdate = _useState2[1];
  var statesRef = react.exports.useRef([]);
  var walkingIndex = 0;
  var beforeFrameId = 0;
  function createState(defaultValue) {
    var myIndex = walkingIndex;
    walkingIndex += 1;
    if (statesRef.current.length < myIndex + 1) {
      statesRef.current[myIndex] = defaultValue;
    }
    var value2 = statesRef.current[myIndex];
    function setValue2(val) {
      statesRef.current[myIndex] = typeof val === "function" ? val(statesRef.current[myIndex]) : val;
      wrapperRaf$1.cancel(beforeFrameId);
      beforeFrameId = wrapperRaf$1(function() {
        forceUpdate({}, true);
      });
    }
    return [value2, setValue2];
  }
  return createState;
}
var _excluded$t = ["component"], _excluded2$6 = ["className"], _excluded3$1 = ["className"];
var InternalRawItem = function InternalRawItem2(props, ref) {
  var context2 = react.exports.useContext(OverflowContext);
  if (!context2) {
    var _props$component = props.component, Component2 = _props$component === void 0 ? "div" : _props$component, _restProps = _objectWithoutProperties$1(props, _excluded$t);
    return /* @__PURE__ */ react.exports.createElement(Component2, _extends$2({}, _restProps, {
      ref
    }));
  }
  var contextClassName = context2.className, restContext = _objectWithoutProperties$1(context2, _excluded2$6);
  var className = props.className, restProps = _objectWithoutProperties$1(props, _excluded3$1);
  return /* @__PURE__ */ react.exports.createElement(OverflowContext.Provider, {
    value: null
  }, /* @__PURE__ */ react.exports.createElement(Item$3, _extends$2({
    ref,
    className: classNames(contextClassName, className)
  }, restContext, restProps)));
};
var RawItem = /* @__PURE__ */ react.exports.forwardRef(InternalRawItem);
RawItem.displayName = "RawItem";
var _excluded$s = ["prefixCls", "data", "renderItem", "renderRawItem", "itemKey", "itemWidth", "ssr", "style", "className", "maxCount", "renderRest", "renderRawRest", "suffix", "component", "itemComponent", "onVisibleChange"];
var OverflowContext = /* @__PURE__ */ react.exports.createContext(null);
var RESPONSIVE = "responsive";
var INVALIDATE = "invalidate";
function defaultRenderRest(omittedItems) {
  return "+ ".concat(omittedItems.length, " ...");
}
function Overflow(props, ref) {
  var _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-overflow" : _props$prefixCls, _props$data = props.data, data2 = _props$data === void 0 ? [] : _props$data, renderItem = props.renderItem, renderRawItem = props.renderRawItem, itemKey2 = props.itemKey, _props$itemWidth = props.itemWidth, itemWidth = _props$itemWidth === void 0 ? 10 : _props$itemWidth, ssr = props.ssr, style2 = props.style, className = props.className, maxCount2 = props.maxCount, renderRest = props.renderRest, renderRawRest = props.renderRawRest, suffix = props.suffix, _props$component = props.component, Component2 = _props$component === void 0 ? "div" : _props$component, itemComponent = props.itemComponent, onVisibleChange = props.onVisibleChange, restProps = _objectWithoutProperties$1(props, _excluded$s);
  var createUseState = useBatchFrameState();
  var fullySSR = ssr === "full";
  var _createUseState = createUseState(null), _createUseState2 = _slicedToArray$4(_createUseState, 2), containerWidth = _createUseState2[0], setContainerWidth = _createUseState2[1];
  var mergedContainerWidth = containerWidth || 0;
  var _createUseState3 = createUseState(/* @__PURE__ */ new Map()), _createUseState4 = _slicedToArray$4(_createUseState3, 2), itemWidths = _createUseState4[0], setItemWidths = _createUseState4[1];
  var _createUseState5 = createUseState(0), _createUseState6 = _slicedToArray$4(_createUseState5, 2), prevRestWidth = _createUseState6[0], setPrevRestWidth = _createUseState6[1];
  var _createUseState7 = createUseState(0), _createUseState8 = _slicedToArray$4(_createUseState7, 2), restWidth = _createUseState8[0], setRestWidth = _createUseState8[1];
  var _createUseState9 = createUseState(0), _createUseState10 = _slicedToArray$4(_createUseState9, 2), suffixWidth = _createUseState10[0], setSuffixWidth = _createUseState10[1];
  var _useState = react.exports.useState(null), _useState2 = _slicedToArray$4(_useState, 2), suffixFixedStart = _useState2[0], setSuffixFixedStart = _useState2[1];
  var _useState3 = react.exports.useState(null), _useState4 = _slicedToArray$4(_useState3, 2), displayCount = _useState4[0], setDisplayCount = _useState4[1];
  var mergedDisplayCount = react.exports.useMemo(function() {
    if (displayCount === null && fullySSR) {
      return Number.MAX_SAFE_INTEGER;
    }
    return displayCount || 0;
  }, [displayCount, containerWidth]);
  var _useState5 = react.exports.useState(false), _useState6 = _slicedToArray$4(_useState5, 2), restReady = _useState6[0], setRestReady = _useState6[1];
  var itemPrefixCls = "".concat(prefixCls, "-item");
  var mergedRestWidth = Math.max(prevRestWidth, restWidth);
  var isResponsive = maxCount2 === RESPONSIVE;
  var shouldResponsive = data2.length && isResponsive;
  var invalidate = maxCount2 === INVALIDATE;
  var showRest = shouldResponsive || typeof maxCount2 === "number" && data2.length > maxCount2;
  var mergedData = react.exports.useMemo(function() {
    var items = data2;
    if (shouldResponsive) {
      if (containerWidth === null && fullySSR) {
        items = data2;
      } else {
        items = data2.slice(0, Math.min(data2.length, mergedContainerWidth / itemWidth));
      }
    } else if (typeof maxCount2 === "number") {
      items = data2.slice(0, maxCount2);
    }
    return items;
  }, [data2, itemWidth, containerWidth, maxCount2, shouldResponsive]);
  var omittedItems = react.exports.useMemo(function() {
    if (shouldResponsive) {
      return data2.slice(mergedDisplayCount + 1);
    }
    return data2.slice(mergedData.length);
  }, [data2, mergedData, shouldResponsive, mergedDisplayCount]);
  var getKey2 = react.exports.useCallback(function(item, index2) {
    var _ref;
    if (typeof itemKey2 === "function") {
      return itemKey2(item);
    }
    return (_ref = itemKey2 && (item === null || item === void 0 ? void 0 : item[itemKey2])) !== null && _ref !== void 0 ? _ref : index2;
  }, [itemKey2]);
  var mergedRenderItem = react.exports.useCallback(renderItem || function(item) {
    return item;
  }, [renderItem]);
  function updateDisplayCount(count2, suffixFixedStartVal, notReady) {
    if (displayCount === count2 && (suffixFixedStartVal === void 0 || suffixFixedStartVal === suffixFixedStart)) {
      return;
    }
    setDisplayCount(count2);
    if (!notReady) {
      setRestReady(count2 < data2.length - 1);
      onVisibleChange === null || onVisibleChange === void 0 ? void 0 : onVisibleChange(count2);
    }
    if (suffixFixedStartVal !== void 0) {
      setSuffixFixedStart(suffixFixedStartVal);
    }
  }
  function onOverflowResize(_2, element) {
    setContainerWidth(element.clientWidth);
  }
  function registerSize(key2, width) {
    setItemWidths(function(origin) {
      var clone3 = new Map(origin);
      if (width === null) {
        clone3.delete(key2);
      } else {
        clone3.set(key2, width);
      }
      return clone3;
    });
  }
  function registerOverflowSize(_2, width) {
    setRestWidth(width);
    setPrevRestWidth(restWidth);
  }
  function registerSuffixSize(_2, width) {
    setSuffixWidth(width);
  }
  function getItemWidth(index2) {
    return itemWidths.get(getKey2(mergedData[index2], index2));
  }
  useLayoutEffect$1(function() {
    if (mergedContainerWidth && mergedRestWidth && mergedData) {
      var totalWidth = suffixWidth;
      var len = mergedData.length;
      var lastIndex = len - 1;
      if (!len) {
        updateDisplayCount(0, null);
        return;
      }
      for (var i2 = 0; i2 < len; i2 += 1) {
        var currentItemWidth = getItemWidth(i2);
        if (fullySSR) {
          currentItemWidth = currentItemWidth || 0;
        }
        if (currentItemWidth === void 0) {
          updateDisplayCount(i2 - 1, void 0, true);
          break;
        }
        totalWidth += currentItemWidth;
        if (lastIndex === 0 && totalWidth <= mergedContainerWidth || i2 === lastIndex - 1 && totalWidth + getItemWidth(lastIndex) <= mergedContainerWidth) {
          updateDisplayCount(lastIndex, null);
          break;
        } else if (totalWidth + mergedRestWidth > mergedContainerWidth) {
          updateDisplayCount(i2 - 1, totalWidth - currentItemWidth - suffixWidth + restWidth);
          break;
        }
      }
      if (suffix && getItemWidth(0) + suffixWidth > mergedContainerWidth) {
        setSuffixFixedStart(null);
      }
    }
  }, [mergedContainerWidth, itemWidths, restWidth, suffixWidth, getKey2, mergedData]);
  var displayRest = restReady && !!omittedItems.length;
  var suffixStyle = {};
  if (suffixFixedStart !== null && shouldResponsive) {
    suffixStyle = {
      position: "absolute",
      left: suffixFixedStart,
      top: 0
    };
  }
  var itemSharedProps = {
    prefixCls: itemPrefixCls,
    responsive: shouldResponsive,
    component: itemComponent,
    invalidate
  };
  var internalRenderItemNode = renderRawItem ? function(item, index2) {
    var key2 = getKey2(item, index2);
    return /* @__PURE__ */ react.exports.createElement(OverflowContext.Provider, {
      key: key2,
      value: _objectSpread2$1(_objectSpread2$1({}, itemSharedProps), {}, {
        order: index2,
        item,
        itemKey: key2,
        registerSize,
        display: index2 <= mergedDisplayCount
      })
    }, renderRawItem(item, index2));
  } : function(item, index2) {
    var key2 = getKey2(item, index2);
    return /* @__PURE__ */ react.exports.createElement(Item$3, _extends$2({}, itemSharedProps, {
      order: index2,
      key: key2,
      item,
      renderItem: mergedRenderItem,
      itemKey: key2,
      registerSize,
      display: index2 <= mergedDisplayCount
    }));
  };
  var restNode;
  var restContextProps = {
    order: displayRest ? mergedDisplayCount : Number.MAX_SAFE_INTEGER,
    className: "".concat(itemPrefixCls, "-rest"),
    registerSize: registerOverflowSize,
    display: displayRest
  };
  if (!renderRawRest) {
    var mergedRenderRest = renderRest || defaultRenderRest;
    restNode = /* @__PURE__ */ react.exports.createElement(Item$3, _extends$2({}, itemSharedProps, restContextProps), typeof mergedRenderRest === "function" ? mergedRenderRest(omittedItems) : mergedRenderRest);
  } else if (renderRawRest) {
    restNode = /* @__PURE__ */ react.exports.createElement(OverflowContext.Provider, {
      value: _objectSpread2$1(_objectSpread2$1({}, itemSharedProps), restContextProps)
    }, renderRawRest(omittedItems));
  }
  var overflowNode = /* @__PURE__ */ react.exports.createElement(Component2, _extends$2({
    className: classNames(!invalidate && prefixCls, className),
    style: style2,
    ref
  }, restProps), mergedData.map(internalRenderItemNode), showRest ? restNode : null, suffix && /* @__PURE__ */ react.exports.createElement(Item$3, _extends$2({}, itemSharedProps, {
    responsive: isResponsive,
    responsiveDisabled: !shouldResponsive,
    order: mergedDisplayCount,
    className: "".concat(itemPrefixCls, "-suffix"),
    registerSize: registerSuffixSize,
    display: true,
    style: suffixStyle
  }), suffix));
  if (isResponsive) {
    overflowNode = /* @__PURE__ */ react.exports.createElement(ResizeObserver$1, {
      onResize: onOverflowResize,
      disabled: !shouldResponsive
    }, overflowNode);
  }
  return overflowNode;
}
var ForwardOverflow = /* @__PURE__ */ react.exports.forwardRef(Overflow);
ForwardOverflow.displayName = "Overflow";
ForwardOverflow.Item = RawItem;
ForwardOverflow.RESPONSIVE = RESPONSIVE;
ForwardOverflow.INVALIDATE = INVALIDATE;
var TransBtn = function TransBtn2(_ref) {
  var className = _ref.className, customizeIcon = _ref.customizeIcon, customizeIconProps = _ref.customizeIconProps, _onMouseDown = _ref.onMouseDown, onClick = _ref.onClick, children = _ref.children;
  var icon;
  if (typeof customizeIcon === "function") {
    icon = customizeIcon(customizeIconProps);
  } else {
    icon = customizeIcon;
  }
  return /* @__PURE__ */ react.exports.createElement("span", {
    className,
    onMouseDown: function onMouseDown(event) {
      event.preventDefault();
      if (_onMouseDown) {
        _onMouseDown(event);
      }
    },
    style: {
      userSelect: "none",
      WebkitUserSelect: "none"
    },
    unselectable: "on",
    onClick,
    "aria-hidden": true
  }, icon !== void 0 ? icon : /* @__PURE__ */ react.exports.createElement("span", {
    className: classNames(className.split(/\s+/).map(function(cls) {
      return "".concat(cls, "-icon");
    }))
  }, children));
};
var Input$4 = function Input2(_ref, ref) {
  var _inputNode2, _inputNode2$props;
  var prefixCls = _ref.prefixCls, id2 = _ref.id, inputElement = _ref.inputElement, disabled = _ref.disabled, tabIndex = _ref.tabIndex, autoFocus = _ref.autoFocus, autoComplete = _ref.autoComplete, editable = _ref.editable, activeDescendantId = _ref.activeDescendantId, value2 = _ref.value, maxLength = _ref.maxLength, _onKeyDown = _ref.onKeyDown, _onMouseDown = _ref.onMouseDown, _onChange = _ref.onChange, onPaste = _ref.onPaste, _onCompositionStart = _ref.onCompositionStart, _onCompositionEnd = _ref.onCompositionEnd, open = _ref.open, attrs = _ref.attrs;
  var inputNode = inputElement || /* @__PURE__ */ react.exports.createElement("input", null);
  var _inputNode = inputNode, originRef = _inputNode.ref, originProps = _inputNode.props;
  var onOriginKeyDown = originProps.onKeyDown, onOriginChange = originProps.onChange, onOriginMouseDown = originProps.onMouseDown, onOriginCompositionStart = originProps.onCompositionStart, onOriginCompositionEnd = originProps.onCompositionEnd, style2 = originProps.style;
  warning$2(!("maxLength" in inputNode.props));
  inputNode = /* @__PURE__ */ react.exports.cloneElement(inputNode, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({
    type: "search"
  }, originProps), {}, {
    id: id2,
    ref: composeRef(ref, originRef),
    disabled,
    tabIndex,
    autoComplete: autoComplete || "off",
    autoFocus,
    className: classNames("".concat(prefixCls, "-selection-search-input"), (_inputNode2 = inputNode) === null || _inputNode2 === void 0 ? void 0 : (_inputNode2$props = _inputNode2.props) === null || _inputNode2$props === void 0 ? void 0 : _inputNode2$props.className),
    role: "combobox",
    "aria-expanded": open,
    "aria-haspopup": "listbox",
    "aria-owns": "".concat(id2, "_list"),
    "aria-autocomplete": "list",
    "aria-controls": "".concat(id2, "_list"),
    "aria-activedescendant": activeDescendantId
  }, attrs), {}, {
    value: editable ? value2 : "",
    maxLength,
    readOnly: !editable,
    unselectable: !editable ? "on" : null,
    style: _objectSpread2$1(_objectSpread2$1({}, style2), {}, {
      opacity: editable ? null : 0
    }),
    onKeyDown: function onKeyDown2(event) {
      _onKeyDown(event);
      if (onOriginKeyDown) {
        onOriginKeyDown(event);
      }
    },
    onMouseDown: function onMouseDown(event) {
      _onMouseDown(event);
      if (onOriginMouseDown) {
        onOriginMouseDown(event);
      }
    },
    onChange: function onChange2(event) {
      _onChange(event);
      if (onOriginChange) {
        onOriginChange(event);
      }
    },
    onCompositionStart: function onCompositionStart(event) {
      _onCompositionStart(event);
      if (onOriginCompositionStart) {
        onOriginCompositionStart(event);
      }
    },
    onCompositionEnd: function onCompositionEnd(event) {
      _onCompositionEnd(event);
      if (onOriginCompositionEnd) {
        onOriginCompositionEnd(event);
      }
    },
    onPaste
  }));
  return inputNode;
};
var RefInput = /* @__PURE__ */ react.exports.forwardRef(Input$4);
RefInput.displayName = "Input";
function toArray$3(value2) {
  if (Array.isArray(value2)) {
    return value2;
  }
  return value2 !== void 0 ? [value2] : [];
}
var isClient = typeof window !== "undefined" && window.document && window.document.documentElement;
var isBrowserClient$1 = isClient;
function hasValue(value2) {
  return value2 !== void 0 && value2 !== null;
}
function isTitleType$1(title) {
  return ["string", "number"].includes(_typeof$4(title));
}
function getTitle(item) {
  var title = void 0;
  if (item) {
    if (isTitleType$1(item.title)) {
      title = item.title.toString();
    } else if (isTitleType$1(item.label)) {
      title = item.label.toString();
    }
  }
  return title;
}
function useLayoutEffect(effect, deps) {
  if (isBrowserClient$1) {
    react.exports.useLayoutEffect(effect, deps);
  } else {
    react.exports.useEffect(effect, deps);
  }
}
function itemKey$1(value2) {
  var _value$key;
  return (_value$key = value2.key) !== null && _value$key !== void 0 ? _value$key : value2.value;
}
var onPreventMouseDown = function onPreventMouseDown2(event) {
  event.preventDefault();
  event.stopPropagation();
};
var SelectSelector = function SelectSelector2(props) {
  var id2 = props.id, prefixCls = props.prefixCls, values2 = props.values, open = props.open, searchValue = props.searchValue, inputRef = props.inputRef, placeholder = props.placeholder, disabled = props.disabled, mode = props.mode, showSearch = props.showSearch, autoFocus = props.autoFocus, autoComplete = props.autoComplete, activeDescendantId = props.activeDescendantId, tabIndex = props.tabIndex, removeIcon = props.removeIcon, maxTagCount = props.maxTagCount, maxTagTextLength = props.maxTagTextLength, _props$maxTagPlacehol = props.maxTagPlaceholder, maxTagPlaceholder = _props$maxTagPlacehol === void 0 ? function(omittedValues) {
    return "+ ".concat(omittedValues.length, " ...");
  } : _props$maxTagPlacehol, tagRender = props.tagRender, onToggleOpen = props.onToggleOpen, onRemove = props.onRemove, onInputChange = props.onInputChange, onInputPaste = props.onInputPaste, onInputKeyDown = props.onInputKeyDown, onInputMouseDown = props.onInputMouseDown, onInputCompositionStart = props.onInputCompositionStart, onInputCompositionEnd = props.onInputCompositionEnd;
  var measureRef = react.exports.useRef(null);
  var _useState = react.exports.useState(0), _useState2 = _slicedToArray$4(_useState, 2), inputWidth = _useState2[0], setInputWidth = _useState2[1];
  var _useState3 = react.exports.useState(false), _useState4 = _slicedToArray$4(_useState3, 2), focused = _useState4[0], setFocused = _useState4[1];
  var selectionPrefixCls = "".concat(prefixCls, "-selection");
  var inputValue = open || mode === "tags" ? searchValue : "";
  var inputEditable = mode === "tags" || showSearch && (open || focused);
  useLayoutEffect(function() {
    setInputWidth(measureRef.current.scrollWidth);
  }, [inputValue]);
  function defaultRenderSelector(item, content, itemDisabled, closable, onClose2) {
    return /* @__PURE__ */ react.exports.createElement("span", {
      className: classNames("".concat(selectionPrefixCls, "-item"), _defineProperty$4({}, "".concat(selectionPrefixCls, "-item-disabled"), itemDisabled)),
      title: getTitle(item)
    }, /* @__PURE__ */ react.exports.createElement("span", {
      className: "".concat(selectionPrefixCls, "-item-content")
    }, content), closable && /* @__PURE__ */ react.exports.createElement(TransBtn, {
      className: "".concat(selectionPrefixCls, "-item-remove"),
      onMouseDown: onPreventMouseDown,
      onClick: onClose2,
      customizeIcon: removeIcon
    }, "\xD7"));
  }
  function customizeRenderSelector(value2, content, itemDisabled, closable, onClose2) {
    var onMouseDown = function onMouseDown2(e3) {
      onPreventMouseDown(e3);
      onToggleOpen(!open);
    };
    return /* @__PURE__ */ react.exports.createElement("span", {
      onMouseDown
    }, tagRender({
      label: content,
      value: value2,
      disabled: itemDisabled,
      closable,
      onClose: onClose2
    }));
  }
  function renderItem(valueItem) {
    var itemDisabled = valueItem.disabled, label2 = valueItem.label, value2 = valueItem.value;
    var closable = !disabled && !itemDisabled;
    var displayLabel = label2;
    if (typeof maxTagTextLength === "number") {
      if (typeof label2 === "string" || typeof label2 === "number") {
        var strLabel = String(displayLabel);
        if (strLabel.length > maxTagTextLength) {
          displayLabel = "".concat(strLabel.slice(0, maxTagTextLength), "...");
        }
      }
    }
    var onClose2 = function onClose3(event) {
      if (event)
        event.stopPropagation();
      onRemove(valueItem);
    };
    return typeof tagRender === "function" ? customizeRenderSelector(value2, displayLabel, itemDisabled, closable, onClose2) : defaultRenderSelector(valueItem, displayLabel, itemDisabled, closable, onClose2);
  }
  function renderRest(omittedValues) {
    var content = typeof maxTagPlaceholder === "function" ? maxTagPlaceholder(omittedValues) : maxTagPlaceholder;
    return defaultRenderSelector({
      title: content
    }, content, false);
  }
  var inputNode = /* @__PURE__ */ react.exports.createElement("div", {
    className: "".concat(selectionPrefixCls, "-search"),
    style: {
      width: inputWidth
    },
    onFocus: function onFocus2() {
      setFocused(true);
    },
    onBlur: function onBlur2() {
      setFocused(false);
    }
  }, /* @__PURE__ */ react.exports.createElement(RefInput, {
    ref: inputRef,
    open,
    prefixCls,
    id: id2,
    inputElement: null,
    disabled,
    autoFocus,
    autoComplete,
    editable: inputEditable,
    activeDescendantId,
    value: inputValue,
    onKeyDown: onInputKeyDown,
    onMouseDown: onInputMouseDown,
    onChange: onInputChange,
    onPaste: onInputPaste,
    onCompositionStart: onInputCompositionStart,
    onCompositionEnd: onInputCompositionEnd,
    tabIndex,
    attrs: pickAttrs(props, true)
  }), /* @__PURE__ */ react.exports.createElement("span", {
    ref: measureRef,
    className: "".concat(selectionPrefixCls, "-search-mirror"),
    "aria-hidden": true
  }, inputValue, "\xA0"));
  var selectionNode = /* @__PURE__ */ react.exports.createElement(ForwardOverflow, {
    prefixCls: "".concat(selectionPrefixCls, "-overflow"),
    data: values2,
    renderItem,
    renderRest,
    suffix: inputNode,
    itemKey: itemKey$1,
    maxCount: maxTagCount
  });
  return /* @__PURE__ */ react.exports.createElement(react.exports.Fragment, null, selectionNode, !values2.length && !inputValue && /* @__PURE__ */ react.exports.createElement("span", {
    className: "".concat(selectionPrefixCls, "-placeholder")
  }, placeholder));
};
var SingleSelector = function SingleSelector2(props) {
  var inputElement = props.inputElement, prefixCls = props.prefixCls, id2 = props.id, inputRef = props.inputRef, disabled = props.disabled, autoFocus = props.autoFocus, autoComplete = props.autoComplete, activeDescendantId = props.activeDescendantId, mode = props.mode, open = props.open, values2 = props.values, placeholder = props.placeholder, tabIndex = props.tabIndex, showSearch = props.showSearch, searchValue = props.searchValue, activeValue = props.activeValue, maxLength = props.maxLength, onInputKeyDown = props.onInputKeyDown, onInputMouseDown = props.onInputMouseDown, onInputChange = props.onInputChange, onInputPaste = props.onInputPaste, onInputCompositionStart = props.onInputCompositionStart, onInputCompositionEnd = props.onInputCompositionEnd;
  var _React$useState = react.exports.useState(false), _React$useState2 = _slicedToArray$4(_React$useState, 2), inputChanged = _React$useState2[0], setInputChanged = _React$useState2[1];
  var combobox = mode === "combobox";
  var inputEditable = combobox || showSearch;
  var item = values2[0];
  var inputValue = searchValue || "";
  if (combobox && activeValue && !inputChanged) {
    inputValue = activeValue;
  }
  react.exports.useEffect(function() {
    if (combobox) {
      setInputChanged(false);
    }
  }, [combobox, activeValue]);
  var hasTextInput = mode !== "combobox" && !open && !showSearch ? false : !!inputValue;
  var title = getTitle(item);
  var renderPlaceholder = function renderPlaceholder2() {
    if (item) {
      return null;
    }
    var hiddenStyle = hasTextInput ? {
      visibility: "hidden"
    } : void 0;
    return /* @__PURE__ */ react.exports.createElement("span", {
      className: "".concat(prefixCls, "-selection-placeholder"),
      style: hiddenStyle
    }, placeholder);
  };
  return /* @__PURE__ */ react.exports.createElement(react.exports.Fragment, null, /* @__PURE__ */ react.exports.createElement("span", {
    className: "".concat(prefixCls, "-selection-search")
  }, /* @__PURE__ */ react.exports.createElement(RefInput, {
    ref: inputRef,
    prefixCls,
    id: id2,
    open,
    inputElement,
    disabled,
    autoFocus,
    autoComplete,
    editable: inputEditable,
    activeDescendantId,
    value: inputValue,
    onKeyDown: onInputKeyDown,
    onMouseDown: onInputMouseDown,
    onChange: function onChange2(e3) {
      setInputChanged(true);
      onInputChange(e3);
    },
    onPaste: onInputPaste,
    onCompositionStart: onInputCompositionStart,
    onCompositionEnd: onInputCompositionEnd,
    tabIndex,
    attrs: pickAttrs(props, true),
    maxLength: combobox ? maxLength : void 0
  })), !combobox && item && !hasTextInput && /* @__PURE__ */ react.exports.createElement("span", {
    className: "".concat(prefixCls, "-selection-item"),
    title
  }, item.label), renderPlaceholder());
};
function useLock() {
  var duration = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 250;
  var lockRef = react.exports.useRef(null);
  var timeoutRef = react.exports.useRef(null);
  react.exports.useEffect(function() {
    return function() {
      window.clearTimeout(timeoutRef.current);
    };
  }, []);
  function doLock(locked) {
    if (locked || lockRef.current === null) {
      lockRef.current = locked;
    }
    window.clearTimeout(timeoutRef.current);
    timeoutRef.current = window.setTimeout(function() {
      lockRef.current = null;
    }, duration);
  }
  return [function() {
    return lockRef.current;
  }, doLock];
}
function isValidateOpenKey(currentKeyCode) {
  return ![
    KeyCode.ESC,
    KeyCode.SHIFT,
    KeyCode.BACKSPACE,
    KeyCode.TAB,
    KeyCode.WIN_KEY,
    KeyCode.ALT,
    KeyCode.META,
    KeyCode.WIN_KEY_RIGHT,
    KeyCode.CTRL,
    KeyCode.SEMICOLON,
    KeyCode.EQUALS,
    KeyCode.CAPS_LOCK,
    KeyCode.CONTEXT_MENU,
    KeyCode.F1,
    KeyCode.F2,
    KeyCode.F3,
    KeyCode.F4,
    KeyCode.F5,
    KeyCode.F6,
    KeyCode.F7,
    KeyCode.F8,
    KeyCode.F9,
    KeyCode.F10,
    KeyCode.F11,
    KeyCode.F12
  ].includes(currentKeyCode);
}
var Selector = function Selector2(props, ref) {
  var inputRef = react.exports.useRef(null);
  var compositionStatusRef = react.exports.useRef(false);
  var prefixCls = props.prefixCls, open = props.open, mode = props.mode, showSearch = props.showSearch, tokenWithEnter = props.tokenWithEnter, onSearch = props.onSearch, onSearchSubmit = props.onSearchSubmit, onToggleOpen = props.onToggleOpen, onInputKeyDown = props.onInputKeyDown, domRef = props.domRef;
  react.exports.useImperativeHandle(ref, function() {
    return {
      focus: function focus() {
        inputRef.current.focus();
      },
      blur: function blur() {
        inputRef.current.blur();
      }
    };
  });
  var _useLock = useLock(0), _useLock2 = _slicedToArray$4(_useLock, 2), getInputMouseDown = _useLock2[0], setInputMouseDown = _useLock2[1];
  var onInternalInputKeyDown = function onInternalInputKeyDown2(event) {
    var which = event.which;
    if (which === KeyCode.UP || which === KeyCode.DOWN) {
      event.preventDefault();
    }
    if (onInputKeyDown) {
      onInputKeyDown(event);
    }
    if (which === KeyCode.ENTER && mode === "tags" && !compositionStatusRef.current && !open) {
      onSearchSubmit === null || onSearchSubmit === void 0 ? void 0 : onSearchSubmit(event.target.value);
    }
    if (isValidateOpenKey(which)) {
      onToggleOpen(true);
    }
  };
  var onInternalInputMouseDown = function onInternalInputMouseDown2() {
    setInputMouseDown(true);
  };
  var pastedTextRef = react.exports.useRef(null);
  var triggerOnSearch = function triggerOnSearch2(value2) {
    if (onSearch(value2, true, compositionStatusRef.current) !== false) {
      onToggleOpen(true);
    }
  };
  var onInputCompositionStart = function onInputCompositionStart2() {
    compositionStatusRef.current = true;
  };
  var onInputCompositionEnd = function onInputCompositionEnd2(e3) {
    compositionStatusRef.current = false;
    if (mode !== "combobox") {
      triggerOnSearch(e3.target.value);
    }
  };
  var onInputChange = function onInputChange2(event) {
    var value2 = event.target.value;
    if (tokenWithEnter && pastedTextRef.current && /[\r\n]/.test(pastedTextRef.current)) {
      var replacedText = pastedTextRef.current.replace(/[\r\n]+$/, "").replace(/\r\n/g, " ").replace(/[\r\n]/g, " ");
      value2 = value2.replace(replacedText, pastedTextRef.current);
    }
    pastedTextRef.current = null;
    triggerOnSearch(value2);
  };
  var onInputPaste = function onInputPaste2(e3) {
    var clipboardData = e3.clipboardData;
    var value2 = clipboardData.getData("text");
    pastedTextRef.current = value2;
  };
  var onClick = function onClick2(_ref) {
    var target = _ref.target;
    if (target !== inputRef.current) {
      var isIE = document.body.style.msTouchAction !== void 0;
      if (isIE) {
        setTimeout(function() {
          inputRef.current.focus();
        });
      } else {
        inputRef.current.focus();
      }
    }
  };
  var onMouseDown = function onMouseDown2(event) {
    var inputMouseDown = getInputMouseDown();
    if (event.target !== inputRef.current && !inputMouseDown && mode !== "combobox") {
      event.preventDefault();
    }
    if (mode !== "combobox" && (!showSearch || !inputMouseDown) || !open) {
      if (open) {
        onSearch("", true, false);
      }
      onToggleOpen();
    }
  };
  var sharedProps = {
    inputRef,
    onInputKeyDown: onInternalInputKeyDown,
    onInputMouseDown: onInternalInputMouseDown,
    onInputChange,
    onInputPaste,
    onInputCompositionStart,
    onInputCompositionEnd
  };
  var selectNode = mode === "multiple" || mode === "tags" ? /* @__PURE__ */ react.exports.createElement(SelectSelector, _extends$2({}, props, sharedProps)) : /* @__PURE__ */ react.exports.createElement(SingleSelector, _extends$2({}, props, sharedProps));
  return /* @__PURE__ */ react.exports.createElement("div", {
    ref: domRef,
    className: "".concat(prefixCls, "-selector"),
    onClick,
    onMouseDown
  }, selectNode);
};
var ForwardSelector = /* @__PURE__ */ react.exports.forwardRef(Selector);
ForwardSelector.displayName = "Selector";
function useSelectTriggerControl(elements, open, triggerOpen, customizedTrigger) {
  var propsRef = react.exports.useRef(null);
  propsRef.current = {
    open,
    triggerOpen,
    customizedTrigger
  };
  react.exports.useEffect(function() {
    function onGlobalMouseDown(event) {
      var _propsRef$current;
      if ((_propsRef$current = propsRef.current) === null || _propsRef$current === void 0 ? void 0 : _propsRef$current.customizedTrigger) {
        return;
      }
      var target = event.target;
      if (target.shadowRoot && event.composed) {
        target = event.composedPath()[0] || target;
      }
      if (propsRef.current.open && elements().filter(function(element) {
        return element;
      }).every(function(element) {
        return !element.contains(target) && element !== target;
      })) {
        propsRef.current.triggerOpen(false);
      }
    }
    window.addEventListener("mousedown", onGlobalMouseDown);
    return function() {
      return window.removeEventListener("mousedown", onGlobalMouseDown);
    };
  }, []);
}
function useDelayReset() {
  var timeout2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 10;
  var _React$useState = react.exports.useState(false), _React$useState2 = _slicedToArray$4(_React$useState, 2), bool = _React$useState2[0], setBool = _React$useState2[1];
  var delayRef = react.exports.useRef(null);
  var cancelLatest = function cancelLatest2() {
    window.clearTimeout(delayRef.current);
  };
  react.exports.useEffect(function() {
    return cancelLatest;
  }, []);
  var delaySetBool = function delaySetBool2(value2, callback) {
    cancelLatest();
    delayRef.current = window.setTimeout(function() {
      setBool(value2);
      if (callback) {
        callback();
      }
    }, timeout2);
  };
  return [bool, delaySetBool, cancelLatest];
}
var BaseSelectContext = /* @__PURE__ */ react.exports.createContext(null);
function useBaseProps() {
  return react.exports.useContext(BaseSelectContext);
}
var _excluded$r = ["id", "prefixCls", "className", "showSearch", "tagRender", "direction", "omitDomProps", "displayValues", "onDisplayValuesChange", "emptyOptions", "notFoundContent", "onClear", "mode", "disabled", "loading", "getInputElement", "getRawInputElement", "open", "defaultOpen", "onDropdownVisibleChange", "activeValue", "onActiveValueChange", "activeDescendantId", "searchValue", "onSearch", "onSearchSplit", "tokenSeparators", "allowClear", "showArrow", "inputIcon", "clearIcon", "OptionList", "animation", "transitionName", "dropdownStyle", "dropdownClassName", "dropdownMatchSelectWidth", "dropdownRender", "dropdownAlign", "placement", "getPopupContainer", "showAction", "onFocus", "onBlur", "onKeyUp", "onKeyDown", "onMouseDown"];
var DEFAULT_OMIT_PROPS = ["value", "onChange", "removeIcon", "placeholder", "autoFocus", "maxTagCount", "maxTagTextLength", "maxTagPlaceholder", "choiceTransitionName", "onInputKeyDown", "onPopupScroll", "tabIndex"];
function isMultiple(mode) {
  return mode === "tags" || mode === "multiple";
}
var BaseSelect = /* @__PURE__ */ react.exports.forwardRef(function(props, ref) {
  var _customizeRawInputEle, _classNames2;
  var id2 = props.id, prefixCls = props.prefixCls, className = props.className, showSearch = props.showSearch, tagRender = props.tagRender, direction2 = props.direction, omitDomProps = props.omitDomProps, displayValues = props.displayValues, onDisplayValuesChange = props.onDisplayValuesChange, emptyOptions = props.emptyOptions, _props$notFoundConten = props.notFoundContent, notFoundContent = _props$notFoundConten === void 0 ? "Not Found" : _props$notFoundConten, onClear = props.onClear, mode = props.mode, disabled = props.disabled, loading = props.loading, getInputElement = props.getInputElement, getRawInputElement = props.getRawInputElement, open = props.open, defaultOpen = props.defaultOpen, onDropdownVisibleChange = props.onDropdownVisibleChange, activeValue = props.activeValue, onActiveValueChange = props.onActiveValueChange, activeDescendantId = props.activeDescendantId, searchValue = props.searchValue, onSearch = props.onSearch, onSearchSplit = props.onSearchSplit, tokenSeparators = props.tokenSeparators, allowClear = props.allowClear, showArrow = props.showArrow, inputIcon = props.inputIcon, clearIcon = props.clearIcon, OptionList3 = props.OptionList, animation2 = props.animation, transitionName2 = props.transitionName, dropdownStyle = props.dropdownStyle, dropdownClassName = props.dropdownClassName, dropdownMatchSelectWidth = props.dropdownMatchSelectWidth, dropdownRender = props.dropdownRender, dropdownAlign = props.dropdownAlign, placement = props.placement, getPopupContainer = props.getPopupContainer, _props$showAction = props.showAction, showAction = _props$showAction === void 0 ? [] : _props$showAction, onFocus2 = props.onFocus, onBlur2 = props.onBlur, onKeyUp2 = props.onKeyUp, onKeyDown2 = props.onKeyDown, onMouseDown = props.onMouseDown, restProps = _objectWithoutProperties$1(props, _excluded$r);
  var multiple = isMultiple(mode);
  var mergedShowSearch = (showSearch !== void 0 ? showSearch : multiple) || mode === "combobox";
  var domProps = _objectSpread2$1({}, restProps);
  DEFAULT_OMIT_PROPS.forEach(function(propName) {
    delete domProps[propName];
  });
  omitDomProps === null || omitDomProps === void 0 ? void 0 : omitDomProps.forEach(function(propName) {
    delete domProps[propName];
  });
  var _React$useState = react.exports.useState(false), _React$useState2 = _slicedToArray$4(_React$useState, 2), mobile = _React$useState2[0], setMobile = _React$useState2[1];
  react.exports.useEffect(function() {
    setMobile(isMobile());
  }, []);
  var containerRef = react.exports.useRef(null);
  var selectorDomRef = react.exports.useRef(null);
  var triggerRef = react.exports.useRef(null);
  var selectorRef = react.exports.useRef(null);
  var listRef = react.exports.useRef(null);
  var _useDelayReset = useDelayReset(), _useDelayReset2 = _slicedToArray$4(_useDelayReset, 3), mockFocused = _useDelayReset2[0], setMockFocused = _useDelayReset2[1], cancelSetMockFocused = _useDelayReset2[2];
  react.exports.useImperativeHandle(ref, function() {
    var _selectorRef$current, _selectorRef$current2;
    return {
      focus: (_selectorRef$current = selectorRef.current) === null || _selectorRef$current === void 0 ? void 0 : _selectorRef$current.focus,
      blur: (_selectorRef$current2 = selectorRef.current) === null || _selectorRef$current2 === void 0 ? void 0 : _selectorRef$current2.blur,
      scrollTo: function scrollTo2(arg) {
        var _listRef$current;
        return (_listRef$current = listRef.current) === null || _listRef$current === void 0 ? void 0 : _listRef$current.scrollTo(arg);
      }
    };
  });
  var mergedSearchValue = react.exports.useMemo(function() {
    var _displayValues$;
    if (mode !== "combobox") {
      return searchValue;
    }
    var val = (_displayValues$ = displayValues[0]) === null || _displayValues$ === void 0 ? void 0 : _displayValues$.value;
    return typeof val === "string" || typeof val === "number" ? String(val) : "";
  }, [searchValue, mode, displayValues]);
  var customizeInputElement = mode === "combobox" && typeof getInputElement === "function" && getInputElement() || null;
  var customizeRawInputElement = typeof getRawInputElement === "function" && getRawInputElement();
  var customizeRawInputRef = useComposeRef(selectorDomRef, customizeRawInputElement === null || customizeRawInputElement === void 0 ? void 0 : (_customizeRawInputEle = customizeRawInputElement.props) === null || _customizeRawInputEle === void 0 ? void 0 : _customizeRawInputEle.ref);
  var _useMergedState = useMergedState(void 0, {
    defaultValue: defaultOpen,
    value: open
  }), _useMergedState2 = _slicedToArray$4(_useMergedState, 2), innerOpen = _useMergedState2[0], setInnerOpen = _useMergedState2[1];
  var mergedOpen = innerOpen;
  var emptyListContent = !notFoundContent && emptyOptions;
  if (disabled || emptyListContent && mergedOpen && mode === "combobox") {
    mergedOpen = false;
  }
  var triggerOpen = emptyListContent ? false : mergedOpen;
  var onToggleOpen = react.exports.useCallback(function(newOpen) {
    var nextOpen = newOpen !== void 0 ? newOpen : !mergedOpen;
    if (mergedOpen !== nextOpen && !disabled) {
      setInnerOpen(nextOpen);
      onDropdownVisibleChange === null || onDropdownVisibleChange === void 0 ? void 0 : onDropdownVisibleChange(nextOpen);
    }
  }, [disabled, mergedOpen, setInnerOpen, onDropdownVisibleChange]);
  var tokenWithEnter = react.exports.useMemo(function() {
    return (tokenSeparators || []).some(function(tokenSeparator) {
      return ["\n", "\r\n"].includes(tokenSeparator);
    });
  }, [tokenSeparators]);
  var onInternalSearch = function onInternalSearch2(searchText, fromTyping, isCompositing) {
    var ret = true;
    var newSearchText = searchText;
    onActiveValueChange === null || onActiveValueChange === void 0 ? void 0 : onActiveValueChange(null);
    var patchLabels = isCompositing ? null : getSeparatedContent(searchText, tokenSeparators);
    if (mode !== "combobox" && patchLabels) {
      newSearchText = "";
      onSearchSplit === null || onSearchSplit === void 0 ? void 0 : onSearchSplit(patchLabels);
      onToggleOpen(false);
      ret = false;
    }
    if (onSearch && mergedSearchValue !== newSearchText) {
      onSearch(newSearchText, {
        source: fromTyping ? "typing" : "effect"
      });
    }
    return ret;
  };
  var onInternalSearchSubmit = function onInternalSearchSubmit2(searchText) {
    if (!searchText || !searchText.trim()) {
      return;
    }
    onSearch(searchText, {
      source: "submit"
    });
  };
  react.exports.useEffect(function() {
    if (!mergedOpen && !multiple && mode !== "combobox") {
      onInternalSearch("", false, false);
    }
  }, [mergedOpen]);
  react.exports.useEffect(function() {
    if (innerOpen && disabled) {
      setInnerOpen(false);
    }
    if (disabled) {
      setMockFocused(false);
    }
  }, [disabled]);
  var _useLock = useLock(), _useLock2 = _slicedToArray$4(_useLock, 2), getClearLock = _useLock2[0], setClearLock = _useLock2[1];
  var onInternalKeyDown = function onInternalKeyDown2(event) {
    var clearLock = getClearLock();
    var which = event.which;
    if (which === KeyCode.ENTER) {
      if (mode !== "combobox") {
        event.preventDefault();
      }
      if (!mergedOpen) {
        onToggleOpen(true);
      }
    }
    setClearLock(!!mergedSearchValue);
    if (which === KeyCode.BACKSPACE && !clearLock && multiple && !mergedSearchValue && displayValues.length) {
      var cloneDisplayValues = _toConsumableArray(displayValues);
      var removedDisplayValue = null;
      for (var i2 = cloneDisplayValues.length - 1; i2 >= 0; i2 -= 1) {
        var current = cloneDisplayValues[i2];
        if (!current.disabled) {
          cloneDisplayValues.splice(i2, 1);
          removedDisplayValue = current;
          break;
        }
      }
      if (removedDisplayValue) {
        onDisplayValuesChange(cloneDisplayValues, {
          type: "remove",
          values: [removedDisplayValue]
        });
      }
    }
    for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      rest[_key - 1] = arguments[_key];
    }
    if (mergedOpen && listRef.current) {
      var _listRef$current2;
      (_listRef$current2 = listRef.current).onKeyDown.apply(_listRef$current2, [event].concat(rest));
    }
    onKeyDown2 === null || onKeyDown2 === void 0 ? void 0 : onKeyDown2.apply(void 0, [event].concat(rest));
  };
  var onInternalKeyUp = function onInternalKeyUp2(event) {
    for (var _len2 = arguments.length, rest = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      rest[_key2 - 1] = arguments[_key2];
    }
    if (mergedOpen && listRef.current) {
      var _listRef$current3;
      (_listRef$current3 = listRef.current).onKeyUp.apply(_listRef$current3, [event].concat(rest));
    }
    onKeyUp2 === null || onKeyUp2 === void 0 ? void 0 : onKeyUp2.apply(void 0, [event].concat(rest));
  };
  var onSelectorRemove = function onSelectorRemove2(val) {
    var newValues = displayValues.filter(function(i2) {
      return i2 !== val;
    });
    onDisplayValuesChange(newValues, {
      type: "remove",
      values: [val]
    });
  };
  var focusRef = react.exports.useRef(false);
  var onContainerFocus = function onContainerFocus2() {
    setMockFocused(true);
    if (!disabled) {
      if (onFocus2 && !focusRef.current) {
        onFocus2.apply(void 0, arguments);
      }
      if (showAction.includes("focus")) {
        onToggleOpen(true);
      }
    }
    focusRef.current = true;
  };
  var onContainerBlur = function onContainerBlur2() {
    setMockFocused(false, function() {
      focusRef.current = false;
      onToggleOpen(false);
    });
    if (disabled) {
      return;
    }
    if (mergedSearchValue) {
      if (mode === "tags") {
        onSearch(mergedSearchValue, {
          source: "submit"
        });
      } else if (mode === "multiple") {
        onSearch("", {
          source: "blur"
        });
      }
    }
    if (onBlur2) {
      onBlur2.apply(void 0, arguments);
    }
  };
  var activeTimeoutIds = [];
  react.exports.useEffect(function() {
    return function() {
      activeTimeoutIds.forEach(function(timeoutId) {
        return clearTimeout(timeoutId);
      });
      activeTimeoutIds.splice(0, activeTimeoutIds.length);
    };
  }, []);
  var onInternalMouseDown = function onInternalMouseDown2(event) {
    var _triggerRef$current;
    var target = event.target;
    var popupElement = (_triggerRef$current = triggerRef.current) === null || _triggerRef$current === void 0 ? void 0 : _triggerRef$current.getPopupElement();
    if (popupElement && popupElement.contains(target)) {
      var timeoutId = setTimeout(function() {
        var index2 = activeTimeoutIds.indexOf(timeoutId);
        if (index2 !== -1) {
          activeTimeoutIds.splice(index2, 1);
        }
        cancelSetMockFocused();
        if (!mobile && !popupElement.contains(document.activeElement)) {
          var _selectorRef$current3;
          (_selectorRef$current3 = selectorRef.current) === null || _selectorRef$current3 === void 0 ? void 0 : _selectorRef$current3.focus();
        }
      });
      activeTimeoutIds.push(timeoutId);
    }
    for (var _len3 = arguments.length, restArgs = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
      restArgs[_key3 - 1] = arguments[_key3];
    }
    onMouseDown === null || onMouseDown === void 0 ? void 0 : onMouseDown.apply(void 0, [event].concat(restArgs));
  };
  var _React$useState3 = react.exports.useState(null), _React$useState4 = _slicedToArray$4(_React$useState3, 2), containerWidth = _React$useState4[0], setContainerWidth = _React$useState4[1];
  var _React$useState5 = react.exports.useState({}), _React$useState6 = _slicedToArray$4(_React$useState5, 2), forceUpdate = _React$useState6[1];
  function onPopupMouseEnter() {
    forceUpdate({});
  }
  useLayoutEffect$1(function() {
    if (triggerOpen) {
      var _containerRef$current;
      var newWidth = Math.ceil((_containerRef$current = containerRef.current) === null || _containerRef$current === void 0 ? void 0 : _containerRef$current.offsetWidth);
      if (containerWidth !== newWidth && !Number.isNaN(newWidth)) {
        setContainerWidth(newWidth);
      }
    }
  }, [triggerOpen]);
  var onTriggerVisibleChange;
  if (customizeRawInputElement) {
    onTriggerVisibleChange = function onTriggerVisibleChange2(newOpen) {
      onToggleOpen(newOpen);
    };
  }
  useSelectTriggerControl(function() {
    var _triggerRef$current2;
    return [containerRef.current, (_triggerRef$current2 = triggerRef.current) === null || _triggerRef$current2 === void 0 ? void 0 : _triggerRef$current2.getPopupElement()];
  }, triggerOpen, onToggleOpen, !!customizeRawInputElement);
  var baseSelectContext = react.exports.useMemo(function() {
    return _objectSpread2$1(_objectSpread2$1({}, props), {}, {
      notFoundContent,
      open: mergedOpen,
      triggerOpen,
      id: id2,
      showSearch: mergedShowSearch,
      multiple,
      toggleOpen: onToggleOpen
    });
  }, [props, notFoundContent, triggerOpen, mergedOpen, id2, mergedShowSearch, multiple, onToggleOpen]);
  var mergedShowArrow = showArrow !== void 0 ? showArrow : loading || !multiple && mode !== "combobox";
  var arrowNode;
  if (mergedShowArrow) {
    arrowNode = /* @__PURE__ */ react.exports.createElement(TransBtn, {
      className: classNames("".concat(prefixCls, "-arrow"), _defineProperty$4({}, "".concat(prefixCls, "-arrow-loading"), loading)),
      customizeIcon: inputIcon,
      customizeIconProps: {
        loading,
        searchValue: mergedSearchValue,
        open: mergedOpen,
        focused: mockFocused,
        showSearch: mergedShowSearch
      }
    });
  }
  var clearNode;
  var onClearMouseDown = function onClearMouseDown2() {
    onClear === null || onClear === void 0 ? void 0 : onClear();
    onDisplayValuesChange([], {
      type: "clear",
      values: displayValues
    });
    onInternalSearch("", false, false);
  };
  if (!disabled && allowClear && (displayValues.length || mergedSearchValue) && !(mode === "combobox" && mergedSearchValue === "")) {
    clearNode = /* @__PURE__ */ react.exports.createElement(TransBtn, {
      className: "".concat(prefixCls, "-clear"),
      onMouseDown: onClearMouseDown,
      customizeIcon: clearIcon
    }, "\xD7");
  }
  var optionList = /* @__PURE__ */ react.exports.createElement(OptionList3, {
    ref: listRef
  });
  var mergedClassName = classNames(prefixCls, className, (_classNames2 = {}, _defineProperty$4(_classNames2, "".concat(prefixCls, "-focused"), mockFocused), _defineProperty$4(_classNames2, "".concat(prefixCls, "-multiple"), multiple), _defineProperty$4(_classNames2, "".concat(prefixCls, "-single"), !multiple), _defineProperty$4(_classNames2, "".concat(prefixCls, "-allow-clear"), allowClear), _defineProperty$4(_classNames2, "".concat(prefixCls, "-show-arrow"), mergedShowArrow), _defineProperty$4(_classNames2, "".concat(prefixCls, "-disabled"), disabled), _defineProperty$4(_classNames2, "".concat(prefixCls, "-loading"), loading), _defineProperty$4(_classNames2, "".concat(prefixCls, "-open"), mergedOpen), _defineProperty$4(_classNames2, "".concat(prefixCls, "-customize-input"), customizeInputElement), _defineProperty$4(_classNames2, "".concat(prefixCls, "-show-search"), mergedShowSearch), _classNames2));
  var selectorNode = /* @__PURE__ */ react.exports.createElement(RefSelectTrigger, {
    ref: triggerRef,
    disabled,
    prefixCls,
    visible: triggerOpen,
    popupElement: optionList,
    containerWidth,
    animation: animation2,
    transitionName: transitionName2,
    dropdownStyle,
    dropdownClassName,
    direction: direction2,
    dropdownMatchSelectWidth,
    dropdownRender,
    dropdownAlign,
    placement,
    getPopupContainer,
    empty: emptyOptions,
    getTriggerDOMNode: function getTriggerDOMNode() {
      return selectorDomRef.current;
    },
    onPopupVisibleChange: onTriggerVisibleChange,
    onPopupMouseEnter
  }, customizeRawInputElement ? /* @__PURE__ */ react.exports.cloneElement(customizeRawInputElement, {
    ref: customizeRawInputRef
  }) : /* @__PURE__ */ react.exports.createElement(ForwardSelector, _extends$2({}, props, {
    domRef: selectorDomRef,
    prefixCls,
    inputElement: customizeInputElement,
    ref: selectorRef,
    id: id2,
    showSearch: mergedShowSearch,
    mode,
    activeDescendantId,
    tagRender,
    values: displayValues,
    open: mergedOpen,
    onToggleOpen,
    activeValue,
    searchValue: mergedSearchValue,
    onSearch: onInternalSearch,
    onSearchSubmit: onInternalSearchSubmit,
    onRemove: onSelectorRemove,
    tokenWithEnter
  })));
  var renderNode;
  if (customizeRawInputElement) {
    renderNode = selectorNode;
  } else {
    renderNode = /* @__PURE__ */ react.exports.createElement("div", _extends$2({
      className: mergedClassName
    }, domProps, {
      ref: containerRef,
      onMouseDown: onInternalMouseDown,
      onKeyDown: onInternalKeyDown,
      onKeyUp: onInternalKeyUp,
      onFocus: onContainerFocus,
      onBlur: onContainerBlur
    }), mockFocused && !mergedOpen && /* @__PURE__ */ react.exports.createElement("span", {
      style: {
        width: 0,
        height: 0,
        position: "absolute",
        overflow: "hidden",
        opacity: 0
      },
      "aria-live": "polite"
    }, "".concat(displayValues.map(function(_ref) {
      var label2 = _ref.label, value2 = _ref.value;
      return ["number", "string"].includes(_typeof$4(label2)) ? label2 : value2;
    }).join(", "))), selectorNode, arrowNode, clearNode);
  }
  return /* @__PURE__ */ react.exports.createElement(BaseSelectContext.Provider, {
    value: baseSelectContext
  }, renderNode);
});
var useCache = function(labeledValues, valueOptions) {
  var cacheRef = react.exports.useRef({
    values: /* @__PURE__ */ new Map(),
    options: /* @__PURE__ */ new Map()
  });
  var filledLabeledValues = react.exports.useMemo(function() {
    var _cacheRef$current = cacheRef.current, prevValueCache = _cacheRef$current.values, prevOptionCache = _cacheRef$current.options;
    var patchedValues = labeledValues.map(function(item) {
      if (item.label === void 0) {
        var _prevValueCache$get;
        return _objectSpread2$1(_objectSpread2$1({}, item), {}, {
          label: (_prevValueCache$get = prevValueCache.get(item.value)) === null || _prevValueCache$get === void 0 ? void 0 : _prevValueCache$get.label
        });
      }
      return item;
    });
    var valueCache = /* @__PURE__ */ new Map();
    var optionCache = /* @__PURE__ */ new Map();
    patchedValues.forEach(function(item) {
      valueCache.set(item.value, item);
      optionCache.set(item.value, valueOptions.get(item.value) || prevOptionCache.get(item.value));
    });
    cacheRef.current.values = valueCache;
    cacheRef.current.options = optionCache;
    return patchedValues;
  }, [labeledValues, valueOptions]);
  var getOption = react.exports.useCallback(function(val) {
    return valueOptions.get(val) || cacheRef.current.options.get(val);
  }, [valueOptions]);
  return [filledLabeledValues, getOption];
};
function includes(test, search) {
  return toArray$3(test).join("").toUpperCase().includes(search);
}
var useFilterOptions = function(options, fieldNames, searchValue, filterOption, optionFilterProp) {
  return react.exports.useMemo(function() {
    if (!searchValue || filterOption === false) {
      return options;
    }
    var fieldOptions = fieldNames.options, fieldLabel = fieldNames.label, fieldValue = fieldNames.value;
    var filteredOptions = [];
    var customizeFilter = typeof filterOption === "function";
    var upperSearch = searchValue.toUpperCase();
    var filterFunc = customizeFilter ? filterOption : function(_2, option) {
      if (optionFilterProp) {
        return includes(option[optionFilterProp], upperSearch);
      }
      if (option[fieldOptions]) {
        return includes(option[fieldLabel !== "children" ? fieldLabel : "label"], upperSearch);
      }
      return includes(option[fieldValue], upperSearch);
    };
    var wrapOption = customizeFilter ? function(opt) {
      return injectPropsWithOption(opt);
    } : function(opt) {
      return opt;
    };
    options.forEach(function(item) {
      if (item[fieldOptions]) {
        var matchGroup = filterFunc(searchValue, wrapOption(item));
        if (matchGroup) {
          filteredOptions.push(item);
        } else {
          var subOptions = item[fieldOptions].filter(function(subItem) {
            return filterFunc(searchValue, wrapOption(subItem));
          });
          if (subOptions.length) {
            filteredOptions.push(_objectSpread2$1(_objectSpread2$1({}, item), {}, _defineProperty$4({}, fieldOptions, subOptions)));
          }
        }
        return;
      }
      if (filterFunc(searchValue, wrapOption(item))) {
        filteredOptions.push(item);
      }
    });
    return filteredOptions;
  }, [options, filterOption, optionFilterProp, searchValue, fieldNames]);
};
var uuid$3 = 0;
var isBrowserClient = canUseDom();
function getUUID() {
  var retId;
  if (isBrowserClient) {
    retId = uuid$3;
    uuid$3 += 1;
  } else {
    retId = "TEST_OR_SSR";
  }
  return retId;
}
function useId$1(id2) {
  var _React$useState = react.exports.useState(), _React$useState2 = _slicedToArray$4(_React$useState, 2), innerId = _React$useState2[0], setInnerId = _React$useState2[1];
  react.exports.useEffect(function() {
    setInnerId("rc_select_".concat(getUUID()));
  }, []);
  return id2 || innerId;
}
var _excluded$q = ["children", "value"], _excluded2$5 = ["children"];
function convertNodeToOption(node) {
  var key2 = node.key, _node$props = node.props, children = _node$props.children, value2 = _node$props.value, restProps = _objectWithoutProperties$1(_node$props, _excluded$q);
  return _objectSpread2$1({
    key: key2,
    value: value2 !== void 0 ? value2 : key2,
    children
  }, restProps);
}
function convertChildrenToData(nodes) {
  var optionOnly = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  return toArray$5(nodes).map(function(node, index2) {
    if (!/* @__PURE__ */ react.exports.isValidElement(node) || !node.type) {
      return null;
    }
    var isSelectOptGroup = node.type.isSelectOptGroup, key2 = node.key, _node$props2 = node.props, children = _node$props2.children, restProps = _objectWithoutProperties$1(_node$props2, _excluded2$5);
    if (optionOnly || !isSelectOptGroup) {
      return convertNodeToOption(node);
    }
    return _objectSpread2$1(_objectSpread2$1({
      key: "__RC_SELECT_GRP__".concat(key2 === null ? index2 : key2, "__"),
      label: key2
    }, restProps), {}, {
      options: convertChildrenToData(children)
    });
  }).filter(function(data2) {
    return data2;
  });
}
function useOptions(options, children, fieldNames, optionFilterProp, optionLabelProp) {
  return react.exports.useMemo(function() {
    var mergedOptions = options;
    var childrenAsData = !options;
    if (childrenAsData) {
      mergedOptions = convertChildrenToData(children);
    }
    var valueOptions = /* @__PURE__ */ new Map();
    var labelOptions = /* @__PURE__ */ new Map();
    var setLabelOptions = function setLabelOptions2(labelOptionsMap, option, key2) {
      if (key2 && typeof key2 === "string") {
        labelOptionsMap.set(option[key2], option);
      }
    };
    function dig(optionList) {
      var isChildren = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      for (var i2 = 0; i2 < optionList.length; i2 += 1) {
        var option = optionList[i2];
        if (!option[fieldNames.options] || isChildren) {
          valueOptions.set(option[fieldNames.value], option);
          setLabelOptions(labelOptions, option, fieldNames.label);
          setLabelOptions(labelOptions, option, optionFilterProp);
          setLabelOptions(labelOptions, option, optionLabelProp);
        } else {
          dig(option[fieldNames.options], true);
        }
      }
    }
    dig(mergedOptions);
    return {
      options: mergedOptions,
      valueOptions,
      labelOptions
    };
  }, [options, children, fieldNames, optionFilterProp, optionLabelProp]);
}
function useRefFunc(callback) {
  var funcRef = react.exports.useRef();
  funcRef.current = callback;
  var cacheFn = react.exports.useCallback(function() {
    return funcRef.current.apply(funcRef, arguments);
  }, []);
  return cacheFn;
}
var OptGroup = function OptGroup2() {
  return null;
};
OptGroup.isSelectOptGroup = true;
var Option = function Option2() {
  return null;
};
Option.isSelectOption = true;
function ownKeys$1(object4, enumerableOnly) {
  var keys2 = Object.keys(object4);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object4);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object4, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$1(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? ownKeys$1(Object(source), true).forEach(function(key2) {
      _defineProperty$2(target, key2, source[key2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function(key2) {
      Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source, key2));
    });
  }
  return target;
}
function _defineProperty$2(obj, key2, value2) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value: value2, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value2;
  }
  return obj;
}
var Filler = /* @__PURE__ */ react.exports.forwardRef(function(_ref, ref) {
  var height = _ref.height, offset3 = _ref.offset, children = _ref.children, prefixCls = _ref.prefixCls, onInnerResize = _ref.onInnerResize;
  var outerStyle = {};
  var innerStyle = {
    display: "flex",
    flexDirection: "column"
  };
  if (offset3 !== void 0) {
    outerStyle = {
      height,
      position: "relative",
      overflow: "hidden"
    };
    innerStyle = _objectSpread$1(_objectSpread$1({}, innerStyle), {}, {
      transform: "translateY(".concat(offset3, "px)"),
      position: "absolute",
      left: 0,
      right: 0,
      top: 0
    });
  }
  return /* @__PURE__ */ react.exports.createElement("div", {
    style: outerStyle
  }, /* @__PURE__ */ react.exports.createElement(ResizeObserver$1, {
    onResize: function onResize2(_ref2) {
      var offsetHeight = _ref2.offsetHeight;
      if (offsetHeight && onInnerResize) {
        onInnerResize();
      }
    }
  }, /* @__PURE__ */ react.exports.createElement("div", {
    style: innerStyle,
    className: classNames(_defineProperty$2({}, "".concat(prefixCls, "-holder-inner"), prefixCls)),
    ref
  }, children)));
});
Filler.displayName = "Filler";
function _typeof$2(obj) {
  "@babel/helpers - typeof";
  return _typeof$2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$2(obj);
}
function _defineProperty$1(obj, key2, value2) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value: value2, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value2;
  }
  return obj;
}
function _classCallCheck$1(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o2, p2) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
    o3.__proto__ = p3;
    return o3;
  };
  return _setPrototypeOf(o2, p2);
}
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _possibleConstructorReturn(self2, call2) {
  if (call2 && (_typeof$2(call2) === "object" || typeof call2 === "function")) {
    return call2;
  } else if (call2 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized(self2);
}
function _assertThisInitialized(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function _getPrototypeOf(o2) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o3) {
    return o3.__proto__ || Object.getPrototypeOf(o3);
  };
  return _getPrototypeOf(o2);
}
var MIN_SIZE = 20;
function getPageY(e3) {
  return "touches" in e3 ? e3.touches[0].pageY : e3.pageY;
}
var ScrollBar = /* @__PURE__ */ function(_React$Component) {
  _inherits(ScrollBar2, _React$Component);
  var _super = _createSuper(ScrollBar2);
  function ScrollBar2() {
    var _this;
    _classCallCheck$1(this, ScrollBar2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _this.moveRaf = null;
    _this.scrollbarRef = /* @__PURE__ */ react.exports.createRef();
    _this.thumbRef = /* @__PURE__ */ react.exports.createRef();
    _this.visibleTimeout = null;
    _this.state = {
      dragging: false,
      pageY: null,
      startTop: null,
      visible: false
    };
    _this.delayHidden = function() {
      clearTimeout(_this.visibleTimeout);
      _this.setState({
        visible: true
      });
      _this.visibleTimeout = setTimeout(function() {
        _this.setState({
          visible: false
        });
      }, 2e3);
    };
    _this.onScrollbarTouchStart = function(e3) {
      e3.preventDefault();
    };
    _this.onContainerMouseDown = function(e3) {
      e3.stopPropagation();
      e3.preventDefault();
    };
    _this.patchEvents = function() {
      window.addEventListener("mousemove", _this.onMouseMove);
      window.addEventListener("mouseup", _this.onMouseUp);
      _this.thumbRef.current.addEventListener("touchmove", _this.onMouseMove);
      _this.thumbRef.current.addEventListener("touchend", _this.onMouseUp);
    };
    _this.removeEvents = function() {
      var _this$scrollbarRef$cu;
      window.removeEventListener("mousemove", _this.onMouseMove);
      window.removeEventListener("mouseup", _this.onMouseUp);
      (_this$scrollbarRef$cu = _this.scrollbarRef.current) === null || _this$scrollbarRef$cu === void 0 ? void 0 : _this$scrollbarRef$cu.removeEventListener("touchstart", _this.onScrollbarTouchStart);
      if (_this.thumbRef.current) {
        _this.thumbRef.current.removeEventListener("touchstart", _this.onMouseDown);
        _this.thumbRef.current.removeEventListener("touchmove", _this.onMouseMove);
        _this.thumbRef.current.removeEventListener("touchend", _this.onMouseUp);
      }
      wrapperRaf$1.cancel(_this.moveRaf);
    };
    _this.onMouseDown = function(e3) {
      var onStartMove = _this.props.onStartMove;
      _this.setState({
        dragging: true,
        pageY: getPageY(e3),
        startTop: _this.getTop()
      });
      onStartMove();
      _this.patchEvents();
      e3.stopPropagation();
      e3.preventDefault();
    };
    _this.onMouseMove = function(e3) {
      var _this$state = _this.state, dragging = _this$state.dragging, pageY = _this$state.pageY, startTop = _this$state.startTop;
      var onScroll = _this.props.onScroll;
      wrapperRaf$1.cancel(_this.moveRaf);
      if (dragging) {
        var offsetY = getPageY(e3) - pageY;
        var newTop = startTop + offsetY;
        var enableScrollRange = _this.getEnableScrollRange();
        var enableHeightRange = _this.getEnableHeightRange();
        var ptg = enableHeightRange ? newTop / enableHeightRange : 0;
        var newScrollTop = Math.ceil(ptg * enableScrollRange);
        _this.moveRaf = wrapperRaf$1(function() {
          onScroll(newScrollTop);
        });
      }
    };
    _this.onMouseUp = function() {
      var onStopMove = _this.props.onStopMove;
      _this.setState({
        dragging: false
      });
      onStopMove();
      _this.removeEvents();
    };
    _this.getSpinHeight = function() {
      var _this$props = _this.props, height = _this$props.height, count2 = _this$props.count;
      var baseHeight = height / count2 * 10;
      baseHeight = Math.max(baseHeight, MIN_SIZE);
      baseHeight = Math.min(baseHeight, height / 2);
      return Math.floor(baseHeight);
    };
    _this.getEnableScrollRange = function() {
      var _this$props2 = _this.props, scrollHeight = _this$props2.scrollHeight, height = _this$props2.height;
      return scrollHeight - height || 0;
    };
    _this.getEnableHeightRange = function() {
      var height = _this.props.height;
      var spinHeight = _this.getSpinHeight();
      return height - spinHeight || 0;
    };
    _this.getTop = function() {
      var scrollTop = _this.props.scrollTop;
      var enableScrollRange = _this.getEnableScrollRange();
      var enableHeightRange = _this.getEnableHeightRange();
      if (scrollTop === 0 || enableScrollRange === 0) {
        return 0;
      }
      var ptg = scrollTop / enableScrollRange;
      return ptg * enableHeightRange;
    };
    _this.showScroll = function() {
      var _this$props3 = _this.props, height = _this$props3.height, scrollHeight = _this$props3.scrollHeight;
      return scrollHeight > height;
    };
    return _this;
  }
  _createClass$1(ScrollBar2, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this.scrollbarRef.current.addEventListener("touchstart", this.onScrollbarTouchStart);
      this.thumbRef.current.addEventListener("touchstart", this.onMouseDown);
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      if (prevProps.scrollTop !== this.props.scrollTop) {
        this.delayHidden();
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.removeEvents();
      clearTimeout(this.visibleTimeout);
    }
  }, {
    key: "render",
    value: function render2() {
      var _this$state2 = this.state, dragging = _this$state2.dragging, visible = _this$state2.visible;
      var prefixCls = this.props.prefixCls;
      var spinHeight = this.getSpinHeight();
      var top = this.getTop();
      var canScroll = this.showScroll();
      var mergedVisible = canScroll && visible;
      return /* @__PURE__ */ react.exports.createElement("div", {
        ref: this.scrollbarRef,
        className: classNames("".concat(prefixCls, "-scrollbar"), _defineProperty$1({}, "".concat(prefixCls, "-scrollbar-show"), canScroll)),
        style: {
          width: 8,
          top: 0,
          bottom: 0,
          right: 0,
          position: "absolute",
          display: mergedVisible ? null : "none"
        },
        onMouseDown: this.onContainerMouseDown,
        onMouseMove: this.delayHidden
      }, /* @__PURE__ */ react.exports.createElement("div", {
        ref: this.thumbRef,
        className: classNames("".concat(prefixCls, "-scrollbar-thumb"), _defineProperty$1({}, "".concat(prefixCls, "-scrollbar-thumb-moving"), dragging)),
        style: {
          width: "100%",
          height: spinHeight,
          top,
          left: 0,
          position: "absolute",
          background: "rgba(0, 0, 0, 0.5)",
          borderRadius: 99,
          cursor: "pointer",
          userSelect: "none"
        },
        onMouseDown: this.onMouseDown
      }));
    }
  }]);
  return ScrollBar2;
}(react.exports.Component);
function Item$2(_ref) {
  var children = _ref.children, setRef = _ref.setRef;
  var refFunc = react.exports.useCallback(function(node) {
    setRef(node);
  }, []);
  return /* @__PURE__ */ react.exports.cloneElement(children, {
    ref: refFunc
  });
}
function useChildren(list, startIndex, endIndex, setNodeRef, renderFunc, _ref) {
  var getKey2 = _ref.getKey;
  return list.slice(startIndex, endIndex + 1).map(function(item, index2) {
    var eleIndex = startIndex + index2;
    var node = renderFunc(item, eleIndex, {});
    var key2 = getKey2(item);
    return /* @__PURE__ */ react.exports.createElement(Item$2, {
      key: key2,
      setRef: function setRef(ele) {
        return setNodeRef(item, ele);
      }
    }, node);
  });
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
var CacheMap = /* @__PURE__ */ function() {
  function CacheMap2() {
    _classCallCheck(this, CacheMap2);
    this.maps = void 0;
    this.maps = /* @__PURE__ */ Object.create(null);
  }
  _createClass(CacheMap2, [{
    key: "set",
    value: function set2(key2, value2) {
      this.maps[key2] = value2;
    }
  }, {
    key: "get",
    value: function get2(key2) {
      return this.maps[key2];
    }
  }]);
  return CacheMap2;
}();
function _slicedToArray$3(arr, i2) {
  return _arrayWithHoles$3(arr) || _iterableToArrayLimit$3(arr, i2) || _unsupportedIterableToArray$2(arr, i2) || _nonIterableRest$3();
}
function _nonIterableRest$3() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$2(o2, minLen) {
  if (!o2)
    return;
  if (typeof o2 === "string")
    return _arrayLikeToArray$2(o2, minLen);
  var n2 = Object.prototype.toString.call(o2).slice(8, -1);
  if (n2 === "Object" && o2.constructor)
    n2 = o2.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o2);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$2(o2, minLen);
}
function _arrayLikeToArray$2(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) {
    arr2[i2] = arr[i2];
  }
  return arr2;
}
function _iterableToArrayLimit$3(arr, i2) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i2 && _arr.length === i2)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles$3(arr) {
  if (Array.isArray(arr))
    return arr;
}
function useHeights(getKey2, onItemAdd, onItemRemove) {
  var _React$useState = react.exports.useState(0), _React$useState2 = _slicedToArray$3(_React$useState, 2), updatedMark = _React$useState2[0], setUpdatedMark = _React$useState2[1];
  var instanceRef = react.exports.useRef(/* @__PURE__ */ new Map());
  var heightsRef = react.exports.useRef(new CacheMap());
  var collectRafRef = react.exports.useRef();
  function cancelRaf() {
    wrapperRaf$1.cancel(collectRafRef.current);
  }
  function collectHeight() {
    cancelRaf();
    collectRafRef.current = wrapperRaf$1(function() {
      instanceRef.current.forEach(function(element, key2) {
        if (element && element.offsetParent) {
          var htmlElement = findDOMNode(element);
          var offsetHeight = htmlElement.offsetHeight;
          if (heightsRef.current.get(key2) !== offsetHeight) {
            heightsRef.current.set(key2, htmlElement.offsetHeight);
          }
        }
      });
      setUpdatedMark(function(c2) {
        return c2 + 1;
      });
    });
  }
  function setInstanceRef(item, instance) {
    var key2 = getKey2(item);
    var origin = instanceRef.current.get(key2);
    if (instance) {
      instanceRef.current.set(key2, instance);
      collectHeight();
    } else {
      instanceRef.current.delete(key2);
    }
    if (!origin !== !instance) {
      if (instance) {
        onItemAdd === null || onItemAdd === void 0 ? void 0 : onItemAdd(item);
      } else {
        onItemRemove === null || onItemRemove === void 0 ? void 0 : onItemRemove(item);
      }
    }
  }
  react.exports.useEffect(function() {
    return cancelRaf;
  }, []);
  return [setInstanceRef, collectHeight, heightsRef.current, updatedMark];
}
function _typeof$1(obj) {
  "@babel/helpers - typeof";
  return _typeof$1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$1(obj);
}
function useScrollTo(containerRef, data2, heights, itemHeight, getKey2, collectHeight, syncScrollTop, triggerFlash) {
  var scrollRef = react.exports.useRef();
  return function(arg) {
    if (arg === null || arg === void 0) {
      triggerFlash();
      return;
    }
    wrapperRaf$1.cancel(scrollRef.current);
    if (typeof arg === "number") {
      syncScrollTop(arg);
    } else if (arg && _typeof$1(arg) === "object") {
      var index2;
      var align = arg.align;
      if ("index" in arg) {
        index2 = arg.index;
      } else {
        index2 = data2.findIndex(function(item) {
          return getKey2(item) === arg.key;
        });
      }
      var _arg$offset = arg.offset, offset3 = _arg$offset === void 0 ? 0 : _arg$offset;
      var syncScroll = function syncScroll2(times, targetAlign) {
        if (times < 0 || !containerRef.current)
          return;
        var height = containerRef.current.clientHeight;
        var needCollectHeight = false;
        var newTargetAlign = targetAlign;
        if (height) {
          var mergedAlign = targetAlign || align;
          var stackTop = 0;
          var itemTop = 0;
          var itemBottom = 0;
          var maxLen = Math.min(data2.length, index2);
          for (var i2 = 0; i2 <= maxLen; i2 += 1) {
            var key2 = getKey2(data2[i2]);
            itemTop = stackTop;
            var cacheHeight = heights.get(key2);
            itemBottom = itemTop + (cacheHeight === void 0 ? itemHeight : cacheHeight);
            stackTop = itemBottom;
            if (i2 === index2 && cacheHeight === void 0) {
              needCollectHeight = true;
            }
          }
          var targetTop = null;
          switch (mergedAlign) {
            case "top":
              targetTop = itemTop - offset3;
              break;
            case "bottom":
              targetTop = itemBottom - height + offset3;
              break;
            default: {
              var scrollTop = containerRef.current.scrollTop;
              var scrollBottom = scrollTop + height;
              if (itemTop < scrollTop) {
                newTargetAlign = "top";
              } else if (itemBottom > scrollBottom) {
                newTargetAlign = "bottom";
              }
            }
          }
          if (targetTop !== null && targetTop !== containerRef.current.scrollTop) {
            syncScrollTop(targetTop);
          }
        }
        scrollRef.current = wrapperRaf$1(function() {
          if (needCollectHeight) {
            collectHeight();
          }
          syncScroll2(times - 1, newTargetAlign);
        });
      };
      syncScroll(3);
    }
  };
}
function findListDiffIndex(originList, targetList, getKey2) {
  var originLen = originList.length;
  var targetLen = targetList.length;
  var shortList;
  var longList;
  if (originLen === 0 && targetLen === 0) {
    return null;
  }
  if (originLen < targetLen) {
    shortList = originList;
    longList = targetList;
  } else {
    shortList = targetList;
    longList = originList;
  }
  var notExistKey = {
    __EMPTY_ITEM__: true
  };
  function getItemKey(item) {
    if (item !== void 0) {
      return getKey2(item);
    }
    return notExistKey;
  }
  var diffIndex = null;
  var multiple = Math.abs(originLen - targetLen) !== 1;
  for (var i2 = 0; i2 < longList.length; i2 += 1) {
    var shortKey = getItemKey(shortList[i2]);
    var longKey = getItemKey(longList[i2]);
    if (shortKey !== longKey) {
      diffIndex = i2;
      multiple = multiple || shortKey !== getItemKey(longList[i2 + 1]);
      break;
    }
  }
  return diffIndex === null ? null : {
    index: diffIndex,
    multiple
  };
}
function _slicedToArray$2(arr, i2) {
  return _arrayWithHoles$2(arr) || _iterableToArrayLimit$2(arr, i2) || _unsupportedIterableToArray$1(arr, i2) || _nonIterableRest$2();
}
function _nonIterableRest$2() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$1(o2, minLen) {
  if (!o2)
    return;
  if (typeof o2 === "string")
    return _arrayLikeToArray$1(o2, minLen);
  var n2 = Object.prototype.toString.call(o2).slice(8, -1);
  if (n2 === "Object" && o2.constructor)
    n2 = o2.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o2);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$1(o2, minLen);
}
function _arrayLikeToArray$1(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) {
    arr2[i2] = arr[i2];
  }
  return arr2;
}
function _iterableToArrayLimit$2(arr, i2) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i2 && _arr.length === i2)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles$2(arr) {
  if (Array.isArray(arr))
    return arr;
}
function useDiffItem(data2, getKey2, onDiff) {
  var _React$useState = react.exports.useState(data2), _React$useState2 = _slicedToArray$2(_React$useState, 2), prevData = _React$useState2[0], setPrevData = _React$useState2[1];
  var _React$useState3 = react.exports.useState(null), _React$useState4 = _slicedToArray$2(_React$useState3, 2), diffItem = _React$useState4[0], setDiffItem = _React$useState4[1];
  react.exports.useEffect(function() {
    var diff2 = findListDiffIndex(prevData || [], data2 || [], getKey2);
    if ((diff2 === null || diff2 === void 0 ? void 0 : diff2.index) !== void 0) {
      onDiff === null || onDiff === void 0 ? void 0 : onDiff(diff2.index);
      setDiffItem(data2[diff2.index]);
    }
    setPrevData(data2);
  }, [data2]);
  return [diffItem];
}
function _typeof(obj) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof(obj);
}
var isFF = (typeof navigator === "undefined" ? "undefined" : _typeof(navigator)) === "object" && /Firefox/i.test(navigator.userAgent);
var useOriginScroll = function(isScrollAtTop, isScrollAtBottom) {
  var lockRef = react.exports.useRef(false);
  var lockTimeoutRef = react.exports.useRef(null);
  function lockScroll() {
    clearTimeout(lockTimeoutRef.current);
    lockRef.current = true;
    lockTimeoutRef.current = setTimeout(function() {
      lockRef.current = false;
    }, 50);
  }
  var scrollPingRef = react.exports.useRef({
    top: isScrollAtTop,
    bottom: isScrollAtBottom
  });
  scrollPingRef.current.top = isScrollAtTop;
  scrollPingRef.current.bottom = isScrollAtBottom;
  return function(deltaY) {
    var smoothOffset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    var originScroll = deltaY < 0 && scrollPingRef.current.top || deltaY > 0 && scrollPingRef.current.bottom;
    if (smoothOffset && originScroll) {
      clearTimeout(lockTimeoutRef.current);
      lockRef.current = false;
    } else if (!originScroll || lockRef.current) {
      lockScroll();
    }
    return !lockRef.current && originScroll;
  };
};
function useFrameWheel(inVirtual, isScrollAtTop, isScrollAtBottom, onWheelDelta) {
  var offsetRef = react.exports.useRef(0);
  var nextFrameRef = react.exports.useRef(null);
  var wheelValueRef = react.exports.useRef(null);
  var isMouseScrollRef = react.exports.useRef(false);
  var originScroll = useOriginScroll(isScrollAtTop, isScrollAtBottom);
  function onWheel(event) {
    if (!inVirtual)
      return;
    wrapperRaf$1.cancel(nextFrameRef.current);
    var deltaY = event.deltaY;
    offsetRef.current += deltaY;
    wheelValueRef.current = deltaY;
    if (originScroll(deltaY))
      return;
    if (!isFF) {
      event.preventDefault();
    }
    nextFrameRef.current = wrapperRaf$1(function() {
      var patchMultiple = isMouseScrollRef.current ? 10 : 1;
      onWheelDelta(offsetRef.current * patchMultiple);
      offsetRef.current = 0;
    });
  }
  function onFireFoxScroll(event) {
    if (!inVirtual)
      return;
    isMouseScrollRef.current = event.detail === wheelValueRef.current;
  }
  return [onWheel, onFireFoxScroll];
}
var SMOOTH_PTG = 14 / 15;
function useMobileTouchMove(inVirtual, listRef, callback) {
  var touchedRef = react.exports.useRef(false);
  var touchYRef = react.exports.useRef(0);
  var elementRef = react.exports.useRef(null);
  var intervalRef = react.exports.useRef(null);
  var cleanUpEvents;
  var onTouchMove = function onTouchMove2(e3) {
    if (touchedRef.current) {
      var currentY = Math.ceil(e3.touches[0].pageY);
      var offsetY = touchYRef.current - currentY;
      touchYRef.current = currentY;
      if (callback(offsetY)) {
        e3.preventDefault();
      }
      clearInterval(intervalRef.current);
      intervalRef.current = setInterval(function() {
        offsetY *= SMOOTH_PTG;
        if (!callback(offsetY, true) || Math.abs(offsetY) <= 0.1) {
          clearInterval(intervalRef.current);
        }
      }, 16);
    }
  };
  var onTouchEnd = function onTouchEnd2() {
    touchedRef.current = false;
    cleanUpEvents();
  };
  var onTouchStart = function onTouchStart2(e3) {
    cleanUpEvents();
    if (e3.touches.length === 1 && !touchedRef.current) {
      touchedRef.current = true;
      touchYRef.current = Math.ceil(e3.touches[0].pageY);
      elementRef.current = e3.target;
      elementRef.current.addEventListener("touchmove", onTouchMove);
      elementRef.current.addEventListener("touchend", onTouchEnd);
    }
  };
  cleanUpEvents = function cleanUpEvents2() {
    if (elementRef.current) {
      elementRef.current.removeEventListener("touchmove", onTouchMove);
      elementRef.current.removeEventListener("touchend", onTouchEnd);
    }
  };
  useLayoutEffect$1(function() {
    if (inVirtual) {
      listRef.current.addEventListener("touchstart", onTouchStart);
    }
    return function() {
      var _listRef$current;
      (_listRef$current = listRef.current) === null || _listRef$current === void 0 ? void 0 : _listRef$current.removeEventListener("touchstart", onTouchStart);
      cleanUpEvents();
      clearInterval(intervalRef.current);
    };
  }, [inVirtual]);
}
var _excluded$p = ["prefixCls", "className", "height", "itemHeight", "fullHeight", "style", "data", "children", "itemKey", "virtual", "component", "onScroll", "onVisibleChange"];
function _extends() {
  _extends = Object.assign || function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key2 in source) {
        if (Object.prototype.hasOwnProperty.call(source, key2)) {
          target[key2] = source[key2];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function ownKeys(object4, enumerableOnly) {
  var keys2 = Object.keys(object4);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object4);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object4, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? ownKeys(Object(source), true).forEach(function(key2) {
      _defineProperty(target, key2, source[key2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key2) {
      Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source, key2));
    });
  }
  return target;
}
function _defineProperty(obj, key2, value2) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value: value2, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value2;
  }
  return obj;
}
function _slicedToArray$1(arr, i2) {
  return _arrayWithHoles$1(arr) || _iterableToArrayLimit$1(arr, i2) || _unsupportedIterableToArray(arr, i2) || _nonIterableRest$1();
}
function _nonIterableRest$1() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o2, minLen) {
  if (!o2)
    return;
  if (typeof o2 === "string")
    return _arrayLikeToArray(o2, minLen);
  var n2 = Object.prototype.toString.call(o2).slice(8, -1);
  if (n2 === "Object" && o2.constructor)
    n2 = o2.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o2);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray(o2, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) {
    arr2[i2] = arr[i2];
  }
  return arr2;
}
function _iterableToArrayLimit$1(arr, i2) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i2 && _arr.length === i2)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles$1(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _objectWithoutProperties(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key2, i2;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
      key2 = sourceSymbolKeys[i2];
      if (excluded.indexOf(key2) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key2))
        continue;
      target[key2] = source[key2];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key2, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key2 = sourceKeys[i2];
    if (excluded.indexOf(key2) >= 0)
      continue;
    target[key2] = source[key2];
  }
  return target;
}
var EMPTY_DATA$1 = [];
var ScrollStyle = {
  overflowY: "auto",
  overflowAnchor: "none"
};
function RawList(props, ref) {
  var _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-virtual-list" : _props$prefixCls, className = props.className, height = props.height, itemHeight = props.itemHeight, _props$fullHeight = props.fullHeight, fullHeight = _props$fullHeight === void 0 ? true : _props$fullHeight, style2 = props.style, data2 = props.data, children = props.children, itemKey2 = props.itemKey, virtual = props.virtual, _props$component = props.component, Component2 = _props$component === void 0 ? "div" : _props$component, onScroll = props.onScroll, onVisibleChange = props.onVisibleChange, restProps = _objectWithoutProperties(props, _excluded$p);
  var useVirtual = !!(virtual !== false && height && itemHeight);
  var inVirtual = useVirtual && data2 && itemHeight * data2.length > height;
  var _useState = react.exports.useState(0), _useState2 = _slicedToArray$1(_useState, 2), scrollTop = _useState2[0], setScrollTop = _useState2[1];
  var _useState3 = react.exports.useState(false), _useState4 = _slicedToArray$1(_useState3, 2), scrollMoving = _useState4[0], setScrollMoving = _useState4[1];
  var mergedClassName = classNames(prefixCls, className);
  var mergedData = data2 || EMPTY_DATA$1;
  var componentRef = react.exports.useRef();
  var fillerInnerRef = react.exports.useRef();
  var scrollBarRef = react.exports.useRef();
  var getKey2 = react.exports.useCallback(function(item) {
    if (typeof itemKey2 === "function") {
      return itemKey2(item);
    }
    return item === null || item === void 0 ? void 0 : item[itemKey2];
  }, [itemKey2]);
  var sharedConfig = {
    getKey: getKey2
  };
  function syncScrollTop(newTop) {
    setScrollTop(function(origin) {
      var value2;
      if (typeof newTop === "function") {
        value2 = newTop(origin);
      } else {
        value2 = newTop;
      }
      var alignedTop = keepInRange(value2);
      componentRef.current.scrollTop = alignedTop;
      return alignedTop;
    });
  }
  var rangeRef = react.exports.useRef({
    start: 0,
    end: mergedData.length
  });
  var diffItemRef = react.exports.useRef();
  var _useDiffItem = useDiffItem(mergedData, getKey2), _useDiffItem2 = _slicedToArray$1(_useDiffItem, 1), diffItem = _useDiffItem2[0];
  diffItemRef.current = diffItem;
  var _useHeights = useHeights(getKey2, null, null), _useHeights2 = _slicedToArray$1(_useHeights, 4), setInstanceRef = _useHeights2[0], collectHeight = _useHeights2[1], heights = _useHeights2[2], heightUpdatedMark = _useHeights2[3];
  var _React$useMemo = react.exports.useMemo(function() {
    if (!useVirtual) {
      return {
        scrollHeight: void 0,
        start: 0,
        end: mergedData.length - 1,
        offset: void 0
      };
    }
    if (!inVirtual) {
      var _fillerInnerRef$curre;
      return {
        scrollHeight: ((_fillerInnerRef$curre = fillerInnerRef.current) === null || _fillerInnerRef$curre === void 0 ? void 0 : _fillerInnerRef$curre.offsetHeight) || 0,
        start: 0,
        end: mergedData.length - 1,
        offset: void 0
      };
    }
    var itemTop = 0;
    var startIndex;
    var startOffset;
    var endIndex;
    var dataLen = mergedData.length;
    for (var i2 = 0; i2 < dataLen; i2 += 1) {
      var item = mergedData[i2];
      var key2 = getKey2(item);
      var cacheHeight = heights.get(key2);
      var currentItemBottom = itemTop + (cacheHeight === void 0 ? itemHeight : cacheHeight);
      if (currentItemBottom >= scrollTop && startIndex === void 0) {
        startIndex = i2;
        startOffset = itemTop;
      }
      if (currentItemBottom > scrollTop + height && endIndex === void 0) {
        endIndex = i2;
      }
      itemTop = currentItemBottom;
    }
    if (startIndex === void 0) {
      startIndex = 0;
      startOffset = 0;
    }
    if (endIndex === void 0) {
      endIndex = mergedData.length - 1;
    }
    endIndex = Math.min(endIndex + 1, mergedData.length);
    return {
      scrollHeight: itemTop,
      start: startIndex,
      end: endIndex,
      offset: startOffset
    };
  }, [inVirtual, useVirtual, scrollTop, mergedData, heightUpdatedMark, height]), scrollHeight = _React$useMemo.scrollHeight, start = _React$useMemo.start, end = _React$useMemo.end, offset3 = _React$useMemo.offset;
  rangeRef.current.start = start;
  rangeRef.current.end = end;
  var maxScrollHeight = scrollHeight - height;
  var maxScrollHeightRef = react.exports.useRef(maxScrollHeight);
  maxScrollHeightRef.current = maxScrollHeight;
  function keepInRange(newScrollTop) {
    var newTop = newScrollTop;
    if (!Number.isNaN(maxScrollHeightRef.current)) {
      newTop = Math.min(newTop, maxScrollHeightRef.current);
    }
    newTop = Math.max(newTop, 0);
    return newTop;
  }
  var isScrollAtTop = scrollTop <= 0;
  var isScrollAtBottom = scrollTop >= maxScrollHeight;
  var originScroll = useOriginScroll(isScrollAtTop, isScrollAtBottom);
  function onScrollBar(newScrollTop) {
    var newTop = newScrollTop;
    syncScrollTop(newTop);
  }
  function onFallbackScroll(e3) {
    var newScrollTop = e3.currentTarget.scrollTop;
    if (newScrollTop !== scrollTop) {
      syncScrollTop(newScrollTop);
    }
    onScroll === null || onScroll === void 0 ? void 0 : onScroll(e3);
  }
  var _useFrameWheel = useFrameWheel(useVirtual, isScrollAtTop, isScrollAtBottom, function(offsetY) {
    syncScrollTop(function(top) {
      var newTop = top + offsetY;
      return newTop;
    });
  }), _useFrameWheel2 = _slicedToArray$1(_useFrameWheel, 2), onRawWheel = _useFrameWheel2[0], onFireFoxScroll = _useFrameWheel2[1];
  useMobileTouchMove(useVirtual, componentRef, function(deltaY, smoothOffset) {
    if (originScroll(deltaY, smoothOffset)) {
      return false;
    }
    onRawWheel({
      preventDefault: function preventDefault() {
      },
      deltaY
    });
    return true;
  });
  useLayoutEffect$1(function() {
    function onMozMousePixelScroll(e3) {
      if (useVirtual) {
        e3.preventDefault();
      }
    }
    componentRef.current.addEventListener("wheel", onRawWheel);
    componentRef.current.addEventListener("DOMMouseScroll", onFireFoxScroll);
    componentRef.current.addEventListener("MozMousePixelScroll", onMozMousePixelScroll);
    return function() {
      if (componentRef.current) {
        componentRef.current.removeEventListener("wheel", onRawWheel);
        componentRef.current.removeEventListener("DOMMouseScroll", onFireFoxScroll);
        componentRef.current.removeEventListener("MozMousePixelScroll", onMozMousePixelScroll);
      }
    };
  }, [useVirtual]);
  var scrollTo2 = useScrollTo(componentRef, mergedData, heights, itemHeight, getKey2, collectHeight, syncScrollTop, function() {
    var _scrollBarRef$current;
    (_scrollBarRef$current = scrollBarRef.current) === null || _scrollBarRef$current === void 0 ? void 0 : _scrollBarRef$current.delayHidden();
  });
  react.exports.useImperativeHandle(ref, function() {
    return {
      scrollTo: scrollTo2
    };
  });
  useLayoutEffect$1(function() {
    if (onVisibleChange) {
      var renderList = mergedData.slice(start, end + 1);
      onVisibleChange(renderList, mergedData);
    }
  }, [start, end, mergedData]);
  var listChildren = useChildren(mergedData, start, end, setInstanceRef, children, sharedConfig);
  var componentStyle = null;
  if (height) {
    componentStyle = _objectSpread(_defineProperty({}, fullHeight ? "height" : "maxHeight", height), ScrollStyle);
    if (useVirtual) {
      componentStyle.overflowY = "hidden";
      if (scrollMoving) {
        componentStyle.pointerEvents = "none";
      }
    }
  }
  return /* @__PURE__ */ react.exports.createElement("div", _extends({
    style: _objectSpread(_objectSpread({}, style2), {}, {
      position: "relative"
    }),
    className: mergedClassName
  }, restProps), /* @__PURE__ */ react.exports.createElement(Component2, {
    className: "".concat(prefixCls, "-holder"),
    style: componentStyle,
    ref: componentRef,
    onScroll: onFallbackScroll
  }, /* @__PURE__ */ react.exports.createElement(Filler, {
    prefixCls,
    height: scrollHeight,
    offset: offset3,
    onInnerResize: collectHeight,
    ref: fillerInnerRef
  }, listChildren)), useVirtual && /* @__PURE__ */ react.exports.createElement(ScrollBar, {
    ref: scrollBarRef,
    prefixCls,
    scrollTop,
    height,
    scrollHeight,
    count: mergedData.length,
    onScroll: onScrollBar,
    onStartMove: function onStartMove() {
      setScrollMoving(true);
    },
    onStopMove: function onStopMove() {
      setScrollMoving(false);
    }
  }));
}
var List$2 = /* @__PURE__ */ react.exports.forwardRef(RawList);
List$2.displayName = "List";
function isPlatformMac() {
  return /(mac\sos|macintosh)/i.test(navigator.appVersion);
}
var SelectContext = /* @__PURE__ */ react.exports.createContext(null);
var _excluded$o = ["disabled", "title", "children", "style", "className"];
function isTitleType(content) {
  return typeof content === "string" || typeof content === "number";
}
var OptionList = function OptionList2(_2, ref) {
  var _useBaseProps = useBaseProps(), prefixCls = _useBaseProps.prefixCls, id2 = _useBaseProps.id, open = _useBaseProps.open, multiple = _useBaseProps.multiple, mode = _useBaseProps.mode, searchValue = _useBaseProps.searchValue, toggleOpen = _useBaseProps.toggleOpen, notFoundContent = _useBaseProps.notFoundContent, onPopupScroll = _useBaseProps.onPopupScroll;
  var _React$useContext = react.exports.useContext(SelectContext), flattenOptions2 = _React$useContext.flattenOptions, onActiveValue = _React$useContext.onActiveValue, defaultActiveFirstOption = _React$useContext.defaultActiveFirstOption, onSelect = _React$useContext.onSelect, menuItemSelectedIcon = _React$useContext.menuItemSelectedIcon, rawValues = _React$useContext.rawValues, fieldNames = _React$useContext.fieldNames, virtual = _React$useContext.virtual, listHeight = _React$useContext.listHeight, listItemHeight = _React$useContext.listItemHeight;
  var itemPrefixCls = "".concat(prefixCls, "-item");
  var memoFlattenOptions = useMemo(function() {
    return flattenOptions2;
  }, [open, flattenOptions2], function(prev, next) {
    return next[0] && prev[1] !== next[1];
  });
  var listRef = react.exports.useRef(null);
  var onListMouseDown = function onListMouseDown2(event) {
    event.preventDefault();
  };
  var scrollIntoView = function scrollIntoView2(args) {
    if (listRef.current) {
      listRef.current.scrollTo(typeof args === "number" ? {
        index: args
      } : args);
    }
  };
  var getEnabledActiveIndex = function getEnabledActiveIndex2(index2) {
    var offset3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
    var len = memoFlattenOptions.length;
    for (var i2 = 0; i2 < len; i2 += 1) {
      var current = (index2 + i2 * offset3 + len) % len;
      var _memoFlattenOptions$c = memoFlattenOptions[current], group2 = _memoFlattenOptions$c.group, data2 = _memoFlattenOptions$c.data;
      if (!group2 && !data2.disabled) {
        return current;
      }
    }
    return -1;
  };
  var _React$useState = react.exports.useState(function() {
    return getEnabledActiveIndex(0);
  }), _React$useState2 = _slicedToArray$4(_React$useState, 2), activeIndex = _React$useState2[0], setActiveIndex = _React$useState2[1];
  var setActive = function setActive2(index2) {
    var fromKeyboard = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    setActiveIndex(index2);
    var info = {
      source: fromKeyboard ? "keyboard" : "mouse"
    };
    var flattenItem = memoFlattenOptions[index2];
    if (!flattenItem) {
      onActiveValue(null, -1, info);
      return;
    }
    onActiveValue(flattenItem.value, index2, info);
  };
  react.exports.useEffect(function() {
    setActive(defaultActiveFirstOption !== false ? getEnabledActiveIndex(0) : -1);
  }, [memoFlattenOptions.length, searchValue]);
  var isSelected = react.exports.useCallback(function(value2) {
    return rawValues.has(value2) && mode !== "combobox";
  }, [mode, _toConsumableArray(rawValues).toString()]);
  react.exports.useEffect(function() {
    var timeoutId = setTimeout(function() {
      if (!multiple && open && rawValues.size === 1) {
        var value2 = Array.from(rawValues)[0];
        var index2 = memoFlattenOptions.findIndex(function(_ref) {
          var data2 = _ref.data;
          return data2.value === value2;
        });
        if (index2 !== -1) {
          setActive(index2);
          scrollIntoView(index2);
        }
      }
    });
    if (open) {
      var _listRef$current;
      (_listRef$current = listRef.current) === null || _listRef$current === void 0 ? void 0 : _listRef$current.scrollTo(void 0);
    }
    return function() {
      return clearTimeout(timeoutId);
    };
  }, [open, searchValue]);
  var onSelectValue = function onSelectValue2(value2) {
    if (value2 !== void 0) {
      onSelect(value2, {
        selected: !rawValues.has(value2)
      });
    }
    if (!multiple) {
      toggleOpen(false);
    }
  };
  react.exports.useImperativeHandle(ref, function() {
    return {
      onKeyDown: function onKeyDown2(event) {
        var which = event.which, ctrlKey = event.ctrlKey;
        switch (which) {
          case KeyCode.N:
          case KeyCode.P:
          case KeyCode.UP:
          case KeyCode.DOWN: {
            var offset3 = 0;
            if (which === KeyCode.UP) {
              offset3 = -1;
            } else if (which === KeyCode.DOWN) {
              offset3 = 1;
            } else if (isPlatformMac() && ctrlKey) {
              if (which === KeyCode.N) {
                offset3 = 1;
              } else if (which === KeyCode.P) {
                offset3 = -1;
              }
            }
            if (offset3 !== 0) {
              var nextActiveIndex = getEnabledActiveIndex(activeIndex + offset3, offset3);
              scrollIntoView(nextActiveIndex);
              setActive(nextActiveIndex, true);
            }
            break;
          }
          case KeyCode.ENTER: {
            var item = memoFlattenOptions[activeIndex];
            if (item && !item.data.disabled) {
              onSelectValue(item.value);
            } else {
              onSelectValue(void 0);
            }
            if (open) {
              event.preventDefault();
            }
            break;
          }
          case KeyCode.ESC: {
            toggleOpen(false);
            if (open) {
              event.stopPropagation();
            }
          }
        }
      },
      onKeyUp: function onKeyUp2() {
      },
      scrollTo: function scrollTo2(index2) {
        scrollIntoView(index2);
      }
    };
  });
  if (memoFlattenOptions.length === 0) {
    return /* @__PURE__ */ react.exports.createElement("div", {
      role: "listbox",
      id: "".concat(id2, "_list"),
      className: "".concat(itemPrefixCls, "-empty"),
      onMouseDown: onListMouseDown
    }, notFoundContent);
  }
  var omitFieldNameList = Object.keys(fieldNames).map(function(key2) {
    return fieldNames[key2];
  });
  var getLabel = function getLabel2(item) {
    return item.label;
  };
  var renderItem = function renderItem2(index2) {
    var item = memoFlattenOptions[index2];
    if (!item)
      return null;
    var itemData = item.data || {};
    var value2 = itemData.value;
    var group2 = item.group;
    var attrs = pickAttrs(itemData, true);
    var mergedLabel = getLabel(item);
    return item ? /* @__PURE__ */ react.exports.createElement("div", _extends$2({
      "aria-label": typeof mergedLabel === "string" && !group2 ? mergedLabel : null
    }, attrs, {
      key: index2,
      role: group2 ? "presentation" : "option",
      id: "".concat(id2, "_list_").concat(index2),
      "aria-selected": isSelected(value2)
    }), value2) : null;
  };
  return /* @__PURE__ */ react.exports.createElement(react.exports.Fragment, null, /* @__PURE__ */ react.exports.createElement("div", {
    role: "listbox",
    id: "".concat(id2, "_list"),
    style: {
      height: 0,
      width: 0,
      overflow: "hidden"
    }
  }, renderItem(activeIndex - 1), renderItem(activeIndex), renderItem(activeIndex + 1)), /* @__PURE__ */ react.exports.createElement(List$2, {
    itemKey: "key",
    ref: listRef,
    data: memoFlattenOptions,
    height: listHeight,
    itemHeight: listItemHeight,
    fullHeight: false,
    onMouseDown: onListMouseDown,
    onScroll: onPopupScroll,
    virtual
  }, function(item, itemIndex) {
    var _classNames;
    var group2 = item.group, groupOption = item.groupOption, data2 = item.data, label2 = item.label, value2 = item.value;
    var key2 = data2.key;
    if (group2) {
      var _data$title;
      var groupTitle = (_data$title = data2.title) !== null && _data$title !== void 0 ? _data$title : isTitleType(label2) ? label2.toString() : void 0;
      return /* @__PURE__ */ react.exports.createElement("div", {
        className: classNames(itemPrefixCls, "".concat(itemPrefixCls, "-group")),
        title: groupTitle
      }, label2 !== void 0 ? label2 : key2);
    }
    var disabled = data2.disabled, title = data2.title;
    data2.children;
    var style2 = data2.style, className = data2.className, otherProps = _objectWithoutProperties$1(data2, _excluded$o);
    var passedProps = omit$2(otherProps, omitFieldNameList);
    var selected = isSelected(value2);
    var optionPrefixCls = "".concat(itemPrefixCls, "-option");
    var optionClassName = classNames(itemPrefixCls, optionPrefixCls, className, (_classNames = {}, _defineProperty$4(_classNames, "".concat(optionPrefixCls, "-grouped"), groupOption), _defineProperty$4(_classNames, "".concat(optionPrefixCls, "-active"), activeIndex === itemIndex && !disabled), _defineProperty$4(_classNames, "".concat(optionPrefixCls, "-disabled"), disabled), _defineProperty$4(_classNames, "".concat(optionPrefixCls, "-selected"), selected), _classNames));
    var mergedLabel = getLabel(item);
    var iconVisible = !menuItemSelectedIcon || typeof menuItemSelectedIcon === "function" || selected;
    var content = typeof mergedLabel === "number" ? mergedLabel : mergedLabel || value2;
    var optionTitle = isTitleType(content) ? content.toString() : void 0;
    if (title !== void 0) {
      optionTitle = title;
    }
    return /* @__PURE__ */ react.exports.createElement("div", _extends$2({}, pickAttrs(passedProps), {
      "aria-selected": selected,
      className: optionClassName,
      title: optionTitle,
      onMouseMove: function onMouseMove() {
        if (activeIndex === itemIndex || disabled) {
          return;
        }
        setActive(itemIndex);
      },
      onClick: function onClick() {
        if (!disabled) {
          onSelectValue(value2);
        }
      },
      style: style2
    }), /* @__PURE__ */ react.exports.createElement("div", {
      className: "".concat(optionPrefixCls, "-content")
    }, content), /* @__PURE__ */ react.exports.isValidElement(menuItemSelectedIcon) || selected, iconVisible && /* @__PURE__ */ react.exports.createElement(TransBtn, {
      className: "".concat(itemPrefixCls, "-option-state"),
      customizeIcon: menuItemSelectedIcon,
      customizeIconProps: {
        isSelected: selected
      }
    }, selected ? "\u2713" : null));
  }));
};
var RefOptionList = /* @__PURE__ */ react.exports.forwardRef(OptionList);
RefOptionList.displayName = "OptionList";
var _excluded$n = ["id", "mode", "prefixCls", "backfill", "fieldNames", "inputValue", "searchValue", "onSearch", "autoClearSearchValue", "onSelect", "onDeselect", "dropdownMatchSelectWidth", "filterOption", "filterSort", "optionFilterProp", "optionLabelProp", "options", "children", "defaultActiveFirstOption", "menuItemSelectedIcon", "virtual", "listHeight", "listItemHeight", "value", "defaultValue", "labelInValue", "onChange"];
var OMIT_DOM_PROPS = ["inputValue"];
function isRawValue(value2) {
  return !value2 || _typeof$4(value2) !== "object";
}
var Select$2 = /* @__PURE__ */ react.exports.forwardRef(function(props, ref) {
  var id2 = props.id, mode = props.mode, _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-select" : _props$prefixCls, backfill = props.backfill, fieldNames = props.fieldNames, inputValue = props.inputValue, searchValue = props.searchValue, onSearch = props.onSearch, _props$autoClearSearc = props.autoClearSearchValue, autoClearSearchValue = _props$autoClearSearc === void 0 ? true : _props$autoClearSearc, onSelect = props.onSelect, onDeselect = props.onDeselect, _props$dropdownMatchS = props.dropdownMatchSelectWidth, dropdownMatchSelectWidth = _props$dropdownMatchS === void 0 ? true : _props$dropdownMatchS, filterOption = props.filterOption, filterSort = props.filterSort, optionFilterProp = props.optionFilterProp, optionLabelProp = props.optionLabelProp, options = props.options, children = props.children, defaultActiveFirstOption = props.defaultActiveFirstOption, menuItemSelectedIcon = props.menuItemSelectedIcon, virtual = props.virtual, _props$listHeight = props.listHeight, listHeight = _props$listHeight === void 0 ? 200 : _props$listHeight, _props$listItemHeight = props.listItemHeight, listItemHeight = _props$listItemHeight === void 0 ? 20 : _props$listItemHeight, value2 = props.value, defaultValue = props.defaultValue, labelInValue = props.labelInValue, onChange2 = props.onChange, restProps = _objectWithoutProperties$1(props, _excluded$n);
  var mergedId = useId$1(id2);
  var multiple = isMultiple(mode);
  var childrenAsData = !!(!options && children);
  var mergedFilterOption = react.exports.useMemo(function() {
    if (filterOption === void 0 && mode === "combobox") {
      return false;
    }
    return filterOption;
  }, [filterOption, mode]);
  var mergedFieldNames = react.exports.useMemo(
    function() {
      return fillFieldNames$1(fieldNames, childrenAsData);
    },
    [
      JSON.stringify(fieldNames),
      childrenAsData
    ]
  );
  var _useMergedState = useMergedState("", {
    value: searchValue !== void 0 ? searchValue : inputValue,
    postState: function postState(search) {
      return search || "";
    }
  }), _useMergedState2 = _slicedToArray$4(_useMergedState, 2), mergedSearchValue = _useMergedState2[0], setSearchValue = _useMergedState2[1];
  var parsedOptions = useOptions(options, children, mergedFieldNames, optionFilterProp, optionLabelProp);
  var valueOptions = parsedOptions.valueOptions, labelOptions = parsedOptions.labelOptions, mergedOptions = parsedOptions.options;
  var convert2LabelValues = react.exports.useCallback(function(draftValues) {
    var valueList = toArray$3(draftValues);
    return valueList.map(function(val) {
      var rawValue;
      var rawLabel;
      var rawKey;
      var rawDisabled;
      var rawTitle;
      if (isRawValue(val)) {
        rawValue = val;
      } else {
        var _val$value;
        rawKey = val.key;
        rawLabel = val.label;
        rawValue = (_val$value = val.value) !== null && _val$value !== void 0 ? _val$value : rawKey;
      }
      var option = valueOptions.get(rawValue);
      if (option) {
        var _option$key;
        if (rawLabel === void 0)
          rawLabel = option === null || option === void 0 ? void 0 : option[optionLabelProp || mergedFieldNames.label];
        if (rawKey === void 0)
          rawKey = (_option$key = option === null || option === void 0 ? void 0 : option.key) !== null && _option$key !== void 0 ? _option$key : rawValue;
        rawDisabled = option === null || option === void 0 ? void 0 : option.disabled;
        rawTitle = option === null || option === void 0 ? void 0 : option.title;
      }
      return {
        label: rawLabel,
        value: rawValue,
        key: rawKey,
        disabled: rawDisabled,
        title: rawTitle
      };
    });
  }, [mergedFieldNames, optionLabelProp, valueOptions]);
  var _useMergedState3 = useMergedState(defaultValue, {
    value: value2
  }), _useMergedState4 = _slicedToArray$4(_useMergedState3, 2), internalValue = _useMergedState4[0], setInternalValue = _useMergedState4[1];
  var rawLabeledValues = react.exports.useMemo(function() {
    var _values$;
    var values2 = convert2LabelValues(internalValue);
    if (mode === "combobox" && !((_values$ = values2[0]) === null || _values$ === void 0 ? void 0 : _values$.value)) {
      return [];
    }
    return values2;
  }, [internalValue, convert2LabelValues, mode]);
  var _useCache = useCache(rawLabeledValues, valueOptions), _useCache2 = _slicedToArray$4(_useCache, 2), mergedValues = _useCache2[0], getMixedOption = _useCache2[1];
  var displayValues = react.exports.useMemo(function() {
    if (!mode && mergedValues.length === 1) {
      var firstValue2 = mergedValues[0];
      if (firstValue2.value === null && (firstValue2.label === null || firstValue2.label === void 0)) {
        return [];
      }
    }
    return mergedValues.map(function(item) {
      var _item$label;
      return _objectSpread2$1(_objectSpread2$1({}, item), {}, {
        label: (_item$label = item.label) !== null && _item$label !== void 0 ? _item$label : item.value
      });
    });
  }, [mode, mergedValues]);
  var rawValues = react.exports.useMemo(function() {
    return new Set(mergedValues.map(function(val) {
      return val.value;
    }));
  }, [mergedValues]);
  react.exports.useEffect(function() {
    if (mode === "combobox") {
      var _mergedValues$;
      var strValue = (_mergedValues$ = mergedValues[0]) === null || _mergedValues$ === void 0 ? void 0 : _mergedValues$.value;
      setSearchValue(hasValue(strValue) ? String(strValue) : "");
    }
  }, [mergedValues]);
  var createTagOption = useRefFunc(function(val, label2) {
    var _ref;
    var mergedLabel = label2 !== null && label2 !== void 0 ? label2 : val;
    return _ref = {}, _defineProperty$4(_ref, mergedFieldNames.value, val), _defineProperty$4(_ref, mergedFieldNames.label, mergedLabel), _ref;
  });
  var filledTagOptions = react.exports.useMemo(function() {
    if (mode !== "tags") {
      return mergedOptions;
    }
    var cloneOptions = _toConsumableArray(mergedOptions);
    var existOptions = function existOptions2(val) {
      return valueOptions.has(val);
    };
    _toConsumableArray(mergedValues).sort(function(a2, b10) {
      return a2.value < b10.value ? -1 : 1;
    }).forEach(function(item) {
      var val = item.value;
      if (!existOptions(val)) {
        cloneOptions.push(createTagOption(val, item.label));
      }
    });
    return cloneOptions;
  }, [createTagOption, mergedOptions, valueOptions, mergedValues, mode]);
  var filteredOptions = useFilterOptions(filledTagOptions, mergedFieldNames, mergedSearchValue, mergedFilterOption, optionFilterProp);
  var filledSearchOptions = react.exports.useMemo(function() {
    if (mode !== "tags" || !mergedSearchValue || filteredOptions.some(function(item) {
      return item[optionFilterProp || "value"] === mergedSearchValue;
    })) {
      return filteredOptions;
    }
    return [createTagOption(mergedSearchValue)].concat(_toConsumableArray(filteredOptions));
  }, [createTagOption, optionFilterProp, mode, filteredOptions, mergedSearchValue]);
  var orderedFilteredOptions = react.exports.useMemo(function() {
    if (!filterSort) {
      return filledSearchOptions;
    }
    return _toConsumableArray(filledSearchOptions).sort(function(a2, b10) {
      return filterSort(a2, b10);
    });
  }, [filledSearchOptions, filterSort]);
  var displayOptions = react.exports.useMemo(function() {
    return flattenOptions(orderedFilteredOptions, {
      fieldNames: mergedFieldNames,
      childrenAsData
    });
  }, [orderedFilteredOptions, mergedFieldNames, childrenAsData]);
  var triggerChange = function triggerChange2(values2) {
    var labeledValues = convert2LabelValues(values2);
    setInternalValue(labeledValues);
    if (onChange2 && (labeledValues.length !== mergedValues.length || labeledValues.some(function(newVal, index2) {
      var _mergedValues$index;
      return ((_mergedValues$index = mergedValues[index2]) === null || _mergedValues$index === void 0 ? void 0 : _mergedValues$index.value) !== (newVal === null || newVal === void 0 ? void 0 : newVal.value);
    }))) {
      var returnValues = labelInValue ? labeledValues : labeledValues.map(function(v2) {
        return v2.value;
      });
      var returnOptions = labeledValues.map(function(v2) {
        return injectPropsWithOption(getMixedOption(v2.value));
      });
      onChange2(
        multiple ? returnValues : returnValues[0],
        multiple ? returnOptions : returnOptions[0]
      );
    }
  };
  var _React$useState = react.exports.useState(null), _React$useState2 = _slicedToArray$4(_React$useState, 2), activeValue = _React$useState2[0], setActiveValue = _React$useState2[1];
  var _React$useState3 = react.exports.useState(0), _React$useState4 = _slicedToArray$4(_React$useState3, 2), accessibilityIndex = _React$useState4[0], setAccessibilityIndex = _React$useState4[1];
  var mergedDefaultActiveFirstOption = defaultActiveFirstOption !== void 0 ? defaultActiveFirstOption : mode !== "combobox";
  var onActiveValue = react.exports.useCallback(function(active, index2) {
    var _ref2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, _ref2$source = _ref2.source, source = _ref2$source === void 0 ? "keyboard" : _ref2$source;
    setAccessibilityIndex(index2);
    if (backfill && mode === "combobox" && active !== null && source === "keyboard") {
      setActiveValue(String(active));
    }
  }, [backfill, mode]);
  var triggerSelect = function triggerSelect2(val, selected) {
    var getSelectEnt = function getSelectEnt2() {
      var _option$key2;
      var option2 = getMixedOption(val);
      return [labelInValue ? {
        label: option2 === null || option2 === void 0 ? void 0 : option2[mergedFieldNames.label],
        value: val,
        key: (_option$key2 = option2 === null || option2 === void 0 ? void 0 : option2.key) !== null && _option$key2 !== void 0 ? _option$key2 : val
      } : val, injectPropsWithOption(option2)];
    };
    if (selected && onSelect) {
      var _getSelectEnt = getSelectEnt(), _getSelectEnt2 = _slicedToArray$4(_getSelectEnt, 2), wrappedValue = _getSelectEnt2[0], option = _getSelectEnt2[1];
      onSelect(wrappedValue, option);
    } else if (!selected && onDeselect) {
      var _getSelectEnt3 = getSelectEnt(), _getSelectEnt4 = _slicedToArray$4(_getSelectEnt3, 2), _wrappedValue = _getSelectEnt4[0], _option = _getSelectEnt4[1];
      onDeselect(_wrappedValue, _option);
    }
  };
  var onInternalSelect = useRefFunc(function(val, info) {
    var cloneValues;
    var mergedSelect = multiple ? info.selected : true;
    if (mergedSelect) {
      cloneValues = multiple ? [].concat(_toConsumableArray(mergedValues), [val]) : [val];
    } else {
      cloneValues = mergedValues.filter(function(v2) {
        return v2.value !== val;
      });
    }
    triggerChange(cloneValues);
    triggerSelect(val, mergedSelect);
    if (mode === "combobox") {
      setActiveValue("");
    } else if (!isMultiple || autoClearSearchValue) {
      setSearchValue("");
      setActiveValue("");
    }
  });
  var onDisplayValuesChange = function onDisplayValuesChange2(nextValues, info) {
    triggerChange(nextValues);
    if (info.type === "remove" || info.type === "clear") {
      info.values.forEach(function(item) {
        triggerSelect(item.value, false);
      });
    }
  };
  var onInternalSearch = function onInternalSearch2(searchText, info) {
    setSearchValue(searchText);
    setActiveValue(null);
    if (info.source === "submit") {
      var formatted = (searchText || "").trim();
      if (formatted) {
        var newRawValues = Array.from(new Set([].concat(_toConsumableArray(rawValues), [formatted])));
        triggerChange(newRawValues);
        triggerSelect(formatted, true);
        setSearchValue("");
      }
      return;
    }
    if (info.source !== "blur") {
      if (mode === "combobox") {
        triggerChange(searchText);
      }
      onSearch === null || onSearch === void 0 ? void 0 : onSearch(searchText);
    }
  };
  var onInternalSearchSplit = function onInternalSearchSplit2(words) {
    var patchValues = words;
    if (mode !== "tags") {
      patchValues = words.map(function(word2) {
        var opt = labelOptions.get(word2);
        return opt === null || opt === void 0 ? void 0 : opt.value;
      }).filter(function(val) {
        return val !== void 0;
      });
    }
    var newRawValues = Array.from(new Set([].concat(_toConsumableArray(rawValues), _toConsumableArray(patchValues))));
    triggerChange(newRawValues);
    newRawValues.forEach(function(newRawValue) {
      triggerSelect(newRawValue, true);
    });
  };
  var selectContext = react.exports.useMemo(function() {
    var realVirtual = virtual !== false && dropdownMatchSelectWidth !== false;
    return _objectSpread2$1(_objectSpread2$1({}, parsedOptions), {}, {
      flattenOptions: displayOptions,
      onActiveValue,
      defaultActiveFirstOption: mergedDefaultActiveFirstOption,
      onSelect: onInternalSelect,
      menuItemSelectedIcon,
      rawValues,
      fieldNames: mergedFieldNames,
      virtual: realVirtual,
      listHeight,
      listItemHeight,
      childrenAsData
    });
  }, [parsedOptions, displayOptions, onActiveValue, mergedDefaultActiveFirstOption, onInternalSelect, menuItemSelectedIcon, rawValues, mergedFieldNames, virtual, dropdownMatchSelectWidth, listHeight, listItemHeight, childrenAsData]);
  return /* @__PURE__ */ react.exports.createElement(SelectContext.Provider, {
    value: selectContext
  }, /* @__PURE__ */ react.exports.createElement(BaseSelect, _extends$2({}, restProps, {
    id: mergedId,
    prefixCls,
    ref,
    omitDomProps: OMIT_DOM_PROPS,
    mode,
    displayValues,
    onDisplayValuesChange,
    searchValue: mergedSearchValue,
    onSearch: onInternalSearch,
    onSearchSplit: onInternalSearchSplit,
    dropdownMatchSelectWidth,
    OptionList: RefOptionList,
    emptyOptions: !displayOptions.length,
    activeValue,
    activeDescendantId: "".concat(mergedId, "_list_").concat(accessibilityIndex)
  })));
});
var TypedSelect = Select$2;
TypedSelect.Option = Option;
TypedSelect.OptGroup = OptGroup;
var Empty$2 = function Empty2() {
  var _React$useContext = react.exports.useContext(ConfigContext), getPrefixCls = _React$useContext.getPrefixCls;
  var prefixCls = getPrefixCls("empty-img-default");
  return /* @__PURE__ */ react.exports.createElement("svg", {
    className: prefixCls,
    width: "184",
    height: "152",
    viewBox: "0 0 184 152",
    xmlns: "http://www.w3.org/2000/svg"
  }, /* @__PURE__ */ react.exports.createElement("g", {
    fill: "none",
    fillRule: "evenodd"
  }, /* @__PURE__ */ react.exports.createElement("g", {
    transform: "translate(24 31.67)"
  }, /* @__PURE__ */ react.exports.createElement("ellipse", {
    className: "".concat(prefixCls, "-ellipse"),
    cx: "67.797",
    cy: "106.89",
    rx: "67.797",
    ry: "12.668"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    className: "".concat(prefixCls, "-path-1"),
    d: "M122.034 69.674L98.109 40.229c-1.148-1.386-2.826-2.225-4.593-2.225h-51.44c-1.766 0-3.444.839-4.592 2.225L13.56 69.674v15.383h108.475V69.674z"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    className: "".concat(prefixCls, "-path-2"),
    d: "M101.537 86.214L80.63 61.102c-1.001-1.207-2.507-1.867-4.048-1.867H31.724c-1.54 0-3.047.66-4.048 1.867L6.769 86.214v13.792h94.768V86.214z",
    transform: "translate(13.56)"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    className: "".concat(prefixCls, "-path-3"),
    d: "M33.83 0h67.933a4 4 0 0 1 4 4v93.344a4 4 0 0 1-4 4H33.83a4 4 0 0 1-4-4V4a4 4 0 0 1 4-4z"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    className: "".concat(prefixCls, "-path-4"),
    d: "M42.678 9.953h50.237a2 2 0 0 1 2 2V36.91a2 2 0 0 1-2 2H42.678a2 2 0 0 1-2-2V11.953a2 2 0 0 1 2-2zM42.94 49.767h49.713a2.262 2.262 0 1 1 0 4.524H42.94a2.262 2.262 0 0 1 0-4.524zM42.94 61.53h49.713a2.262 2.262 0 1 1 0 4.525H42.94a2.262 2.262 0 0 1 0-4.525zM121.813 105.032c-.775 3.071-3.497 5.36-6.735 5.36H20.515c-3.238 0-5.96-2.29-6.734-5.36a7.309 7.309 0 0 1-.222-1.79V69.675h26.318c2.907 0 5.25 2.448 5.25 5.42v.04c0 2.971 2.37 5.37 5.277 5.37h34.785c2.907 0 5.277-2.421 5.277-5.393V75.1c0-2.972 2.343-5.426 5.25-5.426h26.318v33.569c0 .617-.077 1.216-.221 1.789z"
  })), /* @__PURE__ */ react.exports.createElement("path", {
    className: "".concat(prefixCls, "-path-5"),
    d: "M149.121 33.292l-6.83 2.65a1 1 0 0 1-1.317-1.23l1.937-6.207c-2.589-2.944-4.109-6.534-4.109-10.408C138.802 8.102 148.92 0 161.402 0 173.881 0 184 8.102 184 18.097c0 9.995-10.118 18.097-22.599 18.097-4.528 0-8.744-1.066-12.28-2.902z"
  }), /* @__PURE__ */ react.exports.createElement("g", {
    className: "".concat(prefixCls, "-g"),
    transform: "translate(149.65 15.383)"
  }, /* @__PURE__ */ react.exports.createElement("ellipse", {
    cx: "20.654",
    cy: "3.167",
    rx: "2.849",
    ry: "2.815"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M5.698 5.63H0L2.898.704zM9.259.704h4.985V5.63H9.259z"
  }))));
};
var DefaultEmptyImg = Empty$2;
var Simple = function Simple2() {
  var _React$useContext = react.exports.useContext(ConfigContext), getPrefixCls = _React$useContext.getPrefixCls;
  var prefixCls = getPrefixCls("empty-img-simple");
  return /* @__PURE__ */ react.exports.createElement("svg", {
    className: prefixCls,
    width: "64",
    height: "41",
    viewBox: "0 0 64 41",
    xmlns: "http://www.w3.org/2000/svg"
  }, /* @__PURE__ */ react.exports.createElement("g", {
    transform: "translate(0 1)",
    fill: "none",
    fillRule: "evenodd"
  }, /* @__PURE__ */ react.exports.createElement("ellipse", {
    className: "".concat(prefixCls, "-ellipse"),
    cx: "32",
    cy: "33",
    rx: "32",
    ry: "7"
  }), /* @__PURE__ */ react.exports.createElement("g", {
    className: "".concat(prefixCls, "-g"),
    fillRule: "nonzero"
  }, /* @__PURE__ */ react.exports.createElement("path", {
    d: "M55 12.76L44.854 1.258C44.367.474 43.656 0 42.907 0H21.093c-.749 0-1.46.474-1.947 1.257L9 12.761V22h46v-9.24z"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M41.613 15.931c0-1.605.994-2.93 2.227-2.931H55v18.137C55 33.26 53.68 35 52.05 35h-40.1C10.32 35 9 33.259 9 31.137V13h11.16c1.233 0 2.227 1.323 2.227 2.928v.022c0 1.605 1.005 2.901 2.237 2.901h14.752c1.232 0 2.237-1.308 2.237-2.913v-.007z",
    className: "".concat(prefixCls, "-path")
  }))));
};
var SimpleEmptyImg = Simple;
var __rest$x = globalThis && globalThis.__rest || function(s2, e3) {
  var t2 = {};
  for (var p2 in s2) {
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  }
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e3.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
var defaultEmptyImg = /* @__PURE__ */ react.exports.createElement(DefaultEmptyImg, null);
var simpleEmptyImg = /* @__PURE__ */ react.exports.createElement(SimpleEmptyImg, null);
var Empty = function Empty3(_a2) {
  var className = _a2.className, customizePrefixCls = _a2.prefixCls, _a$image = _a2.image, image = _a$image === void 0 ? defaultEmptyImg : _a$image, description = _a2.description, children = _a2.children, imageStyle = _a2.imageStyle, restProps = __rest$x(_a2, ["className", "prefixCls", "image", "description", "children", "imageStyle"]);
  var _React$useContext = react.exports.useContext(ConfigContext), getPrefixCls = _React$useContext.getPrefixCls, direction2 = _React$useContext.direction;
  return /* @__PURE__ */ react.exports.createElement(LocaleReceiver, {
    componentName: "Empty"
  }, function(contextLocale) {
    var _classNames;
    var prefixCls = getPrefixCls("empty", customizePrefixCls);
    var des = typeof description !== "undefined" ? description : contextLocale.description;
    var alt = typeof des === "string" ? des : "empty";
    var imageNode = null;
    if (typeof image === "string") {
      imageNode = /* @__PURE__ */ react.exports.createElement("img", {
        alt,
        src: image
      });
    } else {
      imageNode = image;
    }
    return /* @__PURE__ */ react.exports.createElement("div", _extends$2({
      className: classNames(prefixCls, (_classNames = {}, _defineProperty$4(_classNames, "".concat(prefixCls, "-normal"), image === simpleEmptyImg), _defineProperty$4(_classNames, "".concat(prefixCls, "-rtl"), direction2 === "rtl"), _classNames), className)
    }, restProps), /* @__PURE__ */ react.exports.createElement("div", {
      className: "".concat(prefixCls, "-image"),
      style: imageStyle
    }, imageNode), des && /* @__PURE__ */ react.exports.createElement("div", {
      className: "".concat(prefixCls, "-description")
    }, des), children && /* @__PURE__ */ react.exports.createElement("div", {
      className: "".concat(prefixCls, "-footer")
    }, children));
  });
};
Empty.PRESENTED_IMAGE_DEFAULT = defaultEmptyImg;
Empty.PRESENTED_IMAGE_SIMPLE = simpleEmptyImg;
var Empty$1 = Empty;
var defaultRenderEmpty = function defaultRenderEmpty2(componentName) {
  return /* @__PURE__ */ react.exports.createElement(ConfigConsumer, null, function(_ref) {
    var getPrefixCls = _ref.getPrefixCls;
    var prefix = getPrefixCls("empty");
    switch (componentName) {
      case "Table":
      case "List":
        return /* @__PURE__ */ react.exports.createElement(Empty$1, {
          image: Empty$1.PRESENTED_IMAGE_SIMPLE
        });
      case "Select":
      case "TreeSelect":
      case "Cascader":
      case "Transfer":
      case "Mentions":
        return /* @__PURE__ */ react.exports.createElement(Empty$1, {
          image: Empty$1.PRESENTED_IMAGE_SIMPLE,
          className: "".concat(prefix, "-small")
        });
      default:
        return /* @__PURE__ */ react.exports.createElement(Empty$1, null);
    }
  });
};
var defaultRenderEmpty$1 = defaultRenderEmpty;
var FormItemInputContext = /* @__PURE__ */ react.exports.createContext({});
var NoFormStyle = function NoFormStyle2(_ref) {
  var children = _ref.children, status = _ref.status, override = _ref.override;
  var formItemInputContext = react.exports.useContext(FormItemInputContext);
  var newFormItemInputContext = react.exports.useMemo(function() {
    var newContext = _extends$2({}, formItemInputContext);
    if (override) {
      delete newContext.isFormItemInput;
    }
    if (status) {
      delete newContext.status;
      delete newContext.hasFeedback;
      delete newContext.feedbackIcon;
    }
    return newContext;
  }, [status, override, formItemInputContext]);
  return /* @__PURE__ */ react.exports.createElement(FormItemInputContext.Provider, {
    value: newFormItemInputContext
  }, children);
};
var tuple = function tuple2() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return args;
};
var getCollapsedHeight = function getCollapsedHeight2() {
  return {
    height: 0,
    opacity: 0
  };
};
var getRealHeight = function getRealHeight2(node) {
  var scrollHeight = node.scrollHeight;
  return {
    height: scrollHeight,
    opacity: 1
  };
};
var getCurrentHeight = function getCurrentHeight2(node) {
  return {
    height: node ? node.offsetHeight : 0
  };
};
var skipOpacityTransition = function skipOpacityTransition2(_2, event) {
  return (event === null || event === void 0 ? void 0 : event.deadline) === true || event.propertyName === "height";
};
var collapseMotion = {
  motionName: "ant-motion-collapse",
  onAppearStart: getCollapsedHeight,
  onEnterStart: getCollapsedHeight,
  onAppearActive: getRealHeight,
  onEnterActive: getRealHeight,
  onLeaveStart: getCurrentHeight,
  onLeaveActive: getCollapsedHeight,
  onAppearEnd: skipOpacityTransition,
  onEnterEnd: skipOpacityTransition,
  onLeaveEnd: skipOpacityTransition,
  motionDeadline: 500
};
tuple("bottomLeft", "bottomRight", "topLeft", "topRight");
var getTransitionDirection = function getTransitionDirection2(placement) {
  if (placement !== void 0 && (placement === "topLeft" || placement === "topRight")) {
    return "slide-down";
  }
  return "slide-up";
};
var getTransitionName = function getTransitionName2(rootPrefixCls, motion, transitionName2) {
  if (transitionName2 !== void 0) {
    return transitionName2;
  }
  return "".concat(rootPrefixCls, "-").concat(motion);
};
tuple("warning", "error", "");
function getStatusClassNames(prefixCls, status, hasFeedback) {
  var _classNames;
  return classNames((_classNames = {}, _defineProperty$4(_classNames, "".concat(prefixCls, "-status-success"), status === "success"), _defineProperty$4(_classNames, "".concat(prefixCls, "-status-warning"), status === "warning"), _defineProperty$4(_classNames, "".concat(prefixCls, "-status-error"), status === "error"), _defineProperty$4(_classNames, "".concat(prefixCls, "-status-validating"), status === "validating"), _defineProperty$4(_classNames, "".concat(prefixCls, "-has-feedback"), hasFeedback), _classNames));
}
var getMergedStatus = function getMergedStatus2(contextStatus, customStatus) {
  return customStatus || contextStatus;
};
var CheckOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M912 190h-69.9c-9.8 0-19.1 4.5-25.1 12.2L404.7 724.5 207 474a32 32 0 00-25.1-12.2H112c-6.7 0-10.4 7.7-6.3 12.9l273.9 347c12.8 16.2 37.4 16.2 50.3 0l488.4-618.9c4.1-5.1.4-12.8-6.3-12.8z" } }] }, "name": "check", "theme": "outlined" };
var CheckOutlinedSvg = CheckOutlined$2;
var CheckOutlined = function CheckOutlined2(props, ref) {
  return /* @__PURE__ */ react.exports.createElement(AntdIcon, _objectSpread2$1(_objectSpread2$1({}, props), {}, {
    ref,
    icon: CheckOutlinedSvg
  }));
};
CheckOutlined.displayName = "CheckOutlined";
var CheckOutlined$1 = /* @__PURE__ */ react.exports.forwardRef(CheckOutlined);
var DownOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M884 256h-75c-5.1 0-9.9 2.5-12.9 6.6L512 654.2 227.9 262.6c-3-4.1-7.8-6.6-12.9-6.6h-75c-6.5 0-10.3 7.4-6.5 12.7l352.6 486.1c12.8 17.6 39 17.6 51.7 0l352.6-486.1c3.9-5.3.1-12.7-6.4-12.7z" } }] }, "name": "down", "theme": "outlined" };
var DownOutlinedSvg = DownOutlined$2;
var DownOutlined = function DownOutlined2(props, ref) {
  return /* @__PURE__ */ react.exports.createElement(AntdIcon, _objectSpread2$1(_objectSpread2$1({}, props), {}, {
    ref,
    icon: DownOutlinedSvg
  }));
};
DownOutlined.displayName = "DownOutlined";
var DownOutlined$1 = /* @__PURE__ */ react.exports.forwardRef(DownOutlined);
var SearchOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M909.6 854.5L649.9 594.8C690.2 542.7 712 479 712 412c0-80.2-31.3-155.4-87.9-212.1-56.6-56.7-132-87.9-212.1-87.9s-155.5 31.3-212.1 87.9C143.2 256.5 112 331.8 112 412c0 80.1 31.3 155.5 87.9 212.1C256.5 680.8 331.8 712 412 712c67 0 130.6-21.8 182.7-62l259.7 259.6a8.2 8.2 0 0011.6 0l43.6-43.5a8.2 8.2 0 000-11.6zM570.4 570.4C528 612.7 471.8 636 412 636s-116-23.3-158.4-65.6C211.3 528 188 471.8 188 412s23.3-116.1 65.6-158.4C296 211.3 352.2 188 412 188s116.1 23.2 158.4 65.6S636 352.2 636 412s-23.3 116.1-65.6 158.4z" } }] }, "name": "search", "theme": "outlined" };
var SearchOutlinedSvg = SearchOutlined$2;
var SearchOutlined = function SearchOutlined2(props, ref) {
  return /* @__PURE__ */ react.exports.createElement(AntdIcon, _objectSpread2$1(_objectSpread2$1({}, props), {}, {
    ref,
    icon: SearchOutlinedSvg
  }));
};
SearchOutlined.displayName = "SearchOutlined";
var SearchOutlined$1 = /* @__PURE__ */ react.exports.forwardRef(SearchOutlined);
function getIcons(_ref) {
  var suffixIcon = _ref.suffixIcon, clearIcon = _ref.clearIcon, menuItemSelectedIcon = _ref.menuItemSelectedIcon, removeIcon = _ref.removeIcon, loading = _ref.loading, multiple = _ref.multiple, hasFeedback = _ref.hasFeedback, prefixCls = _ref.prefixCls, showArrow = _ref.showArrow, feedbackIcon = _ref.feedbackIcon;
  var mergedClearIcon = clearIcon;
  if (!clearIcon) {
    mergedClearIcon = /* @__PURE__ */ react.exports.createElement(CloseCircleFilled$1, null);
  }
  var getSuffixIconNode = function getSuffixIconNode2(arrowIcon) {
    return /* @__PURE__ */ react.exports.createElement(react.exports.Fragment, null, showArrow !== false && arrowIcon, hasFeedback && feedbackIcon);
  };
  var mergedSuffixIcon = null;
  if (suffixIcon !== void 0) {
    mergedSuffixIcon = getSuffixIconNode(suffixIcon);
  } else if (loading) {
    mergedSuffixIcon = getSuffixIconNode(/* @__PURE__ */ react.exports.createElement(LoadingOutlined$1, {
      spin: true
    }));
  } else {
    var iconCls = "".concat(prefixCls, "-suffix");
    mergedSuffixIcon = function mergedSuffixIcon2(_ref2) {
      var open = _ref2.open, showSearch = _ref2.showSearch;
      if (open && showSearch) {
        return getSuffixIconNode(/* @__PURE__ */ react.exports.createElement(SearchOutlined$1, {
          className: iconCls
        }));
      }
      return getSuffixIconNode(/* @__PURE__ */ react.exports.createElement(DownOutlined$1, {
        className: iconCls
      }));
    };
  }
  var mergedItemIcon = null;
  if (menuItemSelectedIcon !== void 0) {
    mergedItemIcon = menuItemSelectedIcon;
  } else if (multiple) {
    mergedItemIcon = /* @__PURE__ */ react.exports.createElement(CheckOutlined$1, null);
  } else {
    mergedItemIcon = null;
  }
  var mergedRemoveIcon = null;
  if (removeIcon !== void 0) {
    mergedRemoveIcon = removeIcon;
  } else {
    mergedRemoveIcon = /* @__PURE__ */ react.exports.createElement(CloseOutlined$1, null);
  }
  return {
    clearIcon: mergedClearIcon,
    suffixIcon: mergedSuffixIcon,
    itemIcon: mergedItemIcon,
    removeIcon: mergedRemoveIcon
  };
}
var __rest$w = globalThis && globalThis.__rest || function(s2, e3) {
  var t2 = {};
  for (var p2 in s2) {
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  }
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e3.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
var SECRET_COMBOBOX_MODE_DO_NOT_USE = "SECRET_COMBOBOX_MODE_DO_NOT_USE";
var InternalSelect = function InternalSelect2(_a2, ref) {
  var _classNames2;
  var customizePrefixCls = _a2.prefixCls, _a$bordered = _a2.bordered, bordered = _a$bordered === void 0 ? true : _a$bordered, className = _a2.className, getPopupContainer = _a2.getPopupContainer, dropdownClassName = _a2.dropdownClassName, popupClassName = _a2.popupClassName, _a$listHeight = _a2.listHeight, listHeight = _a$listHeight === void 0 ? 256 : _a$listHeight, placement = _a2.placement, _a$listItemHeight = _a2.listItemHeight, listItemHeight = _a$listItemHeight === void 0 ? 24 : _a$listItemHeight, customizeSize = _a2.size, customDisabled = _a2.disabled, notFoundContent = _a2.notFoundContent, customStatus = _a2.status, showArrow = _a2.showArrow, props = __rest$w(_a2, ["prefixCls", "bordered", "className", "getPopupContainer", "dropdownClassName", "popupClassName", "listHeight", "placement", "listItemHeight", "size", "disabled", "notFoundContent", "status", "showArrow"]);
  var _React$useContext = react.exports.useContext(ConfigContext), getContextPopupContainer = _React$useContext.getPopupContainer, getPrefixCls = _React$useContext.getPrefixCls, renderEmpty = _React$useContext.renderEmpty, direction2 = _React$useContext.direction, virtual = _React$useContext.virtual, dropdownMatchSelectWidth = _React$useContext.dropdownMatchSelectWidth;
  var size2 = react.exports.useContext(SizeContext$1);
  var prefixCls = getPrefixCls("select", customizePrefixCls);
  var rootPrefixCls = getPrefixCls();
  var mode = react.exports.useMemo(function() {
    var m2 = props.mode;
    if (m2 === "combobox") {
      return void 0;
    }
    if (m2 === SECRET_COMBOBOX_MODE_DO_NOT_USE) {
      return "combobox";
    }
    return m2;
  }, [props.mode]);
  var isMultiple2 = mode === "multiple" || mode === "tags";
  var mergedShowArrow = showArrow !== void 0 ? showArrow : props.loading || !(isMultiple2 || mode === "combobox");
  var _useContext = react.exports.useContext(FormItemInputContext), contextStatus = _useContext.status, hasFeedback = _useContext.hasFeedback, isFormItemInput = _useContext.isFormItemInput, feedbackIcon = _useContext.feedbackIcon;
  var mergedStatus = getMergedStatus(contextStatus, customStatus);
  var mergedNotFound;
  if (notFoundContent !== void 0) {
    mergedNotFound = notFoundContent;
  } else if (mode === "combobox") {
    mergedNotFound = null;
  } else {
    mergedNotFound = (renderEmpty || defaultRenderEmpty$1)("Select");
  }
  var _getIcons = getIcons(_extends$2(_extends$2({}, props), {
    multiple: isMultiple2,
    hasFeedback,
    feedbackIcon,
    showArrow: mergedShowArrow,
    prefixCls
  })), suffixIcon = _getIcons.suffixIcon, itemIcon = _getIcons.itemIcon, removeIcon = _getIcons.removeIcon, clearIcon = _getIcons.clearIcon;
  var selectProps = omit$2(props, ["suffixIcon", "itemIcon"]);
  var rcSelectRtlDropdownClassName = classNames(popupClassName || dropdownClassName, _defineProperty$4({}, "".concat(prefixCls, "-dropdown-").concat(direction2), direction2 === "rtl"));
  var mergedSize = customizeSize || size2;
  var disabled = react.exports.useContext(DisabledContext$1);
  var mergedDisabled = customDisabled || disabled;
  var mergedClassName = classNames((_classNames2 = {}, _defineProperty$4(_classNames2, "".concat(prefixCls, "-lg"), mergedSize === "large"), _defineProperty$4(_classNames2, "".concat(prefixCls, "-sm"), mergedSize === "small"), _defineProperty$4(_classNames2, "".concat(prefixCls, "-rtl"), direction2 === "rtl"), _defineProperty$4(_classNames2, "".concat(prefixCls, "-borderless"), !bordered), _defineProperty$4(_classNames2, "".concat(prefixCls, "-in-form-item"), isFormItemInput), _classNames2), getStatusClassNames(prefixCls, mergedStatus, hasFeedback), className);
  var getPlacement = function getPlacement2() {
    if (placement !== void 0) {
      return placement;
    }
    return direction2 === "rtl" ? "bottomRight" : "bottomLeft";
  };
  return /* @__PURE__ */ react.exports.createElement(TypedSelect, _extends$2({
    ref,
    virtual,
    dropdownMatchSelectWidth
  }, selectProps, {
    transitionName: getTransitionName(rootPrefixCls, getTransitionDirection(placement), props.transitionName),
    listHeight,
    listItemHeight,
    mode,
    prefixCls,
    placement: getPlacement(),
    direction: direction2,
    inputIcon: suffixIcon,
    menuItemSelectedIcon: itemIcon,
    removeIcon,
    clearIcon,
    notFoundContent: mergedNotFound,
    className: mergedClassName,
    getPopupContainer: getPopupContainer || getContextPopupContainer,
    dropdownClassName: rcSelectRtlDropdownClassName,
    showArrow: hasFeedback || showArrow,
    disabled: mergedDisabled
  }));
};
var Select = /* @__PURE__ */ react.exports.forwardRef(InternalSelect);
Select.SECRET_COMBOBOX_MODE_DO_NOT_USE = SECRET_COMBOBOX_MODE_DO_NOT_USE;
Select.Option = Option;
Select.OptGroup = OptGroup;
var Select$1 = Select;
function useForceUpdate() {
  var _React$useReducer = react.exports.useReducer(function(x2) {
    return x2 + 1;
  }, 0), _React$useReducer2 = _slicedToArray$4(_React$useReducer, 2), forceUpdate = _React$useReducer2[1];
  return forceUpdate;
}
var responsiveArray = ["xxl", "xl", "lg", "md", "sm", "xs"];
var responsiveMap = {
  xs: "(max-width: 575px)",
  sm: "(min-width: 576px)",
  md: "(min-width: 768px)",
  lg: "(min-width: 992px)",
  xl: "(min-width: 1200px)",
  xxl: "(min-width: 1600px)"
};
var subscribers = /* @__PURE__ */ new Map();
var subUid = -1;
var screens = {};
var responsiveObserve = {
  matchHandlers: {},
  dispatch: function dispatch(pointMap) {
    screens = pointMap;
    subscribers.forEach(function(func) {
      return func(screens);
    });
    return subscribers.size >= 1;
  },
  subscribe: function subscribe(func) {
    if (!subscribers.size)
      this.register();
    subUid += 1;
    subscribers.set(subUid, func);
    func(screens);
    return subUid;
  },
  unsubscribe: function unsubscribe(token2) {
    subscribers["delete"](token2);
    if (!subscribers.size)
      this.unregister();
  },
  unregister: function unregister() {
    var _this = this;
    Object.keys(responsiveMap).forEach(function(screen) {
      var matchMediaQuery = responsiveMap[screen];
      var handler = _this.matchHandlers[matchMediaQuery];
      handler === null || handler === void 0 ? void 0 : handler.mql.removeListener(handler === null || handler === void 0 ? void 0 : handler.listener);
    });
    subscribers.clear();
  },
  register: function register3() {
    var _this2 = this;
    Object.keys(responsiveMap).forEach(function(screen) {
      var matchMediaQuery = responsiveMap[screen];
      var listener = function listener2(_ref) {
        var matches = _ref.matches;
        _this2.dispatch(_extends$2(_extends$2({}, screens), _defineProperty$4({}, screen, matches)));
      };
      var mql = window.matchMedia(matchMediaQuery);
      mql.addListener(listener);
      _this2.matchHandlers[matchMediaQuery] = {
        mql,
        listener
      };
      listener(mql);
    });
  }
};
var ResponsiveObserve = responsiveObserve;
function useBreakpoint() {
  var refreshOnChange = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
  var screensRef = react.exports.useRef({});
  var forceUpdate = useForceUpdate();
  react.exports.useEffect(function() {
    var token2 = ResponsiveObserve.subscribe(function(supportScreens) {
      screensRef.current = supportScreens;
      if (refreshOnChange) {
        forceUpdate();
      }
    });
    return function() {
      return ResponsiveObserve.unsubscribe(token2);
    };
  }, []);
  return screensRef.current;
}
var autoAdjustOverflow$2 = {
  adjustX: 1,
  adjustY: 1
};
var targetOffset$2 = [0, 0];
var placements$2 = {
  left: {
    points: ["cr", "cl"],
    overflow: autoAdjustOverflow$2,
    offset: [-4, 0],
    targetOffset: targetOffset$2
  },
  right: {
    points: ["cl", "cr"],
    overflow: autoAdjustOverflow$2,
    offset: [4, 0],
    targetOffset: targetOffset$2
  },
  top: {
    points: ["bc", "tc"],
    overflow: autoAdjustOverflow$2,
    offset: [0, -4],
    targetOffset: targetOffset$2
  },
  bottom: {
    points: ["tc", "bc"],
    overflow: autoAdjustOverflow$2,
    offset: [0, 4],
    targetOffset: targetOffset$2
  },
  topLeft: {
    points: ["bl", "tl"],
    overflow: autoAdjustOverflow$2,
    offset: [0, -4],
    targetOffset: targetOffset$2
  },
  leftTop: {
    points: ["tr", "tl"],
    overflow: autoAdjustOverflow$2,
    offset: [-4, 0],
    targetOffset: targetOffset$2
  },
  topRight: {
    points: ["br", "tr"],
    overflow: autoAdjustOverflow$2,
    offset: [0, -4],
    targetOffset: targetOffset$2
  },
  rightTop: {
    points: ["tl", "tr"],
    overflow: autoAdjustOverflow$2,
    offset: [4, 0],
    targetOffset: targetOffset$2
  },
  bottomRight: {
    points: ["tr", "br"],
    overflow: autoAdjustOverflow$2,
    offset: [0, 4],
    targetOffset: targetOffset$2
  },
  rightBottom: {
    points: ["bl", "br"],
    overflow: autoAdjustOverflow$2,
    offset: [4, 0],
    targetOffset: targetOffset$2
  },
  bottomLeft: {
    points: ["tl", "bl"],
    overflow: autoAdjustOverflow$2,
    offset: [0, 4],
    targetOffset: targetOffset$2
  },
  leftBottom: {
    points: ["br", "bl"],
    overflow: autoAdjustOverflow$2,
    offset: [-4, 0],
    targetOffset: targetOffset$2
  }
};
function Popup(props) {
  var showArrow = props.showArrow, arrowContent = props.arrowContent, children = props.children, prefixCls = props.prefixCls, id2 = props.id, overlayInnerStyle = props.overlayInnerStyle, className = props.className, style2 = props.style;
  return /* @__PURE__ */ react.exports.createElement("div", {
    className: classNames("".concat(prefixCls, "-content"), className),
    style: style2
  }, showArrow !== false && /* @__PURE__ */ react.exports.createElement("div", {
    className: "".concat(prefixCls, "-arrow"),
    key: "arrow"
  }, arrowContent), /* @__PURE__ */ react.exports.createElement("div", {
    className: "".concat(prefixCls, "-inner"),
    id: id2,
    role: "tooltip",
    style: overlayInnerStyle
  }, typeof children === "function" ? children() : children));
}
var Tooltip$4 = function Tooltip2(props, ref) {
  var overlayClassName = props.overlayClassName, _props$trigger = props.trigger, trigger = _props$trigger === void 0 ? ["hover"] : _props$trigger, _props$mouseEnterDela = props.mouseEnterDelay, mouseEnterDelay = _props$mouseEnterDela === void 0 ? 0 : _props$mouseEnterDela, _props$mouseLeaveDela = props.mouseLeaveDelay, mouseLeaveDelay = _props$mouseLeaveDela === void 0 ? 0.1 : _props$mouseLeaveDela, overlayStyle = props.overlayStyle, _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-tooltip" : _props$prefixCls, children = props.children, onVisibleChange = props.onVisibleChange, afterVisibleChange = props.afterVisibleChange, transitionName2 = props.transitionName, animation2 = props.animation, motion = props.motion, _props$placement = props.placement, placement = _props$placement === void 0 ? "right" : _props$placement, _props$align = props.align, align = _props$align === void 0 ? {} : _props$align, _props$destroyTooltip = props.destroyTooltipOnHide, destroyTooltipOnHide = _props$destroyTooltip === void 0 ? false : _props$destroyTooltip, defaultVisible = props.defaultVisible, getTooltipContainer = props.getTooltipContainer, overlayInnerStyle = props.overlayInnerStyle, arrowContent = props.arrowContent, overlay = props.overlay, id2 = props.id, showArrow = props.showArrow, restProps = _objectWithoutProperties$1(props, ["overlayClassName", "trigger", "mouseEnterDelay", "mouseLeaveDelay", "overlayStyle", "prefixCls", "children", "onVisibleChange", "afterVisibleChange", "transitionName", "animation", "motion", "placement", "align", "destroyTooltipOnHide", "defaultVisible", "getTooltipContainer", "overlayInnerStyle", "arrowContent", "overlay", "id", "showArrow"]);
  var domRef = react.exports.useRef(null);
  react.exports.useImperativeHandle(ref, function() {
    return domRef.current;
  });
  var extraProps = _objectSpread2$1({}, restProps);
  if ("visible" in props) {
    extraProps.popupVisible = props.visible;
  }
  var getPopupElement = function getPopupElement2() {
    return /* @__PURE__ */ react.exports.createElement(Popup, {
      showArrow,
      arrowContent,
      key: "content",
      prefixCls,
      id: id2,
      overlayInnerStyle
    }, overlay);
  };
  var destroyTooltip = false;
  var autoDestroy = false;
  if (typeof destroyTooltipOnHide === "boolean") {
    destroyTooltip = destroyTooltipOnHide;
  } else if (destroyTooltipOnHide && _typeof$4(destroyTooltipOnHide) === "object") {
    var keepParent = destroyTooltipOnHide.keepParent;
    destroyTooltip = keepParent === true;
    autoDestroy = keepParent === false;
  }
  return /* @__PURE__ */ react.exports.createElement(Trigger, _extends$2({
    popupClassName: overlayClassName,
    prefixCls,
    popup: getPopupElement,
    action: trigger,
    builtinPlacements: placements$2,
    popupPlacement: placement,
    ref: domRef,
    popupAlign: align,
    getPopupContainer: getTooltipContainer,
    onPopupVisibleChange: onVisibleChange,
    afterPopupVisibleChange: afterVisibleChange,
    popupTransitionName: transitionName2,
    popupAnimation: animation2,
    popupMotion: motion,
    defaultPopupVisible: defaultVisible,
    destroyPopupOnHide: destroyTooltip,
    autoDestroy,
    mouseLeaveDelay,
    popupStyle: overlayStyle,
    mouseEnterDelay
  }, extraProps), children);
};
var Tooltip$5 = /* @__PURE__ */ react.exports.forwardRef(Tooltip$4);
tuple("success", "processing", "error", "default", "warning");
var PresetColorTypes = tuple("pink", "red", "yellow", "orange", "cyan", "green", "blue", "purple", "geekblue", "magenta", "volcano", "gold", "lime");
var autoAdjustOverflowEnabled = {
  adjustX: 1,
  adjustY: 1
};
var autoAdjustOverflowDisabled = {
  adjustX: 0,
  adjustY: 0
};
var targetOffset$1 = [0, 0];
function getOverflowOptions(autoAdjustOverflow2) {
  if (typeof autoAdjustOverflow2 === "boolean") {
    return autoAdjustOverflow2 ? autoAdjustOverflowEnabled : autoAdjustOverflowDisabled;
  }
  return _extends$2(_extends$2({}, autoAdjustOverflowDisabled), autoAdjustOverflow2);
}
function getPlacements(config) {
  var _config$arrowWidth = config.arrowWidth, arrowWidth = _config$arrowWidth === void 0 ? 4 : _config$arrowWidth, _config$horizontalArr = config.horizontalArrowShift, horizontalArrowShift = _config$horizontalArr === void 0 ? 16 : _config$horizontalArr, _config$verticalArrow = config.verticalArrowShift, verticalArrowShift = _config$verticalArrow === void 0 ? 8 : _config$verticalArrow, autoAdjustOverflow2 = config.autoAdjustOverflow, arrowPointAtCenter = config.arrowPointAtCenter;
  var placementMap = {
    left: {
      points: ["cr", "cl"],
      offset: [-4, 0]
    },
    right: {
      points: ["cl", "cr"],
      offset: [4, 0]
    },
    top: {
      points: ["bc", "tc"],
      offset: [0, -4]
    },
    bottom: {
      points: ["tc", "bc"],
      offset: [0, 4]
    },
    topLeft: {
      points: ["bl", "tc"],
      offset: [-(horizontalArrowShift + arrowWidth), -4]
    },
    leftTop: {
      points: ["tr", "cl"],
      offset: [-4, -(verticalArrowShift + arrowWidth)]
    },
    topRight: {
      points: ["br", "tc"],
      offset: [horizontalArrowShift + arrowWidth, -4]
    },
    rightTop: {
      points: ["tl", "cr"],
      offset: [4, -(verticalArrowShift + arrowWidth)]
    },
    bottomRight: {
      points: ["tr", "bc"],
      offset: [horizontalArrowShift + arrowWidth, 4]
    },
    rightBottom: {
      points: ["bl", "cr"],
      offset: [4, verticalArrowShift + arrowWidth]
    },
    bottomLeft: {
      points: ["tl", "bc"],
      offset: [-(horizontalArrowShift + arrowWidth), 4]
    },
    leftBottom: {
      points: ["br", "cl"],
      offset: [-4, verticalArrowShift + arrowWidth]
    }
  };
  Object.keys(placementMap).forEach(function(key2) {
    placementMap[key2] = arrowPointAtCenter ? _extends$2(_extends$2({}, placementMap[key2]), {
      overflow: getOverflowOptions(autoAdjustOverflow2),
      targetOffset: targetOffset$1
    }) : _extends$2(_extends$2({}, placements$2[key2]), {
      overflow: getOverflowOptions(autoAdjustOverflow2)
    });
    placementMap[key2].ignoreShake = true;
  });
  return placementMap;
}
var __rest$v = globalThis && globalThis.__rest || function(s2, e3) {
  var t2 = {};
  for (var p2 in s2) {
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  }
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e3.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
var splitObject = function splitObject2(obj, keys2) {
  var picked = {};
  var omitted = _extends$2({}, obj);
  keys2.forEach(function(key2) {
    if (obj && key2 in obj) {
      picked[key2] = obj[key2];
      delete omitted[key2];
    }
  });
  return {
    picked,
    omitted
  };
};
var PresetColorRegex = new RegExp("^(".concat(PresetColorTypes.join("|"), ")(-inverse)?$"));
function getDisabledCompatibleChildren(element, prefixCls) {
  var elementType = element.type;
  if ((elementType.__ANT_BUTTON === true || element.type === "button") && element.props.disabled || elementType.__ANT_SWITCH === true && (element.props.disabled || element.props.loading) || elementType.__ANT_RADIO === true && element.props.disabled) {
    var _splitObject = splitObject(element.props.style, ["position", "left", "right", "top", "bottom", "float", "display", "zIndex"]), picked = _splitObject.picked, omitted = _splitObject.omitted;
    var spanStyle = _extends$2(_extends$2({
      display: "inline-block"
    }, picked), {
      cursor: "not-allowed",
      width: element.props.block ? "100%" : null
    });
    var buttonStyle = _extends$2(_extends$2({}, omitted), {
      pointerEvents: "none"
    });
    var child = cloneElement(element, {
      style: buttonStyle,
      className: null
    });
    return /* @__PURE__ */ react.exports.createElement("span", {
      style: spanStyle,
      className: classNames(element.props.className, "".concat(prefixCls, "-disabled-compatible-wrapper"))
    }, child);
  }
  return element;
}
var Tooltip$2 = /* @__PURE__ */ react.exports.forwardRef(function(props, ref) {
  var _classNames2;
  var _React$useContext = react.exports.useContext(ConfigContext), getContextPopupContainer = _React$useContext.getPopupContainer, getPrefixCls = _React$useContext.getPrefixCls, direction2 = _React$useContext.direction;
  var _useMergedState = useMergedState(false, {
    value: props.open !== void 0 ? props.open : props.visible,
    defaultValue: props.defaultOpen !== void 0 ? props.defaultOpen : props.defaultVisible
  }), _useMergedState2 = _slicedToArray$4(_useMergedState, 2), open = _useMergedState2[0], setOpen = _useMergedState2[1];
  var isNoTitle = function isNoTitle2() {
    var title = props.title, overlay = props.overlay;
    return !title && !overlay && title !== 0;
  };
  var onOpenChange = function onOpenChange2(vis) {
    var _a2, _b;
    setOpen(isNoTitle() ? false : vis);
    if (!isNoTitle()) {
      (_a2 = props.onOpenChange) === null || _a2 === void 0 ? void 0 : _a2.call(props, vis);
      (_b = props.onVisibleChange) === null || _b === void 0 ? void 0 : _b.call(props, vis);
    }
  };
  var getTooltipPlacements = function getTooltipPlacements2() {
    var builtinPlacements = props.builtinPlacements, arrowPointAtCenter = props.arrowPointAtCenter, autoAdjustOverflow2 = props.autoAdjustOverflow;
    return builtinPlacements || getPlacements({
      arrowPointAtCenter,
      autoAdjustOverflow: autoAdjustOverflow2
    });
  };
  var onPopupAlign = function onPopupAlign2(domNode, align) {
    var placements2 = getTooltipPlacements();
    var placement = Object.keys(placements2).find(function(key2) {
      return placements2[key2].points[0] === align.points[0] && placements2[key2].points[1] === align.points[1];
    });
    if (!placement) {
      return;
    }
    var rect2 = domNode.getBoundingClientRect();
    var transformOrigin = {
      top: "50%",
      left: "50%"
    };
    if (placement.indexOf("top") >= 0 || placement.indexOf("Bottom") >= 0) {
      transformOrigin.top = "".concat(rect2.height - align.offset[1], "px");
    } else if (placement.indexOf("Top") >= 0 || placement.indexOf("bottom") >= 0) {
      transformOrigin.top = "".concat(-align.offset[1], "px");
    }
    if (placement.indexOf("left") >= 0 || placement.indexOf("Right") >= 0) {
      transformOrigin.left = "".concat(rect2.width - align.offset[0], "px");
    } else if (placement.indexOf("right") >= 0 || placement.indexOf("Left") >= 0) {
      transformOrigin.left = "".concat(-align.offset[0], "px");
    }
    domNode.style.transformOrigin = "".concat(transformOrigin.left, " ").concat(transformOrigin.top);
  };
  var getOverlay = function getOverlay2() {
    var title = props.title, overlay = props.overlay;
    if (title === 0) {
      return title;
    }
    return overlay || title || "";
  };
  var getPopupContainer = props.getPopupContainer, otherProps = __rest$v(props, ["getPopupContainer"]);
  var customizePrefixCls = props.prefixCls, openClassName = props.openClassName, getTooltipContainer = props.getTooltipContainer, overlayClassName = props.overlayClassName, color2 = props.color, overlayInnerStyle = props.overlayInnerStyle, children = props.children;
  var prefixCls = getPrefixCls("tooltip", customizePrefixCls);
  var rootPrefixCls = getPrefixCls();
  var tempOpen = open;
  if (!("open" in props) && !("visible" in props) && isNoTitle()) {
    tempOpen = false;
  }
  var child = getDisabledCompatibleChildren(isValidElement(children) && !isFragment(children) ? children : /* @__PURE__ */ react.exports.createElement("span", null, children), prefixCls);
  var childProps = child.props;
  var childCls = !childProps.className || typeof childProps.className === "string" ? classNames(childProps.className, _defineProperty$4({}, openClassName || "".concat(prefixCls, "-open"), true)) : childProps.className;
  var customOverlayClassName = classNames(overlayClassName, (_classNames2 = {}, _defineProperty$4(_classNames2, "".concat(prefixCls, "-rtl"), direction2 === "rtl"), _defineProperty$4(_classNames2, "".concat(prefixCls, "-").concat(color2), color2 && PresetColorRegex.test(color2)), _classNames2));
  var formattedOverlayInnerStyle = overlayInnerStyle;
  var arrowContentStyle;
  if (color2 && !PresetColorRegex.test(color2)) {
    formattedOverlayInnerStyle = _extends$2(_extends$2({}, overlayInnerStyle), {
      background: color2
    });
    arrowContentStyle = {
      "--antd-arrow-background-color": color2
    };
  }
  return /* @__PURE__ */ react.exports.createElement(Tooltip$5, _extends$2({}, otherProps, {
    prefixCls,
    overlayClassName: customOverlayClassName,
    getTooltipContainer: getPopupContainer || getTooltipContainer || getContextPopupContainer,
    ref,
    builtinPlacements: getTooltipPlacements(),
    overlay: getOverlay(),
    visible: tempOpen,
    onVisibleChange: onOpenChange,
    onPopupAlign,
    overlayInnerStyle: formattedOverlayInnerStyle,
    arrowContent: /* @__PURE__ */ react.exports.createElement("span", {
      className: "".concat(prefixCls, "-arrow-content"),
      style: arrowContentStyle
    }),
    motion: {
      motionName: getTransitionName(rootPrefixCls, "zoom-big-fast", props.transitionName),
      motionDeadline: 1e3
    }
  }), tempOpen ? cloneElement(child, {
    className: childCls
  }) : child);
});
Tooltip$2.defaultProps = {
  placement: "top",
  mouseEnterDelay: 0.1,
  mouseLeaveDelay: 0.1,
  arrowPointAtCenter: false,
  autoAdjustOverflow: true
};
var Tooltip$3 = Tooltip$2;
var getRenderPropValue = function getRenderPropValue2(propValue) {
  if (!propValue) {
    return null;
  }
  var isRenderFunction = typeof propValue === "function";
  if (isRenderFunction) {
    return propValue();
  }
  return propValue;
};
var __rest$u = globalThis && globalThis.__rest || function(s2, e3) {
  var t2 = {};
  for (var p2 in s2) {
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  }
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e3.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
var Overlay = function Overlay2(_ref) {
  var title = _ref.title, content = _ref.content, prefixCls = _ref.prefixCls;
  if (!title && !content) {
    return null;
  }
  return /* @__PURE__ */ react.exports.createElement(react.exports.Fragment, null, title && /* @__PURE__ */ react.exports.createElement("div", {
    className: "".concat(prefixCls, "-title")
  }, getRenderPropValue(title)), /* @__PURE__ */ react.exports.createElement("div", {
    className: "".concat(prefixCls, "-inner-content")
  }, getRenderPropValue(content)));
};
var Popover = /* @__PURE__ */ react.exports.forwardRef(function(props, ref) {
  var customizePrefixCls = props.prefixCls, title = props.title, content = props.content, _overlay = props._overlay, _props$placement = props.placement, placement = _props$placement === void 0 ? "top" : _props$placement, _props$trigger = props.trigger, trigger = _props$trigger === void 0 ? "hover" : _props$trigger, _props$mouseEnterDela = props.mouseEnterDelay, mouseEnterDelay = _props$mouseEnterDela === void 0 ? 0.1 : _props$mouseEnterDela, _props$mouseLeaveDela = props.mouseLeaveDelay, mouseLeaveDelay = _props$mouseLeaveDela === void 0 ? 0.1 : _props$mouseLeaveDela, _props$overlayStyle = props.overlayStyle, overlayStyle = _props$overlayStyle === void 0 ? {} : _props$overlayStyle, otherProps = __rest$u(props, ["prefixCls", "title", "content", "_overlay", "placement", "trigger", "mouseEnterDelay", "mouseLeaveDelay", "overlayStyle"]);
  var _React$useContext = react.exports.useContext(ConfigContext), getPrefixCls = _React$useContext.getPrefixCls;
  var prefixCls = getPrefixCls("popover", customizePrefixCls);
  var rootPrefixCls = getPrefixCls();
  return /* @__PURE__ */ react.exports.createElement(Tooltip$3, _extends$2({
    placement,
    trigger,
    mouseEnterDelay,
    mouseLeaveDelay,
    overlayStyle
  }, otherProps, {
    prefixCls,
    ref,
    overlay: _overlay || /* @__PURE__ */ react.exports.createElement(Overlay, {
      prefixCls,
      title,
      content
    }),
    transitionName: getTransitionName(rootPrefixCls, "zoom-big", otherProps.transitionName)
  }));
});
var Popover$1 = Popover;
var EllipsisOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M176 511a56 56 0 10112 0 56 56 0 10-112 0zm280 0a56 56 0 10112 0 56 56 0 10-112 0zm280 0a56 56 0 10112 0 56 56 0 10-112 0z" } }] }, "name": "ellipsis", "theme": "outlined" };
var EllipsisOutlinedSvg = EllipsisOutlined$2;
var EllipsisOutlined = function EllipsisOutlined2(props, ref) {
  return /* @__PURE__ */ react.exports.createElement(AntdIcon, _objectSpread2$1(_objectSpread2$1({}, props), {}, {
    ref,
    icon: EllipsisOutlinedSvg
  }));
};
EllipsisOutlined.displayName = "EllipsisOutlined";
var EllipsisOutlined$1 = /* @__PURE__ */ react.exports.forwardRef(EllipsisOutlined);
var shallowequal = function shallowEqual(objA, objB, compare2, compareContext) {
  var ret = compare2 ? compare2.call(compareContext, objA, objB) : void 0;
  if (ret !== void 0) {
    return !!ret;
  }
  if (objA === objB) {
    return true;
  }
  if (typeof objA !== "object" || !objA || typeof objB !== "object" || !objB) {
    return false;
  }
  var keysA = Object.keys(objA);
  var keysB = Object.keys(objB);
  if (keysA.length !== keysB.length) {
    return false;
  }
  var bHasOwnProperty = Object.prototype.hasOwnProperty.bind(objB);
  for (var idx = 0; idx < keysA.length; idx++) {
    var key2 = keysA[idx];
    if (!bHasOwnProperty(key2)) {
      return false;
    }
    var valueA = objA[key2];
    var valueB = objB[key2];
    ret = compare2 ? compare2.call(compareContext, valueA, valueB, key2) : void 0;
    if (ret === false || ret === void 0 && valueA !== valueB) {
      return false;
    }
  }
  return true;
};
var _excluded$m = ["children", "locked"];
var MenuContext$2 = /* @__PURE__ */ react.exports.createContext(null);
function mergeProps(origin, target) {
  var clone3 = _objectSpread2$1({}, origin);
  Object.keys(target).forEach(function(key2) {
    var value2 = target[key2];
    if (value2 !== void 0) {
      clone3[key2] = value2;
    }
  });
  return clone3;
}
function InheritableContextProvider(_ref) {
  var children = _ref.children, locked = _ref.locked, restProps = _objectWithoutProperties$1(_ref, _excluded$m);
  var context2 = react.exports.useContext(MenuContext$2);
  var inheritableContext = useMemo(function() {
    return mergeProps(context2, restProps);
  }, [context2, restProps], function(prev, next) {
    return !locked && (prev[0] !== next[0] || !shallowequal(prev[1], next[1]));
  });
  return /* @__PURE__ */ react.exports.createElement(MenuContext$2.Provider, {
    value: inheritableContext
  }, children);
}
function useActive(eventKey, disabled, onMouseEnter, onMouseLeave) {
  var _React$useContext = react.exports.useContext(MenuContext$2), activeKey = _React$useContext.activeKey, onActive = _React$useContext.onActive, onInactive = _React$useContext.onInactive;
  var ret = {
    active: activeKey === eventKey
  };
  if (!disabled) {
    ret.onMouseEnter = function(domEvent) {
      onMouseEnter === null || onMouseEnter === void 0 ? void 0 : onMouseEnter({
        key: eventKey,
        domEvent
      });
      onActive(eventKey);
    };
    ret.onMouseLeave = function(domEvent) {
      onMouseLeave === null || onMouseLeave === void 0 ? void 0 : onMouseLeave({
        key: eventKey,
        domEvent
      });
      onInactive(eventKey);
    };
  }
  return ret;
}
var _excluded$l = ["item"];
function warnItemProp(_ref) {
  var item = _ref.item, restInfo = _objectWithoutProperties$1(_ref, _excluded$l);
  Object.defineProperty(restInfo, "item", {
    get: function get2() {
      warningOnce(false, "`info.item` is deprecated since we will move to function component that not provides React Node instance in future.");
      return item;
    }
  });
  return restInfo;
}
function Icon(_ref) {
  var icon = _ref.icon, props = _ref.props, children = _ref.children;
  var iconNode;
  if (typeof icon === "function") {
    iconNode = /* @__PURE__ */ react.exports.createElement(icon, _objectSpread2$1({}, props));
  } else {
    iconNode = icon;
  }
  return iconNode || children || null;
}
function useDirectionStyle(level) {
  var _React$useContext = react.exports.useContext(MenuContext$2), mode = _React$useContext.mode, rtl2 = _React$useContext.rtl, inlineIndent = _React$useContext.inlineIndent;
  if (mode !== "inline") {
    return null;
  }
  var len = level;
  return rtl2 ? {
    paddingRight: len * inlineIndent
  } : {
    paddingLeft: len * inlineIndent
  };
}
var EmptyList = [];
var PathRegisterContext = /* @__PURE__ */ react.exports.createContext(null);
function useMeasure() {
  return react.exports.useContext(PathRegisterContext);
}
var PathTrackerContext = /* @__PURE__ */ react.exports.createContext(EmptyList);
function useFullPath(eventKey) {
  var parentKeyPath = react.exports.useContext(PathTrackerContext);
  return react.exports.useMemo(function() {
    return eventKey !== void 0 ? [].concat(_toConsumableArray(parentKeyPath), [eventKey]) : parentKeyPath;
  }, [parentKeyPath, eventKey]);
}
var PathUserContext = /* @__PURE__ */ react.exports.createContext(null);
var IdContext = /* @__PURE__ */ react.exports.createContext(null);
function getMenuId(uuid2, eventKey) {
  if (uuid2 === void 0) {
    return null;
  }
  return "".concat(uuid2, "-").concat(eventKey);
}
function useMenuId(eventKey) {
  var id2 = react.exports.useContext(IdContext);
  return getMenuId(id2, eventKey);
}
var PrivateContext = /* @__PURE__ */ react.exports.createContext({});
var _excluded$k = ["title", "attribute", "elementRef"], _excluded2$4 = ["style", "className", "eventKey", "warnKey", "disabled", "itemIcon", "children", "role", "onMouseEnter", "onMouseLeave", "onClick", "onKeyDown", "onFocus"], _excluded3 = ["active"];
var LegacyMenuItem = /* @__PURE__ */ function(_React$Component) {
  _inherits$1(LegacyMenuItem2, _React$Component);
  var _super = _createSuper$1(LegacyMenuItem2);
  function LegacyMenuItem2() {
    _classCallCheck$2(this, LegacyMenuItem2);
    return _super.apply(this, arguments);
  }
  _createClass$2(LegacyMenuItem2, [{
    key: "render",
    value: function render2() {
      var _this$props = this.props, title = _this$props.title, attribute = _this$props.attribute, elementRef = _this$props.elementRef, restProps = _objectWithoutProperties$1(_this$props, _excluded$k);
      var passedProps = omit$2(restProps, ["eventKey"]);
      warningOnce(!attribute, "`attribute` of Menu.Item is deprecated. Please pass attribute directly.");
      return /* @__PURE__ */ react.exports.createElement(ForwardOverflow.Item, _extends$2({}, attribute, {
        title: typeof title === "string" ? title : void 0
      }, passedProps, {
        ref: elementRef
      }));
    }
  }]);
  return LegacyMenuItem2;
}(react.exports.Component);
var InternalMenuItem = function InternalMenuItem2(props) {
  var _classNames;
  var style2 = props.style, className = props.className, eventKey = props.eventKey;
  props.warnKey;
  var disabled = props.disabled, itemIcon = props.itemIcon, children = props.children, role = props.role, onMouseEnter = props.onMouseEnter, onMouseLeave = props.onMouseLeave, onClick = props.onClick, onKeyDown2 = props.onKeyDown, onFocus2 = props.onFocus, restProps = _objectWithoutProperties$1(props, _excluded2$4);
  var domDataId = useMenuId(eventKey);
  var _React$useContext = react.exports.useContext(MenuContext$2), prefixCls = _React$useContext.prefixCls, onItemClick = _React$useContext.onItemClick, contextDisabled = _React$useContext.disabled, overflowDisabled = _React$useContext.overflowDisabled, contextItemIcon = _React$useContext.itemIcon, selectedKeys = _React$useContext.selectedKeys, onActive = _React$useContext.onActive;
  var _React$useContext2 = react.exports.useContext(PrivateContext), _internalRenderMenuItem = _React$useContext2._internalRenderMenuItem;
  var itemCls = "".concat(prefixCls, "-item");
  var legacyMenuItemRef = react.exports.useRef();
  var elementRef = react.exports.useRef();
  var mergedDisabled = contextDisabled || disabled;
  var connectedKeys = useFullPath(eventKey);
  var getEventInfo = function getEventInfo2(e3) {
    return {
      key: eventKey,
      keyPath: _toConsumableArray(connectedKeys).reverse(),
      item: legacyMenuItemRef.current,
      domEvent: e3
    };
  };
  var mergedItemIcon = itemIcon || contextItemIcon;
  var _useActive = useActive(eventKey, mergedDisabled, onMouseEnter, onMouseLeave), active = _useActive.active, activeProps = _objectWithoutProperties$1(_useActive, _excluded3);
  var selected = selectedKeys.includes(eventKey);
  var directionStyle = useDirectionStyle(connectedKeys.length);
  var onInternalClick = function onInternalClick2(e3) {
    if (mergedDisabled) {
      return;
    }
    var info = getEventInfo(e3);
    onClick === null || onClick === void 0 ? void 0 : onClick(warnItemProp(info));
    onItemClick(info);
  };
  var onInternalKeyDown = function onInternalKeyDown2(e3) {
    onKeyDown2 === null || onKeyDown2 === void 0 ? void 0 : onKeyDown2(e3);
    if (e3.which === KeyCode.ENTER) {
      var info = getEventInfo(e3);
      onClick === null || onClick === void 0 ? void 0 : onClick(warnItemProp(info));
      onItemClick(info);
    }
  };
  var onInternalFocus = function onInternalFocus2(e3) {
    onActive(eventKey);
    onFocus2 === null || onFocus2 === void 0 ? void 0 : onFocus2(e3);
  };
  var optionRoleProps = {};
  if (props.role === "option") {
    optionRoleProps["aria-selected"] = selected;
  }
  var renderNode = /* @__PURE__ */ react.exports.createElement(LegacyMenuItem, _extends$2({
    ref: legacyMenuItemRef,
    elementRef,
    role: role === null ? "none" : role || "menuitem",
    tabIndex: disabled ? null : -1,
    "data-menu-id": overflowDisabled && domDataId ? null : domDataId
  }, restProps, activeProps, optionRoleProps, {
    component: "li",
    "aria-disabled": disabled,
    style: _objectSpread2$1(_objectSpread2$1({}, directionStyle), style2),
    className: classNames(itemCls, (_classNames = {}, _defineProperty$4(_classNames, "".concat(itemCls, "-active"), active), _defineProperty$4(_classNames, "".concat(itemCls, "-selected"), selected), _defineProperty$4(_classNames, "".concat(itemCls, "-disabled"), mergedDisabled), _classNames), className),
    onClick: onInternalClick,
    onKeyDown: onInternalKeyDown,
    onFocus: onInternalFocus
  }), children, /* @__PURE__ */ react.exports.createElement(Icon, {
    props: _objectSpread2$1(_objectSpread2$1({}, props), {}, {
      isSelected: selected
    }),
    icon: mergedItemIcon
  }));
  if (_internalRenderMenuItem) {
    renderNode = _internalRenderMenuItem(renderNode, props, {
      selected
    });
  }
  return renderNode;
};
function MenuItem$1(props) {
  var eventKey = props.eventKey;
  var measure = useMeasure();
  var connectedKeyPath = useFullPath(eventKey);
  react.exports.useEffect(function() {
    if (measure) {
      measure.registerPath(eventKey, connectedKeyPath);
      return function() {
        measure.unregisterPath(eventKey, connectedKeyPath);
      };
    }
  }, [connectedKeyPath]);
  if (measure) {
    return null;
  }
  return /* @__PURE__ */ react.exports.createElement(InternalMenuItem, props);
}
var _excluded$j = ["label", "children", "key", "type"];
function parseChildren(children, keyPath) {
  return toArray$5(children).map(function(child, index2) {
    if (/* @__PURE__ */ react.exports.isValidElement(child)) {
      var _child$props$eventKey, _child$props;
      var key2 = child.key;
      var eventKey = (_child$props$eventKey = (_child$props = child.props) === null || _child$props === void 0 ? void 0 : _child$props.eventKey) !== null && _child$props$eventKey !== void 0 ? _child$props$eventKey : key2;
      var emptyKey = eventKey === null || eventKey === void 0;
      if (emptyKey) {
        eventKey = "tmp_key-".concat([].concat(_toConsumableArray(keyPath), [index2]).join("-"));
      }
      var cloneProps = {
        key: eventKey,
        eventKey
      };
      return /* @__PURE__ */ react.exports.cloneElement(child, cloneProps);
    }
    return child;
  });
}
function convertItemsToNodes$1(list) {
  return (list || []).map(function(opt, index2) {
    if (opt && _typeof$4(opt) === "object") {
      var label2 = opt.label, children = opt.children, key2 = opt.key, type4 = opt.type, restProps = _objectWithoutProperties$1(opt, _excluded$j);
      var mergedKey = key2 !== null && key2 !== void 0 ? key2 : "tmp-".concat(index2);
      if (children || type4 === "group") {
        if (type4 === "group") {
          return /* @__PURE__ */ react.exports.createElement(MenuItemGroup, _extends$2({
            key: mergedKey
          }, restProps, {
            title: label2
          }), convertItemsToNodes$1(children));
        }
        return /* @__PURE__ */ react.exports.createElement(SubMenu$1, _extends$2({
          key: mergedKey
        }, restProps, {
          title: label2
        }), convertItemsToNodes$1(children));
      }
      if (type4 === "divider") {
        return /* @__PURE__ */ react.exports.createElement(Divider, _extends$2({
          key: mergedKey
        }, restProps));
      }
      return /* @__PURE__ */ react.exports.createElement(MenuItem$1, _extends$2({
        key: mergedKey
      }, restProps), label2);
    }
    return null;
  }).filter(function(opt) {
    return opt;
  });
}
function parseItems(children, items, keyPath) {
  var childNodes = children;
  if (items) {
    childNodes = convertItemsToNodes$1(items);
  }
  return parseChildren(childNodes, keyPath);
}
function useMemoCallback(func) {
  var funRef = react.exports.useRef(func);
  funRef.current = func;
  var callback = react.exports.useCallback(function() {
    var _funRef$current;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return (_funRef$current = funRef.current) === null || _funRef$current === void 0 ? void 0 : _funRef$current.call.apply(_funRef$current, [funRef].concat(args));
  }, []);
  return func ? callback : void 0;
}
var _excluded$i = ["className", "children"];
var InternalSubMenuList = function InternalSubMenuList2(_ref, ref) {
  var className = _ref.className, children = _ref.children, restProps = _objectWithoutProperties$1(_ref, _excluded$i);
  var _React$useContext = react.exports.useContext(MenuContext$2), prefixCls = _React$useContext.prefixCls, mode = _React$useContext.mode, rtl2 = _React$useContext.rtl;
  return /* @__PURE__ */ react.exports.createElement("ul", _extends$2({
    className: classNames(prefixCls, rtl2 && "".concat(prefixCls, "-rtl"), "".concat(prefixCls, "-sub"), "".concat(prefixCls, "-").concat(mode === "inline" ? "inline" : "vertical"), className)
  }, restProps, {
    "data-menu-list": true,
    ref
  }), children);
};
var SubMenuList = /* @__PURE__ */ react.exports.forwardRef(InternalSubMenuList);
SubMenuList.displayName = "SubMenuList";
var autoAdjustOverflow$1 = {
  adjustX: 1,
  adjustY: 1
};
var placements$1 = {
  topLeft: {
    points: ["bl", "tl"],
    overflow: autoAdjustOverflow$1,
    offset: [0, -7]
  },
  bottomLeft: {
    points: ["tl", "bl"],
    overflow: autoAdjustOverflow$1,
    offset: [0, 7]
  },
  leftTop: {
    points: ["tr", "tl"],
    overflow: autoAdjustOverflow$1,
    offset: [-4, 0]
  },
  rightTop: {
    points: ["tl", "tr"],
    overflow: autoAdjustOverflow$1,
    offset: [4, 0]
  }
};
var placementsRtl = {
  topLeft: {
    points: ["bl", "tl"],
    overflow: autoAdjustOverflow$1,
    offset: [0, -7]
  },
  bottomLeft: {
    points: ["tl", "bl"],
    overflow: autoAdjustOverflow$1,
    offset: [0, 7]
  },
  rightTop: {
    points: ["tr", "tl"],
    overflow: autoAdjustOverflow$1,
    offset: [-4, 0]
  },
  leftTop: {
    points: ["tl", "tr"],
    overflow: autoAdjustOverflow$1,
    offset: [4, 0]
  }
};
function getMotion(mode, motion, defaultMotions) {
  if (motion) {
    return motion;
  }
  if (defaultMotions) {
    return defaultMotions[mode] || defaultMotions.other;
  }
  return void 0;
}
var popupPlacementMap = {
  horizontal: "bottomLeft",
  vertical: "rightTop",
  "vertical-left": "rightTop",
  "vertical-right": "leftTop"
};
function PopupTrigger(_ref) {
  var prefixCls = _ref.prefixCls, visible = _ref.visible, children = _ref.children, popup = _ref.popup, popupClassName = _ref.popupClassName, popupOffset = _ref.popupOffset, disabled = _ref.disabled, mode = _ref.mode, onVisibleChange = _ref.onVisibleChange;
  var _React$useContext = react.exports.useContext(MenuContext$2), getPopupContainer = _React$useContext.getPopupContainer, rtl2 = _React$useContext.rtl, subMenuOpenDelay = _React$useContext.subMenuOpenDelay, subMenuCloseDelay = _React$useContext.subMenuCloseDelay, builtinPlacements = _React$useContext.builtinPlacements, triggerSubMenuAction = _React$useContext.triggerSubMenuAction, forceSubMenuRender = _React$useContext.forceSubMenuRender, rootClassName = _React$useContext.rootClassName, motion = _React$useContext.motion, defaultMotions = _React$useContext.defaultMotions;
  var _React$useState = react.exports.useState(false), _React$useState2 = _slicedToArray$4(_React$useState, 2), innerVisible = _React$useState2[0], setInnerVisible = _React$useState2[1];
  var placement = rtl2 ? _objectSpread2$1(_objectSpread2$1({}, placementsRtl), builtinPlacements) : _objectSpread2$1(_objectSpread2$1({}, placements$1), builtinPlacements);
  var popupPlacement = popupPlacementMap[mode];
  var targetMotion = getMotion(mode, motion, defaultMotions);
  var mergedMotion = _objectSpread2$1(_objectSpread2$1({}, targetMotion), {}, {
    leavedClassName: "".concat(prefixCls, "-hidden"),
    removeOnLeave: false,
    motionAppear: true
  });
  var visibleRef = react.exports.useRef();
  react.exports.useEffect(function() {
    visibleRef.current = wrapperRaf$1(function() {
      setInnerVisible(visible);
    });
    return function() {
      wrapperRaf$1.cancel(visibleRef.current);
    };
  }, [visible]);
  return /* @__PURE__ */ react.exports.createElement(Trigger, {
    prefixCls,
    popupClassName: classNames("".concat(prefixCls, "-popup"), _defineProperty$4({}, "".concat(prefixCls, "-rtl"), rtl2), popupClassName, rootClassName),
    stretch: mode === "horizontal" ? "minWidth" : null,
    getPopupContainer,
    builtinPlacements: placement,
    popupPlacement,
    popupVisible: innerVisible,
    popup,
    popupAlign: popupOffset && {
      offset: popupOffset
    },
    action: disabled ? [] : [triggerSubMenuAction],
    mouseEnterDelay: subMenuOpenDelay,
    mouseLeaveDelay: subMenuCloseDelay,
    onPopupVisibleChange: onVisibleChange,
    forceRender: forceSubMenuRender,
    popupMotion: mergedMotion
  }, children);
}
function InlineSubMenuList(_ref) {
  var id2 = _ref.id, open = _ref.open, keyPath = _ref.keyPath, children = _ref.children;
  var fixedMode = "inline";
  var _React$useContext = react.exports.useContext(MenuContext$2), prefixCls = _React$useContext.prefixCls, forceSubMenuRender = _React$useContext.forceSubMenuRender, motion = _React$useContext.motion, defaultMotions = _React$useContext.defaultMotions, mode = _React$useContext.mode;
  var sameModeRef = react.exports.useRef(false);
  sameModeRef.current = mode === fixedMode;
  var _React$useState = react.exports.useState(!sameModeRef.current), _React$useState2 = _slicedToArray$4(_React$useState, 2), destroy3 = _React$useState2[0], setDestroy = _React$useState2[1];
  var mergedOpen = sameModeRef.current ? open : false;
  react.exports.useEffect(function() {
    if (sameModeRef.current) {
      setDestroy(false);
    }
  }, [mode]);
  var mergedMotion = _objectSpread2$1({}, getMotion(fixedMode, motion, defaultMotions));
  if (keyPath.length > 1) {
    mergedMotion.motionAppear = false;
  }
  var originOnVisibleChanged = mergedMotion.onVisibleChanged;
  mergedMotion.onVisibleChanged = function(newVisible) {
    if (!sameModeRef.current && !newVisible) {
      setDestroy(true);
    }
    return originOnVisibleChanged === null || originOnVisibleChanged === void 0 ? void 0 : originOnVisibleChanged(newVisible);
  };
  if (destroy3) {
    return null;
  }
  return /* @__PURE__ */ react.exports.createElement(InheritableContextProvider, {
    mode: fixedMode,
    locked: !sameModeRef.current
  }, /* @__PURE__ */ react.exports.createElement(CSSMotion, _extends$2({
    visible: mergedOpen
  }, mergedMotion, {
    forceRender: forceSubMenuRender,
    removeOnLeave: false,
    leavedClassName: "".concat(prefixCls, "-hidden")
  }), function(_ref2) {
    var motionClassName = _ref2.className, motionStyle = _ref2.style;
    return /* @__PURE__ */ react.exports.createElement(SubMenuList, {
      id: id2,
      className: motionClassName,
      style: motionStyle
    }, children);
  }));
}
var _excluded$h = ["style", "className", "title", "eventKey", "warnKey", "disabled", "internalPopupClose", "children", "itemIcon", "expandIcon", "popupClassName", "popupOffset", "onClick", "onMouseEnter", "onMouseLeave", "onTitleClick", "onTitleMouseEnter", "onTitleMouseLeave"], _excluded2$3 = ["active"];
var InternalSubMenu = function InternalSubMenu2(props) {
  var _classNames;
  var style2 = props.style, className = props.className, title = props.title, eventKey = props.eventKey;
  props.warnKey;
  var disabled = props.disabled, internalPopupClose = props.internalPopupClose, children = props.children, itemIcon = props.itemIcon, expandIcon = props.expandIcon, popupClassName = props.popupClassName, popupOffset = props.popupOffset, onClick = props.onClick, onMouseEnter = props.onMouseEnter, onMouseLeave = props.onMouseLeave, onTitleClick = props.onTitleClick, onTitleMouseEnter = props.onTitleMouseEnter, onTitleMouseLeave = props.onTitleMouseLeave, restProps = _objectWithoutProperties$1(props, _excluded$h);
  var domDataId = useMenuId(eventKey);
  var _React$useContext = react.exports.useContext(MenuContext$2), prefixCls = _React$useContext.prefixCls, mode = _React$useContext.mode, openKeys = _React$useContext.openKeys, contextDisabled = _React$useContext.disabled, overflowDisabled = _React$useContext.overflowDisabled, activeKey = _React$useContext.activeKey, selectedKeys = _React$useContext.selectedKeys, contextItemIcon = _React$useContext.itemIcon, contextExpandIcon = _React$useContext.expandIcon, onItemClick = _React$useContext.onItemClick, onOpenChange = _React$useContext.onOpenChange, onActive = _React$useContext.onActive;
  var _React$useContext2 = react.exports.useContext(PrivateContext), _internalRenderSubMenuItem = _React$useContext2._internalRenderSubMenuItem;
  var _React$useContext3 = react.exports.useContext(PathUserContext), isSubPathKey = _React$useContext3.isSubPathKey;
  var connectedPath = useFullPath();
  var subMenuPrefixCls = "".concat(prefixCls, "-submenu");
  var mergedDisabled = contextDisabled || disabled;
  var elementRef = react.exports.useRef();
  var popupRef = react.exports.useRef();
  var mergedItemIcon = itemIcon || contextItemIcon;
  var mergedExpandIcon = expandIcon || contextExpandIcon;
  var originOpen = openKeys.includes(eventKey);
  var open = !overflowDisabled && originOpen;
  var childrenSelected = isSubPathKey(selectedKeys, eventKey);
  var _useActive = useActive(eventKey, mergedDisabled, onTitleMouseEnter, onTitleMouseLeave), active = _useActive.active, activeProps = _objectWithoutProperties$1(_useActive, _excluded2$3);
  var _React$useState = react.exports.useState(false), _React$useState2 = _slicedToArray$4(_React$useState, 2), childrenActive = _React$useState2[0], setChildrenActive = _React$useState2[1];
  var triggerChildrenActive = function triggerChildrenActive2(newActive) {
    if (!mergedDisabled) {
      setChildrenActive(newActive);
    }
  };
  var onInternalMouseEnter = function onInternalMouseEnter2(domEvent) {
    triggerChildrenActive(true);
    onMouseEnter === null || onMouseEnter === void 0 ? void 0 : onMouseEnter({
      key: eventKey,
      domEvent
    });
  };
  var onInternalMouseLeave = function onInternalMouseLeave2(domEvent) {
    triggerChildrenActive(false);
    onMouseLeave === null || onMouseLeave === void 0 ? void 0 : onMouseLeave({
      key: eventKey,
      domEvent
    });
  };
  var mergedActive = react.exports.useMemo(function() {
    if (active) {
      return active;
    }
    if (mode !== "inline") {
      return childrenActive || isSubPathKey([activeKey], eventKey);
    }
    return false;
  }, [mode, active, activeKey, childrenActive, eventKey, isSubPathKey]);
  var directionStyle = useDirectionStyle(connectedPath.length);
  var onInternalTitleClick = function onInternalTitleClick2(e3) {
    if (mergedDisabled) {
      return;
    }
    onTitleClick === null || onTitleClick === void 0 ? void 0 : onTitleClick({
      key: eventKey,
      domEvent: e3
    });
    if (mode === "inline") {
      onOpenChange(eventKey, !originOpen);
    }
  };
  var onMergedItemClick = useMemoCallback(function(info) {
    onClick === null || onClick === void 0 ? void 0 : onClick(warnItemProp(info));
    onItemClick(info);
  });
  var onPopupVisibleChange = function onPopupVisibleChange2(newVisible) {
    if (mode !== "inline") {
      onOpenChange(eventKey, newVisible);
    }
  };
  var onInternalFocus = function onInternalFocus2() {
    onActive(eventKey);
  };
  var popupId = domDataId && "".concat(domDataId, "-popup");
  var titleNode = /* @__PURE__ */ react.exports.createElement("div", _extends$2({
    role: "menuitem",
    style: directionStyle,
    className: "".concat(subMenuPrefixCls, "-title"),
    tabIndex: mergedDisabled ? null : -1,
    ref: elementRef,
    title: typeof title === "string" ? title : null,
    "data-menu-id": overflowDisabled && domDataId ? null : domDataId,
    "aria-expanded": open,
    "aria-haspopup": true,
    "aria-controls": popupId,
    "aria-disabled": mergedDisabled,
    onClick: onInternalTitleClick,
    onFocus: onInternalFocus
  }, activeProps), title, /* @__PURE__ */ react.exports.createElement(Icon, {
    icon: mode !== "horizontal" ? mergedExpandIcon : null,
    props: _objectSpread2$1(_objectSpread2$1({}, props), {}, {
      isOpen: open,
      isSubMenu: true
    })
  }, /* @__PURE__ */ react.exports.createElement("i", {
    className: "".concat(subMenuPrefixCls, "-arrow")
  })));
  var triggerModeRef = react.exports.useRef(mode);
  if (mode !== "inline") {
    triggerModeRef.current = connectedPath.length > 1 ? "vertical" : mode;
  }
  if (!overflowDisabled) {
    var triggerMode = triggerModeRef.current;
    titleNode = /* @__PURE__ */ react.exports.createElement(PopupTrigger, {
      mode: triggerMode,
      prefixCls: subMenuPrefixCls,
      visible: !internalPopupClose && open && mode !== "inline",
      popupClassName,
      popupOffset,
      popup: /* @__PURE__ */ react.exports.createElement(
        InheritableContextProvider,
        {
          mode: triggerMode === "horizontal" ? "vertical" : triggerMode
        },
        /* @__PURE__ */ react.exports.createElement(SubMenuList, {
          id: popupId,
          ref: popupRef
        }, children)
      ),
      disabled: mergedDisabled,
      onVisibleChange: onPopupVisibleChange
    }, titleNode);
  }
  var listNode = /* @__PURE__ */ react.exports.createElement(ForwardOverflow.Item, _extends$2({
    role: "none"
  }, restProps, {
    component: "li",
    style: style2,
    className: classNames(subMenuPrefixCls, "".concat(subMenuPrefixCls, "-").concat(mode), className, (_classNames = {}, _defineProperty$4(_classNames, "".concat(subMenuPrefixCls, "-open"), open), _defineProperty$4(_classNames, "".concat(subMenuPrefixCls, "-active"), mergedActive), _defineProperty$4(_classNames, "".concat(subMenuPrefixCls, "-selected"), childrenSelected), _defineProperty$4(_classNames, "".concat(subMenuPrefixCls, "-disabled"), mergedDisabled), _classNames)),
    onMouseEnter: onInternalMouseEnter,
    onMouseLeave: onInternalMouseLeave
  }), titleNode, !overflowDisabled && /* @__PURE__ */ react.exports.createElement(InlineSubMenuList, {
    id: popupId,
    open,
    keyPath: connectedPath
  }, children));
  if (_internalRenderSubMenuItem) {
    listNode = _internalRenderSubMenuItem(listNode, props, {
      selected: childrenSelected,
      active: mergedActive,
      open,
      disabled: mergedDisabled
    });
  }
  return /* @__PURE__ */ react.exports.createElement(InheritableContextProvider, {
    onItemClick: onMergedItemClick,
    mode: mode === "horizontal" ? "vertical" : mode,
    itemIcon: mergedItemIcon,
    expandIcon: mergedExpandIcon
  }, listNode);
};
function SubMenu$1(props) {
  var eventKey = props.eventKey, children = props.children;
  var connectedKeyPath = useFullPath(eventKey);
  var childList = parseChildren(children, connectedKeyPath);
  var measure = useMeasure();
  react.exports.useEffect(function() {
    if (measure) {
      measure.registerPath(eventKey, connectedKeyPath);
      return function() {
        measure.unregisterPath(eventKey, connectedKeyPath);
      };
    }
  }, [connectedKeyPath]);
  var renderNode;
  if (measure) {
    renderNode = childList;
  } else {
    renderNode = /* @__PURE__ */ react.exports.createElement(InternalSubMenu, props, childList);
  }
  return /* @__PURE__ */ react.exports.createElement(PathTrackerContext.Provider, {
    value: connectedKeyPath
  }, renderNode);
}
function focusable(node) {
  var includePositive = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  if (isVisible(node)) {
    var nodeName = node.nodeName.toLowerCase();
    var isFocusableElement = ["input", "select", "textarea", "button"].includes(nodeName) || node.isContentEditable || nodeName === "a" && !!node.getAttribute("href");
    var tabIndexAttr = node.getAttribute("tabindex");
    var tabIndexNum = Number(tabIndexAttr);
    var tabIndex = null;
    if (tabIndexAttr && !Number.isNaN(tabIndexNum)) {
      tabIndex = tabIndexNum;
    } else if (isFocusableElement && tabIndex === null) {
      tabIndex = 0;
    }
    if (isFocusableElement && node.disabled) {
      tabIndex = null;
    }
    return tabIndex !== null && (tabIndex >= 0 || includePositive && tabIndex < 0);
  }
  return false;
}
function getFocusNodeList(node) {
  var includePositive = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  var res = _toConsumableArray(node.querySelectorAll("*")).filter(function(child) {
    return focusable(child, includePositive);
  });
  if (focusable(node, includePositive)) {
    res.unshift(node);
  }
  return res;
}
var LEFT = KeyCode.LEFT, RIGHT = KeyCode.RIGHT, UP = KeyCode.UP, DOWN = KeyCode.DOWN, ENTER = KeyCode.ENTER, ESC$1 = KeyCode.ESC, HOME = KeyCode.HOME, END = KeyCode.END;
var ArrowKeys = [UP, DOWN, LEFT, RIGHT];
function getOffset$1(mode, isRootLevel, isRtl, which) {
  var _inline, _horizontal, _vertical, _offsets;
  var prev = "prev";
  var next = "next";
  var children = "children";
  var parent = "parent";
  if (mode === "inline" && which === ENTER) {
    return {
      inlineTrigger: true
    };
  }
  var inline = (_inline = {}, _defineProperty$4(_inline, UP, prev), _defineProperty$4(_inline, DOWN, next), _inline);
  var horizontal = (_horizontal = {}, _defineProperty$4(_horizontal, LEFT, isRtl ? next : prev), _defineProperty$4(_horizontal, RIGHT, isRtl ? prev : next), _defineProperty$4(_horizontal, DOWN, children), _defineProperty$4(_horizontal, ENTER, children), _horizontal);
  var vertical = (_vertical = {}, _defineProperty$4(_vertical, UP, prev), _defineProperty$4(_vertical, DOWN, next), _defineProperty$4(_vertical, ENTER, children), _defineProperty$4(_vertical, ESC$1, parent), _defineProperty$4(_vertical, LEFT, isRtl ? children : parent), _defineProperty$4(_vertical, RIGHT, isRtl ? parent : children), _vertical);
  var offsets = {
    inline,
    horizontal,
    vertical,
    inlineSub: inline,
    horizontalSub: vertical,
    verticalSub: vertical
  };
  var type4 = (_offsets = offsets["".concat(mode).concat(isRootLevel ? "" : "Sub")]) === null || _offsets === void 0 ? void 0 : _offsets[which];
  switch (type4) {
    case prev:
      return {
        offset: -1,
        sibling: true
      };
    case next:
      return {
        offset: 1,
        sibling: true
      };
    case parent:
      return {
        offset: -1,
        sibling: false
      };
    case children:
      return {
        offset: 1,
        sibling: false
      };
    default:
      return null;
  }
}
function findContainerUL(element) {
  var current = element;
  while (current) {
    if (current.getAttribute("data-menu-list")) {
      return current;
    }
    current = current.parentElement;
  }
  return null;
}
function getFocusElement(activeElement, elements) {
  var current = activeElement || document.activeElement;
  while (current) {
    if (elements.has(current)) {
      return current;
    }
    current = current.parentElement;
  }
  return null;
}
function getFocusableElements(container, elements) {
  var list = getFocusNodeList(container, true);
  return list.filter(function(ele) {
    return elements.has(ele);
  });
}
function getNextFocusElement(parentQueryContainer, elements, focusMenuElement) {
  var offset3 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1;
  if (!parentQueryContainer) {
    return null;
  }
  var sameLevelFocusableMenuElementList = getFocusableElements(parentQueryContainer, elements);
  var count2 = sameLevelFocusableMenuElementList.length;
  var focusIndex = sameLevelFocusableMenuElementList.findIndex(function(ele) {
    return focusMenuElement === ele;
  });
  if (offset3 < 0) {
    if (focusIndex === -1) {
      focusIndex = count2 - 1;
    } else {
      focusIndex -= 1;
    }
  } else if (offset3 > 0) {
    focusIndex += 1;
  }
  focusIndex = (focusIndex + count2) % count2;
  return sameLevelFocusableMenuElementList[focusIndex];
}
function useAccessibility$1(mode, activeKey, isRtl, id2, containerRef, getKeys, getKeyPath, triggerActiveKey, triggerAccessibilityOpen, originOnKeyDown) {
  var rafRef = react.exports.useRef();
  var activeRef = react.exports.useRef();
  activeRef.current = activeKey;
  var cleanRaf = function cleanRaf2() {
    wrapperRaf$1.cancel(rafRef.current);
  };
  react.exports.useEffect(function() {
    return function() {
      cleanRaf();
    };
  }, []);
  return function(e3) {
    var which = e3.which;
    if ([].concat(ArrowKeys, [ENTER, ESC$1, HOME, END]).includes(which)) {
      var elements;
      var key2element;
      var element2key;
      var refreshElements = function refreshElements2() {
        elements = /* @__PURE__ */ new Set();
        key2element = /* @__PURE__ */ new Map();
        element2key = /* @__PURE__ */ new Map();
        var keys2 = getKeys();
        keys2.forEach(function(key2) {
          var element = document.querySelector("[data-menu-id='".concat(getMenuId(id2, key2), "']"));
          if (element) {
            elements.add(element);
            element2key.set(element, key2);
            key2element.set(key2, element);
          }
        });
        return elements;
      };
      refreshElements();
      var activeElement = key2element.get(activeKey);
      var focusMenuElement = getFocusElement(activeElement, elements);
      var focusMenuKey = element2key.get(focusMenuElement);
      var offsetObj = getOffset$1(mode, getKeyPath(focusMenuKey, true).length === 1, isRtl, which);
      if (!offsetObj && which !== HOME && which !== END) {
        return;
      }
      if (ArrowKeys.includes(which) || [HOME, END].includes(which)) {
        e3.preventDefault();
      }
      var tryFocus = function tryFocus2(menuElement) {
        if (menuElement) {
          var focusTargetElement = menuElement;
          var link = menuElement.querySelector("a");
          if (link === null || link === void 0 ? void 0 : link.getAttribute("href")) {
            focusTargetElement = link;
          }
          var targetKey = element2key.get(menuElement);
          triggerActiveKey(targetKey);
          cleanRaf();
          rafRef.current = wrapperRaf$1(function() {
            if (activeRef.current === targetKey) {
              focusTargetElement.focus();
            }
          });
        }
      };
      if ([HOME, END].includes(which) || offsetObj.sibling || !focusMenuElement) {
        var parentQueryContainer;
        if (!focusMenuElement || mode === "inline") {
          parentQueryContainer = containerRef.current;
        } else {
          parentQueryContainer = findContainerUL(focusMenuElement);
        }
        var targetElement;
        var focusableElements = getFocusableElements(parentQueryContainer, elements);
        if (which === HOME) {
          targetElement = focusableElements[0];
        } else if (which === END) {
          targetElement = focusableElements[focusableElements.length - 1];
        } else {
          targetElement = getNextFocusElement(parentQueryContainer, elements, focusMenuElement, offsetObj.offset);
        }
        tryFocus(targetElement);
      } else if (offsetObj.inlineTrigger) {
        triggerAccessibilityOpen(focusMenuKey);
      } else if (offsetObj.offset > 0) {
        triggerAccessibilityOpen(focusMenuKey, true);
        cleanRaf();
        rafRef.current = wrapperRaf$1(function() {
          refreshElements();
          var controlId = focusMenuElement.getAttribute("aria-controls");
          var subQueryContainer = document.getElementById(controlId);
          var targetElement2 = getNextFocusElement(subQueryContainer, elements);
          tryFocus(targetElement2);
        }, 5);
      } else if (offsetObj.offset < 0) {
        var keyPath = getKeyPath(focusMenuKey, true);
        var parentKey = keyPath[keyPath.length - 2];
        var parentMenuElement = key2element.get(parentKey);
        triggerAccessibilityOpen(parentKey, false);
        tryFocus(parentMenuElement);
      }
    }
    originOnKeyDown === null || originOnKeyDown === void 0 ? void 0 : originOnKeyDown(e3);
  };
}
var uniquePrefix = Math.random().toFixed(5).toString().slice(2);
var internalId = 0;
function useUUID(id2) {
  var _useMergedState = useMergedState(id2, {
    value: id2
  }), _useMergedState2 = _slicedToArray$4(_useMergedState, 2), uuid2 = _useMergedState2[0], setUUID = _useMergedState2[1];
  react.exports.useEffect(function() {
    internalId += 1;
    var newId = "".concat(uniquePrefix, "-").concat(internalId);
    setUUID("rc-menu-uuid-".concat(newId));
  }, []);
  return uuid2;
}
function nextSlice(callback) {
  Promise.resolve().then(callback);
}
var PATH_SPLIT = "__RC_UTIL_PATH_SPLIT__";
var getPathStr = function getPathStr2(keyPath) {
  return keyPath.join(PATH_SPLIT);
};
var getPathKeys = function getPathKeys2(keyPathStr) {
  return keyPathStr.split(PATH_SPLIT);
};
var OVERFLOW_KEY = "rc-menu-more";
function useKeyRecords() {
  var _React$useState = react.exports.useState({}), _React$useState2 = _slicedToArray$4(_React$useState, 2), internalForceUpdate = _React$useState2[1];
  var key2pathRef = react.exports.useRef(/* @__PURE__ */ new Map());
  var path2keyRef = react.exports.useRef(/* @__PURE__ */ new Map());
  var _React$useState3 = react.exports.useState([]), _React$useState4 = _slicedToArray$4(_React$useState3, 2), overflowKeys = _React$useState4[0], setOverflowKeys = _React$useState4[1];
  var updateRef = react.exports.useRef(0);
  var destroyRef = react.exports.useRef(false);
  var forceUpdate = function forceUpdate2() {
    if (!destroyRef.current) {
      internalForceUpdate({});
    }
  };
  var registerPath = react.exports.useCallback(function(key2, keyPath) {
    var connectedPath = getPathStr(keyPath);
    path2keyRef.current.set(connectedPath, key2);
    key2pathRef.current.set(key2, connectedPath);
    updateRef.current += 1;
    var id2 = updateRef.current;
    nextSlice(function() {
      if (id2 === updateRef.current) {
        forceUpdate();
      }
    });
  }, []);
  var unregisterPath = react.exports.useCallback(function(key2, keyPath) {
    var connectedPath = getPathStr(keyPath);
    path2keyRef.current.delete(connectedPath);
    key2pathRef.current.delete(key2);
  }, []);
  var refreshOverflowKeys = react.exports.useCallback(function(keys2) {
    setOverflowKeys(keys2);
  }, []);
  var getKeyPath = react.exports.useCallback(function(eventKey, includeOverflow) {
    var fullPath = key2pathRef.current.get(eventKey) || "";
    var keys2 = getPathKeys(fullPath);
    if (includeOverflow && overflowKeys.includes(keys2[0])) {
      keys2.unshift(OVERFLOW_KEY);
    }
    return keys2;
  }, [overflowKeys]);
  var isSubPathKey = react.exports.useCallback(function(pathKeys, eventKey) {
    return pathKeys.some(function(pathKey) {
      var pathKeyList = getKeyPath(pathKey, true);
      return pathKeyList.includes(eventKey);
    });
  }, [getKeyPath]);
  var getKeys = function getKeys2() {
    var keys2 = _toConsumableArray(key2pathRef.current.keys());
    if (overflowKeys.length) {
      keys2.push(OVERFLOW_KEY);
    }
    return keys2;
  };
  var getSubPathKeys = react.exports.useCallback(function(key2) {
    var connectedPath = "".concat(key2pathRef.current.get(key2)).concat(PATH_SPLIT);
    var pathKeys = /* @__PURE__ */ new Set();
    _toConsumableArray(path2keyRef.current.keys()).forEach(function(pathKey) {
      if (pathKey.startsWith(connectedPath)) {
        pathKeys.add(path2keyRef.current.get(pathKey));
      }
    });
    return pathKeys;
  }, []);
  react.exports.useEffect(function() {
    return function() {
      destroyRef.current = true;
    };
  }, []);
  return {
    registerPath,
    unregisterPath,
    refreshOverflowKeys,
    isSubPathKey,
    getKeyPath,
    getKeys,
    getSubPathKeys
  };
}
var _excluded$g = ["prefixCls", "rootClassName", "style", "className", "tabIndex", "items", "children", "direction", "id", "mode", "inlineCollapsed", "disabled", "disabledOverflow", "subMenuOpenDelay", "subMenuCloseDelay", "forceSubMenuRender", "defaultOpenKeys", "openKeys", "activeKey", "defaultActiveFirst", "selectable", "multiple", "defaultSelectedKeys", "selectedKeys", "onSelect", "onDeselect", "inlineIndent", "motion", "defaultMotions", "triggerSubMenuAction", "builtinPlacements", "itemIcon", "expandIcon", "overflowedIndicator", "overflowedIndicatorPopupClassName", "getPopupContainer", "onClick", "onOpenChange", "onKeyDown", "openAnimation", "openTransitionName", "_internalRenderMenuItem", "_internalRenderSubMenuItem"];
var EMPTY_LIST$2 = [];
var Menu$2 = /* @__PURE__ */ react.exports.forwardRef(function(props, ref) {
  var _childList$, _classNames;
  var _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-menu" : _props$prefixCls, rootClassName = props.rootClassName, style2 = props.style, className = props.className, _props$tabIndex = props.tabIndex, tabIndex = _props$tabIndex === void 0 ? 0 : _props$tabIndex, items = props.items, children = props.children, direction2 = props.direction, id2 = props.id, _props$mode = props.mode, mode = _props$mode === void 0 ? "vertical" : _props$mode, inlineCollapsed = props.inlineCollapsed, disabled = props.disabled, disabledOverflow = props.disabledOverflow, _props$subMenuOpenDel = props.subMenuOpenDelay, subMenuOpenDelay = _props$subMenuOpenDel === void 0 ? 0.1 : _props$subMenuOpenDel, _props$subMenuCloseDe = props.subMenuCloseDelay, subMenuCloseDelay = _props$subMenuCloseDe === void 0 ? 0.1 : _props$subMenuCloseDe, forceSubMenuRender = props.forceSubMenuRender, defaultOpenKeys = props.defaultOpenKeys, openKeys = props.openKeys, activeKey = props.activeKey, defaultActiveFirst = props.defaultActiveFirst, _props$selectable = props.selectable, selectable = _props$selectable === void 0 ? true : _props$selectable, _props$multiple = props.multiple, multiple = _props$multiple === void 0 ? false : _props$multiple, defaultSelectedKeys = props.defaultSelectedKeys, selectedKeys = props.selectedKeys, onSelect = props.onSelect, onDeselect = props.onDeselect, _props$inlineIndent = props.inlineIndent, inlineIndent = _props$inlineIndent === void 0 ? 24 : _props$inlineIndent, motion = props.motion, defaultMotions = props.defaultMotions, _props$triggerSubMenu = props.triggerSubMenuAction, triggerSubMenuAction = _props$triggerSubMenu === void 0 ? "hover" : _props$triggerSubMenu, builtinPlacements = props.builtinPlacements, itemIcon = props.itemIcon, expandIcon = props.expandIcon, _props$overflowedIndi = props.overflowedIndicator, overflowedIndicator = _props$overflowedIndi === void 0 ? "..." : _props$overflowedIndi, overflowedIndicatorPopupClassName = props.overflowedIndicatorPopupClassName, getPopupContainer = props.getPopupContainer, onClick = props.onClick, onOpenChange = props.onOpenChange, onKeyDown2 = props.onKeyDown;
  props.openAnimation;
  props.openTransitionName;
  var _internalRenderMenuItem = props._internalRenderMenuItem, _internalRenderSubMenuItem = props._internalRenderSubMenuItem, restProps = _objectWithoutProperties$1(props, _excluded$g);
  var childList = react.exports.useMemo(function() {
    return parseItems(children, items, EMPTY_LIST$2);
  }, [children, items]);
  var _React$useState = react.exports.useState(false), _React$useState2 = _slicedToArray$4(_React$useState, 2), mounted = _React$useState2[0], setMounted = _React$useState2[1];
  var containerRef = react.exports.useRef();
  var uuid2 = useUUID(id2);
  var isRtl = direction2 === "rtl";
  var _React$useMemo = react.exports.useMemo(function() {
    if ((mode === "inline" || mode === "vertical") && inlineCollapsed) {
      return ["vertical", inlineCollapsed];
    }
    return [mode, false];
  }, [mode, inlineCollapsed]), _React$useMemo2 = _slicedToArray$4(_React$useMemo, 2), mergedMode = _React$useMemo2[0], mergedInlineCollapsed = _React$useMemo2[1];
  var _React$useState3 = react.exports.useState(0), _React$useState4 = _slicedToArray$4(_React$useState3, 2), lastVisibleIndex = _React$useState4[0], setLastVisibleIndex = _React$useState4[1];
  var allVisible = lastVisibleIndex >= childList.length - 1 || mergedMode !== "horizontal" || disabledOverflow;
  var _useMergedState = useMergedState(defaultOpenKeys, {
    value: openKeys,
    postState: function postState(keys2) {
      return keys2 || EMPTY_LIST$2;
    }
  }), _useMergedState2 = _slicedToArray$4(_useMergedState, 2), mergedOpenKeys = _useMergedState2[0], setMergedOpenKeys = _useMergedState2[1];
  var triggerOpenKeys = function triggerOpenKeys2(keys2) {
    setMergedOpenKeys(keys2);
    onOpenChange === null || onOpenChange === void 0 ? void 0 : onOpenChange(keys2);
  };
  var _React$useState5 = react.exports.useState(mergedOpenKeys), _React$useState6 = _slicedToArray$4(_React$useState5, 2), inlineCacheOpenKeys = _React$useState6[0], setInlineCacheOpenKeys = _React$useState6[1];
  var isInlineMode = mergedMode === "inline";
  var mountRef = react.exports.useRef(false);
  react.exports.useEffect(function() {
    if (isInlineMode) {
      setInlineCacheOpenKeys(mergedOpenKeys);
    }
  }, [mergedOpenKeys]);
  react.exports.useEffect(function() {
    if (!mountRef.current) {
      return;
    }
    if (isInlineMode) {
      setMergedOpenKeys(inlineCacheOpenKeys);
    } else {
      triggerOpenKeys(EMPTY_LIST$2);
    }
  }, [isInlineMode]);
  react.exports.useEffect(function() {
    mountRef.current = true;
    return function() {
      mountRef.current = false;
    };
  }, []);
  var _useKeyRecords = useKeyRecords(), registerPath = _useKeyRecords.registerPath, unregisterPath = _useKeyRecords.unregisterPath, refreshOverflowKeys = _useKeyRecords.refreshOverflowKeys, isSubPathKey = _useKeyRecords.isSubPathKey, getKeyPath = _useKeyRecords.getKeyPath, getKeys = _useKeyRecords.getKeys, getSubPathKeys = _useKeyRecords.getSubPathKeys;
  var registerPathContext = react.exports.useMemo(function() {
    return {
      registerPath,
      unregisterPath
    };
  }, [registerPath, unregisterPath]);
  var pathUserContext = react.exports.useMemo(function() {
    return {
      isSubPathKey
    };
  }, [isSubPathKey]);
  react.exports.useEffect(function() {
    refreshOverflowKeys(allVisible ? EMPTY_LIST$2 : childList.slice(lastVisibleIndex + 1).map(function(child) {
      return child.key;
    }));
  }, [lastVisibleIndex, allVisible]);
  var _useMergedState3 = useMergedState(activeKey || defaultActiveFirst && ((_childList$ = childList[0]) === null || _childList$ === void 0 ? void 0 : _childList$.key), {
    value: activeKey
  }), _useMergedState4 = _slicedToArray$4(_useMergedState3, 2), mergedActiveKey = _useMergedState4[0], setMergedActiveKey = _useMergedState4[1];
  var onActive = useMemoCallback(function(key2) {
    setMergedActiveKey(key2);
  });
  var onInactive = useMemoCallback(function() {
    setMergedActiveKey(void 0);
  });
  react.exports.useImperativeHandle(ref, function() {
    return {
      list: containerRef.current,
      focus: function focus(options) {
        var _childList$find;
        var shouldFocusKey = mergedActiveKey !== null && mergedActiveKey !== void 0 ? mergedActiveKey : (_childList$find = childList.find(function(node) {
          return !node.props.disabled;
        })) === null || _childList$find === void 0 ? void 0 : _childList$find.key;
        if (shouldFocusKey) {
          var _containerRef$current, _containerRef$current2, _containerRef$current3;
          (_containerRef$current = containerRef.current) === null || _containerRef$current === void 0 ? void 0 : (_containerRef$current2 = _containerRef$current.querySelector("li[data-menu-id='".concat(getMenuId(uuid2, shouldFocusKey), "']"))) === null || _containerRef$current2 === void 0 ? void 0 : (_containerRef$current3 = _containerRef$current2.focus) === null || _containerRef$current3 === void 0 ? void 0 : _containerRef$current3.call(_containerRef$current2, options);
        }
      }
    };
  });
  var _useMergedState5 = useMergedState(defaultSelectedKeys || [], {
    value: selectedKeys,
    postState: function postState(keys2) {
      if (Array.isArray(keys2)) {
        return keys2;
      }
      if (keys2 === null || keys2 === void 0) {
        return EMPTY_LIST$2;
      }
      return [keys2];
    }
  }), _useMergedState6 = _slicedToArray$4(_useMergedState5, 2), mergedSelectKeys = _useMergedState6[0], setMergedSelectKeys = _useMergedState6[1];
  var triggerSelection = function triggerSelection2(info) {
    if (selectable) {
      var targetKey = info.key;
      var exist = mergedSelectKeys.includes(targetKey);
      var newSelectKeys;
      if (multiple) {
        if (exist) {
          newSelectKeys = mergedSelectKeys.filter(function(key2) {
            return key2 !== targetKey;
          });
        } else {
          newSelectKeys = [].concat(_toConsumableArray(mergedSelectKeys), [targetKey]);
        }
      } else {
        newSelectKeys = [targetKey];
      }
      setMergedSelectKeys(newSelectKeys);
      var selectInfo = _objectSpread2$1(_objectSpread2$1({}, info), {}, {
        selectedKeys: newSelectKeys
      });
      if (exist) {
        onDeselect === null || onDeselect === void 0 ? void 0 : onDeselect(selectInfo);
      } else {
        onSelect === null || onSelect === void 0 ? void 0 : onSelect(selectInfo);
      }
    }
    if (!multiple && mergedOpenKeys.length && mergedMode !== "inline") {
      triggerOpenKeys(EMPTY_LIST$2);
    }
  };
  var onInternalClick = useMemoCallback(function(info) {
    onClick === null || onClick === void 0 ? void 0 : onClick(warnItemProp(info));
    triggerSelection(info);
  });
  var onInternalOpenChange = useMemoCallback(function(key2, open) {
    var newOpenKeys = mergedOpenKeys.filter(function(k2) {
      return k2 !== key2;
    });
    if (open) {
      newOpenKeys.push(key2);
    } else if (mergedMode !== "inline") {
      var subPathKeys = getSubPathKeys(key2);
      newOpenKeys = newOpenKeys.filter(function(k2) {
        return !subPathKeys.has(k2);
      });
    }
    if (!shallowequal(mergedOpenKeys, newOpenKeys)) {
      triggerOpenKeys(newOpenKeys);
    }
  });
  var getInternalPopupContainer = useMemoCallback(getPopupContainer);
  var triggerAccessibilityOpen = function triggerAccessibilityOpen2(key2, open) {
    var nextOpen = open !== null && open !== void 0 ? open : !mergedOpenKeys.includes(key2);
    onInternalOpenChange(key2, nextOpen);
  };
  var onInternalKeyDown = useAccessibility$1(mergedMode, mergedActiveKey, isRtl, uuid2, containerRef, getKeys, getKeyPath, setMergedActiveKey, triggerAccessibilityOpen, onKeyDown2);
  react.exports.useEffect(function() {
    setMounted(true);
  }, []);
  var privateContext = react.exports.useMemo(function() {
    return {
      _internalRenderMenuItem,
      _internalRenderSubMenuItem
    };
  }, [_internalRenderMenuItem, _internalRenderSubMenuItem]);
  var wrappedChildList = mergedMode !== "horizontal" || disabledOverflow ? childList : childList.map(function(child, index2) {
    return /* @__PURE__ */ react.exports.createElement(InheritableContextProvider, {
      key: child.key,
      overflowDisabled: index2 > lastVisibleIndex
    }, child);
  });
  var container = /* @__PURE__ */ react.exports.createElement(ForwardOverflow, _extends$2({
    id: id2,
    ref: containerRef,
    prefixCls: "".concat(prefixCls, "-overflow"),
    component: "ul",
    itemComponent: MenuItem$1,
    className: classNames(prefixCls, "".concat(prefixCls, "-root"), "".concat(prefixCls, "-").concat(mergedMode), className, (_classNames = {}, _defineProperty$4(_classNames, "".concat(prefixCls, "-inline-collapsed"), mergedInlineCollapsed), _defineProperty$4(_classNames, "".concat(prefixCls, "-rtl"), isRtl), _classNames), rootClassName),
    dir: direction2,
    style: style2,
    role: "menu",
    tabIndex,
    data: wrappedChildList,
    renderRawItem: function renderRawItem(node) {
      return node;
    },
    renderRawRest: function renderRawRest(omitItems) {
      var len = omitItems.length;
      var originOmitItems = len ? childList.slice(-len) : null;
      return /* @__PURE__ */ react.exports.createElement(SubMenu$1, {
        eventKey: OVERFLOW_KEY,
        title: overflowedIndicator,
        disabled: allVisible,
        internalPopupClose: len === 0,
        popupClassName: overflowedIndicatorPopupClassName
      }, originOmitItems);
    },
    maxCount: mergedMode !== "horizontal" || disabledOverflow ? ForwardOverflow.INVALIDATE : ForwardOverflow.RESPONSIVE,
    ssr: "full",
    "data-menu-list": true,
    onVisibleChange: function onVisibleChange(newLastIndex) {
      setLastVisibleIndex(newLastIndex);
    },
    onKeyDown: onInternalKeyDown
  }, restProps));
  return /* @__PURE__ */ react.exports.createElement(PrivateContext.Provider, {
    value: privateContext
  }, /* @__PURE__ */ react.exports.createElement(IdContext.Provider, {
    value: uuid2
  }, /* @__PURE__ */ react.exports.createElement(InheritableContextProvider, {
    prefixCls,
    rootClassName,
    mode: mergedMode,
    openKeys: mergedOpenKeys,
    rtl: isRtl,
    disabled,
    motion: mounted ? motion : null,
    defaultMotions: mounted ? defaultMotions : null,
    activeKey: mergedActiveKey,
    onActive,
    onInactive,
    selectedKeys: mergedSelectKeys,
    inlineIndent,
    subMenuOpenDelay,
    subMenuCloseDelay,
    forceSubMenuRender,
    builtinPlacements,
    triggerSubMenuAction,
    getPopupContainer: getInternalPopupContainer,
    itemIcon,
    expandIcon,
    onItemClick: onInternalClick,
    onOpenChange: onInternalOpenChange
  }, /* @__PURE__ */ react.exports.createElement(PathUserContext.Provider, {
    value: pathUserContext
  }, container), /* @__PURE__ */ react.exports.createElement("div", {
    style: {
      display: "none"
    },
    "aria-hidden": true
  }, /* @__PURE__ */ react.exports.createElement(PathRegisterContext.Provider, {
    value: registerPathContext
  }, childList)))));
});
var _excluded$f = ["className", "title", "eventKey", "children"], _excluded2$2 = ["children"];
var InternalMenuItemGroup = function InternalMenuItemGroup2(_ref) {
  var className = _ref.className, title = _ref.title;
  _ref.eventKey;
  var children = _ref.children, restProps = _objectWithoutProperties$1(_ref, _excluded$f);
  var _React$useContext = react.exports.useContext(MenuContext$2), prefixCls = _React$useContext.prefixCls;
  var groupPrefixCls = "".concat(prefixCls, "-item-group");
  return /* @__PURE__ */ react.exports.createElement("li", _extends$2({}, restProps, {
    onClick: function onClick(e3) {
      return e3.stopPropagation();
    },
    className: classNames(groupPrefixCls, className)
  }), /* @__PURE__ */ react.exports.createElement("div", {
    className: "".concat(groupPrefixCls, "-title"),
    title: typeof title === "string" ? title : void 0
  }, title), /* @__PURE__ */ react.exports.createElement("ul", {
    className: "".concat(groupPrefixCls, "-list")
  }, children));
};
function MenuItemGroup(_ref2) {
  var children = _ref2.children, props = _objectWithoutProperties$1(_ref2, _excluded2$2);
  var connectedKeyPath = useFullPath(props.eventKey);
  var childList = parseChildren(children, connectedKeyPath);
  var measure = useMeasure();
  if (measure) {
    return childList;
  }
  return /* @__PURE__ */ react.exports.createElement(InternalMenuItemGroup, omit$2(props, ["warnKey"]), childList);
}
function Divider(_ref) {
  var className = _ref.className, style2 = _ref.style;
  var _React$useContext = react.exports.useContext(MenuContext$2), prefixCls = _React$useContext.prefixCls;
  var measure = useMeasure();
  if (measure) {
    return null;
  }
  return /* @__PURE__ */ react.exports.createElement("li", {
    className: classNames("".concat(prefixCls, "-item-divider"), className),
    style: style2
  });
}
var ExportMenu = Menu$2;
ExportMenu.Item = MenuItem$1;
ExportMenu.SubMenu = SubMenu$1;
ExportMenu.ItemGroup = MenuItemGroup;
ExportMenu.Divider = Divider;
var LeftOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M724 218.3V141c0-6.7-7.7-10.4-12.9-6.3L260.3 486.8a31.86 31.86 0 000 50.3l450.8 352.1c5.3 4.1 12.9.4 12.9-6.3v-77.3c0-4.9-2.3-9.6-6.1-12.6l-360-281 360-281.1c3.8-3 6.1-7.7 6.1-12.6z" } }] }, "name": "left", "theme": "outlined" };
var LeftOutlinedSvg = LeftOutlined$2;
var LeftOutlined = function LeftOutlined2(props, ref) {
  return /* @__PURE__ */ react.exports.createElement(AntdIcon, _objectSpread2$1(_objectSpread2$1({}, props), {}, {
    ref,
    icon: LeftOutlinedSvg
  }));
};
LeftOutlined.displayName = "LeftOutlined";
var LeftOutlined$1 = /* @__PURE__ */ react.exports.forwardRef(LeftOutlined);
var RightOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M765.7 486.8L314.9 134.7A7.97 7.97 0 00302 141v77.3c0 4.9 2.3 9.6 6.1 12.6l360 281.1-360 281.1c-3.9 3-6.1 7.7-6.1 12.6V883c0 6.7 7.7 10.4 12.9 6.3l450.8-352.1a31.96 31.96 0 000-50.4z" } }] }, "name": "right", "theme": "outlined" };
var RightOutlinedSvg = RightOutlined$2;
var RightOutlined = function RightOutlined2(props, ref) {
  return /* @__PURE__ */ react.exports.createElement(AntdIcon, _objectSpread2$1(_objectSpread2$1({}, props), {}, {
    ref,
    icon: RightOutlinedSvg
  }));
};
RightOutlined.displayName = "RightOutlined";
var RightOutlined$1 = /* @__PURE__ */ react.exports.forwardRef(RightOutlined);
globalThis && globalThis.__rest || function(s2, e3) {
  var t2 = {};
  for (var p2 in s2) {
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  }
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e3.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
var SiderContext = /* @__PURE__ */ react.exports.createContext({});
var __rest$t = globalThis && globalThis.__rest || function(s2, e3) {
  var t2 = {};
  for (var p2 in s2) {
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  }
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e3.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
var MenuDivider = function MenuDivider2(_a2) {
  var customizePrefixCls = _a2.prefixCls, className = _a2.className, dashed = _a2.dashed, restProps = __rest$t(_a2, ["prefixCls", "className", "dashed"]);
  var _React$useContext = react.exports.useContext(ConfigContext), getPrefixCls = _React$useContext.getPrefixCls;
  var prefixCls = getPrefixCls("menu", customizePrefixCls);
  var classString = classNames(_defineProperty$4({}, "".concat(prefixCls, "-item-divider-dashed"), !!dashed), className);
  return /* @__PURE__ */ react.exports.createElement(Divider, _extends$2({
    className: classString
  }, restProps));
};
var MenuDivider$1 = MenuDivider;
var MenuContext = /* @__PURE__ */ react.exports.createContext({
  prefixCls: "",
  firstLevel: true,
  inlineCollapsed: false
});
var MenuContext$1 = MenuContext;
var __rest$s = globalThis && globalThis.__rest || function(s2, e3) {
  var t2 = {};
  for (var p2 in s2) {
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  }
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e3.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
var MenuItem = /* @__PURE__ */ function(_React$Component) {
  _inherits$1(MenuItem2, _React$Component);
  var _super = _createSuper$1(MenuItem2);
  function MenuItem2() {
    var _this;
    _classCallCheck$2(this, MenuItem2);
    _this = _super.apply(this, arguments);
    _this.renderItem = function(_ref) {
      var _classNames;
      var siderCollapsed = _ref.siderCollapsed;
      var _a2;
      var _this$context = _this.context, prefixCls = _this$context.prefixCls, firstLevel = _this$context.firstLevel, inlineCollapsed = _this$context.inlineCollapsed, direction2 = _this$context.direction, disableMenuItemTitleTooltip = _this$context.disableMenuItemTitleTooltip;
      var _this$props = _this.props, className = _this$props.className, children = _this$props.children;
      var _b = _this.props, title = _b.title, icon = _b.icon, danger = _b.danger, rest = __rest$s(_b, ["title", "icon", "danger"]);
      var tooltipTitle = title;
      if (typeof title === "undefined") {
        tooltipTitle = firstLevel ? children : "";
      } else if (title === false) {
        tooltipTitle = "";
      }
      var tooltipProps = {
        title: tooltipTitle
      };
      if (!siderCollapsed && !inlineCollapsed) {
        tooltipProps.title = null;
        tooltipProps.open = false;
      }
      var childrenLength = toArray$5(children).length;
      var returnNode = /* @__PURE__ */ react.exports.createElement(MenuItem$1, _extends$2({}, rest, {
        className: classNames((_classNames = {}, _defineProperty$4(_classNames, "".concat(prefixCls, "-item-danger"), danger), _defineProperty$4(_classNames, "".concat(prefixCls, "-item-only-child"), (icon ? childrenLength + 1 : childrenLength) === 1), _classNames), className),
        title: typeof title === "string" ? title : void 0
      }), cloneElement(icon, {
        className: classNames(isValidElement(icon) ? (_a2 = icon.props) === null || _a2 === void 0 ? void 0 : _a2.className : "", "".concat(prefixCls, "-item-icon"))
      }), _this.renderItemChildren(inlineCollapsed));
      if (!disableMenuItemTitleTooltip) {
        returnNode = /* @__PURE__ */ react.exports.createElement(Tooltip$3, _extends$2({}, tooltipProps, {
          placement: direction2 === "rtl" ? "left" : "right",
          overlayClassName: "".concat(prefixCls, "-inline-collapsed-tooltip")
        }), returnNode);
      }
      return returnNode;
    };
    return _this;
  }
  _createClass$2(MenuItem2, [{
    key: "renderItemChildren",
    value: function renderItemChildren(inlineCollapsed) {
      var _this$context2 = this.context, prefixCls = _this$context2.prefixCls, firstLevel = _this$context2.firstLevel;
      var _this$props2 = this.props, icon = _this$props2.icon, children = _this$props2.children;
      var wrapNode = /* @__PURE__ */ react.exports.createElement("span", {
        className: "".concat(prefixCls, "-title-content")
      }, children);
      if (!icon || isValidElement(children) && children.type === "span") {
        if (children && inlineCollapsed && firstLevel && typeof children === "string") {
          return /* @__PURE__ */ react.exports.createElement("div", {
            className: "".concat(prefixCls, "-inline-collapsed-noicon")
          }, children.charAt(0));
        }
      }
      return wrapNode;
    }
  }, {
    key: "render",
    value: function render2() {
      return /* @__PURE__ */ react.exports.createElement(SiderContext.Consumer, null, this.renderItem);
    }
  }]);
  return MenuItem2;
}(react.exports.Component);
MenuItem.contextType = MenuContext$1;
function SubMenu(props) {
  var _a2;
  var popupClassName = props.popupClassName, icon = props.icon, title = props.title, theme2 = props.theme;
  var context2 = react.exports.useContext(MenuContext$1);
  var prefixCls = context2.prefixCls, inlineCollapsed = context2.inlineCollapsed, antdMenuTheme = context2.antdMenuTheme;
  var parentPath = useFullPath();
  var titleNode;
  if (!icon) {
    titleNode = inlineCollapsed && !parentPath.length && title && typeof title === "string" ? /* @__PURE__ */ react.exports.createElement("div", {
      className: "".concat(prefixCls, "-inline-collapsed-noicon")
    }, title.charAt(0)) : /* @__PURE__ */ react.exports.createElement("span", {
      className: "".concat(prefixCls, "-title-content")
    }, title);
  } else {
    var titleIsSpan = isValidElement(title) && title.type === "span";
    titleNode = /* @__PURE__ */ react.exports.createElement(react.exports.Fragment, null, cloneElement(icon, {
      className: classNames(isValidElement(icon) ? (_a2 = icon.props) === null || _a2 === void 0 ? void 0 : _a2.className : "", "".concat(prefixCls, "-item-icon"))
    }), titleIsSpan ? title : /* @__PURE__ */ react.exports.createElement("span", {
      className: "".concat(prefixCls, "-title-content")
    }, title));
  }
  var contextValue = react.exports.useMemo(function() {
    return _extends$2(_extends$2({}, context2), {
      firstLevel: false
    });
  }, [context2]);
  return /* @__PURE__ */ react.exports.createElement(MenuContext$1.Provider, {
    value: contextValue
  }, /* @__PURE__ */ react.exports.createElement(SubMenu$1, _extends$2({}, omit$2(props, ["icon"]), {
    title: titleNode,
    popupClassName: classNames(prefixCls, "".concat(prefixCls, "-").concat(theme2 || antdMenuTheme), popupClassName)
  })));
}
var __rest$r = globalThis && globalThis.__rest || function(s2, e3) {
  var t2 = {};
  for (var p2 in s2) {
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  }
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e3.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
function convertItemsToNodes(list) {
  return (list || []).map(function(opt, index2) {
    if (opt && _typeof$4(opt) === "object") {
      var _a2 = opt, label2 = _a2.label, children = _a2.children, key2 = _a2.key, type4 = _a2.type, restProps = __rest$r(_a2, ["label", "children", "key", "type"]);
      var mergedKey = key2 !== null && key2 !== void 0 ? key2 : "tmp-".concat(index2);
      if (children || type4 === "group") {
        if (type4 === "group") {
          return /* @__PURE__ */ react.exports.createElement(MenuItemGroup, _extends$2({
            key: mergedKey
          }, restProps, {
            title: label2
          }), convertItemsToNodes(children));
        }
        return /* @__PURE__ */ react.exports.createElement(SubMenu, _extends$2({
          key: mergedKey
        }, restProps, {
          title: label2
        }), convertItemsToNodes(children));
      }
      if (type4 === "divider") {
        return /* @__PURE__ */ react.exports.createElement(MenuDivider$1, _extends$2({
          key: mergedKey
        }, restProps));
      }
      return /* @__PURE__ */ react.exports.createElement(MenuItem, _extends$2({
        key: mergedKey
      }, restProps), label2);
    }
    return null;
  }).filter(function(opt) {
    return opt;
  });
}
function useItems(items) {
  return react.exports.useMemo(function() {
    if (!items) {
      return items;
    }
    return convertItemsToNodes(items);
  }, [items]);
}
var __rest$q = globalThis && globalThis.__rest || function(s2, e3) {
  var t2 = {};
  for (var p2 in s2) {
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  }
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e3.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
var OverrideContext = /* @__PURE__ */ react.exports.createContext(null);
var OverrideProvider = function OverrideProvider2(_a2) {
  var children = _a2.children, restProps = __rest$q(_a2, ["children"]);
  var override = react.exports.useContext(OverrideContext);
  var context2 = react.exports.useMemo(function() {
    return _extends$2(_extends$2({}, override), restProps);
  }, [
    override,
    restProps.prefixCls,
    restProps.mode,
    restProps.selectable
  ]);
  return /* @__PURE__ */ react.exports.createElement(OverrideContext.Provider, {
    value: context2
  }, children);
};
var OverrideContext$1 = OverrideContext;
var __rest$p = globalThis && globalThis.__rest || function(s2, e3) {
  var t2 = {};
  for (var p2 in s2) {
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  }
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e3.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
var InternalMenu = /* @__PURE__ */ react.exports.forwardRef(function(props, ref) {
  var _a2;
  var override = react.exports.useContext(OverrideContext$1) || {};
  var _React$useContext = react.exports.useContext(ConfigContext), getPrefixCls = _React$useContext.getPrefixCls, getPopupContainer = _React$useContext.getPopupContainer, direction2 = _React$useContext.direction;
  var rootPrefixCls = getPrefixCls();
  var customizePrefixCls = props.prefixCls, className = props.className, _props$theme = props.theme, theme2 = _props$theme === void 0 ? "light" : _props$theme, expandIcon = props.expandIcon, _internalDisableMenuItemTitleTooltip = props._internalDisableMenuItemTitleTooltip, inlineCollapsed = props.inlineCollapsed, siderCollapsed = props.siderCollapsed, items = props.items, children = props.children, mode = props.mode, selectable = props.selectable, onClick = props.onClick, restProps = __rest$p(props, ["prefixCls", "className", "theme", "expandIcon", "_internalDisableMenuItemTitleTooltip", "inlineCollapsed", "siderCollapsed", "items", "children", "mode", "selectable", "onClick"]);
  var passedProps = omit$2(restProps, ["collapsedWidth"]);
  var mergedChildren = useItems(items) || children;
  (_a2 = override.validator) === null || _a2 === void 0 ? void 0 : _a2.call(override, {
    mode
  });
  var onItemClick = useEvent(function() {
    var _a3;
    onClick === null || onClick === void 0 ? void 0 : onClick.apply(void 0, arguments);
    (_a3 = override === null || override === void 0 ? void 0 : override.onClick) === null || _a3 === void 0 ? void 0 : _a3.call(override);
  });
  var mergedMode = override.mode || mode;
  var mergedSelectable = selectable !== null && selectable !== void 0 ? selectable : override.selectable;
  var mergedInlineCollapsed = react.exports.useMemo(function() {
    if (siderCollapsed !== void 0) {
      return siderCollapsed;
    }
    return inlineCollapsed;
  }, [inlineCollapsed, siderCollapsed]);
  var defaultMotions = {
    horizontal: {
      motionName: "".concat(rootPrefixCls, "-slide-up")
    },
    inline: collapseMotion,
    other: {
      motionName: "".concat(rootPrefixCls, "-zoom-big")
    }
  };
  var prefixCls = getPrefixCls("menu", customizePrefixCls || override.prefixCls);
  var menuClassName = classNames("".concat(prefixCls, "-").concat(theme2), className);
  var mergedExpandIcon;
  if (typeof expandIcon === "function") {
    mergedExpandIcon = expandIcon;
  } else {
    mergedExpandIcon = cloneElement(expandIcon || override.expandIcon, {
      className: "".concat(prefixCls, "-submenu-expand-icon")
    });
  }
  var contextValue = react.exports.useMemo(function() {
    return {
      prefixCls,
      inlineCollapsed: mergedInlineCollapsed || false,
      antdMenuTheme: theme2,
      direction: direction2,
      firstLevel: true,
      disableMenuItemTitleTooltip: _internalDisableMenuItemTitleTooltip
    };
  }, [prefixCls, mergedInlineCollapsed, theme2, direction2, _internalDisableMenuItemTitleTooltip]);
  return /* @__PURE__ */ react.exports.createElement(OverrideContext$1.Provider, {
    value: null
  }, /* @__PURE__ */ react.exports.createElement(MenuContext$1.Provider, {
    value: contextValue
  }, /* @__PURE__ */ react.exports.createElement(ExportMenu, _extends$2({
    getPopupContainer,
    overflowedIndicator: /* @__PURE__ */ react.exports.createElement(EllipsisOutlined$1, null),
    overflowedIndicatorPopupClassName: "".concat(prefixCls, "-").concat(theme2),
    mode: mergedMode,
    selectable: mergedSelectable,
    onClick: onItemClick
  }, passedProps, {
    inlineCollapsed: mergedInlineCollapsed,
    className: menuClassName,
    prefixCls,
    direction: direction2,
    defaultMotions,
    expandIcon: mergedExpandIcon,
    ref
  }), mergedChildren)));
});
var Menu = /* @__PURE__ */ function(_React$Component) {
  _inherits$1(Menu2, _React$Component);
  var _super = _createSuper$1(Menu2);
  function Menu2() {
    var _this;
    _classCallCheck$2(this, Menu2);
    _this = _super.apply(this, arguments);
    _this.focus = function(options) {
      var _a2;
      (_a2 = _this.menu) === null || _a2 === void 0 ? void 0 : _a2.focus(options);
    };
    return _this;
  }
  _createClass$2(Menu2, [{
    key: "render",
    value: function render2() {
      var _this2 = this;
      return /* @__PURE__ */ react.exports.createElement(SiderContext.Consumer, null, function(context2) {
        return /* @__PURE__ */ react.exports.createElement(InternalMenu, _extends$2({
          ref: function ref(node) {
            _this2.menu = node;
          }
        }, _this2.props, context2));
      });
    }
  }]);
  return Menu2;
}(react.exports.Component);
Menu.Divider = MenuDivider$1;
Menu.Item = MenuItem;
Menu.SubMenu = SubMenu;
Menu.ItemGroup = MenuItemGroup;
var Menu$1 = Menu;
var autoAdjustOverflow = {
  adjustX: 1,
  adjustY: 1
};
var targetOffset = [0, 0];
var placements = {
  topLeft: {
    points: ["bl", "tl"],
    overflow: autoAdjustOverflow,
    offset: [0, -4],
    targetOffset
  },
  topCenter: {
    points: ["bc", "tc"],
    overflow: autoAdjustOverflow,
    offset: [0, -4],
    targetOffset
  },
  topRight: {
    points: ["br", "tr"],
    overflow: autoAdjustOverflow,
    offset: [0, -4],
    targetOffset
  },
  bottomLeft: {
    points: ["tl", "bl"],
    overflow: autoAdjustOverflow,
    offset: [0, 4],
    targetOffset
  },
  bottomCenter: {
    points: ["tc", "bc"],
    overflow: autoAdjustOverflow,
    offset: [0, 4],
    targetOffset
  },
  bottomRight: {
    points: ["tr", "br"],
    overflow: autoAdjustOverflow,
    offset: [0, 4],
    targetOffset
  }
};
var ESC = KeyCode.ESC, TAB = KeyCode.TAB;
function useAccessibility(_ref) {
  var visible = _ref.visible, setTriggerVisible = _ref.setTriggerVisible, triggerRef = _ref.triggerRef, onVisibleChange = _ref.onVisibleChange, autoFocus = _ref.autoFocus;
  var focusMenuRef = react.exports.useRef(false);
  var handleCloseMenuAndReturnFocus = function handleCloseMenuAndReturnFocus2() {
    if (visible && triggerRef.current) {
      var _triggerRef$current, _triggerRef$current$t, _triggerRef$current$t2, _triggerRef$current$t3;
      (_triggerRef$current = triggerRef.current) === null || _triggerRef$current === void 0 ? void 0 : (_triggerRef$current$t = _triggerRef$current.triggerRef) === null || _triggerRef$current$t === void 0 ? void 0 : (_triggerRef$current$t2 = _triggerRef$current$t.current) === null || _triggerRef$current$t2 === void 0 ? void 0 : (_triggerRef$current$t3 = _triggerRef$current$t2.focus) === null || _triggerRef$current$t3 === void 0 ? void 0 : _triggerRef$current$t3.call(_triggerRef$current$t2);
      setTriggerVisible(false);
      if (typeof onVisibleChange === "function") {
        onVisibleChange(false);
      }
    }
  };
  var focusMenu = function focusMenu2() {
    var _triggerRef$current2, _triggerRef$current2$, _triggerRef$current2$2, _triggerRef$current2$3;
    var elements = getFocusNodeList((_triggerRef$current2 = triggerRef.current) === null || _triggerRef$current2 === void 0 ? void 0 : (_triggerRef$current2$ = _triggerRef$current2.popupRef) === null || _triggerRef$current2$ === void 0 ? void 0 : (_triggerRef$current2$2 = _triggerRef$current2$.current) === null || _triggerRef$current2$2 === void 0 ? void 0 : (_triggerRef$current2$3 = _triggerRef$current2$2.getElement) === null || _triggerRef$current2$3 === void 0 ? void 0 : _triggerRef$current2$3.call(_triggerRef$current2$2));
    var firstElement = elements[0];
    if (firstElement === null || firstElement === void 0 ? void 0 : firstElement.focus) {
      firstElement.focus();
      focusMenuRef.current = true;
      return true;
    }
    return false;
  };
  var handleKeyDown = function handleKeyDown2(event) {
    switch (event.keyCode) {
      case ESC:
        handleCloseMenuAndReturnFocus();
        break;
      case TAB: {
        var focusResult = false;
        if (!focusMenuRef.current) {
          focusResult = focusMenu();
        }
        if (focusResult) {
          event.preventDefault();
        } else {
          handleCloseMenuAndReturnFocus();
        }
        break;
      }
    }
  };
  react.exports.useEffect(function() {
    if (visible) {
      window.addEventListener("keydown", handleKeyDown);
      if (autoFocus) {
        wrapperRaf$1(focusMenu, 3);
      }
      return function() {
        window.removeEventListener("keydown", handleKeyDown);
        focusMenuRef.current = false;
      };
    }
    return function() {
      focusMenuRef.current = false;
    };
  }, [visible]);
}
var _excluded$e = ["arrow", "prefixCls", "transitionName", "animation", "align", "placement", "placements", "getPopupContainer", "showAction", "hideAction", "overlayClassName", "overlayStyle", "visible", "trigger", "autoFocus"];
function Dropdown$2(props, ref) {
  var _props$arrow = props.arrow, arrow = _props$arrow === void 0 ? false : _props$arrow, _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-dropdown" : _props$prefixCls, transitionName2 = props.transitionName, animation2 = props.animation, align = props.align, _props$placement = props.placement, placement = _props$placement === void 0 ? "bottomLeft" : _props$placement, _props$placements = props.placements, placements$12 = _props$placements === void 0 ? placements : _props$placements, getPopupContainer = props.getPopupContainer, showAction = props.showAction, hideAction = props.hideAction, overlayClassName = props.overlayClassName, overlayStyle = props.overlayStyle, visible = props.visible, _props$trigger = props.trigger, trigger = _props$trigger === void 0 ? ["hover"] : _props$trigger, autoFocus = props.autoFocus, otherProps = _objectWithoutProperties$1(props, _excluded$e);
  var _React$useState = react.exports.useState(), _React$useState2 = _slicedToArray$4(_React$useState, 2), triggerVisible = _React$useState2[0], setTriggerVisible = _React$useState2[1];
  var mergedVisible = "visible" in props ? visible : triggerVisible;
  var triggerRef = react.exports.useRef(null);
  react.exports.useImperativeHandle(ref, function() {
    return triggerRef.current;
  });
  useAccessibility({
    visible: mergedVisible,
    setTriggerVisible,
    triggerRef,
    onVisibleChange: props.onVisibleChange,
    autoFocus
  });
  var getOverlayElement = function getOverlayElement2() {
    var overlay = props.overlay;
    var overlayElement;
    if (typeof overlay === "function") {
      overlayElement = overlay();
    } else {
      overlayElement = overlay;
    }
    return overlayElement;
  };
  var onClick = function onClick2(e3) {
    var onOverlayClick = props.onOverlayClick;
    setTriggerVisible(false);
    if (onOverlayClick) {
      onOverlayClick(e3);
    }
  };
  var onVisibleChange = function onVisibleChange2(newVisible) {
    var onVisibleChangeProp = props.onVisibleChange;
    setTriggerVisible(newVisible);
    if (typeof onVisibleChangeProp === "function") {
      onVisibleChangeProp(newVisible);
    }
  };
  var getMenuElement = function getMenuElement2() {
    var overlayElement = getOverlayElement();
    return /* @__PURE__ */ react.exports.createElement(react.exports.Fragment, null, arrow && /* @__PURE__ */ react.exports.createElement("div", {
      className: "".concat(prefixCls, "-arrow")
    }), overlayElement);
  };
  var getMenuElementOrLambda = function getMenuElementOrLambda2() {
    var overlay = props.overlay;
    if (typeof overlay === "function") {
      return getMenuElement;
    }
    return getMenuElement();
  };
  var getMinOverlayWidthMatchTrigger = function getMinOverlayWidthMatchTrigger2() {
    var minOverlayWidthMatchTrigger = props.minOverlayWidthMatchTrigger, alignPoint2 = props.alignPoint;
    if ("minOverlayWidthMatchTrigger" in props) {
      return minOverlayWidthMatchTrigger;
    }
    return !alignPoint2;
  };
  var getOpenClassName = function getOpenClassName2() {
    var openClassName = props.openClassName;
    if (openClassName !== void 0) {
      return openClassName;
    }
    return "".concat(prefixCls, "-open");
  };
  var renderChildren = function renderChildren2() {
    var children = props.children;
    var childrenProps = children.props ? children.props : {};
    var childClassName = classNames(childrenProps.className, getOpenClassName());
    return mergedVisible && children ? /* @__PURE__ */ react.exports.cloneElement(children, {
      className: childClassName
    }) : children;
  };
  var triggerHideAction = hideAction;
  if (!triggerHideAction && trigger.indexOf("contextMenu") !== -1) {
    triggerHideAction = ["click"];
  }
  return /* @__PURE__ */ react.exports.createElement(Trigger, _objectSpread2$1(_objectSpread2$1({
    builtinPlacements: placements$12
  }, otherProps), {}, {
    prefixCls,
    ref: triggerRef,
    popupClassName: classNames(overlayClassName, _defineProperty$4({}, "".concat(prefixCls, "-show-arrow"), arrow)),
    popupStyle: overlayStyle,
    action: trigger,
    showAction,
    hideAction: triggerHideAction || [],
    popupPlacement: placement,
    popupAlign: align,
    popupTransitionName: transitionName2,
    popupAnimation: animation2,
    popupVisible: mergedVisible,
    stretch: getMinOverlayWidthMatchTrigger() ? "minWidth" : "",
    popup: getMenuElementOrLambda(),
    onPopupVisibleChange: onVisibleChange,
    onPopupClick: onClick,
    getPopupContainer
  }), renderChildren());
}
var Dropdown$3 = /* @__PURE__ */ react.exports.forwardRef(Dropdown$2);
var id$1 = 0;
var ids = {};
function wrapperRaf(callback) {
  var delayFrames = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
  var myId = id$1++;
  var restFrames = delayFrames;
  function internalCallback() {
    restFrames -= 1;
    if (restFrames <= 0) {
      callback();
      delete ids[myId];
    } else {
      ids[myId] = wrapperRaf$1(internalCallback);
    }
  }
  ids[myId] = wrapperRaf$1(internalCallback);
  return myId;
}
wrapperRaf.cancel = function cancel(pid) {
  if (pid === void 0)
    return;
  wrapperRaf$1.cancel(ids[pid]);
  delete ids[pid];
};
wrapperRaf.ids = ids;
var styleForPseudo;
function isHidden(element) {
  return !element || element.offsetParent === null || element.hidden;
}
function getValidateContainer(nodeRoot) {
  if (nodeRoot instanceof Document) {
    return nodeRoot.body;
  }
  return Array.from(nodeRoot.childNodes).find(function(ele) {
    return (ele === null || ele === void 0 ? void 0 : ele.nodeType) === Node.ELEMENT_NODE;
  });
}
function isNotGrey(color2) {
  var match2 = (color2 || "").match(/rgba?\((\d*), (\d*), (\d*)(, [\d.]*)?\)/);
  if (match2 && match2[1] && match2[2] && match2[3]) {
    return !(match2[1] === match2[2] && match2[2] === match2[3]);
  }
  return true;
}
var InternalWave = /* @__PURE__ */ function(_React$Component) {
  _inherits$1(InternalWave2, _React$Component);
  var _super = _createSuper$1(InternalWave2);
  function InternalWave2() {
    var _this;
    _classCallCheck$2(this, InternalWave2);
    _this = _super.apply(this, arguments);
    _this.containerRef = /* @__PURE__ */ react.exports.createRef();
    _this.animationStart = false;
    _this.destroyed = false;
    _this.onClick = function(node, waveColor) {
      var _a2, _b;
      var _this$props = _this.props, insertExtraNode = _this$props.insertExtraNode, disabled = _this$props.disabled;
      if (disabled || !node || isHidden(node) || node.className.indexOf("-leave") >= 0) {
        return;
      }
      _this.extraNode = document.createElement("div");
      var _assertThisInitialize = _assertThisInitialized$1(_this), extraNode = _assertThisInitialize.extraNode;
      var getPrefixCls = _this.context.getPrefixCls;
      extraNode.className = "".concat(getPrefixCls(""), "-click-animating-node");
      var attributeName = _this.getAttributeName();
      node.setAttribute(attributeName, "true");
      if (waveColor && waveColor !== "#ffffff" && waveColor !== "rgb(255, 255, 255)" && isNotGrey(waveColor) && !/rgba\((?:\d*, ){3}0\)/.test(waveColor) && waveColor !== "transparent") {
        extraNode.style.borderColor = waveColor;
        var nodeRoot = ((_a2 = node.getRootNode) === null || _a2 === void 0 ? void 0 : _a2.call(node)) || node.ownerDocument;
        var nodeBody = (_b = getValidateContainer(nodeRoot)) !== null && _b !== void 0 ? _b : nodeRoot;
        styleForPseudo = updateCSS("\n      [".concat(getPrefixCls(""), "-click-animating-without-extra-node='true']::after, .").concat(getPrefixCls(""), "-click-animating-node {\n        --antd-wave-shadow-color: ").concat(waveColor, ";\n      }"), "antd-wave", {
          csp: _this.csp,
          attachTo: nodeBody
        });
      }
      if (insertExtraNode) {
        node.appendChild(extraNode);
      }
      ["transition", "animation"].forEach(function(name) {
        node.addEventListener("".concat(name, "start"), _this.onTransitionStart);
        node.addEventListener("".concat(name, "end"), _this.onTransitionEnd);
      });
    };
    _this.onTransitionStart = function(e3) {
      if (_this.destroyed) {
        return;
      }
      var node = _this.containerRef.current;
      if (!e3 || e3.target !== node || _this.animationStart) {
        return;
      }
      _this.resetEffect(node);
    };
    _this.onTransitionEnd = function(e3) {
      if (!e3 || e3.animationName !== "fadeEffect") {
        return;
      }
      _this.resetEffect(e3.target);
    };
    _this.bindAnimationEvent = function(node) {
      if (!node || !node.getAttribute || node.getAttribute("disabled") || node.className.indexOf("disabled") >= 0) {
        return;
      }
      var onClick = function onClick2(e3) {
        if (e3.target.tagName === "INPUT" || isHidden(e3.target)) {
          return;
        }
        _this.resetEffect(node);
        var waveColor = getComputedStyle(node).getPropertyValue("border-top-color") || getComputedStyle(node).getPropertyValue("border-color") || getComputedStyle(node).getPropertyValue("background-color");
        _this.clickWaveTimeoutId = window.setTimeout(function() {
          return _this.onClick(node, waveColor);
        }, 0);
        wrapperRaf.cancel(_this.animationStartId);
        _this.animationStart = true;
        _this.animationStartId = wrapperRaf(function() {
          _this.animationStart = false;
        }, 10);
      };
      node.addEventListener("click", onClick, true);
      return {
        cancel: function cancel2() {
          node.removeEventListener("click", onClick, true);
        }
      };
    };
    _this.renderWave = function(_ref) {
      var csp = _ref.csp;
      var children = _this.props.children;
      _this.csp = csp;
      if (!/* @__PURE__ */ react.exports.isValidElement(children))
        return children;
      var ref = _this.containerRef;
      if (supportRef(children)) {
        ref = composeRef(children.ref, _this.containerRef);
      }
      return cloneElement(children, {
        ref
      });
    };
    return _this;
  }
  _createClass$2(InternalWave2, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this.destroyed = false;
      var node = this.containerRef.current;
      if (!node || node.nodeType !== 1) {
        return;
      }
      this.instance = this.bindAnimationEvent(node);
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      if (this.instance) {
        this.instance.cancel();
      }
      if (this.clickWaveTimeoutId) {
        clearTimeout(this.clickWaveTimeoutId);
      }
      this.destroyed = true;
    }
  }, {
    key: "getAttributeName",
    value: function getAttributeName() {
      var getPrefixCls = this.context.getPrefixCls;
      var insertExtraNode = this.props.insertExtraNode;
      return insertExtraNode ? "".concat(getPrefixCls(""), "-click-animating") : "".concat(getPrefixCls(""), "-click-animating-without-extra-node");
    }
  }, {
    key: "resetEffect",
    value: function resetEffect(node) {
      var _this2 = this;
      if (!node || node === this.extraNode || !(node instanceof Element)) {
        return;
      }
      var insertExtraNode = this.props.insertExtraNode;
      var attributeName = this.getAttributeName();
      node.setAttribute(attributeName, "false");
      if (styleForPseudo) {
        styleForPseudo.innerHTML = "";
      }
      if (insertExtraNode && this.extraNode && node.contains(this.extraNode)) {
        node.removeChild(this.extraNode);
      }
      ["transition", "animation"].forEach(function(name) {
        node.removeEventListener("".concat(name, "start"), _this2.onTransitionStart);
        node.removeEventListener("".concat(name, "end"), _this2.onTransitionEnd);
      });
    }
  }, {
    key: "render",
    value: function render2() {
      return /* @__PURE__ */ react.exports.createElement(ConfigConsumer, null, this.renderWave);
    }
  }]);
  return InternalWave2;
}(react.exports.Component);
InternalWave.contextType = ConfigContext;
var Wave = /* @__PURE__ */ react.exports.forwardRef(function(props, ref) {
  return /* @__PURE__ */ react.exports.createElement(InternalWave, _extends$2({
    ref
  }, props));
});
var Wave$1 = Wave;
var __rest$o = globalThis && globalThis.__rest || function(s2, e3) {
  var t2 = {};
  for (var p2 in s2) {
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  }
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e3.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
var GroupSizeContext = /* @__PURE__ */ react.exports.createContext(void 0);
var ButtonGroup$1 = function ButtonGroup2(props) {
  var _classNames;
  var _React$useContext = react.exports.useContext(ConfigContext), getPrefixCls = _React$useContext.getPrefixCls, direction2 = _React$useContext.direction;
  var customizePrefixCls = props.prefixCls, size2 = props.size, className = props.className, others = __rest$o(props, ["prefixCls", "size", "className"]);
  var prefixCls = getPrefixCls("btn-group", customizePrefixCls);
  var sizeCls = "";
  switch (size2) {
    case "large":
      sizeCls = "lg";
      break;
    case "small":
      sizeCls = "sm";
      break;
  }
  var classes = classNames(prefixCls, (_classNames = {}, _defineProperty$4(_classNames, "".concat(prefixCls, "-").concat(sizeCls), sizeCls), _defineProperty$4(_classNames, "".concat(prefixCls, "-rtl"), direction2 === "rtl"), _classNames), className);
  return /* @__PURE__ */ react.exports.createElement(GroupSizeContext.Provider, {
    value: size2
  }, /* @__PURE__ */ react.exports.createElement("div", _extends$2({}, others, {
    className: classes
  })));
};
var Group$7 = ButtonGroup$1;
var getCollapsedWidth = function getCollapsedWidth2() {
  return {
    width: 0,
    opacity: 0,
    transform: "scale(0)"
  };
};
var getRealWidth = function getRealWidth2(node) {
  return {
    width: node.scrollWidth,
    opacity: 1,
    transform: "scale(1)"
  };
};
var LoadingIcon = function LoadingIcon2(_ref) {
  var prefixCls = _ref.prefixCls, loading = _ref.loading, existIcon = _ref.existIcon;
  var visible = !!loading;
  if (existIcon) {
    return /* @__PURE__ */ React.createElement("span", {
      className: "".concat(prefixCls, "-loading-icon")
    }, /* @__PURE__ */ React.createElement(LoadingOutlined$1, null));
  }
  return /* @__PURE__ */ React.createElement(CSSMotion, {
    visible,
    motionName: "".concat(prefixCls, "-loading-icon-motion"),
    removeOnLeave: true,
    onAppearStart: getCollapsedWidth,
    onAppearActive: getRealWidth,
    onEnterStart: getCollapsedWidth,
    onEnterActive: getRealWidth,
    onLeaveStart: getRealWidth,
    onLeaveActive: getCollapsedWidth
  }, function(_ref2, ref) {
    var className = _ref2.className, style2 = _ref2.style;
    return /* @__PURE__ */ React.createElement("span", {
      className: "".concat(prefixCls, "-loading-icon"),
      style: style2,
      ref
    }, /* @__PURE__ */ React.createElement(LoadingOutlined$1, {
      className
    }));
  });
};
var LoadingIcon$1 = LoadingIcon;
var __rest$n = globalThis && globalThis.__rest || function(s2, e3) {
  var t2 = {};
  for (var p2 in s2) {
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  }
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e3.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
var rxTwoCNChar = /^[\u4e00-\u9fa5]{2}$/;
var isTwoCNChar = rxTwoCNChar.test.bind(rxTwoCNChar);
function isString$2(str) {
  return typeof str === "string";
}
function isUnBorderedButtonType(type4) {
  return type4 === "text" || type4 === "link";
}
function isReactFragment(node) {
  return /* @__PURE__ */ react.exports.isValidElement(node) && node.type === react.exports.Fragment;
}
function insertSpace(child, needInserted) {
  if (child === null || child === void 0) {
    return;
  }
  var SPACE = needInserted ? " " : "";
  if (typeof child !== "string" && typeof child !== "number" && isString$2(child.type) && isTwoCNChar(child.props.children)) {
    return cloneElement(child, {
      children: child.props.children.split("").join(SPACE)
    });
  }
  if (typeof child === "string") {
    return isTwoCNChar(child) ? /* @__PURE__ */ react.exports.createElement("span", null, child.split("").join(SPACE)) : /* @__PURE__ */ react.exports.createElement("span", null, child);
  }
  if (isReactFragment(child)) {
    return /* @__PURE__ */ react.exports.createElement("span", null, child);
  }
  return child;
}
function spaceChildren(children, needInserted) {
  var isPrevChildPure = false;
  var childList = [];
  react.exports.Children.forEach(children, function(child) {
    var type4 = _typeof$4(child);
    var isCurrentChildPure = type4 === "string" || type4 === "number";
    if (isPrevChildPure && isCurrentChildPure) {
      var lastIndex = childList.length - 1;
      var lastChild = childList[lastIndex];
      childList[lastIndex] = "".concat(lastChild).concat(child);
    } else {
      childList.push(child);
    }
    isPrevChildPure = isCurrentChildPure;
  });
  return react.exports.Children.map(childList, function(child) {
    return insertSpace(child, needInserted);
  });
}
tuple("default", "primary", "ghost", "dashed", "link", "text");
tuple("default", "circle", "round");
tuple("submit", "button", "reset");
var InternalButton = function InternalButton2(props, ref) {
  var _classNames;
  var _props$loading = props.loading, loading = _props$loading === void 0 ? false : _props$loading, customizePrefixCls = props.prefixCls, _props$type = props.type, type4 = _props$type === void 0 ? "default" : _props$type, danger = props.danger, _props$shape = props.shape, shape = _props$shape === void 0 ? "default" : _props$shape, customizeSize = props.size, customDisabled = props.disabled, className = props.className, children = props.children, icon = props.icon, _props$ghost = props.ghost, ghost = _props$ghost === void 0 ? false : _props$ghost, _props$block = props.block, block = _props$block === void 0 ? false : _props$block, _props$htmlType = props.htmlType, htmlType = _props$htmlType === void 0 ? "button" : _props$htmlType, rest = __rest$n(props, ["loading", "prefixCls", "type", "danger", "shape", "size", "disabled", "className", "children", "icon", "ghost", "block", "htmlType"]);
  var size2 = react.exports.useContext(SizeContext$1);
  var disabled = react.exports.useContext(DisabledContext$1);
  var mergedDisabled = customDisabled || disabled;
  var groupSize = react.exports.useContext(GroupSizeContext);
  var _React$useState = react.exports.useState(!!loading), _React$useState2 = _slicedToArray$4(_React$useState, 2), innerLoading = _React$useState2[0], setLoading = _React$useState2[1];
  var _React$useState3 = react.exports.useState(false), _React$useState4 = _slicedToArray$4(_React$useState3, 2), hasTwoCNChar = _React$useState4[0], setHasTwoCNChar = _React$useState4[1];
  var _React$useContext = react.exports.useContext(ConfigContext), getPrefixCls = _React$useContext.getPrefixCls, autoInsertSpaceInButton = _React$useContext.autoInsertSpaceInButton, direction2 = _React$useContext.direction;
  var buttonRef = ref || /* @__PURE__ */ react.exports.createRef();
  var isNeedInserted = function isNeedInserted2() {
    return react.exports.Children.count(children) === 1 && !icon && !isUnBorderedButtonType(type4);
  };
  var fixTwoCNChar = function fixTwoCNChar2() {
    if (!buttonRef || !buttonRef.current || autoInsertSpaceInButton === false) {
      return;
    }
    var buttonText = buttonRef.current.textContent;
    if (isNeedInserted() && isTwoCNChar(buttonText)) {
      if (!hasTwoCNChar) {
        setHasTwoCNChar(true);
      }
    } else if (hasTwoCNChar) {
      setHasTwoCNChar(false);
    }
  };
  var loadingOrDelay = typeof loading === "boolean" ? loading : (loading === null || loading === void 0 ? void 0 : loading.delay) || true;
  react.exports.useEffect(function() {
    var delayTimer = null;
    if (typeof loadingOrDelay === "number") {
      delayTimer = window.setTimeout(function() {
        delayTimer = null;
        setLoading(loadingOrDelay);
      }, loadingOrDelay);
    } else {
      setLoading(loadingOrDelay);
    }
    return function() {
      if (delayTimer) {
        window.clearTimeout(delayTimer);
        delayTimer = null;
      }
    };
  }, [loadingOrDelay]);
  react.exports.useEffect(fixTwoCNChar, [buttonRef]);
  var handleClick = function handleClick2(e3) {
    var onClick = props.onClick;
    if (innerLoading || mergedDisabled) {
      e3.preventDefault();
      return;
    }
    onClick === null || onClick === void 0 ? void 0 : onClick(e3);
  };
  var prefixCls = getPrefixCls("btn", customizePrefixCls);
  var autoInsertSpace = autoInsertSpaceInButton !== false;
  var sizeClassNameMap = {
    large: "lg",
    small: "sm",
    middle: void 0
  };
  var sizeFullname = groupSize || customizeSize || size2;
  var sizeCls = sizeFullname ? sizeClassNameMap[sizeFullname] || "" : "";
  var iconType = innerLoading ? "loading" : icon;
  var linkButtonRestProps = omit$2(rest, ["navigate"]);
  var classes = classNames(prefixCls, (_classNames = {}, _defineProperty$4(_classNames, "".concat(prefixCls, "-").concat(shape), shape !== "default" && shape), _defineProperty$4(_classNames, "".concat(prefixCls, "-").concat(type4), type4), _defineProperty$4(_classNames, "".concat(prefixCls, "-").concat(sizeCls), sizeCls), _defineProperty$4(_classNames, "".concat(prefixCls, "-icon-only"), !children && children !== 0 && !!iconType), _defineProperty$4(_classNames, "".concat(prefixCls, "-background-ghost"), ghost && !isUnBorderedButtonType(type4)), _defineProperty$4(_classNames, "".concat(prefixCls, "-loading"), innerLoading), _defineProperty$4(_classNames, "".concat(prefixCls, "-two-chinese-chars"), hasTwoCNChar && autoInsertSpace && !innerLoading), _defineProperty$4(_classNames, "".concat(prefixCls, "-block"), block), _defineProperty$4(_classNames, "".concat(prefixCls, "-dangerous"), !!danger), _defineProperty$4(_classNames, "".concat(prefixCls, "-rtl"), direction2 === "rtl"), _defineProperty$4(_classNames, "".concat(prefixCls, "-disabled"), linkButtonRestProps.href !== void 0 && mergedDisabled), _classNames), className);
  var iconNode = icon && !innerLoading ? icon : /* @__PURE__ */ react.exports.createElement(LoadingIcon$1, {
    existIcon: !!icon,
    prefixCls,
    loading: !!innerLoading
  });
  var kids = children || children === 0 ? spaceChildren(children, isNeedInserted() && autoInsertSpace) : null;
  if (linkButtonRestProps.href !== void 0) {
    return /* @__PURE__ */ react.exports.createElement("a", _extends$2({}, linkButtonRestProps, {
      className: classes,
      onClick: handleClick,
      ref: buttonRef
    }), iconNode, kids);
  }
  var buttonNode = /* @__PURE__ */ react.exports.createElement("button", _extends$2({}, rest, {
    type: htmlType,
    className: classes,
    onClick: handleClick,
    disabled: mergedDisabled,
    ref: buttonRef
  }), iconNode, kids);
  if (isUnBorderedButtonType(type4)) {
    return buttonNode;
  }
  return /* @__PURE__ */ react.exports.createElement(Wave$1, {
    disabled: !!innerLoading
  }, buttonNode);
};
var Button$1 = /* @__PURE__ */ react.exports.forwardRef(InternalButton);
Button$1.Group = Group$7;
Button$1.__ANT_BUTTON = true;
var Button$2 = Button$1;
var __rest$m = globalThis && globalThis.__rest || function(s2, e3) {
  var t2 = {};
  for (var p2 in s2) {
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  }
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e3.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
var ButtonGroup = Button$2.Group;
var DropdownButton = function DropdownButton2(props) {
  var _React$useContext = react.exports.useContext(ConfigContext), getContextPopupContainer = _React$useContext.getPopupContainer, getPrefixCls = _React$useContext.getPrefixCls, direction2 = _React$useContext.direction;
  var customizePrefixCls = props.prefixCls, _props$type = props.type, type4 = _props$type === void 0 ? "default" : _props$type, danger = props.danger, disabled = props.disabled, loading = props.loading, onClick = props.onClick, htmlType = props.htmlType, children = props.children, className = props.className, overlay = props.overlay, trigger = props.trigger, align = props.align, visible = props.visible, open = props.open, onVisibleChange = props.onVisibleChange, onOpenChange = props.onOpenChange, placement = props.placement, getPopupContainer = props.getPopupContainer, href = props.href, _props$icon = props.icon, icon = _props$icon === void 0 ? /* @__PURE__ */ react.exports.createElement(EllipsisOutlined$1, null) : _props$icon, title = props.title, _props$buttonsRender = props.buttonsRender, buttonsRender = _props$buttonsRender === void 0 ? function(buttons) {
    return buttons;
  } : _props$buttonsRender, mouseEnterDelay = props.mouseEnterDelay, mouseLeaveDelay = props.mouseLeaveDelay, overlayClassName = props.overlayClassName, overlayStyle = props.overlayStyle, destroyPopupOnHide = props.destroyPopupOnHide, restProps = __rest$m(props, ["prefixCls", "type", "danger", "disabled", "loading", "onClick", "htmlType", "children", "className", "overlay", "trigger", "align", "visible", "open", "onVisibleChange", "onOpenChange", "placement", "getPopupContainer", "href", "icon", "title", "buttonsRender", "mouseEnterDelay", "mouseLeaveDelay", "overlayClassName", "overlayStyle", "destroyPopupOnHide"]);
  var prefixCls = getPrefixCls("dropdown-button", customizePrefixCls);
  var dropdownProps = {
    align,
    overlay,
    disabled,
    trigger: disabled ? [] : trigger,
    onOpenChange: onOpenChange || onVisibleChange,
    getPopupContainer: getPopupContainer || getContextPopupContainer,
    mouseEnterDelay,
    mouseLeaveDelay,
    overlayClassName,
    overlayStyle,
    destroyPopupOnHide
  };
  if ("open" in props) {
    dropdownProps.open = open;
  } else if ("visible" in props) {
    dropdownProps.open = visible;
  }
  if ("placement" in props) {
    dropdownProps.placement = placement;
  } else {
    dropdownProps.placement = direction2 === "rtl" ? "bottomLeft" : "bottomRight";
  }
  var leftButton = /* @__PURE__ */ react.exports.createElement(Button$2, {
    type: type4,
    danger,
    disabled,
    loading,
    onClick,
    htmlType,
    href,
    title
  }, children);
  var rightButton = /* @__PURE__ */ react.exports.createElement(Button$2, {
    type: type4,
    danger,
    icon
  });
  var _buttonsRender = buttonsRender([leftButton, rightButton]), _buttonsRender2 = _slicedToArray$4(_buttonsRender, 2), leftButtonToRender = _buttonsRender2[0], rightButtonToRender = _buttonsRender2[1];
  return /* @__PURE__ */ react.exports.createElement(ButtonGroup, _extends$2({}, restProps, {
    className: classNames(prefixCls, className)
  }), leftButtonToRender, /* @__PURE__ */ react.exports.createElement(Dropdown$1, _extends$2({}, dropdownProps), rightButtonToRender));
};
DropdownButton.__ANT_BUTTON = true;
var DropdownButton$1 = DropdownButton;
tuple("topLeft", "topCenter", "topRight", "bottomLeft", "bottomCenter", "bottomRight", "top", "bottom");
var Dropdown = function Dropdown2(props) {
  var _React$useContext = react.exports.useContext(ConfigContext), getContextPopupContainer = _React$useContext.getPopupContainer, getPrefixCls = _React$useContext.getPrefixCls, direction2 = _React$useContext.direction;
  var getTransitionName3 = function getTransitionName4() {
    var rootPrefixCls = getPrefixCls();
    var _props$placement = props.placement, placement = _props$placement === void 0 ? "" : _props$placement, transitionName2 = props.transitionName;
    if (transitionName2 !== void 0) {
      return transitionName2;
    }
    if (placement.includes("top")) {
      return "".concat(rootPrefixCls, "-slide-down");
    }
    return "".concat(rootPrefixCls, "-slide-up");
  };
  var getPlacement = function getPlacement2() {
    var placement = props.placement;
    if (!placement) {
      return direction2 === "rtl" ? "bottomRight" : "bottomLeft";
    }
    if (placement.includes("Center")) {
      var newPlacement = placement.slice(0, placement.indexOf("Center"));
      return newPlacement;
    }
    return placement;
  };
  var arrow = props.arrow, customizePrefixCls = props.prefixCls, children = props.children, trigger = props.trigger, disabled = props.disabled, getPopupContainer = props.getPopupContainer, overlayClassName = props.overlayClassName, visible = props.visible, open = props.open, onVisibleChange = props.onVisibleChange, onOpenChange = props.onOpenChange, _props$mouseEnterDela = props.mouseEnterDelay, mouseEnterDelay = _props$mouseEnterDela === void 0 ? 0.15 : _props$mouseEnterDela, _props$mouseLeaveDela = props.mouseLeaveDelay, mouseLeaveDelay = _props$mouseLeaveDela === void 0 ? 0.1 : _props$mouseLeaveDela;
  var prefixCls = getPrefixCls("dropdown", customizePrefixCls);
  var child = react.exports.Children.only(children);
  var dropdownTrigger = cloneElement(child, {
    className: classNames("".concat(prefixCls, "-trigger"), _defineProperty$4({}, "".concat(prefixCls, "-rtl"), direction2 === "rtl"), child.props.className),
    disabled
  });
  var triggerActions = disabled ? [] : trigger;
  var alignPoint2;
  if (triggerActions && triggerActions.includes("contextMenu")) {
    alignPoint2 = true;
  }
  var _useMergedState = useMergedState(false, {
    value: open !== void 0 ? open : visible
  }), _useMergedState2 = _slicedToArray$4(_useMergedState, 2), mergedOpen = _useMergedState2[0], setOpen = _useMergedState2[1];
  var onInnerOpenChange = useEvent(function(nextOpen) {
    onVisibleChange === null || onVisibleChange === void 0 ? void 0 : onVisibleChange(nextOpen);
    onOpenChange === null || onOpenChange === void 0 ? void 0 : onOpenChange(nextOpen);
    setOpen(nextOpen);
  });
  var overlayClassNameCustomized = classNames(overlayClassName, _defineProperty$4({}, "".concat(prefixCls, "-rtl"), direction2 === "rtl"));
  var builtinPlacements = getPlacements({
    arrowPointAtCenter: _typeof$4(arrow) === "object" && arrow.pointAtCenter,
    autoAdjustOverflow: true
  });
  var onMenuClick = react.exports.useCallback(function() {
    setOpen(false);
  }, []);
  var renderOverlay = function renderOverlay2() {
    var overlay = props.overlay;
    var overlayNode;
    if (typeof overlay === "function") {
      overlayNode = overlay();
    } else {
      overlayNode = overlay;
    }
    overlayNode = react.exports.Children.only(typeof overlayNode === "string" ? /* @__PURE__ */ react.exports.createElement("span", null, overlayNode) : overlayNode);
    return /* @__PURE__ */ react.exports.createElement(OverrideProvider, {
      prefixCls: "".concat(prefixCls, "-menu"),
      expandIcon: /* @__PURE__ */ react.exports.createElement("span", {
        className: "".concat(prefixCls, "-menu-submenu-arrow")
      }, /* @__PURE__ */ react.exports.createElement(RightOutlined$1, {
        className: "".concat(prefixCls, "-menu-submenu-arrow-icon")
      })),
      mode: "vertical",
      selectable: false,
      onClick: onMenuClick,
      validator: function validator2(_ref3) {
        _ref3.mode;
      }
    }, overlayNode);
  };
  return /* @__PURE__ */ react.exports.createElement(Dropdown$3, _extends$2({
    alignPoint: alignPoint2
  }, props, {
    mouseEnterDelay,
    mouseLeaveDelay,
    visible: mergedOpen,
    builtinPlacements,
    arrow: !!arrow,
    overlayClassName: overlayClassNameCustomized,
    prefixCls,
    getPopupContainer: getPopupContainer || getContextPopupContainer,
    transitionName: getTransitionName3(),
    trigger: triggerActions,
    overlay: renderOverlay,
    placement: getPlacement(),
    onVisibleChange: onInnerOpenChange
  }), dropdownTrigger);
};
Dropdown.Button = DropdownButton$1;
var Dropdown$1 = Dropdown;
var baseGetTag = _baseGetTag, isObjectLike$2 = isObjectLike_1;
var symbolTag = "[object Symbol]";
function isSymbol$1(value2) {
  return typeof value2 == "symbol" || isObjectLike$2(value2) && baseGetTag(value2) == symbolTag;
}
var isSymbol_1 = isSymbol$1;
var reWhitespace = /\s/;
function trimmedEndIndex$1(string3) {
  var index2 = string3.length;
  while (index2-- && reWhitespace.test(string3.charAt(index2))) {
  }
  return index2;
}
var _trimmedEndIndex = trimmedEndIndex$1;
var trimmedEndIndex = _trimmedEndIndex;
var reTrimStart = /^\s+/;
function baseTrim$1(string3) {
  return string3 ? string3.slice(0, trimmedEndIndex(string3) + 1).replace(reTrimStart, "") : string3;
}
var _baseTrim = baseTrim$1;
var baseTrim = _baseTrim, isObject$3 = isObject_1, isSymbol = isSymbol_1;
var NAN = 0 / 0;
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
var reIsBinary = /^0b[01]+$/i;
var reIsOctal = /^0o[0-7]+$/i;
var freeParseInt = parseInt;
function toNumber$1(value2) {
  if (typeof value2 == "number") {
    return value2;
  }
  if (isSymbol(value2)) {
    return NAN;
  }
  if (isObject$3(value2)) {
    var other2 = typeof value2.valueOf == "function" ? value2.valueOf() : value2;
    value2 = isObject$3(other2) ? other2 + "" : other2;
  }
  if (typeof value2 != "string") {
    return value2 === 0 ? value2 : +value2;
  }
  value2 = baseTrim(value2);
  var isBinary = reIsBinary.test(value2);
  return isBinary || reIsOctal.test(value2) ? freeParseInt(value2.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value2) ? NAN : +value2;
}
var toNumber_1 = toNumber$1;
var RadioGroupContext = /* @__PURE__ */ react.exports.createContext(null);
var RadioGroupContextProvider = RadioGroupContext.Provider;
var RadioOptionTypeContext = /* @__PURE__ */ react.exports.createContext(null);
var RadioOptionTypeContextProvider = RadioOptionTypeContext.Provider;
var Checkbox$3 = /* @__PURE__ */ function(_Component) {
  _inherits$1(Checkbox2, _Component);
  var _super = _createSuper$1(Checkbox2);
  function Checkbox2(props) {
    var _this;
    _classCallCheck$2(this, Checkbox2);
    _this = _super.call(this, props);
    _this.handleChange = function(e3) {
      var _this$props = _this.props, disabled = _this$props.disabled, onChange2 = _this$props.onChange;
      if (disabled) {
        return;
      }
      if (!("checked" in _this.props)) {
        _this.setState({
          checked: e3.target.checked
        });
      }
      if (onChange2) {
        onChange2({
          target: _objectSpread2$1(_objectSpread2$1({}, _this.props), {}, {
            checked: e3.target.checked
          }),
          stopPropagation: function stopPropagation() {
            e3.stopPropagation();
          },
          preventDefault: function preventDefault() {
            e3.preventDefault();
          },
          nativeEvent: e3.nativeEvent
        });
      }
    };
    _this.saveInput = function(node) {
      _this.input = node;
    };
    var checked = "checked" in props ? props.checked : props.defaultChecked;
    _this.state = {
      checked
    };
    return _this;
  }
  _createClass$2(Checkbox2, [{
    key: "focus",
    value: function focus() {
      this.input.focus();
    }
  }, {
    key: "blur",
    value: function blur() {
      this.input.blur();
    }
  }, {
    key: "render",
    value: function render2() {
      var _classNames;
      var _this$props2 = this.props, prefixCls = _this$props2.prefixCls, className = _this$props2.className, style2 = _this$props2.style, name = _this$props2.name, id2 = _this$props2.id, type4 = _this$props2.type, disabled = _this$props2.disabled, readOnly = _this$props2.readOnly, tabIndex = _this$props2.tabIndex, onClick = _this$props2.onClick, onFocus2 = _this$props2.onFocus, onBlur2 = _this$props2.onBlur, onKeyDown2 = _this$props2.onKeyDown, onKeyPress2 = _this$props2.onKeyPress, onKeyUp2 = _this$props2.onKeyUp, autoFocus = _this$props2.autoFocus, value2 = _this$props2.value, required4 = _this$props2.required, others = _objectWithoutProperties$1(_this$props2, ["prefixCls", "className", "style", "name", "id", "type", "disabled", "readOnly", "tabIndex", "onClick", "onFocus", "onBlur", "onKeyDown", "onKeyPress", "onKeyUp", "autoFocus", "value", "required"]);
      var globalProps = Object.keys(others).reduce(function(prev, key2) {
        if (key2.substr(0, 5) === "aria-" || key2.substr(0, 5) === "data-" || key2 === "role") {
          prev[key2] = others[key2];
        }
        return prev;
      }, {});
      var checked = this.state.checked;
      var classString = classNames(prefixCls, className, (_classNames = {}, _defineProperty$4(_classNames, "".concat(prefixCls, "-checked"), checked), _defineProperty$4(_classNames, "".concat(prefixCls, "-disabled"), disabled), _classNames));
      return /* @__PURE__ */ jsxs("span", {
        className: classString,
        style: style2,
        children: [/* @__PURE__ */ jsx("input", {
          name,
          id: id2,
          type: type4,
          required: required4,
          readOnly,
          disabled,
          tabIndex,
          className: "".concat(prefixCls, "-input"),
          checked: !!checked,
          onClick,
          onFocus: onFocus2,
          onBlur: onBlur2,
          onKeyUp: onKeyUp2,
          onKeyDown: onKeyDown2,
          onKeyPress: onKeyPress2,
          onChange: this.handleChange,
          autoFocus,
          ref: this.saveInput,
          value: value2,
          ...globalProps
        }), /* @__PURE__ */ jsx("span", {
          className: "".concat(prefixCls, "-inner")
        })]
      });
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function getDerivedStateFromProps(props, state2) {
      if ("checked" in props) {
        return _objectSpread2$1(_objectSpread2$1({}, state2), {}, {
          checked: props.checked
        });
      }
      return null;
    }
  }]);
  return Checkbox2;
}(react.exports.Component);
Checkbox$3.defaultProps = {
  prefixCls: "rc-checkbox",
  className: "",
  style: {},
  type: "checkbox",
  defaultChecked: false,
  onFocus: function onFocus() {
  },
  onBlur: function onBlur() {
  },
  onChange: function onChange() {
  },
  onKeyDown: function onKeyDown() {
  },
  onKeyPress: function onKeyPress() {
  },
  onKeyUp: function onKeyUp() {
  }
};
var __rest$l = globalThis && globalThis.__rest || function(s2, e3) {
  var t2 = {};
  for (var p2 in s2) {
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  }
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e3.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
var InternalRadio = function InternalRadio2(props, ref) {
  var _classNames;
  var groupContext = react.exports.useContext(RadioGroupContext);
  var radioOptionTypeContext = react.exports.useContext(RadioOptionTypeContext);
  var _React$useContext = react.exports.useContext(ConfigContext), getPrefixCls = _React$useContext.getPrefixCls, direction2 = _React$useContext.direction;
  var innerRef = react.exports.useRef();
  var mergedRef = composeRef(ref, innerRef);
  var _useContext = react.exports.useContext(FormItemInputContext), isFormItemInput = _useContext.isFormItemInput;
  var onChange2 = function onChange3(e3) {
    var _a2, _b;
    (_a2 = props.onChange) === null || _a2 === void 0 ? void 0 : _a2.call(props, e3);
    (_b = groupContext === null || groupContext === void 0 ? void 0 : groupContext.onChange) === null || _b === void 0 ? void 0 : _b.call(groupContext, e3);
  };
  var customizePrefixCls = props.prefixCls, className = props.className, children = props.children, style2 = props.style, customDisabled = props.disabled, restProps = __rest$l(props, ["prefixCls", "className", "children", "style", "disabled"]);
  var radioPrefixCls = getPrefixCls("radio", customizePrefixCls);
  var prefixCls = ((groupContext === null || groupContext === void 0 ? void 0 : groupContext.optionType) || radioOptionTypeContext) === "button" ? "".concat(radioPrefixCls, "-button") : radioPrefixCls;
  var radioProps = _extends$2({}, restProps);
  var disabled = react.exports.useContext(DisabledContext$1);
  radioProps.disabled = customDisabled || disabled;
  if (groupContext) {
    radioProps.name = groupContext.name;
    radioProps.onChange = onChange2;
    radioProps.checked = props.value === groupContext.value;
    radioProps.disabled = radioProps.disabled || groupContext.disabled;
  }
  var wrapperClassString = classNames("".concat(prefixCls, "-wrapper"), (_classNames = {}, _defineProperty$4(_classNames, "".concat(prefixCls, "-wrapper-checked"), radioProps.checked), _defineProperty$4(_classNames, "".concat(prefixCls, "-wrapper-disabled"), radioProps.disabled), _defineProperty$4(_classNames, "".concat(prefixCls, "-wrapper-rtl"), direction2 === "rtl"), _defineProperty$4(_classNames, "".concat(prefixCls, "-wrapper-in-form-item"), isFormItemInput), _classNames), className);
  return /* @__PURE__ */ react.exports.createElement("label", {
    className: wrapperClassString,
    style: style2,
    onMouseEnter: props.onMouseEnter,
    onMouseLeave: props.onMouseLeave
  }, /* @__PURE__ */ react.exports.createElement(Checkbox$3, _extends$2({}, radioProps, {
    type: "radio",
    prefixCls,
    ref: mergedRef
  })), children !== void 0 ? /* @__PURE__ */ react.exports.createElement("span", null, children) : null);
};
var Radio$2 = /* @__PURE__ */ react.exports.forwardRef(InternalRadio);
var InternalRadio$1 = Radio$2;
var RadioGroup = /* @__PURE__ */ react.exports.forwardRef(function(props, ref) {
  var _classNames;
  var _React$useContext = react.exports.useContext(ConfigContext), getPrefixCls = _React$useContext.getPrefixCls, direction2 = _React$useContext.direction;
  var size2 = react.exports.useContext(SizeContext$1);
  var _useMergedState = useMergedState(props.defaultValue, {
    value: props.value
  }), _useMergedState2 = _slicedToArray$4(_useMergedState, 2), value2 = _useMergedState2[0], setValue2 = _useMergedState2[1];
  var onRadioChange = function onRadioChange2(ev) {
    var lastValue = value2;
    var val = ev.target.value;
    if (!("value" in props)) {
      setValue2(val);
    }
    var onChange2 = props.onChange;
    if (onChange2 && val !== lastValue) {
      onChange2(ev);
    }
  };
  var customizePrefixCls = props.prefixCls, _props$className = props.className, className = _props$className === void 0 ? "" : _props$className, options = props.options, _props$buttonStyle = props.buttonStyle, buttonStyle = _props$buttonStyle === void 0 ? "outline" : _props$buttonStyle, disabled = props.disabled, children = props.children, customizeSize = props.size, style2 = props.style, id2 = props.id, onMouseEnter = props.onMouseEnter, onMouseLeave = props.onMouseLeave, onFocus2 = props.onFocus, onBlur2 = props.onBlur;
  var prefixCls = getPrefixCls("radio", customizePrefixCls);
  var groupPrefixCls = "".concat(prefixCls, "-group");
  var childrenToRender = children;
  if (options && options.length > 0) {
    childrenToRender = options.map(function(option) {
      if (typeof option === "string" || typeof option === "number") {
        return /* @__PURE__ */ react.exports.createElement(InternalRadio$1, {
          key: option.toString(),
          prefixCls,
          disabled,
          value: option,
          checked: value2 === option
        }, option);
      }
      return /* @__PURE__ */ react.exports.createElement(InternalRadio$1, {
        key: "radio-group-value-options-".concat(option.value),
        prefixCls,
        disabled: option.disabled || disabled,
        value: option.value,
        checked: value2 === option.value,
        style: option.style
      }, option.label);
    });
  }
  var mergedSize = customizeSize || size2;
  var classString = classNames(groupPrefixCls, "".concat(groupPrefixCls, "-").concat(buttonStyle), (_classNames = {}, _defineProperty$4(_classNames, "".concat(groupPrefixCls, "-").concat(mergedSize), mergedSize), _defineProperty$4(_classNames, "".concat(groupPrefixCls, "-rtl"), direction2 === "rtl"), _classNames), className);
  return /* @__PURE__ */ react.exports.createElement("div", _extends$2({}, getDataOrAriaProps(props), {
    className: classString,
    style: style2,
    onMouseEnter,
    onMouseLeave,
    onFocus: onFocus2,
    onBlur: onBlur2,
    id: id2,
    ref
  }), /* @__PURE__ */ react.exports.createElement(RadioGroupContextProvider, {
    value: {
      onChange: onRadioChange,
      value: value2,
      disabled: props.disabled,
      name: props.name,
      optionType: props.optionType
    }
  }, childrenToRender));
});
var Group$6 = /* @__PURE__ */ react.exports.memo(RadioGroup);
var __rest$k = globalThis && globalThis.__rest || function(s2, e3) {
  var t2 = {};
  for (var p2 in s2) {
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  }
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e3.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
var RadioButton = function RadioButton2(props, ref) {
  var _React$useContext = react.exports.useContext(ConfigContext), getPrefixCls = _React$useContext.getPrefixCls;
  var customizePrefixCls = props.prefixCls, radioProps = __rest$k(props, ["prefixCls"]);
  var prefixCls = getPrefixCls("radio", customizePrefixCls);
  return /* @__PURE__ */ react.exports.createElement(RadioOptionTypeContextProvider, {
    value: "button"
  }, /* @__PURE__ */ react.exports.createElement(InternalRadio$1, _extends$2({
    prefixCls
  }, radioProps, {
    type: "radio",
    ref
  })));
};
var Button = /* @__PURE__ */ react.exports.forwardRef(RadioButton);
var Radio = InternalRadio$1;
Radio.Button = Button;
Radio.Group = Group$6;
Radio.__ANT_RADIO = true;
var Radio$1 = Radio;
var root = _root;
var now$2 = function() {
  return root.Date.now();
};
var now_1 = now$2;
var isObject$2 = isObject_1, now$1 = now_1, toNumber = toNumber_1;
var FUNC_ERROR_TEXT = "Expected a function";
var nativeMax = Math.max, nativeMin = Math.min;
function debounce$2(func, wait, options) {
  var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  wait = toNumber(wait) || 0;
  if (isObject$2(options)) {
    leading = !!options.leading;
    maxing = "maxWait" in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = "trailing" in options ? !!options.trailing : trailing;
  }
  function invokeFunc(time) {
    var args = lastArgs, thisArg = lastThis;
    lastArgs = lastThis = void 0;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }
  function leadingEdge(time) {
    lastInvokeTime = time;
    timerId = setTimeout(timerExpired, wait);
    return leading ? invokeFunc(time) : result;
  }
  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
    return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
  }
  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
    return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
  }
  function timerExpired() {
    var time = now$1();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    timerId = setTimeout(timerExpired, remainingWait(time));
  }
  function trailingEdge(time) {
    timerId = void 0;
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = void 0;
    return result;
  }
  function cancel2() {
    if (timerId !== void 0) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = void 0;
  }
  function flush() {
    return timerId === void 0 ? result : trailingEdge(now$1());
  }
  function debounced() {
    var time = now$1(), isInvoking = shouldInvoke(time);
    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;
    if (isInvoking) {
      if (timerId === void 0) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        clearTimeout(timerId);
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === void 0) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel2;
  debounced.flush = flush;
  return debounced;
}
var debounce_1 = debounce$2;
function removeFromCheckedKeys(halfCheckedKeys, checkedKeys) {
  var filteredKeys = /* @__PURE__ */ new Set();
  halfCheckedKeys.forEach(function(key2) {
    if (!checkedKeys.has(key2)) {
      filteredKeys.add(key2);
    }
  });
  return filteredKeys;
}
function isCheckDisabled(node) {
  var _ref = node || {}, disabled = _ref.disabled, disableCheckbox = _ref.disableCheckbox, checkable = _ref.checkable;
  return !!(disabled || disableCheckbox) || checkable === false;
}
function fillConductCheck(keys2, levelEntities, maxLevel, syntheticGetCheckDisabled) {
  var checkedKeys = new Set(keys2);
  var halfCheckedKeys = /* @__PURE__ */ new Set();
  for (var level = 0; level <= maxLevel; level += 1) {
    var entities = levelEntities.get(level) || /* @__PURE__ */ new Set();
    entities.forEach(function(entity) {
      var key2 = entity.key, node = entity.node, _entity$children = entity.children, children = _entity$children === void 0 ? [] : _entity$children;
      if (checkedKeys.has(key2) && !syntheticGetCheckDisabled(node)) {
        children.filter(function(childEntity) {
          return !syntheticGetCheckDisabled(childEntity.node);
        }).forEach(function(childEntity) {
          checkedKeys.add(childEntity.key);
        });
      }
    });
  }
  var visitedKeys = /* @__PURE__ */ new Set();
  for (var _level = maxLevel; _level >= 0; _level -= 1) {
    var _entities = levelEntities.get(_level) || /* @__PURE__ */ new Set();
    _entities.forEach(function(entity) {
      var parent = entity.parent, node = entity.node;
      if (syntheticGetCheckDisabled(node) || !entity.parent || visitedKeys.has(entity.parent.key)) {
        return;
      }
      if (syntheticGetCheckDisabled(entity.parent.node)) {
        visitedKeys.add(parent.key);
        return;
      }
      var allChecked = true;
      var partialChecked = false;
      (parent.children || []).filter(function(childEntity) {
        return !syntheticGetCheckDisabled(childEntity.node);
      }).forEach(function(_ref2) {
        var key2 = _ref2.key;
        var checked = checkedKeys.has(key2);
        if (allChecked && !checked) {
          allChecked = false;
        }
        if (!partialChecked && (checked || halfCheckedKeys.has(key2))) {
          partialChecked = true;
        }
      });
      if (allChecked) {
        checkedKeys.add(parent.key);
      }
      if (partialChecked) {
        halfCheckedKeys.add(parent.key);
      }
      visitedKeys.add(parent.key);
    });
  }
  return {
    checkedKeys: Array.from(checkedKeys),
    halfCheckedKeys: Array.from(removeFromCheckedKeys(halfCheckedKeys, checkedKeys))
  };
}
function cleanConductCheck(keys2, halfKeys, levelEntities, maxLevel, syntheticGetCheckDisabled) {
  var checkedKeys = new Set(keys2);
  var halfCheckedKeys = new Set(halfKeys);
  for (var level = 0; level <= maxLevel; level += 1) {
    var entities = levelEntities.get(level) || /* @__PURE__ */ new Set();
    entities.forEach(function(entity) {
      var key2 = entity.key, node = entity.node, _entity$children2 = entity.children, children = _entity$children2 === void 0 ? [] : _entity$children2;
      if (!checkedKeys.has(key2) && !halfCheckedKeys.has(key2) && !syntheticGetCheckDisabled(node)) {
        children.filter(function(childEntity) {
          return !syntheticGetCheckDisabled(childEntity.node);
        }).forEach(function(childEntity) {
          checkedKeys.delete(childEntity.key);
        });
      }
    });
  }
  halfCheckedKeys = /* @__PURE__ */ new Set();
  var visitedKeys = /* @__PURE__ */ new Set();
  for (var _level2 = maxLevel; _level2 >= 0; _level2 -= 1) {
    var _entities2 = levelEntities.get(_level2) || /* @__PURE__ */ new Set();
    _entities2.forEach(function(entity) {
      var parent = entity.parent, node = entity.node;
      if (syntheticGetCheckDisabled(node) || !entity.parent || visitedKeys.has(entity.parent.key)) {
        return;
      }
      if (syntheticGetCheckDisabled(entity.parent.node)) {
        visitedKeys.add(parent.key);
        return;
      }
      var allChecked = true;
      var partialChecked = false;
      (parent.children || []).filter(function(childEntity) {
        return !syntheticGetCheckDisabled(childEntity.node);
      }).forEach(function(_ref3) {
        var key2 = _ref3.key;
        var checked = checkedKeys.has(key2);
        if (allChecked && !checked) {
          allChecked = false;
        }
        if (!partialChecked && (checked || halfCheckedKeys.has(key2))) {
          partialChecked = true;
        }
      });
      if (!allChecked) {
        checkedKeys.delete(parent.key);
      }
      if (partialChecked) {
        halfCheckedKeys.add(parent.key);
      }
      visitedKeys.add(parent.key);
    });
  }
  return {
    checkedKeys: Array.from(checkedKeys),
    halfCheckedKeys: Array.from(removeFromCheckedKeys(halfCheckedKeys, checkedKeys))
  };
}
function conductCheck(keyList, checked, keyEntities, getCheckDisabled) {
  var warningMissKeys = [];
  var syntheticGetCheckDisabled;
  if (getCheckDisabled) {
    syntheticGetCheckDisabled = getCheckDisabled;
  } else {
    syntheticGetCheckDisabled = isCheckDisabled;
  }
  var keys2 = new Set(keyList.filter(function(key2) {
    var hasEntity = !!keyEntities[key2];
    if (!hasEntity) {
      warningMissKeys.push(key2);
    }
    return hasEntity;
  }));
  var levelEntities = /* @__PURE__ */ new Map();
  var maxLevel = 0;
  Object.keys(keyEntities).forEach(function(key2) {
    var entity = keyEntities[key2];
    var level = entity.level;
    var levelSet = levelEntities.get(level);
    if (!levelSet) {
      levelSet = /* @__PURE__ */ new Set();
      levelEntities.set(level, levelSet);
    }
    levelSet.add(entity);
    maxLevel = Math.max(maxLevel, level);
  });
  warningOnce(!warningMissKeys.length, "Tree missing follow keys: ".concat(warningMissKeys.slice(0, 100).map(function(key2) {
    return "'".concat(key2, "'");
  }).join(", ")));
  var result;
  if (checked === true) {
    result = fillConductCheck(keys2, levelEntities, maxLevel, syntheticGetCheckDisabled);
  } else {
    result = cleanConductCheck(keys2, checked.halfCheckedKeys, levelEntities, maxLevel, syntheticGetCheckDisabled);
  }
  return result;
}
var TreeContext = /* @__PURE__ */ react.exports.createContext(null);
var Indent = function Indent2(_ref) {
  var prefixCls = _ref.prefixCls, level = _ref.level, isStart = _ref.isStart, isEnd = _ref.isEnd;
  var baseClassName = "".concat(prefixCls, "-indent-unit");
  var list = [];
  for (var i2 = 0; i2 < level; i2 += 1) {
    var _classNames;
    list.push(/* @__PURE__ */ react.exports.createElement("span", {
      key: i2,
      className: classNames(baseClassName, (_classNames = {}, _defineProperty$4(_classNames, "".concat(baseClassName, "-start"), isStart[i2]), _defineProperty$4(_classNames, "".concat(baseClassName, "-end"), isEnd[i2]), _classNames))
    }));
  }
  return /* @__PURE__ */ react.exports.createElement("span", {
    "aria-hidden": "true",
    className: "".concat(prefixCls, "-indent")
  }, list);
};
var Indent$1 = /* @__PURE__ */ react.exports.memo(Indent);
var _excluded$d = ["eventKey", "className", "style", "dragOver", "dragOverGapTop", "dragOverGapBottom", "isLeaf", "isStart", "isEnd", "expanded", "selected", "checked", "halfChecked", "loading", "domRef", "active", "data", "onMouseMove", "selectable"];
var ICON_OPEN = "open";
var ICON_CLOSE = "close";
var defaultTitle = "---";
var InternalTreeNode = /* @__PURE__ */ function(_React$Component) {
  _inherits$1(InternalTreeNode2, _React$Component);
  var _super = _createSuper$1(InternalTreeNode2);
  function InternalTreeNode2() {
    var _this;
    _classCallCheck$2(this, InternalTreeNode2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _this.state = {
      dragNodeHighlight: false
    };
    _this.selectHandle = void 0;
    _this.onSelectorClick = function(e3) {
      var onNodeClick = _this.props.context.onNodeClick;
      onNodeClick(e3, convertNodePropsToEventData(_this.props));
      if (_this.isSelectable()) {
        _this.onSelect(e3);
      } else {
        _this.onCheck(e3);
      }
    };
    _this.onSelectorDoubleClick = function(e3) {
      var onNodeDoubleClick = _this.props.context.onNodeDoubleClick;
      onNodeDoubleClick(e3, convertNodePropsToEventData(_this.props));
    };
    _this.onSelect = function(e3) {
      if (_this.isDisabled())
        return;
      var onNodeSelect = _this.props.context.onNodeSelect;
      e3.preventDefault();
      onNodeSelect(e3, convertNodePropsToEventData(_this.props));
    };
    _this.onCheck = function(e3) {
      if (_this.isDisabled())
        return;
      var _this$props = _this.props, disableCheckbox = _this$props.disableCheckbox, checked = _this$props.checked;
      var onNodeCheck = _this.props.context.onNodeCheck;
      if (!_this.isCheckable() || disableCheckbox)
        return;
      e3.preventDefault();
      var targetChecked = !checked;
      onNodeCheck(e3, convertNodePropsToEventData(_this.props), targetChecked);
    };
    _this.onMouseEnter = function(e3) {
      var onNodeMouseEnter = _this.props.context.onNodeMouseEnter;
      onNodeMouseEnter(e3, convertNodePropsToEventData(_this.props));
    };
    _this.onMouseLeave = function(e3) {
      var onNodeMouseLeave = _this.props.context.onNodeMouseLeave;
      onNodeMouseLeave(e3, convertNodePropsToEventData(_this.props));
    };
    _this.onContextMenu = function(e3) {
      var onNodeContextMenu = _this.props.context.onNodeContextMenu;
      onNodeContextMenu(e3, convertNodePropsToEventData(_this.props));
    };
    _this.onDragStart = function(e3) {
      var onNodeDragStart = _this.props.context.onNodeDragStart;
      e3.stopPropagation();
      _this.setState({
        dragNodeHighlight: true
      });
      onNodeDragStart(e3, _assertThisInitialized$1(_this));
      try {
        e3.dataTransfer.setData("text/plain", "");
      } catch (error) {
      }
    };
    _this.onDragEnter = function(e3) {
      var onNodeDragEnter = _this.props.context.onNodeDragEnter;
      e3.preventDefault();
      e3.stopPropagation();
      onNodeDragEnter(e3, _assertThisInitialized$1(_this));
    };
    _this.onDragOver = function(e3) {
      var onNodeDragOver = _this.props.context.onNodeDragOver;
      e3.preventDefault();
      e3.stopPropagation();
      onNodeDragOver(e3, _assertThisInitialized$1(_this));
    };
    _this.onDragLeave = function(e3) {
      var onNodeDragLeave = _this.props.context.onNodeDragLeave;
      e3.stopPropagation();
      onNodeDragLeave(e3, _assertThisInitialized$1(_this));
    };
    _this.onDragEnd = function(e3) {
      var onNodeDragEnd = _this.props.context.onNodeDragEnd;
      e3.stopPropagation();
      _this.setState({
        dragNodeHighlight: false
      });
      onNodeDragEnd(e3, _assertThisInitialized$1(_this));
    };
    _this.onDrop = function(e3) {
      var onNodeDrop = _this.props.context.onNodeDrop;
      e3.preventDefault();
      e3.stopPropagation();
      _this.setState({
        dragNodeHighlight: false
      });
      onNodeDrop(e3, _assertThisInitialized$1(_this));
    };
    _this.onExpand = function(e3) {
      var _this$props2 = _this.props, loading = _this$props2.loading, onNodeExpand = _this$props2.context.onNodeExpand;
      if (loading)
        return;
      onNodeExpand(e3, convertNodePropsToEventData(_this.props));
    };
    _this.setSelectHandle = function(node) {
      _this.selectHandle = node;
    };
    _this.getNodeState = function() {
      var expanded = _this.props.expanded;
      if (_this.isLeaf()) {
        return null;
      }
      return expanded ? ICON_OPEN : ICON_CLOSE;
    };
    _this.hasChildren = function() {
      var eventKey = _this.props.eventKey;
      var keyEntities = _this.props.context.keyEntities;
      var _ref = keyEntities[eventKey] || {}, children = _ref.children;
      return !!(children || []).length;
    };
    _this.isLeaf = function() {
      var _this$props3 = _this.props, isLeaf = _this$props3.isLeaf, loaded = _this$props3.loaded;
      var loadData = _this.props.context.loadData;
      var hasChildren = _this.hasChildren();
      if (isLeaf === false) {
        return false;
      }
      return isLeaf || !loadData && !hasChildren || loadData && loaded && !hasChildren;
    };
    _this.isDisabled = function() {
      var disabled = _this.props.disabled;
      var treeDisabled = _this.props.context.disabled;
      return !!(treeDisabled || disabled);
    };
    _this.isCheckable = function() {
      var checkable = _this.props.checkable;
      var treeCheckable = _this.props.context.checkable;
      if (!treeCheckable || checkable === false)
        return false;
      return treeCheckable;
    };
    _this.syncLoadData = function(props) {
      var expanded = props.expanded, loading = props.loading, loaded = props.loaded;
      var _this$props$context = _this.props.context, loadData = _this$props$context.loadData, onNodeLoad = _this$props$context.onNodeLoad;
      if (loading) {
        return;
      }
      if (loadData && expanded && !_this.isLeaf()) {
        if (!_this.hasChildren() && !loaded) {
          onNodeLoad(convertNodePropsToEventData(_this.props));
        }
      }
    };
    _this.isDraggable = function() {
      var _this$props4 = _this.props, data2 = _this$props4.data, draggable = _this$props4.context.draggable;
      return !!(draggable && (!draggable.nodeDraggable || draggable.nodeDraggable(data2)));
    };
    _this.renderDragHandler = function() {
      var _this$props$context2 = _this.props.context, draggable = _this$props$context2.draggable, prefixCls = _this$props$context2.prefixCls;
      return (draggable === null || draggable === void 0 ? void 0 : draggable.icon) ? /* @__PURE__ */ react.exports.createElement("span", {
        className: "".concat(prefixCls, "-draggable-icon")
      }, draggable.icon) : null;
    };
    _this.renderSwitcherIconDom = function(isLeaf) {
      var switcherIconFromProps = _this.props.switcherIcon;
      var switcherIconFromCtx = _this.props.context.switcherIcon;
      var switcherIcon = switcherIconFromProps || switcherIconFromCtx;
      if (typeof switcherIcon === "function") {
        return switcherIcon(_objectSpread2$1(_objectSpread2$1({}, _this.props), {}, {
          isLeaf
        }));
      }
      return switcherIcon;
    };
    _this.renderSwitcher = function() {
      var expanded = _this.props.expanded;
      var prefixCls = _this.props.context.prefixCls;
      if (_this.isLeaf()) {
        var _switcherIconDom = _this.renderSwitcherIconDom(true);
        return _switcherIconDom !== false ? /* @__PURE__ */ react.exports.createElement("span", {
          className: classNames("".concat(prefixCls, "-switcher"), "".concat(prefixCls, "-switcher-noop"))
        }, _switcherIconDom) : null;
      }
      var switcherCls = classNames("".concat(prefixCls, "-switcher"), "".concat(prefixCls, "-switcher_").concat(expanded ? ICON_OPEN : ICON_CLOSE));
      var switcherIconDom = _this.renderSwitcherIconDom(false);
      return switcherIconDom !== false ? /* @__PURE__ */ react.exports.createElement("span", {
        onClick: _this.onExpand,
        className: switcherCls
      }, switcherIconDom) : null;
    };
    _this.renderCheckbox = function() {
      var _this$props5 = _this.props, checked = _this$props5.checked, halfChecked = _this$props5.halfChecked, disableCheckbox = _this$props5.disableCheckbox;
      var prefixCls = _this.props.context.prefixCls;
      var disabled = _this.isDisabled();
      var checkable = _this.isCheckable();
      if (!checkable)
        return null;
      var $custom = typeof checkable !== "boolean" ? checkable : null;
      return /* @__PURE__ */ react.exports.createElement("span", {
        className: classNames("".concat(prefixCls, "-checkbox"), checked && "".concat(prefixCls, "-checkbox-checked"), !checked && halfChecked && "".concat(prefixCls, "-checkbox-indeterminate"), (disabled || disableCheckbox) && "".concat(prefixCls, "-checkbox-disabled")),
        onClick: _this.onCheck
      }, $custom);
    };
    _this.renderIcon = function() {
      var loading = _this.props.loading;
      var prefixCls = _this.props.context.prefixCls;
      return /* @__PURE__ */ react.exports.createElement("span", {
        className: classNames("".concat(prefixCls, "-iconEle"), "".concat(prefixCls, "-icon__").concat(_this.getNodeState() || "docu"), loading && "".concat(prefixCls, "-icon_loading"))
      });
    };
    _this.renderSelector = function() {
      var dragNodeHighlight = _this.state.dragNodeHighlight;
      var _this$props6 = _this.props, title = _this$props6.title, selected = _this$props6.selected, icon = _this$props6.icon, loading = _this$props6.loading, data2 = _this$props6.data;
      var _this$props$context3 = _this.props.context, prefixCls = _this$props$context3.prefixCls, showIcon = _this$props$context3.showIcon, treeIcon = _this$props$context3.icon, loadData = _this$props$context3.loadData, titleRender = _this$props$context3.titleRender;
      var disabled = _this.isDisabled();
      var wrapClass = "".concat(prefixCls, "-node-content-wrapper");
      var $icon;
      if (showIcon) {
        var currentIcon = icon || treeIcon;
        $icon = currentIcon ? /* @__PURE__ */ react.exports.createElement("span", {
          className: classNames("".concat(prefixCls, "-iconEle"), "".concat(prefixCls, "-icon__customize"))
        }, typeof currentIcon === "function" ? currentIcon(_this.props) : currentIcon) : _this.renderIcon();
      } else if (loadData && loading) {
        $icon = _this.renderIcon();
      }
      var titleNode;
      if (typeof title === "function") {
        titleNode = title(data2);
      } else if (titleRender) {
        titleNode = titleRender(data2);
      } else {
        titleNode = title;
      }
      var $title = /* @__PURE__ */ react.exports.createElement("span", {
        className: "".concat(prefixCls, "-title")
      }, titleNode);
      return /* @__PURE__ */ react.exports.createElement("span", {
        ref: _this.setSelectHandle,
        title: typeof title === "string" ? title : "",
        className: classNames("".concat(wrapClass), "".concat(wrapClass, "-").concat(_this.getNodeState() || "normal"), !disabled && (selected || dragNodeHighlight) && "".concat(prefixCls, "-node-selected")),
        onMouseEnter: _this.onMouseEnter,
        onMouseLeave: _this.onMouseLeave,
        onContextMenu: _this.onContextMenu,
        onClick: _this.onSelectorClick,
        onDoubleClick: _this.onSelectorDoubleClick
      }, $icon, $title, _this.renderDropIndicator());
    };
    _this.renderDropIndicator = function() {
      var _this$props7 = _this.props, disabled = _this$props7.disabled, eventKey = _this$props7.eventKey;
      var _this$props$context4 = _this.props.context, draggable = _this$props$context4.draggable, dropLevelOffset = _this$props$context4.dropLevelOffset, dropPosition = _this$props$context4.dropPosition, prefixCls = _this$props$context4.prefixCls, indent = _this$props$context4.indent, dropIndicatorRender2 = _this$props$context4.dropIndicatorRender, dragOverNodeKey = _this$props$context4.dragOverNodeKey, direction2 = _this$props$context4.direction;
      var rootDraggable = draggable !== false;
      var showIndicator = !disabled && rootDraggable && dragOverNodeKey === eventKey;
      return showIndicator ? dropIndicatorRender2({
        dropPosition,
        dropLevelOffset,
        indent,
        prefixCls,
        direction: direction2
      }) : null;
    };
    return _this;
  }
  _createClass$2(InternalTreeNode2, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this.syncLoadData(this.props);
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate() {
      this.syncLoadData(this.props);
    }
  }, {
    key: "isSelectable",
    value: function isSelectable() {
      var selectable = this.props.selectable;
      var treeSelectable = this.props.context.selectable;
      if (typeof selectable === "boolean") {
        return selectable;
      }
      return treeSelectable;
    }
  }, {
    key: "render",
    value: function render2() {
      var _classNames;
      var _this$props8 = this.props, eventKey = _this$props8.eventKey, className = _this$props8.className, style2 = _this$props8.style, dragOver = _this$props8.dragOver, dragOverGapTop = _this$props8.dragOverGapTop, dragOverGapBottom = _this$props8.dragOverGapBottom, isLeaf = _this$props8.isLeaf, isStart = _this$props8.isStart, isEnd = _this$props8.isEnd, expanded = _this$props8.expanded, selected = _this$props8.selected, checked = _this$props8.checked, halfChecked = _this$props8.halfChecked, loading = _this$props8.loading, domRef = _this$props8.domRef, active = _this$props8.active;
      _this$props8.data;
      var onMouseMove = _this$props8.onMouseMove, selectable = _this$props8.selectable, otherProps = _objectWithoutProperties$1(_this$props8, _excluded$d);
      var _this$props$context5 = this.props.context, prefixCls = _this$props$context5.prefixCls, filterTreeNode = _this$props$context5.filterTreeNode, keyEntities = _this$props$context5.keyEntities, dropContainerKey = _this$props$context5.dropContainerKey, dropTargetKey = _this$props$context5.dropTargetKey, draggingNodeKey = _this$props$context5.draggingNodeKey;
      var disabled = this.isDisabled();
      var dataOrAriaAttributeProps = pickAttrs(otherProps, {
        aria: true,
        data: true
      });
      var _ref2 = keyEntities[eventKey] || {}, level = _ref2.level;
      var isEndNode = isEnd[isEnd.length - 1];
      var mergedDraggable = this.isDraggable();
      var draggableWithoutDisabled = !disabled && mergedDraggable;
      var dragging = draggingNodeKey === eventKey;
      var ariaSelected = selectable !== void 0 ? {
        "aria-selected": !!selectable
      } : void 0;
      return /* @__PURE__ */ react.exports.createElement("div", _extends$2({
        ref: domRef,
        className: classNames(className, "".concat(prefixCls, "-treenode"), (_classNames = {}, _defineProperty$4(_classNames, "".concat(prefixCls, "-treenode-disabled"), disabled), _defineProperty$4(_classNames, "".concat(prefixCls, "-treenode-switcher-").concat(expanded ? "open" : "close"), !isLeaf), _defineProperty$4(_classNames, "".concat(prefixCls, "-treenode-checkbox-checked"), checked), _defineProperty$4(_classNames, "".concat(prefixCls, "-treenode-checkbox-indeterminate"), halfChecked), _defineProperty$4(_classNames, "".concat(prefixCls, "-treenode-selected"), selected), _defineProperty$4(_classNames, "".concat(prefixCls, "-treenode-loading"), loading), _defineProperty$4(_classNames, "".concat(prefixCls, "-treenode-active"), active), _defineProperty$4(_classNames, "".concat(prefixCls, "-treenode-leaf-last"), isEndNode), _defineProperty$4(_classNames, "".concat(prefixCls, "-treenode-draggable"), mergedDraggable), _defineProperty$4(_classNames, "dragging", dragging), _defineProperty$4(_classNames, "drop-target", dropTargetKey === eventKey), _defineProperty$4(_classNames, "drop-container", dropContainerKey === eventKey), _defineProperty$4(_classNames, "drag-over", !disabled && dragOver), _defineProperty$4(_classNames, "drag-over-gap-top", !disabled && dragOverGapTop), _defineProperty$4(_classNames, "drag-over-gap-bottom", !disabled && dragOverGapBottom), _defineProperty$4(_classNames, "filter-node", filterTreeNode && filterTreeNode(convertNodePropsToEventData(this.props))), _classNames)),
        style: style2,
        draggable: draggableWithoutDisabled,
        "aria-grabbed": dragging,
        onDragStart: draggableWithoutDisabled ? this.onDragStart : void 0,
        onDragEnter: mergedDraggable ? this.onDragEnter : void 0,
        onDragOver: mergedDraggable ? this.onDragOver : void 0,
        onDragLeave: mergedDraggable ? this.onDragLeave : void 0,
        onDrop: mergedDraggable ? this.onDrop : void 0,
        onDragEnd: mergedDraggable ? this.onDragEnd : void 0,
        onMouseMove
      }, ariaSelected, dataOrAriaAttributeProps), /* @__PURE__ */ react.exports.createElement(Indent$1, {
        prefixCls,
        level,
        isStart,
        isEnd
      }), this.renderDragHandler(), this.renderSwitcher(), this.renderCheckbox(), this.renderSelector());
    }
  }]);
  return InternalTreeNode2;
}(react.exports.Component);
var ContextTreeNode = function ContextTreeNode2(props) {
  return /* @__PURE__ */ react.exports.createElement(TreeContext.Consumer, null, function(context2) {
    return /* @__PURE__ */ react.exports.createElement(InternalTreeNode, _extends$2({}, props, {
      context: context2
    }));
  });
};
ContextTreeNode.displayName = "TreeNode";
ContextTreeNode.defaultProps = {
  title: defaultTitle
};
ContextTreeNode.isTreeNode = 1;
function arrDel(list, value2) {
  if (!list)
    return [];
  var clone3 = list.slice();
  var index2 = clone3.indexOf(value2);
  if (index2 >= 0) {
    clone3.splice(index2, 1);
  }
  return clone3;
}
function arrAdd(list, value2) {
  var clone3 = (list || []).slice();
  if (clone3.indexOf(value2) === -1) {
    clone3.push(value2);
  }
  return clone3;
}
function posToArr(pos) {
  return pos.split("-");
}
function getPosition(level, index2) {
  return "".concat(level, "-").concat(index2);
}
function isTreeNode(node) {
  return node && node.type && node.type.isTreeNode;
}
function getDragChildrenKeys(dragNodeKey, keyEntities) {
  var dragChildrenKeys = [];
  var entity = keyEntities[dragNodeKey];
  function dig() {
    var list = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    list.forEach(function(_ref) {
      var key2 = _ref.key, children = _ref.children;
      dragChildrenKeys.push(key2);
      dig(children);
    });
  }
  dig(entity.children);
  return dragChildrenKeys;
}
function isLastChild(treeNodeEntity) {
  if (treeNodeEntity.parent) {
    var posArr = posToArr(treeNodeEntity.pos);
    return Number(posArr[posArr.length - 1]) === treeNodeEntity.parent.children.length - 1;
  }
  return false;
}
function isFirstChild(treeNodeEntity) {
  var posArr = posToArr(treeNodeEntity.pos);
  return Number(posArr[posArr.length - 1]) === 0;
}
function calcDropPosition(event, dragNode, targetNode, indent, startMousePosition, allowDrop2, flattenedNodes, keyEntities, expandKeys, direction2) {
  var _abstractDropNodeEnti;
  var clientX = event.clientX, clientY = event.clientY;
  var _event$target$getBoun = event.target.getBoundingClientRect(), top = _event$target$getBoun.top, height = _event$target$getBoun.height;
  var horizontalMouseOffset = (direction2 === "rtl" ? -1 : 1) * (((startMousePosition === null || startMousePosition === void 0 ? void 0 : startMousePosition.x) || 0) - clientX);
  var rawDropLevelOffset = (horizontalMouseOffset - 12) / indent;
  var abstractDropNodeEntity = keyEntities[targetNode.props.eventKey];
  if (clientY < top + height / 2) {
    var nodeIndex = flattenedNodes.findIndex(function(flattenedNode) {
      return flattenedNode.key === abstractDropNodeEntity.key;
    });
    var prevNodeIndex = nodeIndex <= 0 ? 0 : nodeIndex - 1;
    var prevNodeKey = flattenedNodes[prevNodeIndex].key;
    abstractDropNodeEntity = keyEntities[prevNodeKey];
  }
  var initialAbstractDropNodeKey = abstractDropNodeEntity.key;
  var abstractDragOverEntity = abstractDropNodeEntity;
  var dragOverNodeKey = abstractDropNodeEntity.key;
  var dropPosition = 0;
  var dropLevelOffset = 0;
  if (!expandKeys.includes(initialAbstractDropNodeKey)) {
    for (var i2 = 0; i2 < rawDropLevelOffset; i2 += 1) {
      if (isLastChild(abstractDropNodeEntity)) {
        abstractDropNodeEntity = abstractDropNodeEntity.parent;
        dropLevelOffset += 1;
      } else {
        break;
      }
    }
  }
  var abstractDragDataNode = dragNode.props.data;
  var abstractDropDataNode = abstractDropNodeEntity.node;
  var dropAllowed = true;
  if (isFirstChild(abstractDropNodeEntity) && abstractDropNodeEntity.level === 0 && clientY < top + height / 2 && allowDrop2({
    dragNode: abstractDragDataNode,
    dropNode: abstractDropDataNode,
    dropPosition: -1
  }) && abstractDropNodeEntity.key === targetNode.props.eventKey) {
    dropPosition = -1;
  } else if ((abstractDragOverEntity.children || []).length && expandKeys.includes(dragOverNodeKey)) {
    if (allowDrop2({
      dragNode: abstractDragDataNode,
      dropNode: abstractDropDataNode,
      dropPosition: 0
    })) {
      dropPosition = 0;
    } else {
      dropAllowed = false;
    }
  } else if (dropLevelOffset === 0) {
    if (rawDropLevelOffset > -1.5) {
      if (allowDrop2({
        dragNode: abstractDragDataNode,
        dropNode: abstractDropDataNode,
        dropPosition: 1
      })) {
        dropPosition = 1;
      } else {
        dropAllowed = false;
      }
    } else {
      if (allowDrop2({
        dragNode: abstractDragDataNode,
        dropNode: abstractDropDataNode,
        dropPosition: 0
      })) {
        dropPosition = 0;
      } else if (allowDrop2({
        dragNode: abstractDragDataNode,
        dropNode: abstractDropDataNode,
        dropPosition: 1
      })) {
        dropPosition = 1;
      } else {
        dropAllowed = false;
      }
    }
  } else {
    if (allowDrop2({
      dragNode: abstractDragDataNode,
      dropNode: abstractDropDataNode,
      dropPosition: 1
    })) {
      dropPosition = 1;
    } else {
      dropAllowed = false;
    }
  }
  return {
    dropPosition,
    dropLevelOffset,
    dropTargetKey: abstractDropNodeEntity.key,
    dropTargetPos: abstractDropNodeEntity.pos,
    dragOverNodeKey,
    dropContainerKey: dropPosition === 0 ? null : ((_abstractDropNodeEnti = abstractDropNodeEntity.parent) === null || _abstractDropNodeEnti === void 0 ? void 0 : _abstractDropNodeEnti.key) || null,
    dropAllowed
  };
}
function calcSelectedKeys(selectedKeys, props) {
  if (!selectedKeys)
    return void 0;
  var multiple = props.multiple;
  if (multiple) {
    return selectedKeys.slice();
  }
  if (selectedKeys.length) {
    return [selectedKeys[0]];
  }
  return selectedKeys;
}
function parseCheckedKeys(keys2) {
  if (!keys2) {
    return null;
  }
  var keyProps;
  if (Array.isArray(keys2)) {
    keyProps = {
      checkedKeys: keys2,
      halfCheckedKeys: void 0
    };
  } else if (_typeof$4(keys2) === "object") {
    keyProps = {
      checkedKeys: keys2.checked || void 0,
      halfCheckedKeys: keys2.halfChecked || void 0
    };
  } else {
    warningOnce(false, "`checkedKeys` is not an array or an object");
    return null;
  }
  return keyProps;
}
function conductExpandParent(keyList, keyEntities) {
  var expandedKeys = /* @__PURE__ */ new Set();
  function conductUp(key2) {
    if (expandedKeys.has(key2))
      return;
    var entity = keyEntities[key2];
    if (!entity)
      return;
    expandedKeys.add(key2);
    var parent = entity.parent, node = entity.node;
    if (node.disabled)
      return;
    if (parent) {
      conductUp(parent.key);
    }
  }
  (keyList || []).forEach(function(key2) {
    conductUp(key2);
  });
  return _toConsumableArray(expandedKeys);
}
var _excluded$c = ["children"];
function getKey(key2, pos) {
  if (key2 !== null && key2 !== void 0) {
    return key2;
  }
  return pos;
}
function fillFieldNames(fieldNames) {
  var _ref = fieldNames || {}, title = _ref.title, _title = _ref._title, key2 = _ref.key, children = _ref.children;
  var mergedTitle = title || "title";
  return {
    title: mergedTitle,
    _title: _title || [mergedTitle],
    key: key2 || "key",
    children: children || "children"
  };
}
function convertTreeToData(rootNodes) {
  function dig(node) {
    var treeNodes = toArray$5(node);
    return treeNodes.map(function(treeNode) {
      if (!isTreeNode(treeNode)) {
        warningOnce(!treeNode, "Tree/TreeNode can only accept TreeNode as children.");
        return null;
      }
      var key2 = treeNode.key;
      var _treeNode$props = treeNode.props, children = _treeNode$props.children, rest = _objectWithoutProperties$1(_treeNode$props, _excluded$c);
      var dataNode = _objectSpread2$1({
        key: key2
      }, rest);
      var parsedChildren = dig(children);
      if (parsedChildren.length) {
        dataNode.children = parsedChildren;
      }
      return dataNode;
    }).filter(function(dataNode) {
      return dataNode;
    });
  }
  return dig(rootNodes);
}
function flattenTreeData(treeNodeList, expandedKeys, fieldNames) {
  var _fillFieldNames = fillFieldNames(fieldNames), fieldTitles = _fillFieldNames._title, fieldKey = _fillFieldNames.key, fieldChildren = _fillFieldNames.children;
  var expandedKeySet = new Set(expandedKeys === true ? [] : expandedKeys);
  var flattenList = [];
  function dig(list) {
    var parent = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    return list.map(function(treeNode, index2) {
      var pos = getPosition(parent ? parent.pos : "0", index2);
      var mergedKey = getKey(treeNode[fieldKey], pos);
      var mergedTitle;
      for (var i2 = 0; i2 < fieldTitles.length; i2 += 1) {
        var fieldTitle = fieldTitles[i2];
        if (treeNode[fieldTitle] !== void 0) {
          mergedTitle = treeNode[fieldTitle];
          break;
        }
      }
      var flattenNode = _objectSpread2$1(_objectSpread2$1({}, omit$2(treeNode, [].concat(_toConsumableArray(fieldTitles), [fieldKey, fieldChildren]))), {}, {
        title: mergedTitle,
        key: mergedKey,
        parent,
        pos,
        children: null,
        data: treeNode,
        isStart: [].concat(_toConsumableArray(parent ? parent.isStart : []), [index2 === 0]),
        isEnd: [].concat(_toConsumableArray(parent ? parent.isEnd : []), [index2 === list.length - 1])
      });
      flattenList.push(flattenNode);
      if (expandedKeys === true || expandedKeySet.has(mergedKey)) {
        flattenNode.children = dig(treeNode[fieldChildren] || [], flattenNode);
      } else {
        flattenNode.children = [];
      }
      return flattenNode;
    });
  }
  dig(treeNodeList);
  return flattenList;
}
function traverseDataNodes(dataNodes, callback, config) {
  var mergedConfig = {};
  if (_typeof$4(config) === "object") {
    mergedConfig = config;
  } else {
    mergedConfig = {
      externalGetKey: config
    };
  }
  mergedConfig = mergedConfig || {};
  var _mergedConfig = mergedConfig, childrenPropName = _mergedConfig.childrenPropName, externalGetKey = _mergedConfig.externalGetKey, fieldNames = _mergedConfig.fieldNames;
  var _fillFieldNames2 = fillFieldNames(fieldNames), fieldKey = _fillFieldNames2.key, fieldChildren = _fillFieldNames2.children;
  var mergeChildrenPropName = childrenPropName || fieldChildren;
  var syntheticGetKey;
  if (externalGetKey) {
    if (typeof externalGetKey === "string") {
      syntheticGetKey = function syntheticGetKey2(node) {
        return node[externalGetKey];
      };
    } else if (typeof externalGetKey === "function") {
      syntheticGetKey = function syntheticGetKey2(node) {
        return externalGetKey(node);
      };
    }
  } else {
    syntheticGetKey = function syntheticGetKey2(node, pos) {
      return getKey(node[fieldKey], pos);
    };
  }
  function processNode(node, index2, parent, pathNodes) {
    var children = node ? node[mergeChildrenPropName] : dataNodes;
    var pos = node ? getPosition(parent.pos, index2) : "0";
    var connectNodes = node ? [].concat(_toConsumableArray(pathNodes), [node]) : [];
    if (node) {
      var key2 = syntheticGetKey(node, pos);
      var data2 = {
        node,
        index: index2,
        pos,
        key: key2,
        parentPos: parent.node ? parent.pos : null,
        level: parent.level + 1,
        nodes: connectNodes
      };
      callback(data2);
    }
    if (children) {
      children.forEach(function(subNode, subIndex) {
        processNode(subNode, subIndex, {
          node,
          pos,
          level: parent ? parent.level + 1 : -1
        }, connectNodes);
      });
    }
  }
  processNode(null);
}
function convertDataToEntities(dataNodes) {
  var _ref2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, initWrapper = _ref2.initWrapper, processEntity = _ref2.processEntity, onProcessFinished = _ref2.onProcessFinished, externalGetKey = _ref2.externalGetKey, childrenPropName = _ref2.childrenPropName, fieldNames = _ref2.fieldNames;
  var legacyExternalGetKey = arguments.length > 2 ? arguments[2] : void 0;
  var mergedExternalGetKey = externalGetKey || legacyExternalGetKey;
  var posEntities = {};
  var keyEntities = {};
  var wrapper = {
    posEntities,
    keyEntities
  };
  if (initWrapper) {
    wrapper = initWrapper(wrapper) || wrapper;
  }
  traverseDataNodes(dataNodes, function(item) {
    var node = item.node, index2 = item.index, pos = item.pos, key2 = item.key, parentPos = item.parentPos, level = item.level, nodes = item.nodes;
    var entity = {
      node,
      nodes,
      index: index2,
      key: key2,
      pos,
      level
    };
    var mergedKey = getKey(key2, pos);
    posEntities[pos] = entity;
    keyEntities[mergedKey] = entity;
    entity.parent = posEntities[parentPos];
    if (entity.parent) {
      entity.parent.children = entity.parent.children || [];
      entity.parent.children.push(entity);
    }
    if (processEntity) {
      processEntity(entity, wrapper);
    }
  }, {
    externalGetKey: mergedExternalGetKey,
    childrenPropName,
    fieldNames
  });
  if (onProcessFinished) {
    onProcessFinished(wrapper);
  }
  return wrapper;
}
function getTreeNodeProps(key2, _ref3) {
  var expandedKeys = _ref3.expandedKeys, selectedKeys = _ref3.selectedKeys, loadedKeys = _ref3.loadedKeys, loadingKeys = _ref3.loadingKeys, checkedKeys = _ref3.checkedKeys, halfCheckedKeys = _ref3.halfCheckedKeys, dragOverNodeKey = _ref3.dragOverNodeKey, dropPosition = _ref3.dropPosition, keyEntities = _ref3.keyEntities;
  var entity = keyEntities[key2];
  var treeNodeProps = {
    eventKey: key2,
    expanded: expandedKeys.indexOf(key2) !== -1,
    selected: selectedKeys.indexOf(key2) !== -1,
    loaded: loadedKeys.indexOf(key2) !== -1,
    loading: loadingKeys.indexOf(key2) !== -1,
    checked: checkedKeys.indexOf(key2) !== -1,
    halfChecked: halfCheckedKeys.indexOf(key2) !== -1,
    pos: String(entity ? entity.pos : ""),
    dragOver: dragOverNodeKey === key2 && dropPosition === 0,
    dragOverGapTop: dragOverNodeKey === key2 && dropPosition === -1,
    dragOverGapBottom: dragOverNodeKey === key2 && dropPosition === 1
  };
  return treeNodeProps;
}
function convertNodePropsToEventData(props) {
  var data2 = props.data, expanded = props.expanded, selected = props.selected, checked = props.checked, loaded = props.loaded, loading = props.loading, halfChecked = props.halfChecked, dragOver = props.dragOver, dragOverGapTop = props.dragOverGapTop, dragOverGapBottom = props.dragOverGapBottom, pos = props.pos, active = props.active, eventKey = props.eventKey;
  var eventData = _objectSpread2$1(_objectSpread2$1({}, data2), {}, {
    expanded,
    selected,
    checked,
    loaded,
    loading,
    halfChecked,
    dragOver,
    dragOverGapTop,
    dragOverGapBottom,
    pos,
    active,
    key: eventKey
  });
  if (!("props" in eventData)) {
    Object.defineProperty(eventData, "props", {
      get: function get2() {
        warningOnce(false, "Second param return from event is node data instead of TreeNode instance. Please read value directly instead of reading from `props`.");
        return props;
      }
    });
  }
  return eventData;
}
var __rest$j = globalThis && globalThis.__rest || function(s2, e3) {
  var t2 = {};
  for (var p2 in s2) {
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  }
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e3.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
var GroupContext = /* @__PURE__ */ react.exports.createContext(null);
var InternalCheckboxGroup = function InternalCheckboxGroup2(_a2, ref) {
  var defaultValue = _a2.defaultValue, children = _a2.children, _a$options = _a2.options, options = _a$options === void 0 ? [] : _a$options, customizePrefixCls = _a2.prefixCls, className = _a2.className, style2 = _a2.style, onChange2 = _a2.onChange, restProps = __rest$j(_a2, ["defaultValue", "children", "options", "prefixCls", "className", "style", "onChange"]);
  var _React$useContext = react.exports.useContext(ConfigContext), getPrefixCls = _React$useContext.getPrefixCls, direction2 = _React$useContext.direction;
  var _React$useState = react.exports.useState(restProps.value || defaultValue || []), _React$useState2 = _slicedToArray$4(_React$useState, 2), value2 = _React$useState2[0], setValue2 = _React$useState2[1];
  var _React$useState3 = react.exports.useState([]), _React$useState4 = _slicedToArray$4(_React$useState3, 2), registeredValues = _React$useState4[0], setRegisteredValues = _React$useState4[1];
  react.exports.useEffect(function() {
    if ("value" in restProps) {
      setValue2(restProps.value || []);
    }
  }, [restProps.value]);
  var getOptions = function getOptions2() {
    return options.map(function(option) {
      if (typeof option === "string" || typeof option === "number") {
        return {
          label: option,
          value: option
        };
      }
      return option;
    });
  };
  var cancelValue = function cancelValue2(val) {
    setRegisteredValues(function(prevValues) {
      return prevValues.filter(function(v2) {
        return v2 !== val;
      });
    });
  };
  var registerValue = function registerValue2(val) {
    setRegisteredValues(function(prevValues) {
      return [].concat(_toConsumableArray(prevValues), [val]);
    });
  };
  var toggleOption = function toggleOption2(option) {
    var optionIndex = value2.indexOf(option.value);
    var newValue = _toConsumableArray(value2);
    if (optionIndex === -1) {
      newValue.push(option.value);
    } else {
      newValue.splice(optionIndex, 1);
    }
    if (!("value" in restProps)) {
      setValue2(newValue);
    }
    var opts = getOptions();
    onChange2 === null || onChange2 === void 0 ? void 0 : onChange2(newValue.filter(function(val) {
      return registeredValues.indexOf(val) !== -1;
    }).sort(function(a2, b10) {
      var indexA = opts.findIndex(function(opt) {
        return opt.value === a2;
      });
      var indexB = opts.findIndex(function(opt) {
        return opt.value === b10;
      });
      return indexA - indexB;
    }));
  };
  var prefixCls = getPrefixCls("checkbox", customizePrefixCls);
  var groupPrefixCls = "".concat(prefixCls, "-group");
  var domProps = omit$2(restProps, ["value", "disabled"]);
  if (options && options.length > 0) {
    children = getOptions().map(function(option) {
      return /* @__PURE__ */ react.exports.createElement(InternalCheckbox$1, {
        prefixCls,
        key: option.value.toString(),
        disabled: "disabled" in option ? option.disabled : restProps.disabled,
        value: option.value,
        checked: value2.indexOf(option.value) !== -1,
        onChange: option.onChange,
        className: "".concat(groupPrefixCls, "-item"),
        style: option.style
      }, option.label);
    });
  }
  var context2 = {
    toggleOption,
    value: value2,
    disabled: restProps.disabled,
    name: restProps.name,
    registerValue,
    cancelValue
  };
  var classString = classNames(groupPrefixCls, _defineProperty$4({}, "".concat(groupPrefixCls, "-rtl"), direction2 === "rtl"), className);
  return /* @__PURE__ */ react.exports.createElement("div", _extends$2({
    className: classString,
    style: style2
  }, domProps, {
    ref
  }), /* @__PURE__ */ react.exports.createElement(GroupContext.Provider, {
    value: context2
  }, children));
};
var CheckboxGroup = /* @__PURE__ */ react.exports.forwardRef(InternalCheckboxGroup);
var Group$5 = /* @__PURE__ */ react.exports.memo(CheckboxGroup);
var __rest$i = globalThis && globalThis.__rest || function(s2, e3) {
  var t2 = {};
  for (var p2 in s2) {
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  }
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e3.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
var InternalCheckbox = function InternalCheckbox2(_a2, ref) {
  var _classNames;
  var customizePrefixCls = _a2.prefixCls, className = _a2.className, children = _a2.children, _a$indeterminate = _a2.indeterminate, indeterminate = _a$indeterminate === void 0 ? false : _a$indeterminate, style2 = _a2.style, onMouseEnter = _a2.onMouseEnter, onMouseLeave = _a2.onMouseLeave, _a$skipGroup = _a2.skipGroup, skipGroup = _a$skipGroup === void 0 ? false : _a$skipGroup, disabled = _a2.disabled, restProps = __rest$i(_a2, ["prefixCls", "className", "children", "indeterminate", "style", "onMouseEnter", "onMouseLeave", "skipGroup", "disabled"]);
  var _React$useContext = react.exports.useContext(ConfigContext), getPrefixCls = _React$useContext.getPrefixCls, direction2 = _React$useContext.direction;
  var checkboxGroup = react.exports.useContext(GroupContext);
  var _useContext = react.exports.useContext(FormItemInputContext), isFormItemInput = _useContext.isFormItemInput;
  var contextDisabled = react.exports.useContext(DisabledContext$1);
  var mergedDisabled = disabled || (checkboxGroup === null || checkboxGroup === void 0 ? void 0 : checkboxGroup.disabled) || contextDisabled;
  var prevValue = react.exports.useRef(restProps.value);
  react.exports.useEffect(function() {
    checkboxGroup === null || checkboxGroup === void 0 ? void 0 : checkboxGroup.registerValue(restProps.value);
  }, []);
  react.exports.useEffect(function() {
    if (skipGroup) {
      return;
    }
    if (restProps.value !== prevValue.current) {
      checkboxGroup === null || checkboxGroup === void 0 ? void 0 : checkboxGroup.cancelValue(prevValue.current);
      checkboxGroup === null || checkboxGroup === void 0 ? void 0 : checkboxGroup.registerValue(restProps.value);
      prevValue.current = restProps.value;
    }
    return function() {
      return checkboxGroup === null || checkboxGroup === void 0 ? void 0 : checkboxGroup.cancelValue(restProps.value);
    };
  }, [restProps.value]);
  var prefixCls = getPrefixCls("checkbox", customizePrefixCls);
  var checkboxProps = _extends$2({}, restProps);
  if (checkboxGroup && !skipGroup) {
    checkboxProps.onChange = function() {
      if (restProps.onChange) {
        restProps.onChange.apply(restProps, arguments);
      }
      if (checkboxGroup.toggleOption) {
        checkboxGroup.toggleOption({
          label: children,
          value: restProps.value
        });
      }
    };
    checkboxProps.name = checkboxGroup.name;
    checkboxProps.checked = checkboxGroup.value.indexOf(restProps.value) !== -1;
  }
  var classString = classNames((_classNames = {}, _defineProperty$4(_classNames, "".concat(prefixCls, "-wrapper"), true), _defineProperty$4(_classNames, "".concat(prefixCls, "-rtl"), direction2 === "rtl"), _defineProperty$4(_classNames, "".concat(prefixCls, "-wrapper-checked"), checkboxProps.checked), _defineProperty$4(_classNames, "".concat(prefixCls, "-wrapper-disabled"), mergedDisabled), _defineProperty$4(_classNames, "".concat(prefixCls, "-wrapper-in-form-item"), isFormItemInput), _classNames), className);
  var checkboxClass = classNames(_defineProperty$4({}, "".concat(prefixCls, "-indeterminate"), indeterminate));
  var ariaChecked = indeterminate ? "mixed" : void 0;
  return /* @__PURE__ */ react.exports.createElement("label", {
    className: classString,
    style: style2,
    onMouseEnter,
    onMouseLeave
  }, /* @__PURE__ */ react.exports.createElement(Checkbox$3, _extends$2({
    "aria-checked": ariaChecked
  }, checkboxProps, {
    prefixCls,
    className: checkboxClass,
    disabled: mergedDisabled,
    ref
  })), children !== void 0 && /* @__PURE__ */ react.exports.createElement("span", null, children));
};
var Checkbox$2 = /* @__PURE__ */ react.exports.forwardRef(InternalCheckbox);
var InternalCheckbox$1 = Checkbox$2;
var Checkbox = InternalCheckbox$1;
Checkbox.Group = Group$5;
Checkbox.__ANT_CHECKBOX = true;
var Checkbox$1 = Checkbox;
var RowContext = /* @__PURE__ */ react.exports.createContext({});
var RowContext$1 = RowContext;
var __rest$h = globalThis && globalThis.__rest || function(s2, e3) {
  var t2 = {};
  for (var p2 in s2) {
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  }
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e3.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
function parseFlex(flex) {
  if (typeof flex === "number") {
    return "".concat(flex, " ").concat(flex, " auto");
  }
  if (/^\d+(\.\d+)?(px|em|rem|%)$/.test(flex)) {
    return "0 0 ".concat(flex);
  }
  return flex;
}
var sizes = ["xs", "sm", "md", "lg", "xl", "xxl"];
var Col = /* @__PURE__ */ react.exports.forwardRef(function(props, ref) {
  var _classNames;
  var _React$useContext = react.exports.useContext(ConfigContext), getPrefixCls = _React$useContext.getPrefixCls, direction2 = _React$useContext.direction;
  var _React$useContext2 = react.exports.useContext(RowContext$1), gutter = _React$useContext2.gutter, wrap = _React$useContext2.wrap, supportFlexGap = _React$useContext2.supportFlexGap;
  var customizePrefixCls = props.prefixCls, span = props.span, order = props.order, offset3 = props.offset, push = props.push, pull = props.pull, className = props.className, children = props.children, flex = props.flex, style2 = props.style, others = __rest$h(props, ["prefixCls", "span", "order", "offset", "push", "pull", "className", "children", "flex", "style"]);
  var prefixCls = getPrefixCls("col", customizePrefixCls);
  var sizeClassObj = {};
  sizes.forEach(function(size2) {
    var _extends2;
    var sizeProps = {};
    var propSize = props[size2];
    if (typeof propSize === "number") {
      sizeProps.span = propSize;
    } else if (_typeof$4(propSize) === "object") {
      sizeProps = propSize || {};
    }
    delete others[size2];
    sizeClassObj = _extends$2(_extends$2({}, sizeClassObj), (_extends2 = {}, _defineProperty$4(_extends2, "".concat(prefixCls, "-").concat(size2, "-").concat(sizeProps.span), sizeProps.span !== void 0), _defineProperty$4(_extends2, "".concat(prefixCls, "-").concat(size2, "-order-").concat(sizeProps.order), sizeProps.order || sizeProps.order === 0), _defineProperty$4(_extends2, "".concat(prefixCls, "-").concat(size2, "-offset-").concat(sizeProps.offset), sizeProps.offset || sizeProps.offset === 0), _defineProperty$4(_extends2, "".concat(prefixCls, "-").concat(size2, "-push-").concat(sizeProps.push), sizeProps.push || sizeProps.push === 0), _defineProperty$4(_extends2, "".concat(prefixCls, "-").concat(size2, "-pull-").concat(sizeProps.pull), sizeProps.pull || sizeProps.pull === 0), _defineProperty$4(_extends2, "".concat(prefixCls, "-rtl"), direction2 === "rtl"), _extends2));
  });
  var classes = classNames(prefixCls, (_classNames = {}, _defineProperty$4(_classNames, "".concat(prefixCls, "-").concat(span), span !== void 0), _defineProperty$4(_classNames, "".concat(prefixCls, "-order-").concat(order), order), _defineProperty$4(_classNames, "".concat(prefixCls, "-offset-").concat(offset3), offset3), _defineProperty$4(_classNames, "".concat(prefixCls, "-push-").concat(push), push), _defineProperty$4(_classNames, "".concat(prefixCls, "-pull-").concat(pull), pull), _classNames), className, sizeClassObj);
  var mergedStyle = {};
  if (gutter && gutter[0] > 0) {
    var horizontalGutter = gutter[0] / 2;
    mergedStyle.paddingLeft = horizontalGutter;
    mergedStyle.paddingRight = horizontalGutter;
  }
  if (gutter && gutter[1] > 0 && !supportFlexGap) {
    var verticalGutter = gutter[1] / 2;
    mergedStyle.paddingTop = verticalGutter;
    mergedStyle.paddingBottom = verticalGutter;
  }
  if (flex) {
    mergedStyle.flex = parseFlex(flex);
    if (wrap === false && !mergedStyle.minWidth) {
      mergedStyle.minWidth = 0;
    }
  }
  return /* @__PURE__ */ react.exports.createElement("div", _extends$2({}, others, {
    style: _extends$2(_extends$2({}, mergedStyle), style2),
    className: classes,
    ref
  }), children);
});
var Col$1 = Col;
var isStyleNameSupport = function isStyleNameSupport2(styleName) {
  if (canUseDom() && window.document.documentElement) {
    var styleNameList = Array.isArray(styleName) ? styleName : [styleName];
    var documentElement = window.document.documentElement;
    return styleNameList.some(function(name) {
      return name in documentElement.style;
    });
  }
  return false;
};
var isStyleValueSupport = function isStyleValueSupport2(styleName, value2) {
  if (!isStyleNameSupport(styleName)) {
    return false;
  }
  var ele = document.createElement("div");
  var origin = ele.style[styleName];
  ele.style[styleName] = value2;
  return ele.style[styleName] !== origin;
};
function isStyleSupport(styleName, styleValue) {
  if (!Array.isArray(styleName) && styleValue !== void 0) {
    return isStyleValueSupport(styleName, styleValue);
  }
  return isStyleNameSupport(styleName);
}
var canUseDocElement = function canUseDocElement2() {
  return canUseDom() && window.document.documentElement;
};
var flexGapSupported;
var detectFlexGapSupported = function detectFlexGapSupported2() {
  if (!canUseDocElement()) {
    return false;
  }
  if (flexGapSupported !== void 0) {
    return flexGapSupported;
  }
  var flex = document.createElement("div");
  flex.style.display = "flex";
  flex.style.flexDirection = "column";
  flex.style.rowGap = "1px";
  flex.appendChild(document.createElement("div"));
  flex.appendChild(document.createElement("div"));
  document.body.appendChild(flex);
  flexGapSupported = flex.scrollHeight === 1;
  document.body.removeChild(flex);
  return flexGapSupported;
};
var useFlexGapSupport = function() {
  var _React$useState = react.exports.useState(false), _React$useState2 = _slicedToArray$4(_React$useState, 2), flexible = _React$useState2[0], setFlexible = _React$useState2[1];
  react.exports.useEffect(function() {
    setFlexible(detectFlexGapSupported());
  }, []);
  return flexible;
};
var __rest$g = globalThis && globalThis.__rest || function(s2, e3) {
  var t2 = {};
  for (var p2 in s2) {
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  }
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e3.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
tuple("top", "middle", "bottom", "stretch");
tuple("start", "end", "center", "space-around", "space-between", "space-evenly");
var Row = /* @__PURE__ */ react.exports.forwardRef(function(props, ref) {
  var _classNames;
  var customizePrefixCls = props.prefixCls, justify2 = props.justify, align = props.align, className = props.className, style2 = props.style, children = props.children, _props$gutter = props.gutter, gutter = _props$gutter === void 0 ? 0 : _props$gutter, wrap = props.wrap, others = __rest$g(props, ["prefixCls", "justify", "align", "className", "style", "children", "gutter", "wrap"]);
  var _React$useContext = react.exports.useContext(ConfigContext), getPrefixCls = _React$useContext.getPrefixCls, direction2 = _React$useContext.direction;
  var _React$useState = react.exports.useState({
    xs: true,
    sm: true,
    md: true,
    lg: true,
    xl: true,
    xxl: true
  }), _React$useState2 = _slicedToArray$4(_React$useState, 2), screens2 = _React$useState2[0], setScreens = _React$useState2[1];
  var supportFlexGap = useFlexGapSupport();
  var gutterRef = react.exports.useRef(gutter);
  react.exports.useEffect(function() {
    var token2 = ResponsiveObserve.subscribe(function(screen) {
      var currentGutter = gutterRef.current || 0;
      if (!Array.isArray(currentGutter) && _typeof$4(currentGutter) === "object" || Array.isArray(currentGutter) && (_typeof$4(currentGutter[0]) === "object" || _typeof$4(currentGutter[1]) === "object")) {
        setScreens(screen);
      }
    });
    return function() {
      return ResponsiveObserve.unsubscribe(token2);
    };
  }, []);
  var getGutter = function getGutter2() {
    var results = [void 0, void 0];
    var normalizedGutter = Array.isArray(gutter) ? gutter : [gutter, void 0];
    normalizedGutter.forEach(function(g2, index2) {
      if (_typeof$4(g2) === "object") {
        for (var i2 = 0; i2 < responsiveArray.length; i2++) {
          var breakpoint = responsiveArray[i2];
          if (screens2[breakpoint] && g2[breakpoint] !== void 0) {
            results[index2] = g2[breakpoint];
            break;
          }
        }
      } else {
        results[index2] = g2;
      }
    });
    return results;
  };
  var prefixCls = getPrefixCls("row", customizePrefixCls);
  var gutters = getGutter();
  var classes = classNames(prefixCls, (_classNames = {}, _defineProperty$4(_classNames, "".concat(prefixCls, "-no-wrap"), wrap === false), _defineProperty$4(_classNames, "".concat(prefixCls, "-").concat(justify2), justify2), _defineProperty$4(_classNames, "".concat(prefixCls, "-").concat(align), align), _defineProperty$4(_classNames, "".concat(prefixCls, "-rtl"), direction2 === "rtl"), _classNames), className);
  var rowStyle = {};
  var horizontalGutter = gutters[0] != null && gutters[0] > 0 ? gutters[0] / -2 : void 0;
  var verticalGutter = gutters[1] != null && gutters[1] > 0 ? gutters[1] / -2 : void 0;
  if (horizontalGutter) {
    rowStyle.marginLeft = horizontalGutter;
    rowStyle.marginRight = horizontalGutter;
  }
  if (supportFlexGap) {
    var _gutters = _slicedToArray$4(gutters, 2);
    rowStyle.rowGap = _gutters[1];
  } else if (verticalGutter) {
    rowStyle.marginTop = verticalGutter;
    rowStyle.marginBottom = verticalGutter;
  }
  var _gutters2 = _slicedToArray$4(gutters, 2), gutterH = _gutters2[0], gutterV = _gutters2[1];
  var rowContext = react.exports.useMemo(function() {
    return {
      gutter: [gutterH, gutterV],
      wrap,
      supportFlexGap
    };
  }, [gutterH, gutterV, wrap, supportFlexGap]);
  return /* @__PURE__ */ react.exports.createElement(RowContext$1.Provider, {
    value: rowContext
  }, /* @__PURE__ */ react.exports.createElement("div", _extends$2({}, others, {
    className: classes,
    style: _extends$2(_extends$2({}, rowStyle), style2),
    ref
  }), children));
});
var Row$1 = Row;
var ClockCircleOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z" } }, { "tag": "path", "attrs": { "d": "M686.7 638.6L544.1 535.5V288c0-4.4-3.6-8-8-8H488c-4.4 0-8 3.6-8 8v275.4c0 2.6 1.2 5 3.3 6.5l165.4 120.6c3.6 2.6 8.6 1.8 11.2-1.7l28.6-39c2.6-3.7 1.8-8.7-1.8-11.2z" } }] }, "name": "clock-circle", "theme": "outlined" };
var ClockCircleOutlinedSvg = ClockCircleOutlined$2;
var ClockCircleOutlined = function ClockCircleOutlined2(props, ref) {
  return /* @__PURE__ */ react.exports.createElement(AntdIcon, _objectSpread2$1(_objectSpread2$1({}, props), {}, {
    ref,
    icon: ClockCircleOutlinedSvg
  }));
};
ClockCircleOutlined.displayName = "ClockCircleOutlined";
var ClockCircleOutlined$1 = /* @__PURE__ */ react.exports.forwardRef(ClockCircleOutlined);
var SwapRightOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "0 0 1024 1024", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M873.1 596.2l-164-208A32 32 0 00684 376h-64.8c-6.7 0-10.4 7.7-6.3 13l144.3 183H152c-4.4 0-8 3.6-8 8v60c0 4.4 3.6 8 8 8h695.9c26.8 0 41.7-30.8 25.2-51.8z" } }] }, "name": "swap-right", "theme": "outlined" };
var SwapRightOutlinedSvg = SwapRightOutlined$2;
var SwapRightOutlined = function SwapRightOutlined2(props, ref) {
  return /* @__PURE__ */ react.exports.createElement(AntdIcon, _objectSpread2$1(_objectSpread2$1({}, props), {}, {
    ref,
    icon: SwapRightOutlinedSvg
  }));
};
SwapRightOutlined.displayName = "SwapRightOutlined";
var SwapRightOutlined$1 = /* @__PURE__ */ react.exports.forwardRef(SwapRightOutlined);
var cached;
function getScrollBarSize(fresh) {
  if (typeof document === "undefined") {
    return 0;
  }
  if (fresh || cached === void 0) {
    var inner = document.createElement("div");
    inner.style.width = "100%";
    inner.style.height = "200px";
    var outer = document.createElement("div");
    var outerStyle = outer.style;
    outerStyle.position = "absolute";
    outerStyle.top = "0";
    outerStyle.left = "0";
    outerStyle.pointerEvents = "none";
    outerStyle.visibility = "hidden";
    outerStyle.width = "200px";
    outerStyle.height = "150px";
    outerStyle.overflow = "hidden";
    outer.appendChild(inner);
    document.body.appendChild(outer);
    var widthContained = inner.offsetWidth;
    outer.style.overflow = "scroll";
    var widthScroll = inner.offsetWidth;
    if (widthContained === widthScroll) {
      widthScroll = outer.clientWidth;
    }
    document.body.removeChild(outer);
    cached = widthContained - widthScroll;
  }
  return cached;
}
function ensureSize(str) {
  var match2 = str.match(/^(.*)px$/);
  var value2 = Number(match2 === null || match2 === void 0 ? void 0 : match2[1]);
  return Number.isNaN(value2) ? getScrollBarSize() : value2;
}
function getTargetScrollBarSize(target) {
  if (typeof document === "undefined" || !target || !(target instanceof Element)) {
    return {
      width: 0,
      height: 0
    };
  }
  var _getComputedStyle2 = getComputedStyle(target, "::-webkit-scrollbar"), width = _getComputedStyle2.width, height = _getComputedStyle2.height;
  return {
    width: ensureSize(width),
    height: ensureSize(height)
  };
}
function setStyle(style2) {
  var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  if (!style2) {
    return {};
  }
  var _options$element = options.element, element = _options$element === void 0 ? document.body : _options$element;
  var oldStyle = {};
  var styleKeys = Object.keys(style2);
  styleKeys.forEach(function(key2) {
    oldStyle[key2] = element.style[key2];
  });
  styleKeys.forEach(function(key2) {
    element.style[key2] = style2[key2];
  });
  return oldStyle;
}
function isBodyOverflowing() {
  return document.body.scrollHeight > (window.innerHeight || document.documentElement.clientHeight) && window.innerWidth > document.body.offsetWidth;
}
var cacheStyle$1 = {};
var switchScrollingEffect = function(close2) {
  if (!isBodyOverflowing() && !close2) {
    return;
  }
  var scrollingEffectClassName2 = "ant-scrolling-effect";
  var scrollingEffectClassNameReg2 = new RegExp("".concat(scrollingEffectClassName2), "g");
  var bodyClassName = document.body.className;
  if (close2) {
    if (!scrollingEffectClassNameReg2.test(bodyClassName))
      return;
    setStyle(cacheStyle$1);
    cacheStyle$1 = {};
    document.body.className = bodyClassName.replace(scrollingEffectClassNameReg2, "").trim();
    return;
  }
  var scrollBarSize = getScrollBarSize();
  if (scrollBarSize) {
    cacheStyle$1 = setStyle({
      position: "relative",
      width: "calc(100% - ".concat(scrollBarSize, "px)")
    });
    if (!scrollingEffectClassNameReg2.test(bodyClassName)) {
      var addClassName = "".concat(bodyClassName, " ").concat(scrollingEffectClassName2);
      document.body.className = addClassName.trim();
    }
  }
};
var uuid$2 = 0;
var locks = [];
var scrollingEffectClassName = "ant-scrolling-effect";
var scrollingEffectClassNameReg = new RegExp("".concat(scrollingEffectClassName), "g");
var cacheStyle = /* @__PURE__ */ new Map();
var ScrollLocker = /* @__PURE__ */ _createClass$2(function ScrollLocker2(_options) {
  var _this = this;
  _classCallCheck$2(this, ScrollLocker2);
  this.lockTarget = void 0;
  this.options = void 0;
  this.getContainer = function() {
    var _this$options;
    return (_this$options = _this.options) === null || _this$options === void 0 ? void 0 : _this$options.container;
  };
  this.reLock = function(options) {
    var findLock = locks.find(function(_ref) {
      var target = _ref.target;
      return target === _this.lockTarget;
    });
    if (findLock) {
      _this.unLock();
    }
    _this.options = options;
    if (findLock) {
      findLock.options = options;
      _this.lock();
    }
  };
  this.lock = function() {
    var _this$options3;
    if (locks.some(function(_ref2) {
      var target = _ref2.target;
      return target === _this.lockTarget;
    })) {
      return;
    }
    if (locks.some(function(_ref3) {
      var _this$options2;
      var options = _ref3.options;
      return (options === null || options === void 0 ? void 0 : options.container) === ((_this$options2 = _this.options) === null || _this$options2 === void 0 ? void 0 : _this$options2.container);
    })) {
      locks = [].concat(_toConsumableArray(locks), [{
        target: _this.lockTarget,
        options: _this.options
      }]);
      return;
    }
    var scrollBarSize = 0;
    var container = ((_this$options3 = _this.options) === null || _this$options3 === void 0 ? void 0 : _this$options3.container) || document.body;
    if (container === document.body && window.innerWidth - document.documentElement.clientWidth > 0 || container.scrollHeight > container.clientHeight) {
      scrollBarSize = getScrollBarSize();
    }
    var containerClassName = container.className;
    if (locks.filter(function(_ref4) {
      var _this$options4;
      var options = _ref4.options;
      return (options === null || options === void 0 ? void 0 : options.container) === ((_this$options4 = _this.options) === null || _this$options4 === void 0 ? void 0 : _this$options4.container);
    }).length === 0) {
      cacheStyle.set(container, setStyle({
        width: scrollBarSize !== 0 ? "calc(100% - ".concat(scrollBarSize, "px)") : void 0,
        overflow: "hidden",
        overflowX: "hidden",
        overflowY: "hidden"
      }, {
        element: container
      }));
    }
    if (!scrollingEffectClassNameReg.test(containerClassName)) {
      var addClassName = "".concat(containerClassName, " ").concat(scrollingEffectClassName);
      container.className = addClassName.trim();
    }
    locks = [].concat(_toConsumableArray(locks), [{
      target: _this.lockTarget,
      options: _this.options
    }]);
  };
  this.unLock = function() {
    var _this$options5;
    var findLock = locks.find(function(_ref5) {
      var target = _ref5.target;
      return target === _this.lockTarget;
    });
    locks = locks.filter(function(_ref6) {
      var target = _ref6.target;
      return target !== _this.lockTarget;
    });
    if (!findLock || locks.some(function(_ref7) {
      var _findLock$options;
      var options = _ref7.options;
      return (options === null || options === void 0 ? void 0 : options.container) === ((_findLock$options = findLock.options) === null || _findLock$options === void 0 ? void 0 : _findLock$options.container);
    })) {
      return;
    }
    var container = ((_this$options5 = _this.options) === null || _this$options5 === void 0 ? void 0 : _this$options5.container) || document.body;
    var containerClassName = container.className;
    if (!scrollingEffectClassNameReg.test(containerClassName))
      return;
    setStyle(cacheStyle.get(container), {
      element: container
    });
    cacheStyle.delete(container);
    container.className = container.className.replace(scrollingEffectClassNameReg, "").trim();
  };
  this.lockTarget = uuid$2++;
  this.options = _options;
});
var openCount = 0;
var supportDom = canUseDom();
var cacheOverflow = {};
var getParent = function getParent3(getContainer2) {
  if (!supportDom) {
    return null;
  }
  if (getContainer2) {
    if (typeof getContainer2 === "string") {
      return document.querySelectorAll(getContainer2)[0];
    }
    if (typeof getContainer2 === "function") {
      return getContainer2();
    }
    if (_typeof$4(getContainer2) === "object" && getContainer2 instanceof window.HTMLElement) {
      return getContainer2;
    }
  }
  return document.body;
};
var PortalWrapper = /* @__PURE__ */ function(_React$Component) {
  _inherits$1(PortalWrapper2, _React$Component);
  var _super = _createSuper$1(PortalWrapper2);
  function PortalWrapper2(props) {
    var _this;
    _classCallCheck$2(this, PortalWrapper2);
    _this = _super.call(this, props);
    _this.container = void 0;
    _this.componentRef = /* @__PURE__ */ react.exports.createRef();
    _this.rafId = void 0;
    _this.scrollLocker = void 0;
    _this.renderComponent = void 0;
    _this.updateScrollLocker = function(prevProps) {
      var _ref = prevProps || {}, prevVisible = _ref.visible;
      var _this$props = _this.props, getContainer2 = _this$props.getContainer, visible = _this$props.visible;
      if (visible && visible !== prevVisible && supportDom && getParent(getContainer2) !== _this.scrollLocker.getContainer()) {
        _this.scrollLocker.reLock({
          container: getParent(getContainer2)
        });
      }
    };
    _this.updateOpenCount = function(prevProps) {
      var _ref2 = prevProps || {}, prevVisible = _ref2.visible, prevGetContainer = _ref2.getContainer;
      var _this$props2 = _this.props, visible = _this$props2.visible, getContainer2 = _this$props2.getContainer;
      if (visible !== prevVisible && supportDom && getParent(getContainer2) === document.body) {
        if (visible && !prevVisible) {
          openCount += 1;
        } else if (prevProps) {
          openCount -= 1;
        }
      }
      var getContainerIsFunc = typeof getContainer2 === "function" && typeof prevGetContainer === "function";
      if (getContainerIsFunc ? getContainer2.toString() !== prevGetContainer.toString() : getContainer2 !== prevGetContainer) {
        _this.removeCurrentContainer();
      }
    };
    _this.attachToParent = function() {
      var force = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
      if (force || _this.container && !_this.container.parentNode) {
        var parent = getParent(_this.props.getContainer);
        if (parent) {
          parent.appendChild(_this.container);
          return true;
        }
        return false;
      }
      return true;
    };
    _this.getContainer = function() {
      if (!supportDom) {
        return null;
      }
      if (!_this.container) {
        _this.container = document.createElement("div");
        _this.attachToParent(true);
      }
      _this.setWrapperClassName();
      return _this.container;
    };
    _this.setWrapperClassName = function() {
      var wrapperClassName = _this.props.wrapperClassName;
      if (_this.container && wrapperClassName && wrapperClassName !== _this.container.className) {
        _this.container.className = wrapperClassName;
      }
    };
    _this.removeCurrentContainer = function() {
      var _this$container, _this$container$paren;
      (_this$container = _this.container) === null || _this$container === void 0 ? void 0 : (_this$container$paren = _this$container.parentNode) === null || _this$container$paren === void 0 ? void 0 : _this$container$paren.removeChild(_this.container);
    };
    _this.switchScrollingEffect = function() {
      if (openCount === 1 && !Object.keys(cacheOverflow).length) {
        switchScrollingEffect();
        cacheOverflow = setStyle({
          overflow: "hidden",
          overflowX: "hidden",
          overflowY: "hidden"
        });
      } else if (!openCount) {
        setStyle(cacheOverflow);
        cacheOverflow = {};
        switchScrollingEffect(true);
      }
    };
    _this.scrollLocker = new ScrollLocker({
      container: getParent(props.getContainer)
    });
    return _this;
  }
  _createClass$2(PortalWrapper2, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      var _this2 = this;
      this.updateOpenCount();
      if (!this.attachToParent()) {
        this.rafId = wrapperRaf$1(function() {
          _this2.forceUpdate();
        });
      }
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      this.updateOpenCount(prevProps);
      this.updateScrollLocker(prevProps);
      this.setWrapperClassName();
      this.attachToParent();
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      var _this$props3 = this.props, visible = _this$props3.visible, getContainer2 = _this$props3.getContainer;
      if (supportDom && getParent(getContainer2) === document.body) {
        openCount = visible && openCount ? openCount - 1 : openCount;
      }
      this.removeCurrentContainer();
      wrapperRaf$1.cancel(this.rafId);
    }
  }, {
    key: "render",
    value: function render2() {
      var _this$props4 = this.props, children = _this$props4.children, forceRender = _this$props4.forceRender, visible = _this$props4.visible;
      var portal = null;
      var childProps = {
        getOpenCount: function getOpenCount() {
          return openCount;
        },
        getContainer: this.getContainer,
        switchScrollingEffect: this.switchScrollingEffect,
        scrollLocker: this.scrollLocker
      };
      if (forceRender || visible || this.componentRef.current) {
        portal = /* @__PURE__ */ react.exports.createElement(Portal, {
          getContainer: this.getContainer,
          ref: this.componentRef
        }, children(childProps));
      }
      return portal;
    }
  }]);
  return PortalWrapper2;
}(react.exports.Component);
var EyeOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M942.2 486.2C847.4 286.5 704.1 186 512 186c-192.2 0-335.4 100.5-430.2 300.3a60.3 60.3 0 000 51.5C176.6 737.5 319.9 838 512 838c192.2 0 335.4-100.5 430.2-300.3 7.7-16.2 7.7-35 0-51.5zM512 766c-161.3 0-279.4-81.8-362.7-254C232.6 339.8 350.7 258 512 258c161.3 0 279.4 81.8 362.7 254C791.5 684.2 673.4 766 512 766zm-4-430c-97.2 0-176 78.8-176 176s78.8 176 176 176 176-78.8 176-176-78.8-176-176-176zm0 288c-61.9 0-112-50.1-112-112s50.1-112 112-112 112 50.1 112 112-50.1 112-112 112z" } }] }, "name": "eye", "theme": "outlined" };
var EyeOutlinedSvg = EyeOutlined$2;
var EyeOutlined = function EyeOutlined2(props, ref) {
  return /* @__PURE__ */ react.exports.createElement(AntdIcon, _objectSpread2$1(_objectSpread2$1({}, props), {}, {
    ref,
    icon: EyeOutlinedSvg
  }));
};
EyeOutlined.displayName = "EyeOutlined";
var EyeOutlined$1 = /* @__PURE__ */ react.exports.forwardRef(EyeOutlined);
function getClientSize() {
  var width = document.documentElement.clientWidth;
  var height = window.innerHeight || document.documentElement.clientHeight;
  return {
    width,
    height
  };
}
function getOffset(node) {
  var box2 = node.getBoundingClientRect();
  var docElem = document.documentElement;
  return {
    left: box2.left + (window.pageXOffset || docElem.scrollLeft) - (docElem.clientLeft || document.body.clientLeft || 0),
    top: box2.top + (window.pageYOffset || docElem.scrollTop) - (docElem.clientTop || document.body.clientTop || 0)
  };
}
function getUseId() {
  var fullClone2 = _objectSpread2$1({}, React$1);
  return fullClone2.useId;
}
var uuid$1 = 0;
function useId(id2) {
  var _React$useState = react.exports.useState("ssr-id"), _React$useState2 = _slicedToArray$4(_React$useState, 2), innerId = _React$useState2[0], setInnerId = _React$useState2[1];
  var useOriginId = getUseId();
  var reactNativeId = useOriginId === null || useOriginId === void 0 ? void 0 : useOriginId();
  react.exports.useEffect(function() {
    if (!useOriginId) {
      var nextId = uuid$1;
      uuid$1 += 1;
      setInnerId("rc_unique_".concat(nextId));
    }
  }, []);
  if (id2) {
    return id2;
  }
  return reactNativeId || innerId;
}
function Mask(props) {
  var prefixCls = props.prefixCls, style2 = props.style, visible = props.visible, maskProps = props.maskProps, motionName = props.motionName;
  return /* @__PURE__ */ react.exports.createElement(CSSMotion, {
    key: "mask",
    visible,
    motionName,
    leavedClassName: "".concat(prefixCls, "-mask-hidden")
  }, function(_ref) {
    var motionClassName = _ref.className, motionStyle = _ref.style;
    return /* @__PURE__ */ react.exports.createElement("div", _extends$2({
      style: _objectSpread2$1(_objectSpread2$1({}, motionStyle), style2),
      className: classNames("".concat(prefixCls, "-mask"), motionClassName)
    }, maskProps));
  });
}
function getMotionName(prefixCls, transitionName2, animationName) {
  var motionName = transitionName2;
  if (!motionName && animationName) {
    motionName = "".concat(prefixCls, "-").concat(animationName);
  }
  return motionName;
}
function getScroll(w2, top) {
  var ret = w2["page".concat(top ? "Y" : "X", "Offset")];
  var method4 = "scroll".concat(top ? "Top" : "Left");
  if (typeof ret !== "number") {
    var d2 = w2.document;
    ret = d2.documentElement[method4];
    if (typeof ret !== "number") {
      ret = d2.body[method4];
    }
  }
  return ret;
}
function offset$1(el) {
  var rect2 = el.getBoundingClientRect();
  var pos = {
    left: rect2.left,
    top: rect2.top
  };
  var doc = el.ownerDocument;
  var w2 = doc.defaultView || doc.parentWindow;
  pos.left += getScroll(w2);
  pos.top += getScroll(w2, true);
  return pos;
}
var MemoChildren = /* @__PURE__ */ react.exports.memo(function(_ref) {
  var children = _ref.children;
  return children;
}, function(_2, _ref2) {
  var shouldUpdate = _ref2.shouldUpdate;
  return !shouldUpdate;
});
var sentinelStyle = {
  width: 0,
  height: 0,
  overflow: "hidden",
  outline: "none"
};
var Panel$1 = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  var prefixCls = props.prefixCls, className = props.className, style2 = props.style, title = props.title, ariaId = props.ariaId, footer = props.footer, closable = props.closable, closeIcon = props.closeIcon, onClose2 = props.onClose, children = props.children, bodyStyle = props.bodyStyle, bodyProps = props.bodyProps, modalRender = props.modalRender, onMouseDown = props.onMouseDown, onMouseUp = props.onMouseUp, holderRef = props.holderRef, visible = props.visible, forceRender = props.forceRender, width = props.width, height = props.height;
  var sentinelStartRef = react.exports.useRef();
  var sentinelEndRef = react.exports.useRef();
  React.useImperativeHandle(ref, function() {
    return {
      focus: function focus() {
        var _sentinelStartRef$cur;
        (_sentinelStartRef$cur = sentinelStartRef.current) === null || _sentinelStartRef$cur === void 0 ? void 0 : _sentinelStartRef$cur.focus();
      },
      changeActive: function changeActive(next) {
        var _document = document, activeElement = _document.activeElement;
        if (next && activeElement === sentinelEndRef.current) {
          sentinelStartRef.current.focus();
        } else if (!next && activeElement === sentinelStartRef.current) {
          sentinelEndRef.current.focus();
        }
      }
    };
  });
  var contentStyle = {};
  if (width !== void 0) {
    contentStyle.width = width;
  }
  if (height !== void 0) {
    contentStyle.height = height;
  }
  var footerNode;
  if (footer) {
    footerNode = /* @__PURE__ */ jsx("div", {
      className: "".concat(prefixCls, "-footer"),
      children: footer
    });
  }
  var headerNode;
  if (title) {
    headerNode = /* @__PURE__ */ jsx("div", {
      className: "".concat(prefixCls, "-header"),
      children: /* @__PURE__ */ jsx("div", {
        className: "".concat(prefixCls, "-title"),
        id: ariaId,
        children: title
      })
    });
  }
  var closer;
  if (closable) {
    closer = /* @__PURE__ */ jsx("button", {
      type: "button",
      onClick: onClose2,
      "aria-label": "Close",
      className: "".concat(prefixCls, "-close"),
      children: closeIcon || /* @__PURE__ */ jsx("span", {
        className: "".concat(prefixCls, "-close-x")
      })
    });
  }
  var content = /* @__PURE__ */ jsxs("div", {
    className: "".concat(prefixCls, "-content"),
    children: [closer, headerNode, /* @__PURE__ */ jsx("div", {
      className: "".concat(prefixCls, "-body"),
      style: bodyStyle,
      ...bodyProps,
      children
    }), footerNode]
  });
  return /* @__PURE__ */ jsxs("div", {
    role: "dialog",
    "aria-labelledby": title ? ariaId : null,
    "aria-modal": "true",
    ref: holderRef,
    style: _objectSpread2$1(_objectSpread2$1({}, style2), contentStyle),
    className: classNames(prefixCls, className),
    onMouseDown,
    onMouseUp,
    children: [/* @__PURE__ */ jsx("div", {
      tabIndex: 0,
      ref: sentinelStartRef,
      style: sentinelStyle,
      "aria-hidden": "true"
    }), /* @__PURE__ */ jsx(MemoChildren, {
      shouldUpdate: visible || forceRender,
      children: modalRender ? modalRender(content) : content
    }), /* @__PURE__ */ jsx("div", {
      tabIndex: 0,
      ref: sentinelEndRef,
      style: sentinelStyle,
      "aria-hidden": "true"
    })]
  }, "dialog-element");
});
var Content = /* @__PURE__ */ react.exports.forwardRef(function(props, ref) {
  var prefixCls = props.prefixCls, title = props.title, style2 = props.style, className = props.className, visible = props.visible, forceRender = props.forceRender, destroyOnClose = props.destroyOnClose, motionName = props.motionName, ariaId = props.ariaId, onVisibleChanged = props.onVisibleChanged, mousePosition = props.mousePosition;
  var dialogRef = react.exports.useRef();
  var _React$useState = react.exports.useState(), _React$useState2 = _slicedToArray$4(_React$useState, 2), transformOrigin = _React$useState2[0], setTransformOrigin = _React$useState2[1];
  var contentStyle = {};
  if (transformOrigin) {
    contentStyle.transformOrigin = transformOrigin;
  }
  function onPrepare() {
    var elementOffset = offset$1(dialogRef.current);
    setTransformOrigin(mousePosition ? "".concat(mousePosition.x - elementOffset.left, "px ").concat(mousePosition.y - elementOffset.top, "px") : "");
  }
  return /* @__PURE__ */ react.exports.createElement(CSSMotion, {
    visible,
    onVisibleChanged,
    onAppearPrepare: onPrepare,
    onEnterPrepare: onPrepare,
    forceRender,
    motionName,
    removeOnLeave: destroyOnClose,
    ref: dialogRef
  }, function(_ref, motionRef) {
    var motionClassName = _ref.className, motionStyle = _ref.style;
    return /* @__PURE__ */ react.exports.createElement(Panel$1, _extends$2({}, props, {
      ref,
      title,
      ariaId,
      prefixCls,
      holderRef: motionRef,
      style: _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, motionStyle), style2), contentStyle),
      className: classNames(className, motionClassName)
    }));
  });
});
Content.displayName = "Content";
function Dialog(props) {
  var _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-dialog" : _props$prefixCls, zIndex = props.zIndex, _props$visible = props.visible, visible = _props$visible === void 0 ? false : _props$visible, _props$keyboard = props.keyboard, keyboard = _props$keyboard === void 0 ? true : _props$keyboard, _props$focusTriggerAf = props.focusTriggerAfterClose, focusTriggerAfterClose = _props$focusTriggerAf === void 0 ? true : _props$focusTriggerAf, scrollLocker = props.scrollLocker, wrapStyle = props.wrapStyle, wrapClassName = props.wrapClassName, wrapProps = props.wrapProps, onClose2 = props.onClose, afterClose = props.afterClose, transitionName2 = props.transitionName, animation2 = props.animation, _props$closable = props.closable, closable = _props$closable === void 0 ? true : _props$closable, _props$mask = props.mask, mask = _props$mask === void 0 ? true : _props$mask, maskTransitionName = props.maskTransitionName, maskAnimation = props.maskAnimation, _props$maskClosable = props.maskClosable, maskClosable = _props$maskClosable === void 0 ? true : _props$maskClosable, maskStyle = props.maskStyle, maskProps = props.maskProps, rootClassName = props.rootClassName;
  var lastOutSideActiveElementRef = react.exports.useRef();
  var wrapperRef = react.exports.useRef();
  var contentRef = react.exports.useRef();
  var _React$useState = react.exports.useState(visible), _React$useState2 = _slicedToArray$4(_React$useState, 2), animatedVisible = _React$useState2[0], setAnimatedVisible = _React$useState2[1];
  var ariaId = useId();
  function onDialogVisibleChanged(newVisible) {
    if (newVisible) {
      if (!contains$1(wrapperRef.current, document.activeElement)) {
        var _contentRef$current;
        lastOutSideActiveElementRef.current = document.activeElement;
        (_contentRef$current = contentRef.current) === null || _contentRef$current === void 0 ? void 0 : _contentRef$current.focus();
      }
    } else {
      setAnimatedVisible(false);
      if (mask && lastOutSideActiveElementRef.current && focusTriggerAfterClose) {
        try {
          lastOutSideActiveElementRef.current.focus({
            preventScroll: true
          });
        } catch (e3) {
        }
        lastOutSideActiveElementRef.current = null;
      }
      if (animatedVisible) {
        afterClose === null || afterClose === void 0 ? void 0 : afterClose();
      }
    }
  }
  function onInternalClose(e3) {
    onClose2 === null || onClose2 === void 0 ? void 0 : onClose2(e3);
  }
  var contentClickRef = react.exports.useRef(false);
  var contentTimeoutRef = react.exports.useRef();
  var onContentMouseDown = function onContentMouseDown2() {
    clearTimeout(contentTimeoutRef.current);
    contentClickRef.current = true;
  };
  var onContentMouseUp = function onContentMouseUp2() {
    contentTimeoutRef.current = setTimeout(function() {
      contentClickRef.current = false;
    });
  };
  var onWrapperClick = null;
  if (maskClosable) {
    onWrapperClick = function onWrapperClick2(e3) {
      if (contentClickRef.current) {
        contentClickRef.current = false;
      } else if (wrapperRef.current === e3.target) {
        onInternalClose(e3);
      }
    };
  }
  function onWrapperKeyDown(e3) {
    if (keyboard && e3.keyCode === KeyCode.ESC) {
      e3.stopPropagation();
      onInternalClose(e3);
      return;
    }
    if (visible) {
      if (e3.keyCode === KeyCode.TAB) {
        contentRef.current.changeActive(!e3.shiftKey);
      }
    }
  }
  react.exports.useEffect(function() {
    if (visible) {
      setAnimatedVisible(true);
    }
    return function() {
    };
  }, [visible]);
  react.exports.useEffect(function() {
    return function() {
      clearTimeout(contentTimeoutRef.current);
    };
  }, []);
  react.exports.useEffect(function() {
    if (animatedVisible) {
      scrollLocker === null || scrollLocker === void 0 ? void 0 : scrollLocker.lock();
      return scrollLocker === null || scrollLocker === void 0 ? void 0 : scrollLocker.unLock;
    }
    return function() {
    };
  }, [animatedVisible, scrollLocker]);
  return /* @__PURE__ */ react.exports.createElement("div", _extends$2({
    className: classNames("".concat(prefixCls, "-root"), rootClassName)
  }, pickAttrs(props, {
    data: true
  })), /* @__PURE__ */ react.exports.createElement(Mask, {
    prefixCls,
    visible: mask && visible,
    motionName: getMotionName(prefixCls, maskTransitionName, maskAnimation),
    style: _objectSpread2$1({
      zIndex
    }, maskStyle),
    maskProps
  }), /* @__PURE__ */ react.exports.createElement("div", _extends$2({
    tabIndex: -1,
    onKeyDown: onWrapperKeyDown,
    className: classNames("".concat(prefixCls, "-wrap"), wrapClassName),
    ref: wrapperRef,
    onClick: onWrapperClick,
    style: _objectSpread2$1(_objectSpread2$1({
      zIndex
    }, wrapStyle), {}, {
      display: !animatedVisible ? "none" : null
    })
  }, wrapProps), /* @__PURE__ */ react.exports.createElement(Content, _extends$2({}, props, {
    onMouseDown: onContentMouseDown,
    onMouseUp: onContentMouseUp,
    ref: contentRef,
    closable,
    ariaId,
    prefixCls,
    visible,
    onClose: onInternalClose,
    onVisibleChanged: onDialogVisibleChanged,
    motionName: getMotionName(prefixCls, transitionName2, animation2)
  }))));
}
var DialogWrap = function DialogWrap2(props) {
  var visible = props.visible, getContainer2 = props.getContainer, forceRender = props.forceRender, _props$destroyOnClose = props.destroyOnClose, destroyOnClose = _props$destroyOnClose === void 0 ? false : _props$destroyOnClose, _afterClose = props.afterClose;
  var _React$useState = react.exports.useState(visible), _React$useState2 = _slicedToArray$4(_React$useState, 2), animatedVisible = _React$useState2[0], setAnimatedVisible = _React$useState2[1];
  react.exports.useEffect(function() {
    if (visible) {
      setAnimatedVisible(true);
    }
  }, [visible]);
  if (getContainer2 === false) {
    return /* @__PURE__ */ react.exports.createElement(Dialog, _extends$2({}, props, {
      getOpenCount: function getOpenCount() {
        return 2;
      }
    }));
  }
  if (!forceRender && destroyOnClose && !animatedVisible) {
    return null;
  }
  return /* @__PURE__ */ react.exports.createElement(PortalWrapper, {
    visible,
    forceRender,
    getContainer: getContainer2
  }, function(childProps) {
    return /* @__PURE__ */ react.exports.createElement(Dialog, _extends$2({}, props, {
      destroyOnClose,
      afterClose: function afterClose() {
        _afterClose === null || _afterClose === void 0 ? void 0 : _afterClose();
        setAnimatedVisible(false);
      }
    }, childProps));
  });
};
DialogWrap.displayName = "Dialog";
function useFrameSetState(initial) {
  var frame2 = react.exports.useRef(null);
  var _React$useState = react.exports.useState(initial), _React$useState2 = _slicedToArray$4(_React$useState, 2), state2 = _React$useState2[0], setState = _React$useState2[1];
  var queue = react.exports.useRef([]);
  var setFrameState = function setFrameState2(newState) {
    if (frame2.current === null) {
      queue.current = [];
      frame2.current = wrapperRaf$1(function() {
        setState(function(preState) {
          var memoState = preState;
          queue.current.forEach(function(queueState) {
            memoState = _objectSpread2$1(_objectSpread2$1({}, memoState), queueState);
          });
          frame2.current = null;
          return memoState;
        });
      });
    }
    queue.current.push(newState);
  };
  react.exports.useEffect(function() {
    return function() {
      return frame2.current && wrapperRaf$1.cancel(frame2.current);
    };
  }, []);
  return [state2, setFrameState];
}
function fixPoint(key2, start, width, clientWidth) {
  var startAddWidth = start + width;
  var offsetStart = (width - clientWidth) / 2;
  if (width > clientWidth) {
    if (start > 0) {
      return _defineProperty$4({}, key2, offsetStart);
    }
    if (start < 0 && startAddWidth < clientWidth) {
      return _defineProperty$4({}, key2, -offsetStart);
    }
  } else if (start < 0 || startAddWidth > clientWidth) {
    return _defineProperty$4({}, key2, start < 0 ? offsetStart : -offsetStart);
  }
  return {};
}
function getFixScaleEleTransPosition(width, height, left2, top) {
  var _getClientSize = getClientSize(), clientWidth = _getClientSize.width, clientHeight = _getClientSize.height;
  var fixPos = null;
  if (width <= clientWidth && height <= clientHeight) {
    fixPos = {
      x: 0,
      y: 0
    };
  } else if (width > clientWidth || height > clientHeight) {
    fixPos = _objectSpread2$1(_objectSpread2$1({}, fixPoint("x", left2, width, clientWidth)), fixPoint("y", top, height, clientHeight));
  }
  return fixPos;
}
var _excluded$b = ["visible", "onVisibleChange", "getContainer", "current", "countRender"];
var context = /* @__PURE__ */ react.exports.createContext({
  previewUrls: /* @__PURE__ */ new Map(),
  setPreviewUrls: function setPreviewUrls() {
    return null;
  },
  current: null,
  setCurrent: function setCurrent() {
    return null;
  },
  setShowPreview: function setShowPreview() {
    return null;
  },
  setMousePosition: function setMousePosition() {
    return null;
  },
  registerImage: function registerImage() {
    return function() {
      return null;
    };
  },
  rootClassName: ""
});
var Provider = context.Provider;
var Group$4 = function Group2(_ref) {
  var _ref$previewPrefixCls = _ref.previewPrefixCls, previewPrefixCls = _ref$previewPrefixCls === void 0 ? "rc-image-preview" : _ref$previewPrefixCls, children = _ref.children, _ref$icons = _ref.icons, icons2 = _ref$icons === void 0 ? {} : _ref$icons, preview = _ref.preview;
  var _ref2 = _typeof$4(preview) === "object" ? preview : {}, _ref2$visible = _ref2.visible, previewVisible = _ref2$visible === void 0 ? void 0 : _ref2$visible, _ref2$onVisibleChange = _ref2.onVisibleChange, onPreviewVisibleChange = _ref2$onVisibleChange === void 0 ? void 0 : _ref2$onVisibleChange, _ref2$getContainer = _ref2.getContainer, getContainer2 = _ref2$getContainer === void 0 ? void 0 : _ref2$getContainer, _ref2$current = _ref2.current, currentIndex = _ref2$current === void 0 ? 0 : _ref2$current, _ref2$countRender = _ref2.countRender, countRender = _ref2$countRender === void 0 ? void 0 : _ref2$countRender, dialogProps = _objectWithoutProperties$1(_ref2, _excluded$b);
  var _useState = react.exports.useState(/* @__PURE__ */ new Map()), _useState2 = _slicedToArray$4(_useState, 2), previewUrls = _useState2[0], setPreviewUrls2 = _useState2[1];
  var _useState3 = react.exports.useState(), _useState4 = _slicedToArray$4(_useState3, 2), current = _useState4[0], setCurrent2 = _useState4[1];
  var _useMergedState = useMergedState(!!previewVisible, {
    value: previewVisible,
    onChange: onPreviewVisibleChange
  }), _useMergedState2 = _slicedToArray$4(_useMergedState, 2), isShowPreview = _useMergedState2[0], setShowPreview2 = _useMergedState2[1];
  var _useState5 = react.exports.useState(null), _useState6 = _slicedToArray$4(_useState5, 2), mousePosition = _useState6[0], setMousePosition2 = _useState6[1];
  var isControlled = previewVisible !== void 0;
  var previewUrlsKeys = Array.from(previewUrls.keys());
  var currentControlledKey = previewUrlsKeys[currentIndex];
  var canPreviewUrls = new Map(Array.from(previewUrls).filter(function(_ref3) {
    var _ref4 = _slicedToArray$4(_ref3, 2), canPreview = _ref4[1].canPreview;
    return !!canPreview;
  }).map(function(_ref5) {
    var _ref6 = _slicedToArray$4(_ref5, 2), id2 = _ref6[0], url2 = _ref6[1].url;
    return [id2, url2];
  }));
  var registerImage2 = function registerImage3(id2, url2) {
    var canPreview = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
    var unRegister = function unRegister2() {
      setPreviewUrls2(function(oldPreviewUrls) {
        var clonePreviewUrls = new Map(oldPreviewUrls);
        var deleteResult = clonePreviewUrls.delete(id2);
        return deleteResult ? clonePreviewUrls : oldPreviewUrls;
      });
    };
    setPreviewUrls2(function(oldPreviewUrls) {
      return new Map(oldPreviewUrls).set(id2, {
        url: url2,
        canPreview
      });
    });
    return unRegister;
  };
  var onPreviewClose = function onPreviewClose2(e3) {
    e3.stopPropagation();
    setShowPreview2(false);
    setMousePosition2(null);
  };
  react.exports.useEffect(function() {
    setCurrent2(currentControlledKey);
  }, [currentControlledKey]);
  react.exports.useEffect(function() {
    if (!isShowPreview && isControlled) {
      setCurrent2(currentControlledKey);
    }
  }, [currentControlledKey, isControlled, isShowPreview]);
  return /* @__PURE__ */ react.exports.createElement(Provider, {
    value: {
      isPreviewGroup: true,
      previewUrls: canPreviewUrls,
      setPreviewUrls: setPreviewUrls2,
      current,
      setCurrent: setCurrent2,
      setShowPreview: setShowPreview2,
      setMousePosition: setMousePosition2,
      registerImage: registerImage2
    }
  }, children, /* @__PURE__ */ react.exports.createElement(Preview, _extends$2({
    "aria-hidden": !isShowPreview,
    visible: isShowPreview,
    prefixCls: previewPrefixCls,
    onClose: onPreviewClose,
    mousePosition,
    src: canPreviewUrls.get(current),
    icons: icons2,
    getContainer: getContainer2,
    countRender
  }, dialogProps)));
};
var _excluded$a = ["prefixCls", "src", "alt", "onClose", "afterClose", "visible", "icons", "rootClassName", "countRender"];
var useState = react.exports.useState, useEffect = react.exports.useEffect, useCallback = react.exports.useCallback, useRef = react.exports.useRef, useContext = react.exports.useContext;
var initialPosition = {
  x: 0,
  y: 0
};
var Preview = function Preview2(props) {
  var _countRender;
  var prefixCls = props.prefixCls, src2 = props.src, alt = props.alt, onClose2 = props.onClose;
  props.afterClose;
  var visible = props.visible, _props$icons = props.icons, icons2 = _props$icons === void 0 ? {} : _props$icons, rootClassName = props.rootClassName, countRender = props.countRender, restProps = _objectWithoutProperties$1(props, _excluded$a);
  var rotateLeft = icons2.rotateLeft, rotateRight = icons2.rotateRight, zoomIn2 = icons2.zoomIn, zoomOut2 = icons2.zoomOut, close2 = icons2.close, left2 = icons2.left, right2 = icons2.right;
  var _useState = useState(1), _useState2 = _slicedToArray$4(_useState, 2), scale2 = _useState2[0], setScale = _useState2[1];
  var _useState3 = useState(0), _useState4 = _slicedToArray$4(_useState3, 2), rotate2 = _useState4[0], setRotate = _useState4[1];
  var _useFrameSetState = useFrameSetState(initialPosition), _useFrameSetState2 = _slicedToArray$4(_useFrameSetState, 2), position = _useFrameSetState2[0], setPosition = _useFrameSetState2[1];
  var imgRef = useRef();
  var originPositionRef = useRef({
    originX: 0,
    originY: 0,
    deltaX: 0,
    deltaY: 0
  });
  var _useState5 = useState(false), _useState6 = _slicedToArray$4(_useState5, 2), isMoving = _useState6[0], setMoving = _useState6[1];
  var _useContext = useContext(context), previewUrls = _useContext.previewUrls, current = _useContext.current, isPreviewGroup = _useContext.isPreviewGroup, setCurrent2 = _useContext.setCurrent;
  var previewGroupCount = previewUrls.size;
  var previewUrlsKeys = Array.from(previewUrls.keys());
  var currentPreviewIndex = previewUrlsKeys.indexOf(current);
  var combinationSrc = isPreviewGroup ? previewUrls.get(current) : src2;
  var showLeftOrRightSwitches = isPreviewGroup && previewGroupCount > 1;
  var _useState7 = useState({
    wheelDirection: 0
  }), _useState8 = _slicedToArray$4(_useState7, 2), lastWheelZoomDirection = _useState8[0], setLastWheelZoomDirection = _useState8[1];
  var onAfterClose = function onAfterClose2() {
    setScale(1);
    setRotate(0);
    setPosition(initialPosition);
  };
  var onZoomIn = function onZoomIn2() {
    setScale(function(value2) {
      return value2 + 1;
    });
    setPosition(initialPosition);
  };
  var onZoomOut = function onZoomOut2() {
    if (scale2 > 1) {
      setScale(function(value2) {
        return value2 - 1;
      });
    }
    setPosition(initialPosition);
  };
  var onRotateRight = function onRotateRight2() {
    setRotate(function(value2) {
      return value2 + 90;
    });
  };
  var onRotateLeft = function onRotateLeft2() {
    setRotate(function(value2) {
      return value2 - 90;
    });
  };
  var onSwitchLeft = function onSwitchLeft2(event) {
    event.preventDefault();
    event.stopPropagation();
    if (currentPreviewIndex > 0) {
      setCurrent2(previewUrlsKeys[currentPreviewIndex - 1]);
    }
  };
  var onSwitchRight = function onSwitchRight2(event) {
    event.preventDefault();
    event.stopPropagation();
    if (currentPreviewIndex < previewGroupCount - 1) {
      setCurrent2(previewUrlsKeys[currentPreviewIndex + 1]);
    }
  };
  var wrapClassName = classNames(_defineProperty$4({}, "".concat(prefixCls, "-moving"), isMoving));
  var toolClassName = "".concat(prefixCls, "-operations-operation");
  var iconClassName = "".concat(prefixCls, "-operations-icon");
  var tools = [{
    icon: close2,
    onClick: onClose2,
    type: "close"
  }, {
    icon: zoomIn2,
    onClick: onZoomIn,
    type: "zoomIn"
  }, {
    icon: zoomOut2,
    onClick: onZoomOut,
    type: "zoomOut",
    disabled: scale2 === 1
  }, {
    icon: rotateRight,
    onClick: onRotateRight,
    type: "rotateRight"
  }, {
    icon: rotateLeft,
    onClick: onRotateLeft,
    type: "rotateLeft"
  }];
  var onMouseUp = function onMouseUp2() {
    if (visible && isMoving) {
      var width = imgRef.current.offsetWidth * scale2;
      var height = imgRef.current.offsetHeight * scale2;
      var _imgRef$current$getBo = imgRef.current.getBoundingClientRect(), _left = _imgRef$current$getBo.left, top = _imgRef$current$getBo.top;
      var isRotate2 = rotate2 % 180 !== 0;
      setMoving(false);
      var fixState = getFixScaleEleTransPosition(isRotate2 ? height : width, isRotate2 ? width : height, _left, top);
      if (fixState) {
        setPosition(_objectSpread2$1({}, fixState));
      }
    }
  };
  var onMouseDown = function onMouseDown2(event) {
    if (event.button !== 0)
      return;
    event.preventDefault();
    event.stopPropagation();
    originPositionRef.current.deltaX = event.pageX - position.x;
    originPositionRef.current.deltaY = event.pageY - position.y;
    originPositionRef.current.originX = position.x;
    originPositionRef.current.originY = position.y;
    setMoving(true);
  };
  var onMouseMove = function onMouseMove2(event) {
    if (visible && isMoving) {
      setPosition({
        x: event.pageX - originPositionRef.current.deltaX,
        y: event.pageY - originPositionRef.current.deltaY
      });
    }
  };
  var onWheelMove = function onWheelMove2(event) {
    if (!visible)
      return;
    event.preventDefault();
    var wheelDirection = event.deltaY;
    setLastWheelZoomDirection({
      wheelDirection
    });
  };
  var onKeyDown2 = useCallback(function(event) {
    if (!visible || !showLeftOrRightSwitches)
      return;
    event.preventDefault();
    if (event.keyCode === KeyCode.LEFT) {
      if (currentPreviewIndex > 0) {
        setCurrent2(previewUrlsKeys[currentPreviewIndex - 1]);
      }
    } else if (event.keyCode === KeyCode.RIGHT) {
      if (currentPreviewIndex < previewGroupCount - 1) {
        setCurrent2(previewUrlsKeys[currentPreviewIndex + 1]);
      }
    }
  }, [currentPreviewIndex, previewGroupCount, previewUrlsKeys, setCurrent2, showLeftOrRightSwitches, visible]);
  var onDoubleClick = function onDoubleClick2() {
    if (visible) {
      if (scale2 !== 1) {
        setScale(1);
      }
      if (position.x !== initialPosition.x || position.y !== initialPosition.y) {
        setPosition(initialPosition);
      }
    }
  };
  useEffect(function() {
    var wheelDirection = lastWheelZoomDirection.wheelDirection;
    if (wheelDirection > 0) {
      onZoomOut();
    } else if (wheelDirection < 0) {
      onZoomIn();
    }
  }, [lastWheelZoomDirection]);
  useEffect(function() {
    var onTopMouseUpListener;
    var onTopMouseMoveListener;
    var onMouseUpListener = addEventListenerWrap(window, "mouseup", onMouseUp, false);
    var onMouseMoveListener = addEventListenerWrap(window, "mousemove", onMouseMove, false);
    var onScrollWheelListener = addEventListenerWrap(window, "wheel", onWheelMove, {
      passive: false
    });
    var onKeyDownListener = addEventListenerWrap(window, "keydown", onKeyDown2, false);
    try {
      if (window.top !== window.self) {
        onTopMouseUpListener = addEventListenerWrap(window.top, "mouseup", onMouseUp, false);
        onTopMouseMoveListener = addEventListenerWrap(window.top, "mousemove", onMouseMove, false);
      }
    } catch (error) {
    }
    return function() {
      onMouseUpListener.remove();
      onMouseMoveListener.remove();
      onScrollWheelListener.remove();
      onKeyDownListener.remove();
      if (onTopMouseUpListener)
        onTopMouseUpListener.remove();
      if (onTopMouseMoveListener)
        onTopMouseMoveListener.remove();
    };
  }, [visible, isMoving, onKeyDown2]);
  return /* @__PURE__ */ react.exports.createElement(DialogWrap, _extends$2({
    transitionName: "zoom",
    maskTransitionName: "fade",
    closable: false,
    keyboard: true,
    prefixCls,
    onClose: onClose2,
    afterClose: onAfterClose,
    visible,
    wrapClassName,
    rootClassName
  }, restProps), /* @__PURE__ */ react.exports.createElement("ul", {
    className: "".concat(prefixCls, "-operations")
  }, showLeftOrRightSwitches && /* @__PURE__ */ react.exports.createElement("li", {
    className: "".concat(prefixCls, "-operations-progress")
  }, (_countRender = countRender === null || countRender === void 0 ? void 0 : countRender(currentPreviewIndex + 1, previewGroupCount)) !== null && _countRender !== void 0 ? _countRender : "".concat(currentPreviewIndex + 1, " / ").concat(previewGroupCount)), tools.map(function(_ref) {
    var icon = _ref.icon, onClick = _ref.onClick, type4 = _ref.type, disabled = _ref.disabled;
    return /* @__PURE__ */ react.exports.createElement("li", {
      className: classNames(toolClassName, _defineProperty$4({}, "".concat(prefixCls, "-operations-operation-disabled"), !!disabled)),
      onClick,
      key: type4
    }, /* @__PURE__ */ react.exports.isValidElement(icon) ? /* @__PURE__ */ react.exports.cloneElement(icon, {
      className: iconClassName
    }) : icon);
  })), /* @__PURE__ */ react.exports.createElement("div", {
    className: "".concat(prefixCls, "-img-wrapper"),
    style: {
      transform: "translate3d(".concat(position.x, "px, ").concat(position.y, "px, 0)")
    }
  }, /* @__PURE__ */ react.exports.createElement("img", {
    width: props.width,
    height: props.height,
    onMouseDown,
    onDoubleClick,
    ref: imgRef,
    className: "".concat(prefixCls, "-img"),
    src: combinationSrc,
    alt,
    style: {
      transform: "scale3d(".concat(scale2, ", ").concat(scale2, ", 1) rotate(").concat(rotate2, "deg)")
    }
  })), showLeftOrRightSwitches && /* @__PURE__ */ react.exports.createElement("div", {
    className: classNames("".concat(prefixCls, "-switch-left"), _defineProperty$4({}, "".concat(prefixCls, "-switch-left-disabled"), currentPreviewIndex === 0)),
    onClick: onSwitchLeft
  }, left2), showLeftOrRightSwitches && /* @__PURE__ */ react.exports.createElement("div", {
    className: classNames("".concat(prefixCls, "-switch-right"), _defineProperty$4({}, "".concat(prefixCls, "-switch-right-disabled"), currentPreviewIndex === previewGroupCount - 1)),
    onClick: onSwitchRight
  }, right2));
};
var _excluded$9 = ["src", "alt", "onPreviewClose", "prefixCls", "previewPrefixCls", "placeholder", "fallback", "width", "height", "style", "preview", "className", "onClick", "onError", "wrapperClassName", "wrapperStyle", "rootClassName", "crossOrigin", "decoding", "loading", "referrerPolicy", "sizes", "srcSet", "useMap", "draggable"], _excluded2$1 = ["src", "visible", "onVisibleChange", "getContainer", "mask", "maskClassName", "icons"];
var uuid = 0;
var ImageInternal = function ImageInternal2(_ref) {
  var _imgCommonProps$style;
  var imgSrc = _ref.src, alt = _ref.alt, onInitialPreviewClose = _ref.onPreviewClose, _ref$prefixCls = _ref.prefixCls, prefixCls = _ref$prefixCls === void 0 ? "rc-image" : _ref$prefixCls, _ref$previewPrefixCls = _ref.previewPrefixCls, previewPrefixCls = _ref$previewPrefixCls === void 0 ? "".concat(prefixCls, "-preview") : _ref$previewPrefixCls, placeholder = _ref.placeholder, fallback = _ref.fallback, width = _ref.width, height = _ref.height, style2 = _ref.style, _ref$preview = _ref.preview, preview = _ref$preview === void 0 ? true : _ref$preview, className = _ref.className, onClick = _ref.onClick, onImageError = _ref.onError, wrapperClassName = _ref.wrapperClassName, wrapperStyle = _ref.wrapperStyle, rootClassName = _ref.rootClassName, crossOrigin = _ref.crossOrigin, decoding = _ref.decoding, loading = _ref.loading, referrerPolicy = _ref.referrerPolicy, sizes2 = _ref.sizes, srcSet = _ref.srcSet, useMap = _ref.useMap, draggable = _ref.draggable, otherProps = _objectWithoutProperties$1(_ref, _excluded$9);
  var isCustomPlaceholder = placeholder && placeholder !== true;
  var _ref2 = _typeof$4(preview) === "object" ? preview : {}, previewSrc = _ref2.src, _ref2$visible = _ref2.visible, previewVisible = _ref2$visible === void 0 ? void 0 : _ref2$visible, _ref2$onVisibleChange = _ref2.onVisibleChange, onPreviewVisibleChange = _ref2$onVisibleChange === void 0 ? onInitialPreviewClose : _ref2$onVisibleChange, _ref2$getContainer = _ref2.getContainer, getPreviewContainer = _ref2$getContainer === void 0 ? void 0 : _ref2$getContainer, previewMask = _ref2.mask, maskClassName = _ref2.maskClassName, icons2 = _ref2.icons, dialogProps = _objectWithoutProperties$1(_ref2, _excluded2$1);
  var src2 = previewSrc !== null && previewSrc !== void 0 ? previewSrc : imgSrc;
  var isControlled = previewVisible !== void 0;
  var _useMergedState = useMergedState(!!previewVisible, {
    value: previewVisible,
    onChange: onPreviewVisibleChange
  }), _useMergedState2 = _slicedToArray$4(_useMergedState, 2), isShowPreview = _useMergedState2[0], setShowPreview2 = _useMergedState2[1];
  var _useState = react.exports.useState(isCustomPlaceholder ? "loading" : "normal"), _useState2 = _slicedToArray$4(_useState, 2), status = _useState2[0], setStatus = _useState2[1];
  var _useState3 = react.exports.useState(null), _useState4 = _slicedToArray$4(_useState3, 2), mousePosition = _useState4[0], setMousePosition2 = _useState4[1];
  var isError = status === "error";
  var _React$useContext = react.exports.useContext(context), isPreviewGroup = _React$useContext.isPreviewGroup, setCurrent2 = _React$useContext.setCurrent, setGroupShowPreview = _React$useContext.setShowPreview, setGroupMousePosition = _React$useContext.setMousePosition, registerImage2 = _React$useContext.registerImage;
  var _React$useState = react.exports.useState(function() {
    uuid += 1;
    return uuid;
  }), _React$useState2 = _slicedToArray$4(_React$useState, 1), currentId = _React$useState2[0];
  var canPreview = preview && !isError;
  var isLoaded = react.exports.useRef(false);
  var onLoad = function onLoad2() {
    setStatus("normal");
  };
  var onError = function onError2(e3) {
    if (onImageError) {
      onImageError(e3);
    }
    setStatus("error");
  };
  var onPreview = function onPreview2(e3) {
    if (!isControlled) {
      var _getOffset = getOffset(e3.target), left2 = _getOffset.left, top = _getOffset.top;
      if (isPreviewGroup) {
        setCurrent2(currentId);
        setGroupMousePosition({
          x: left2,
          y: top
        });
      } else {
        setMousePosition2({
          x: left2,
          y: top
        });
      }
    }
    if (isPreviewGroup) {
      setGroupShowPreview(true);
    } else {
      setShowPreview2(true);
    }
    if (onClick)
      onClick(e3);
  };
  var onPreviewClose = function onPreviewClose2(e3) {
    e3.stopPropagation();
    setShowPreview2(false);
    if (!isControlled) {
      setMousePosition2(null);
    }
  };
  var getImgRef = function getImgRef2(img) {
    isLoaded.current = false;
    if (status !== "loading")
      return;
    if ((img === null || img === void 0 ? void 0 : img.complete) && (img.naturalWidth || img.naturalHeight)) {
      isLoaded.current = true;
      onLoad();
    }
  };
  react.exports.useEffect(function() {
    var unRegister = registerImage2(currentId, src2);
    return unRegister;
  }, []);
  react.exports.useEffect(function() {
    registerImage2(currentId, src2, canPreview);
  }, [src2, canPreview]);
  react.exports.useEffect(function() {
    if (isError) {
      setStatus("normal");
    }
    if (isCustomPlaceholder && !isLoaded.current) {
      setStatus("loading");
    }
  }, [imgSrc]);
  var wrapperClass = classNames(prefixCls, wrapperClassName, rootClassName, _defineProperty$4({}, "".concat(prefixCls, "-error"), isError));
  var mergedSrc = isError && fallback ? fallback : src2;
  var imgCommonProps = {
    crossOrigin,
    decoding,
    draggable,
    loading,
    referrerPolicy,
    sizes: sizes2,
    srcSet,
    useMap,
    alt,
    className: classNames("".concat(prefixCls, "-img"), _defineProperty$4({}, "".concat(prefixCls, "-img-placeholder"), placeholder === true), className),
    style: _objectSpread2$1({
      height
    }, style2)
  };
  return /* @__PURE__ */ react.exports.createElement(react.exports.Fragment, null, /* @__PURE__ */ react.exports.createElement("div", _extends$2({}, otherProps, {
    className: wrapperClass,
    onClick: canPreview ? onPreview : onClick,
    style: _objectSpread2$1({
      width,
      height
    }, wrapperStyle)
  }), /* @__PURE__ */ react.exports.createElement("img", _extends$2({}, imgCommonProps, {
    ref: getImgRef
  }, isError && fallback ? {
    src: fallback
  } : {
    onLoad,
    onError,
    src: imgSrc
  }, {
    width,
    height
  })), status === "loading" && /* @__PURE__ */ react.exports.createElement("div", {
    "aria-hidden": "true",
    className: "".concat(prefixCls, "-placeholder")
  }, placeholder), previewMask && canPreview && /* @__PURE__ */ react.exports.createElement("div", {
    className: classNames("".concat(prefixCls, "-mask"), maskClassName),
    style: {
      display: ((_imgCommonProps$style = imgCommonProps.style) === null || _imgCommonProps$style === void 0 ? void 0 : _imgCommonProps$style.display) === "none" ? "none" : void 0
    }
  }, previewMask)), !isPreviewGroup && canPreview && /* @__PURE__ */ react.exports.createElement(Preview, _extends$2({
    "aria-hidden": !isShowPreview,
    visible: isShowPreview,
    prefixCls: previewPrefixCls,
    onClose: onPreviewClose,
    mousePosition,
    src: mergedSrc,
    alt,
    getContainer: getPreviewContainer,
    icons: icons2,
    rootClassName
  }, dialogProps)));
};
ImageInternal.PreviewGroup = Group$4;
ImageInternal.displayName = "Image";
var RotateLeftOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "defs", "attrs": {}, "children": [{ "tag": "style", "attrs": {} }] }, { "tag": "path", "attrs": { "d": "M672 418H144c-17.7 0-32 14.3-32 32v414c0 17.7 14.3 32 32 32h528c17.7 0 32-14.3 32-32V450c0-17.7-14.3-32-32-32zm-44 402H188V494h440v326z" } }, { "tag": "path", "attrs": { "d": "M819.3 328.5c-78.8-100.7-196-153.6-314.6-154.2l-.2-64c0-6.5-7.6-10.1-12.6-6.1l-128 101c-4 3.1-3.9 9.1 0 12.3L492 318.6c5.1 4 12.7.4 12.6-6.1v-63.9c12.9.1 25.9.9 38.8 2.5 42.1 5.2 82.1 18.2 119 38.7 38.1 21.2 71.2 49.7 98.4 84.3 27.1 34.7 46.7 73.7 58.1 115.8a325.95 325.95 0 016.5 140.9h74.9c14.8-103.6-11.3-213-81-302.3z" } }] }, "name": "rotate-left", "theme": "outlined" };
var RotateLeftOutlinedSvg = RotateLeftOutlined$2;
var RotateLeftOutlined = function RotateLeftOutlined2(props, ref) {
  return /* @__PURE__ */ react.exports.createElement(AntdIcon, _objectSpread2$1(_objectSpread2$1({}, props), {}, {
    ref,
    icon: RotateLeftOutlinedSvg
  }));
};
RotateLeftOutlined.displayName = "RotateLeftOutlined";
var RotateLeftOutlined$1 = /* @__PURE__ */ react.exports.forwardRef(RotateLeftOutlined);
var RotateRightOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "defs", "attrs": {}, "children": [{ "tag": "style", "attrs": {} }] }, { "tag": "path", "attrs": { "d": "M480.5 251.2c13-1.6 25.9-2.4 38.8-2.5v63.9c0 6.5 7.5 10.1 12.6 6.1L660 217.6c4-3.2 4-9.2 0-12.3l-128-101c-5.1-4-12.6-.4-12.6 6.1l-.2 64c-118.6.5-235.8 53.4-314.6 154.2A399.75 399.75 0 00123.5 631h74.9c-.9-5.3-1.7-10.7-2.4-16.1-5.1-42.1-2.1-84.1 8.9-124.8 11.4-42.2 31-81.1 58.1-115.8 27.2-34.7 60.3-63.2 98.4-84.3 37-20.6 76.9-33.6 119.1-38.8z" } }, { "tag": "path", "attrs": { "d": "M880 418H352c-17.7 0-32 14.3-32 32v414c0 17.7 14.3 32 32 32h528c17.7 0 32-14.3 32-32V450c0-17.7-14.3-32-32-32zm-44 402H396V494h440v326z" } }] }, "name": "rotate-right", "theme": "outlined" };
var RotateRightOutlinedSvg = RotateRightOutlined$2;
var RotateRightOutlined = function RotateRightOutlined2(props, ref) {
  return /* @__PURE__ */ react.exports.createElement(AntdIcon, _objectSpread2$1(_objectSpread2$1({}, props), {}, {
    ref,
    icon: RotateRightOutlinedSvg
  }));
};
RotateRightOutlined.displayName = "RotateRightOutlined";
var RotateRightOutlined$1 = /* @__PURE__ */ react.exports.forwardRef(RotateRightOutlined);
var ZoomInOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M637 443H519V309c0-4.4-3.6-8-8-8h-60c-4.4 0-8 3.6-8 8v134H325c-4.4 0-8 3.6-8 8v60c0 4.4 3.6 8 8 8h118v134c0 4.4 3.6 8 8 8h60c4.4 0 8-3.6 8-8V519h118c4.4 0 8-3.6 8-8v-60c0-4.4-3.6-8-8-8zm284 424L775 721c122.1-148.9 113.6-369.5-26-509-148-148.1-388.4-148.1-537 0-148.1 148.6-148.1 389 0 537 139.5 139.6 360.1 148.1 509 26l146 146c3.2 2.8 8.3 2.8 11 0l43-43c2.8-2.7 2.8-7.8 0-11zM696 696c-118.8 118.7-311.2 118.7-430 0-118.7-118.8-118.7-311.2 0-430 118.8-118.7 311.2-118.7 430 0 118.7 118.8 118.7 311.2 0 430z" } }] }, "name": "zoom-in", "theme": "outlined" };
var ZoomInOutlinedSvg = ZoomInOutlined$2;
var ZoomInOutlined = function ZoomInOutlined2(props, ref) {
  return /* @__PURE__ */ react.exports.createElement(AntdIcon, _objectSpread2$1(_objectSpread2$1({}, props), {}, {
    ref,
    icon: ZoomInOutlinedSvg
  }));
};
ZoomInOutlined.displayName = "ZoomInOutlined";
var ZoomInOutlined$1 = /* @__PURE__ */ react.exports.forwardRef(ZoomInOutlined);
var ZoomOutOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M637 443H325c-4.4 0-8 3.6-8 8v60c0 4.4 3.6 8 8 8h312c4.4 0 8-3.6 8-8v-60c0-4.4-3.6-8-8-8zm284 424L775 721c122.1-148.9 113.6-369.5-26-509-148-148.1-388.4-148.1-537 0-148.1 148.6-148.1 389 0 537 139.5 139.6 360.1 148.1 509 26l146 146c3.2 2.8 8.3 2.8 11 0l43-43c2.8-2.7 2.8-7.8 0-11zM696 696c-118.8 118.7-311.2 118.7-430 0-118.7-118.8-118.7-311.2 0-430 118.8-118.7 311.2-118.7 430 0 118.7 118.8 118.7 311.2 0 430z" } }] }, "name": "zoom-out", "theme": "outlined" };
var ZoomOutOutlinedSvg = ZoomOutOutlined$2;
var ZoomOutOutlined = function ZoomOutOutlined2(props, ref) {
  return /* @__PURE__ */ react.exports.createElement(AntdIcon, _objectSpread2$1(_objectSpread2$1({}, props), {}, {
    ref,
    icon: ZoomOutOutlinedSvg
  }));
};
ZoomOutOutlined.displayName = "ZoomOutOutlined";
var ZoomOutOutlined$1 = /* @__PURE__ */ react.exports.forwardRef(ZoomOutOutlined);
var __rest$f = globalThis && globalThis.__rest || function(s2, e3) {
  var t2 = {};
  for (var p2 in s2) {
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  }
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e3.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
var icons = {
  rotateLeft: /* @__PURE__ */ react.exports.createElement(RotateLeftOutlined$1, null),
  rotateRight: /* @__PURE__ */ react.exports.createElement(RotateRightOutlined$1, null),
  zoomIn: /* @__PURE__ */ react.exports.createElement(ZoomInOutlined$1, null),
  zoomOut: /* @__PURE__ */ react.exports.createElement(ZoomOutOutlined$1, null),
  close: /* @__PURE__ */ react.exports.createElement(CloseOutlined$1, null),
  left: /* @__PURE__ */ react.exports.createElement(LeftOutlined$1, null),
  right: /* @__PURE__ */ react.exports.createElement(RightOutlined$1, null)
};
var InternalPreviewGroup = function InternalPreviewGroup2(_a2) {
  var customizePrefixCls = _a2.previewPrefixCls, preview = _a2.preview, props = __rest$f(_a2, ["previewPrefixCls", "preview"]);
  var _React$useContext = react.exports.useContext(ConfigContext), getPrefixCls = _React$useContext.getPrefixCls;
  var prefixCls = getPrefixCls("image-preview", customizePrefixCls);
  var rootPrefixCls = getPrefixCls();
  var mergedPreview = react.exports.useMemo(function() {
    if (preview === false) {
      return preview;
    }
    var _preview = _typeof$4(preview) === "object" ? preview : {};
    return _extends$2(_extends$2({}, _preview), {
      transitionName: getTransitionName(rootPrefixCls, "zoom", _preview.transitionName),
      maskTransitionName: getTransitionName(rootPrefixCls, "fade", _preview.maskTransitionName)
    });
  }, [preview]);
  return /* @__PURE__ */ react.exports.createElement(ImageInternal.PreviewGroup, _extends$2({
    preview: mergedPreview,
    previewPrefixCls: prefixCls,
    icons
  }, props));
};
var PreviewGroup = InternalPreviewGroup;
var __rest$e = globalThis && globalThis.__rest || function(s2, e3) {
  var t2 = {};
  for (var p2 in s2) {
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  }
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e3.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
var Image$3 = function Image2(_a2) {
  var customizePrefixCls = _a2.prefixCls, preview = _a2.preview, otherProps = __rest$e(_a2, ["prefixCls", "preview"]);
  var _useContext = react.exports.useContext(ConfigContext), getPrefixCls = _useContext.getPrefixCls, _useContext$locale = _useContext.locale, contextLocale = _useContext$locale === void 0 ? defaultLocale : _useContext$locale, getContextPopupContainer = _useContext.getPopupContainer;
  var prefixCls = getPrefixCls("image", customizePrefixCls);
  var rootPrefixCls = getPrefixCls();
  var imageLocale = contextLocale.Image || defaultLocale.Image;
  var mergedPreview = react.exports.useMemo(function() {
    if (preview === false) {
      return preview;
    }
    var _preview = _typeof$4(preview) === "object" ? preview : {};
    var getContainer2 = _preview.getContainer, restPreviewProps = __rest$e(_preview, ["getContainer"]);
    return _extends$2(_extends$2({
      mask: /* @__PURE__ */ react.exports.createElement("div", {
        className: "".concat(prefixCls, "-mask-info")
      }, /* @__PURE__ */ react.exports.createElement(EyeOutlined$1, null), imageLocale === null || imageLocale === void 0 ? void 0 : imageLocale.preview),
      icons
    }, restPreviewProps), {
      getContainer: getContainer2 || getContextPopupContainer,
      transitionName: getTransitionName(rootPrefixCls, "zoom", _preview.transitionName),
      maskTransitionName: getTransitionName(rootPrefixCls, "fade", _preview.maskTransitionName)
    });
  }, [preview, imageLocale]);
  return /* @__PURE__ */ react.exports.createElement(ImageInternal, _extends$2({
    prefixCls,
    preview: mergedPreview
  }, otherProps));
};
Image$3.PreviewGroup = PreviewGroup;
var Image$4 = Image$3;
var Group$2 = function Group3(props) {
  var _classNames;
  var _useContext = react.exports.useContext(ConfigContext), getPrefixCls = _useContext.getPrefixCls, direction2 = _useContext.direction;
  var customizePrefixCls = props.prefixCls, _props$className = props.className, className = _props$className === void 0 ? "" : _props$className;
  var prefixCls = getPrefixCls("input-group", customizePrefixCls);
  var cls = classNames(prefixCls, (_classNames = {}, _defineProperty$4(_classNames, "".concat(prefixCls, "-lg"), props.size === "large"), _defineProperty$4(_classNames, "".concat(prefixCls, "-sm"), props.size === "small"), _defineProperty$4(_classNames, "".concat(prefixCls, "-compact"), props.compact), _defineProperty$4(_classNames, "".concat(prefixCls, "-rtl"), direction2 === "rtl"), _classNames), className);
  var formItemContext = react.exports.useContext(FormItemInputContext);
  var groupFormItemContext = react.exports.useMemo(function() {
    return _extends$2(_extends$2({}, formItemContext), {
      isFormItemInput: false
    });
  }, [formItemContext]);
  return /* @__PURE__ */ react.exports.createElement("span", {
    className: cls,
    style: props.style,
    onMouseEnter: props.onMouseEnter,
    onMouseLeave: props.onMouseLeave,
    onFocus: props.onFocus,
    onBlur: props.onBlur
  }, /* @__PURE__ */ react.exports.createElement(FormItemInputContext.Provider, {
    value: groupFormItemContext
  }, props.children));
};
var Group$3 = Group$2;
function hasAddon$1(props) {
  return !!(props.addonBefore || props.addonAfter);
}
function hasPrefixSuffix$1(props) {
  return !!(props.prefix || props.suffix || props.allowClear);
}
function resolveOnChange$1(target, e3, onChange2, targetValue) {
  if (!onChange2) {
    return;
  }
  var event = e3;
  if (e3.type === "click") {
    var currentTarget = target.cloneNode(true);
    event = Object.create(e3, {
      target: {
        value: currentTarget
      },
      currentTarget: {
        value: currentTarget
      }
    });
    currentTarget.value = "";
    onChange2(event);
    return;
  }
  if (targetValue !== void 0) {
    event = Object.create(e3, {
      target: {
        value: target
      },
      currentTarget: {
        value: target
      }
    });
    target.value = targetValue;
    onChange2(event);
    return;
  }
  onChange2(event);
}
function triggerFocus$1(element, option) {
  if (!element)
    return;
  element.focus(option);
  var _ref = option || {}, cursor = _ref.cursor;
  if (cursor) {
    var len = element.value.length;
    switch (cursor) {
      case "start":
        element.setSelectionRange(0, 0);
        break;
      case "end":
        element.setSelectionRange(len, len);
        break;
      default:
        element.setSelectionRange(0, len);
    }
  }
}
function fixControlledValue$1(value2) {
  if (typeof value2 === "undefined" || value2 === null) {
    return "";
  }
  return String(value2);
}
var BaseInput = function BaseInput2(props) {
  var inputElement = props.inputElement, prefixCls = props.prefixCls, prefix = props.prefix, suffix = props.suffix, addonBefore = props.addonBefore, addonAfter = props.addonAfter, className = props.className, style2 = props.style, affixWrapperClassName = props.affixWrapperClassName, groupClassName = props.groupClassName, wrapperClassName = props.wrapperClassName, disabled = props.disabled, readOnly = props.readOnly, focused = props.focused, triggerFocus2 = props.triggerFocus, allowClear = props.allowClear, value2 = props.value, handleReset = props.handleReset, hidden = props.hidden;
  var containerRef = react.exports.useRef(null);
  var onInputMouseDown = function onInputMouseDown2(e3) {
    var _containerRef$current;
    if ((_containerRef$current = containerRef.current) === null || _containerRef$current === void 0 ? void 0 : _containerRef$current.contains(e3.target)) {
      triggerFocus2 === null || triggerFocus2 === void 0 ? void 0 : triggerFocus2();
    }
  };
  var getClearIcon = function getClearIcon2() {
    var _classNames;
    if (!allowClear) {
      return null;
    }
    var needClear = !disabled && !readOnly && value2;
    var clearIconCls = "".concat(prefixCls, "-clear-icon");
    var iconNode = _typeof$4(allowClear) === "object" && (allowClear === null || allowClear === void 0 ? void 0 : allowClear.clearIcon) ? allowClear.clearIcon : "\u2716";
    return /* @__PURE__ */ jsx("span", {
      onClick: handleReset,
      onMouseDown: function onMouseDown(e3) {
        return e3.preventDefault();
      },
      className: classNames(clearIconCls, (_classNames = {}, _defineProperty$4(_classNames, "".concat(clearIconCls, "-hidden"), !needClear), _defineProperty$4(_classNames, "".concat(clearIconCls, "-has-suffix"), !!suffix), _classNames)),
      role: "button",
      tabIndex: -1,
      children: iconNode
    });
  };
  var element = /* @__PURE__ */ react.exports.cloneElement(inputElement, {
    value: value2,
    hidden
  });
  if (hasPrefixSuffix$1(props)) {
    var _classNames2;
    var affixWrapperPrefixCls = "".concat(prefixCls, "-affix-wrapper");
    var affixWrapperCls = classNames(affixWrapperPrefixCls, (_classNames2 = {}, _defineProperty$4(_classNames2, "".concat(affixWrapperPrefixCls, "-disabled"), disabled), _defineProperty$4(_classNames2, "".concat(affixWrapperPrefixCls, "-focused"), focused), _defineProperty$4(_classNames2, "".concat(affixWrapperPrefixCls, "-readonly"), readOnly), _defineProperty$4(_classNames2, "".concat(affixWrapperPrefixCls, "-input-with-clear-btn"), suffix && allowClear && value2), _classNames2), !hasAddon$1(props) && className, affixWrapperClassName);
    var suffixNode = (suffix || allowClear) && /* @__PURE__ */ jsxs("span", {
      className: "".concat(prefixCls, "-suffix"),
      children: [getClearIcon(), suffix]
    });
    element = /* @__PURE__ */ jsxs("span", {
      className: affixWrapperCls,
      style: style2,
      hidden: !hasAddon$1(props) && hidden,
      onMouseDown: onInputMouseDown,
      ref: containerRef,
      children: [prefix && /* @__PURE__ */ jsx("span", {
        className: "".concat(prefixCls, "-prefix"),
        children: prefix
      }), /* @__PURE__ */ react.exports.cloneElement(inputElement, {
        style: null,
        value: value2,
        hidden: null
      }), suffixNode]
    });
  }
  if (hasAddon$1(props)) {
    var wrapperCls = "".concat(prefixCls, "-group");
    var addonCls = "".concat(wrapperCls, "-addon");
    var mergedWrapperClassName = classNames("".concat(prefixCls, "-wrapper"), wrapperCls, wrapperClassName);
    var mergedGroupClassName = classNames("".concat(prefixCls, "-group-wrapper"), className, groupClassName);
    return /* @__PURE__ */ jsx("span", {
      className: mergedGroupClassName,
      style: style2,
      hidden,
      children: /* @__PURE__ */ jsxs("span", {
        className: mergedWrapperClassName,
        children: [addonBefore && /* @__PURE__ */ jsx("span", {
          className: addonCls,
          children: addonBefore
        }), /* @__PURE__ */ react.exports.cloneElement(element, {
          style: null,
          hidden: null
        }), addonAfter && /* @__PURE__ */ jsx("span", {
          className: addonCls,
          children: addonAfter
        })]
      })
    });
  }
  return element;
};
var _excluded$8 = ["autoComplete", "onChange", "onFocus", "onBlur", "onPressEnter", "onKeyDown", "prefixCls", "disabled", "htmlSize", "className", "maxLength", "suffix", "showCount", "type", "inputClassName"];
var Input$3 = /* @__PURE__ */ react.exports.forwardRef(function(props, ref) {
  var autoComplete = props.autoComplete, onChange2 = props.onChange, onFocus2 = props.onFocus, onBlur2 = props.onBlur, onPressEnter = props.onPressEnter, onKeyDown2 = props.onKeyDown, _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-input" : _props$prefixCls, disabled = props.disabled, htmlSize = props.htmlSize, className = props.className, maxLength = props.maxLength, suffix = props.suffix, showCount = props.showCount, _props$type = props.type, type4 = _props$type === void 0 ? "text" : _props$type, inputClassName = props.inputClassName, rest = _objectWithoutProperties$1(props, _excluded$8);
  var _useMergedState = useMergedState(props.defaultValue, {
    value: props.value
  }), _useMergedState2 = _slicedToArray$4(_useMergedState, 2), value2 = _useMergedState2[0], setValue2 = _useMergedState2[1];
  var _useState = react.exports.useState(false), _useState2 = _slicedToArray$4(_useState, 2), focused = _useState2[0], setFocused = _useState2[1];
  var inputRef = react.exports.useRef(null);
  var focus = function focus2(option) {
    if (inputRef.current) {
      triggerFocus$1(inputRef.current, option);
    }
  };
  react.exports.useImperativeHandle(ref, function() {
    return {
      focus,
      blur: function blur() {
        var _inputRef$current;
        (_inputRef$current = inputRef.current) === null || _inputRef$current === void 0 ? void 0 : _inputRef$current.blur();
      },
      setSelectionRange: function setSelectionRange(start, end, direction2) {
        var _inputRef$current2;
        (_inputRef$current2 = inputRef.current) === null || _inputRef$current2 === void 0 ? void 0 : _inputRef$current2.setSelectionRange(start, end, direction2);
      },
      select: function select() {
        var _inputRef$current3;
        (_inputRef$current3 = inputRef.current) === null || _inputRef$current3 === void 0 ? void 0 : _inputRef$current3.select();
      },
      input: inputRef.current
    };
  });
  react.exports.useEffect(function() {
    setFocused(function(prev) {
      return prev && disabled ? false : prev;
    });
  }, [disabled]);
  var handleChange = function handleChange2(e3) {
    if (props.value === void 0) {
      setValue2(e3.target.value);
    }
    if (inputRef.current) {
      resolveOnChange$1(inputRef.current, e3, onChange2);
    }
  };
  var handleKeyDown = function handleKeyDown2(e3) {
    if (onPressEnter && e3.key === "Enter") {
      onPressEnter(e3);
    }
    onKeyDown2 === null || onKeyDown2 === void 0 ? void 0 : onKeyDown2(e3);
  };
  var handleFocus = function handleFocus2(e3) {
    setFocused(true);
    onFocus2 === null || onFocus2 === void 0 ? void 0 : onFocus2(e3);
  };
  var handleBlur = function handleBlur2(e3) {
    setFocused(false);
    onBlur2 === null || onBlur2 === void 0 ? void 0 : onBlur2(e3);
  };
  var handleReset = function handleReset2(e3) {
    setValue2("");
    focus();
    if (inputRef.current) {
      resolveOnChange$1(inputRef.current, e3, onChange2);
    }
  };
  var getInputElement = function getInputElement2() {
    var otherProps = omit$2(props, [
      "prefixCls",
      "onPressEnter",
      "addonBefore",
      "addonAfter",
      "prefix",
      "suffix",
      "allowClear",
      "defaultValue",
      "showCount",
      "affixWrapperClassName",
      "groupClassName",
      "inputClassName",
      "wrapperClassName",
      "htmlSize"
    ]);
    return /* @__PURE__ */ jsx("input", {
      ..._objectSpread2$1(_objectSpread2$1({
        autoComplete
      }, otherProps), {}, {
        onChange: handleChange,
        onFocus: handleFocus,
        onBlur: handleBlur,
        onKeyDown: handleKeyDown,
        className: classNames(prefixCls, _defineProperty$4({}, "".concat(prefixCls, "-disabled"), disabled), inputClassName, !hasAddon$1(props) && !hasPrefixSuffix$1(props) && className),
        ref: inputRef,
        size: htmlSize,
        type: type4
      })
    });
  };
  var getSuffix = function getSuffix2() {
    var hasMaxLength = Number(maxLength) > 0;
    if (suffix || showCount) {
      var val = fixControlledValue$1(value2);
      var valueLength = _toConsumableArray(val).length;
      var dataCount = _typeof$4(showCount) === "object" ? showCount.formatter({
        value: val,
        count: valueLength,
        maxLength
      }) : "".concat(valueLength).concat(hasMaxLength ? " / ".concat(maxLength) : "");
      return /* @__PURE__ */ jsxs(Fragment, {
        children: [!!showCount && /* @__PURE__ */ jsx("span", {
          className: classNames("".concat(prefixCls, "-show-count-suffix"), _defineProperty$4({}, "".concat(prefixCls, "-show-count-has-suffix"), !!suffix)),
          children: dataCount
        }), suffix]
      });
    }
    return null;
  };
  return /* @__PURE__ */ jsx(BaseInput, {
    ..._objectSpread2$1(_objectSpread2$1({}, rest), {}, {
      prefixCls,
      className,
      inputElement: getInputElement(),
      handleReset,
      value: fixControlledValue$1(value2),
      focused,
      triggerFocus: focus,
      suffix: getSuffix(),
      disabled
    })
  });
});
function hasPrefixSuffix(props) {
  return !!(props.prefix || props.suffix || props.allowClear);
}
var __rest$d = globalThis && globalThis.__rest || function(s2, e3) {
  var t2 = {};
  for (var p2 in s2) {
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  }
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e3.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
function fixControlledValue(value2) {
  if (typeof value2 === "undefined" || value2 === null) {
    return "";
  }
  return String(value2);
}
function resolveOnChange(target, e3, onChange2, targetValue) {
  if (!onChange2) {
    return;
  }
  var event = e3;
  if (e3.type === "click") {
    var currentTarget = target.cloneNode(true);
    event = Object.create(e3, {
      target: {
        value: currentTarget
      },
      currentTarget: {
        value: currentTarget
      }
    });
    currentTarget.value = "";
    onChange2(event);
    return;
  }
  if (targetValue !== void 0) {
    event = Object.create(e3, {
      target: {
        value: target
      },
      currentTarget: {
        value: target
      }
    });
    target.value = targetValue;
    onChange2(event);
    return;
  }
  onChange2(event);
}
function triggerFocus(element, option) {
  if (!element) {
    return;
  }
  element.focus(option);
  var _ref = option || {}, cursor = _ref.cursor;
  if (cursor) {
    var len = element.value.length;
    switch (cursor) {
      case "start":
        element.setSelectionRange(0, 0);
        break;
      case "end":
        element.setSelectionRange(len, len);
        break;
      default:
        element.setSelectionRange(0, len);
        break;
    }
  }
}
var Input$2 = /* @__PURE__ */ react.exports.forwardRef(function(props, ref) {
  var _classNames, _classNames2, _classNames4;
  var customizePrefixCls = props.prefixCls, _props$bordered = props.bordered, bordered = _props$bordered === void 0 ? true : _props$bordered, customStatus = props.status, customSize = props.size, customDisabled = props.disabled, onBlur2 = props.onBlur, onFocus2 = props.onFocus, suffix = props.suffix, allowClear = props.allowClear, addonAfter = props.addonAfter, addonBefore = props.addonBefore, onChange2 = props.onChange, rest = __rest$d(props, ["prefixCls", "bordered", "status", "size", "disabled", "onBlur", "onFocus", "suffix", "allowClear", "addonAfter", "addonBefore", "onChange"]);
  var _React$useContext = React.useContext(ConfigContext), getPrefixCls = _React$useContext.getPrefixCls, direction2 = _React$useContext.direction, input = _React$useContext.input;
  var prefixCls = getPrefixCls("input", customizePrefixCls);
  var inputRef = react.exports.useRef(null);
  var size2 = React.useContext(SizeContext$1);
  var mergedSize = customSize || size2;
  var disabled = React.useContext(DisabledContext$1);
  var mergedDisabled = customDisabled || disabled;
  var _useContext = react.exports.useContext(FormItemInputContext), contextStatus = _useContext.status, hasFeedback = _useContext.hasFeedback, feedbackIcon = _useContext.feedbackIcon;
  var mergedStatus = getMergedStatus(contextStatus, customStatus);
  var inputHasPrefixSuffix = hasPrefixSuffix(props) || !!hasFeedback;
  var prevHasPrefixSuffix = react.exports.useRef(inputHasPrefixSuffix);
  react.exports.useEffect(function() {
    if (inputHasPrefixSuffix && !prevHasPrefixSuffix.current)
      ;
    prevHasPrefixSuffix.current = inputHasPrefixSuffix;
  }, [inputHasPrefixSuffix]);
  var removePasswordTimeoutRef = react.exports.useRef([]);
  var removePasswordTimeout = function removePasswordTimeout2() {
    removePasswordTimeoutRef.current.push(window.setTimeout(function() {
      var _a2, _b, _c, _d;
      if (((_a2 = inputRef.current) === null || _a2 === void 0 ? void 0 : _a2.input) && ((_b = inputRef.current) === null || _b === void 0 ? void 0 : _b.input.getAttribute("type")) === "password" && ((_c = inputRef.current) === null || _c === void 0 ? void 0 : _c.input.hasAttribute("value"))) {
        (_d = inputRef.current) === null || _d === void 0 ? void 0 : _d.input.removeAttribute("value");
      }
    }));
  };
  react.exports.useEffect(function() {
    removePasswordTimeout();
    return function() {
      return removePasswordTimeoutRef.current.forEach(function(item) {
        return window.clearTimeout(item);
      });
    };
  }, []);
  var handleBlur = function handleBlur2(e3) {
    removePasswordTimeout();
    onBlur2 === null || onBlur2 === void 0 ? void 0 : onBlur2(e3);
  };
  var handleFocus = function handleFocus2(e3) {
    removePasswordTimeout();
    onFocus2 === null || onFocus2 === void 0 ? void 0 : onFocus2(e3);
  };
  var handleChange = function handleChange2(e3) {
    removePasswordTimeout();
    onChange2 === null || onChange2 === void 0 ? void 0 : onChange2(e3);
  };
  var suffixNode = (hasFeedback || suffix) && /* @__PURE__ */ jsxs(Fragment, {
    children: [suffix, hasFeedback && feedbackIcon]
  });
  var mergedAllowClear;
  if (_typeof$4(allowClear) === "object" && (allowClear === null || allowClear === void 0 ? void 0 : allowClear.clearIcon)) {
    mergedAllowClear = allowClear;
  } else if (allowClear) {
    mergedAllowClear = {
      clearIcon: /* @__PURE__ */ jsx(CloseCircleFilled$1, {})
    };
  }
  return /* @__PURE__ */ jsx(Input$3, {
    ref: composeRef(ref, inputRef),
    prefixCls,
    autoComplete: input === null || input === void 0 ? void 0 : input.autoComplete,
    ...rest,
    disabled: mergedDisabled || void 0,
    onBlur: handleBlur,
    onFocus: handleFocus,
    suffix: suffixNode,
    allowClear: mergedAllowClear,
    onChange: handleChange,
    addonAfter: addonAfter && /* @__PURE__ */ jsx(NoFormStyle, {
      override: true,
      status: true,
      children: addonAfter
    }),
    addonBefore: addonBefore && /* @__PURE__ */ jsx(NoFormStyle, {
      override: true,
      status: true,
      children: addonBefore
    }),
    inputClassName: classNames((_classNames = {}, _defineProperty$4(_classNames, "".concat(prefixCls, "-sm"), mergedSize === "small"), _defineProperty$4(_classNames, "".concat(prefixCls, "-lg"), mergedSize === "large"), _defineProperty$4(_classNames, "".concat(prefixCls, "-rtl"), direction2 === "rtl"), _defineProperty$4(_classNames, "".concat(prefixCls, "-borderless"), !bordered), _classNames), !inputHasPrefixSuffix && getStatusClassNames(prefixCls, mergedStatus)),
    affixWrapperClassName: classNames((_classNames2 = {}, _defineProperty$4(_classNames2, "".concat(prefixCls, "-affix-wrapper-sm"), mergedSize === "small"), _defineProperty$4(_classNames2, "".concat(prefixCls, "-affix-wrapper-lg"), mergedSize === "large"), _defineProperty$4(_classNames2, "".concat(prefixCls, "-affix-wrapper-rtl"), direction2 === "rtl"), _defineProperty$4(_classNames2, "".concat(prefixCls, "-affix-wrapper-borderless"), !bordered), _classNames2), getStatusClassNames("".concat(prefixCls, "-affix-wrapper"), mergedStatus, hasFeedback)),
    wrapperClassName: classNames(_defineProperty$4({}, "".concat(prefixCls, "-group-rtl"), direction2 === "rtl")),
    groupClassName: classNames((_classNames4 = {}, _defineProperty$4(_classNames4, "".concat(prefixCls, "-group-wrapper-sm"), mergedSize === "small"), _defineProperty$4(_classNames4, "".concat(prefixCls, "-group-wrapper-lg"), mergedSize === "large"), _defineProperty$4(_classNames4, "".concat(prefixCls, "-group-wrapper-rtl"), direction2 === "rtl"), _classNames4), getStatusClassNames("".concat(prefixCls, "-group-wrapper"), mergedStatus, hasFeedback))
  });
});
var InternalInput = Input$2;
var EyeInvisibleOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M942.2 486.2Q889.47 375.11 816.7 305l-50.88 50.88C807.31 395.53 843.45 447.4 874.7 512 791.5 684.2 673.4 766 512 766q-72.67 0-133.87-22.38L323 798.75Q408 838 512 838q288.3 0 430.2-300.3a60.29 60.29 0 000-51.5zm-63.57-320.64L836 122.88a8 8 0 00-11.32 0L715.31 232.2Q624.86 186 512 186q-288.3 0-430.2 300.3a60.3 60.3 0 000 51.5q56.69 119.4 136.5 191.41L112.48 835a8 8 0 000 11.31L155.17 889a8 8 0 0011.31 0l712.15-712.12a8 8 0 000-11.32zM149.3 512C232.6 339.8 350.7 258 512 258c54.54 0 104.13 9.36 149.12 28.39l-70.3 70.3a176 176 0 00-238.13 238.13l-83.42 83.42C223.1 637.49 183.3 582.28 149.3 512zm246.7 0a112.11 112.11 0 01146.2-106.69L401.31 546.2A112 112 0 01396 512z" } }, { "tag": "path", "attrs": { "d": "M508 624c-3.46 0-6.87-.16-10.25-.47l-52.82 52.82a176.09 176.09 0 00227.42-227.42l-52.82 52.82c.31 3.38.47 6.79.47 10.25a111.94 111.94 0 01-112 112z" } }] }, "name": "eye-invisible", "theme": "outlined" };
var EyeInvisibleOutlinedSvg = EyeInvisibleOutlined$2;
var EyeInvisibleOutlined = function EyeInvisibleOutlined2(props, ref) {
  return /* @__PURE__ */ react.exports.createElement(AntdIcon, _objectSpread2$1(_objectSpread2$1({}, props), {}, {
    ref,
    icon: EyeInvisibleOutlinedSvg
  }));
};
EyeInvisibleOutlined.displayName = "EyeInvisibleOutlined";
var EyeInvisibleOutlined$1 = /* @__PURE__ */ react.exports.forwardRef(EyeInvisibleOutlined);
var __rest$c = globalThis && globalThis.__rest || function(s2, e3) {
  var t2 = {};
  for (var p2 in s2) {
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  }
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e3.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
var defaultIconRender = function defaultIconRender2(visible) {
  return visible ? /* @__PURE__ */ react.exports.createElement(EyeOutlined$1, null) : /* @__PURE__ */ react.exports.createElement(EyeInvisibleOutlined$1, null);
};
var ActionMap = {
  click: "onClick",
  hover: "onMouseOver"
};
var Password = /* @__PURE__ */ react.exports.forwardRef(function(props, ref) {
  var _useState = react.exports.useState(false), _useState2 = _slicedToArray$4(_useState, 2), visible = _useState2[0], setVisible = _useState2[1];
  var onVisibleChange = function onVisibleChange2() {
    var disabled = props.disabled;
    if (disabled) {
      return;
    }
    setVisible(function(prevState) {
      return !prevState;
    });
  };
  var getIcon2 = function getIcon3(prefixCls) {
    var _iconProps;
    var _props$action = props.action, action = _props$action === void 0 ? "click" : _props$action, _props$iconRender = props.iconRender, iconRender = _props$iconRender === void 0 ? defaultIconRender : _props$iconRender;
    var iconTrigger = ActionMap[action] || "";
    var icon = iconRender(visible);
    var iconProps = (_iconProps = {}, _defineProperty$4(_iconProps, iconTrigger, onVisibleChange), _defineProperty$4(_iconProps, "className", "".concat(prefixCls, "-icon")), _defineProperty$4(_iconProps, "key", "passwordIcon"), _defineProperty$4(_iconProps, "onMouseDown", function onMouseDown(e3) {
      e3.preventDefault();
    }), _defineProperty$4(_iconProps, "onMouseUp", function onMouseUp(e3) {
      e3.preventDefault();
    }), _iconProps);
    return /* @__PURE__ */ react.exports.cloneElement(/* @__PURE__ */ react.exports.isValidElement(icon) ? icon : /* @__PURE__ */ react.exports.createElement("span", null, icon), iconProps);
  };
  var renderPassword = function renderPassword2(_ref) {
    var getPrefixCls = _ref.getPrefixCls;
    var className = props.className, customizePrefixCls = props.prefixCls, customizeInputPrefixCls = props.inputPrefixCls, size2 = props.size, _props$visibilityTogg = props.visibilityToggle, visibilityToggle = _props$visibilityTogg === void 0 ? true : _props$visibilityTogg, restProps = __rest$c(props, ["className", "prefixCls", "inputPrefixCls", "size", "visibilityToggle"]);
    var inputPrefixCls = getPrefixCls("input", customizeInputPrefixCls);
    var prefixCls = getPrefixCls("input-password", customizePrefixCls);
    var suffixIcon = visibilityToggle && getIcon2(prefixCls);
    var inputClassName = classNames(prefixCls, className, _defineProperty$4({}, "".concat(prefixCls, "-").concat(size2), !!size2));
    var omittedProps = _extends$2(_extends$2({}, omit$2(restProps, ["suffix", "iconRender"])), {
      type: visible ? "text" : "password",
      className: inputClassName,
      prefixCls: inputPrefixCls,
      suffix: suffixIcon
    });
    if (size2) {
      omittedProps.size = size2;
    }
    return /* @__PURE__ */ react.exports.createElement(InternalInput, _extends$2({
      ref
    }, omittedProps));
  };
  return /* @__PURE__ */ react.exports.createElement(ConfigConsumer, null, renderPassword);
});
var Password$1 = Password;
var __rest$b = globalThis && globalThis.__rest || function(s2, e3) {
  var t2 = {};
  for (var p2 in s2) {
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  }
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e3.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
var Search$1 = /* @__PURE__ */ react.exports.forwardRef(function(props, ref) {
  var _classNames;
  var customizePrefixCls = props.prefixCls, customizeInputPrefixCls = props.inputPrefixCls, className = props.className, customizeSize = props.size, suffix = props.suffix, _props$enterButton = props.enterButton, enterButton = _props$enterButton === void 0 ? false : _props$enterButton, addonAfter = props.addonAfter, loading = props.loading, disabled = props.disabled, customOnSearch = props.onSearch, customOnChange = props.onChange, onCompositionStart = props.onCompositionStart, onCompositionEnd = props.onCompositionEnd, restProps = __rest$b(props, ["prefixCls", "inputPrefixCls", "className", "size", "suffix", "enterButton", "addonAfter", "loading", "disabled", "onSearch", "onChange", "onCompositionStart", "onCompositionEnd"]);
  var _React$useContext = react.exports.useContext(ConfigContext), getPrefixCls = _React$useContext.getPrefixCls, direction2 = _React$useContext.direction;
  var contextSize = react.exports.useContext(SizeContext$1);
  var composedRef = react.exports.useRef(false);
  var size2 = customizeSize || contextSize;
  var inputRef = react.exports.useRef(null);
  var onChange2 = function onChange3(e3) {
    if (e3 && e3.target && e3.type === "click" && customOnSearch) {
      customOnSearch(e3.target.value, e3);
    }
    if (customOnChange) {
      customOnChange(e3);
    }
  };
  var onMouseDown = function onMouseDown2(e3) {
    var _a2;
    if (document.activeElement === ((_a2 = inputRef.current) === null || _a2 === void 0 ? void 0 : _a2.input)) {
      e3.preventDefault();
    }
  };
  var onSearch = function onSearch2(e3) {
    var _a2, _b;
    if (customOnSearch) {
      customOnSearch((_b = (_a2 = inputRef.current) === null || _a2 === void 0 ? void 0 : _a2.input) === null || _b === void 0 ? void 0 : _b.value, e3);
    }
  };
  var onPressEnter = function onPressEnter2(e3) {
    if (composedRef.current) {
      return;
    }
    onSearch(e3);
  };
  var prefixCls = getPrefixCls("input-search", customizePrefixCls);
  var inputPrefixCls = getPrefixCls("input", customizeInputPrefixCls);
  var searchIcon = typeof enterButton === "boolean" ? /* @__PURE__ */ react.exports.createElement(SearchOutlined$1, null) : null;
  var btnClassName = "".concat(prefixCls, "-button");
  var button;
  var enterButtonAsElement = enterButton || {};
  var isAntdButton = enterButtonAsElement.type && enterButtonAsElement.type.__ANT_BUTTON === true;
  if (isAntdButton || enterButtonAsElement.type === "button") {
    button = cloneElement(enterButtonAsElement, _extends$2({
      onMouseDown,
      onClick: function onClick(e3) {
        var _a2, _b;
        (_b = (_a2 = enterButtonAsElement === null || enterButtonAsElement === void 0 ? void 0 : enterButtonAsElement.props) === null || _a2 === void 0 ? void 0 : _a2.onClick) === null || _b === void 0 ? void 0 : _b.call(_a2, e3);
        onSearch(e3);
      },
      key: "enterButton"
    }, isAntdButton ? {
      className: btnClassName,
      size: size2
    } : {}));
  } else {
    button = /* @__PURE__ */ react.exports.createElement(Button$2, {
      className: btnClassName,
      type: enterButton ? "primary" : void 0,
      size: size2,
      disabled,
      key: "enterButton",
      onMouseDown,
      onClick: onSearch,
      loading,
      icon: searchIcon
    }, enterButton);
  }
  if (addonAfter) {
    button = [button, cloneElement(addonAfter, {
      key: "addonAfter"
    })];
  }
  var cls = classNames(prefixCls, (_classNames = {}, _defineProperty$4(_classNames, "".concat(prefixCls, "-rtl"), direction2 === "rtl"), _defineProperty$4(_classNames, "".concat(prefixCls, "-").concat(size2), !!size2), _defineProperty$4(_classNames, "".concat(prefixCls, "-with-button"), !!enterButton), _classNames), className);
  var handleOnCompositionStart = function handleOnCompositionStart2(e3) {
    composedRef.current = true;
    onCompositionStart === null || onCompositionStart === void 0 ? void 0 : onCompositionStart(e3);
  };
  var handleOnCompositionEnd = function handleOnCompositionEnd2(e3) {
    composedRef.current = false;
    onCompositionEnd === null || onCompositionEnd === void 0 ? void 0 : onCompositionEnd(e3);
  };
  return /* @__PURE__ */ react.exports.createElement(InternalInput, _extends$2({
    ref: composeRef(inputRef, ref),
    onPressEnter
  }, restProps, {
    size: size2,
    onCompositionStart: handleOnCompositionStart,
    onCompositionEnd: handleOnCompositionEnd,
    prefixCls: inputPrefixCls,
    addonAfter: button,
    suffix,
    onChange: onChange2,
    className: cls,
    disabled
  }));
});
var Search$2 = Search$1;
var HIDDEN_TEXTAREA_STYLE = "\n  min-height:0 !important;\n  max-height:none !important;\n  height:0 !important;\n  visibility:hidden !important;\n  overflow:hidden !important;\n  position:absolute !important;\n  z-index:-1000 !important;\n  top:0 !important;\n  right:0 !important\n";
var SIZING_STYLE = ["letter-spacing", "line-height", "padding-top", "padding-bottom", "font-family", "font-weight", "font-size", "font-variant", "text-rendering", "text-transform", "width", "text-indent", "padding-left", "padding-right", "border-width", "box-sizing", "word-break"];
var computedStyleCache = {};
var hiddenTextarea;
function calculateNodeStyling(node) {
  var useCache2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  var nodeRef = node.getAttribute("id") || node.getAttribute("data-reactid") || node.getAttribute("name");
  if (useCache2 && computedStyleCache[nodeRef]) {
    return computedStyleCache[nodeRef];
  }
  var style2 = window.getComputedStyle(node);
  var boxSizing = style2.getPropertyValue("box-sizing") || style2.getPropertyValue("-moz-box-sizing") || style2.getPropertyValue("-webkit-box-sizing");
  var paddingSize = parseFloat(style2.getPropertyValue("padding-bottom")) + parseFloat(style2.getPropertyValue("padding-top"));
  var borderSize = parseFloat(style2.getPropertyValue("border-bottom-width")) + parseFloat(style2.getPropertyValue("border-top-width"));
  var sizingStyle = SIZING_STYLE.map(function(name) {
    return "".concat(name, ":").concat(style2.getPropertyValue(name));
  }).join(";");
  var nodeInfo = {
    sizingStyle,
    paddingSize,
    borderSize,
    boxSizing
  };
  if (useCache2 && nodeRef) {
    computedStyleCache[nodeRef] = nodeInfo;
  }
  return nodeInfo;
}
function calculateNodeHeight(uiTextNode) {
  var useCache2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  var minRows = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
  var maxRows = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
  if (!hiddenTextarea) {
    hiddenTextarea = document.createElement("textarea");
    hiddenTextarea.setAttribute("tab-index", "-1");
    hiddenTextarea.setAttribute("aria-hidden", "true");
    document.body.appendChild(hiddenTextarea);
  }
  if (uiTextNode.getAttribute("wrap")) {
    hiddenTextarea.setAttribute("wrap", uiTextNode.getAttribute("wrap"));
  } else {
    hiddenTextarea.removeAttribute("wrap");
  }
  var _calculateNodeStyling = calculateNodeStyling(uiTextNode, useCache2), paddingSize = _calculateNodeStyling.paddingSize, borderSize = _calculateNodeStyling.borderSize, boxSizing = _calculateNodeStyling.boxSizing, sizingStyle = _calculateNodeStyling.sizingStyle;
  hiddenTextarea.setAttribute("style", "".concat(sizingStyle, ";").concat(HIDDEN_TEXTAREA_STYLE));
  hiddenTextarea.value = uiTextNode.value || uiTextNode.placeholder || "";
  var minHeight = Number.MIN_SAFE_INTEGER;
  var maxHeight = Number.MAX_SAFE_INTEGER;
  var height = hiddenTextarea.scrollHeight;
  var overflowY;
  if (boxSizing === "border-box") {
    height += borderSize;
  } else if (boxSizing === "content-box") {
    height -= paddingSize;
  }
  if (minRows !== null || maxRows !== null) {
    hiddenTextarea.value = " ";
    var singleRowHeight = hiddenTextarea.scrollHeight - paddingSize;
    if (minRows !== null) {
      minHeight = singleRowHeight * minRows;
      if (boxSizing === "border-box") {
        minHeight = minHeight + paddingSize + borderSize;
      }
      height = Math.max(minHeight, height);
    }
    if (maxRows !== null) {
      maxHeight = singleRowHeight * maxRows;
      if (boxSizing === "border-box") {
        maxHeight = maxHeight + paddingSize + borderSize;
      }
      overflowY = height > maxHeight ? "" : "hidden";
      height = Math.min(maxHeight, height);
    }
  }
  return {
    height,
    minHeight,
    maxHeight,
    overflowY,
    resize: "none"
  };
}
var RESIZE_STATUS;
(function(RESIZE_STATUS2) {
  RESIZE_STATUS2[RESIZE_STATUS2["NONE"] = 0] = "NONE";
  RESIZE_STATUS2[RESIZE_STATUS2["RESIZING"] = 1] = "RESIZING";
  RESIZE_STATUS2[RESIZE_STATUS2["RESIZED"] = 2] = "RESIZED";
})(RESIZE_STATUS || (RESIZE_STATUS = {}));
var ResizableTextArea = /* @__PURE__ */ function(_React$Component) {
  _inherits$1(ResizableTextArea2, _React$Component);
  var _super = _createSuper$1(ResizableTextArea2);
  function ResizableTextArea2(props) {
    var _this;
    _classCallCheck$2(this, ResizableTextArea2);
    _this = _super.call(this, props);
    _this.nextFrameActionId = void 0;
    _this.resizeFrameId = void 0;
    _this.textArea = void 0;
    _this.saveTextArea = function(textArea) {
      _this.textArea = textArea;
    };
    _this.handleResize = function(size2) {
      var resizeStatus = _this.state.resizeStatus;
      var _this$props = _this.props, autoSize = _this$props.autoSize, onResize2 = _this$props.onResize;
      if (resizeStatus !== RESIZE_STATUS.NONE) {
        return;
      }
      if (typeof onResize2 === "function") {
        onResize2(size2);
      }
      if (autoSize) {
        _this.resizeOnNextFrame();
      }
    };
    _this.resizeOnNextFrame = function() {
      cancelAnimationFrame(_this.nextFrameActionId);
      _this.nextFrameActionId = requestAnimationFrame(_this.resizeTextarea);
    };
    _this.resizeTextarea = function() {
      var autoSize = _this.props.autoSize;
      if (!autoSize || !_this.textArea) {
        return;
      }
      var minRows = autoSize.minRows, maxRows = autoSize.maxRows;
      var textareaStyles = calculateNodeHeight(_this.textArea, false, minRows, maxRows);
      _this.setState({
        textareaStyles,
        resizeStatus: RESIZE_STATUS.RESIZING
      }, function() {
        cancelAnimationFrame(_this.resizeFrameId);
        _this.resizeFrameId = requestAnimationFrame(function() {
          _this.setState({
            resizeStatus: RESIZE_STATUS.RESIZED
          }, function() {
            _this.resizeFrameId = requestAnimationFrame(function() {
              _this.setState({
                resizeStatus: RESIZE_STATUS.NONE
              });
              _this.fixFirefoxAutoScroll();
            });
          });
        });
      });
    };
    _this.renderTextArea = function() {
      var _this$props2 = _this.props, _this$props2$prefixCl = _this$props2.prefixCls, prefixCls = _this$props2$prefixCl === void 0 ? "rc-textarea" : _this$props2$prefixCl, autoSize = _this$props2.autoSize, onResize2 = _this$props2.onResize, className = _this$props2.className, disabled = _this$props2.disabled;
      var _this$state = _this.state, textareaStyles = _this$state.textareaStyles, resizeStatus = _this$state.resizeStatus;
      var otherProps = omit$2(_this.props, ["prefixCls", "onPressEnter", "autoSize", "defaultValue", "onResize"]);
      var cls = classNames(prefixCls, className, _defineProperty$4({}, "".concat(prefixCls, "-disabled"), disabled));
      if ("value" in otherProps) {
        otherProps.value = otherProps.value || "";
      }
      var style2 = _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, _this.props.style), textareaStyles), resizeStatus === RESIZE_STATUS.RESIZING ? {
        overflowX: "hidden",
        overflowY: "hidden"
      } : null);
      return /* @__PURE__ */ react.exports.createElement(ResizeObserver$1, {
        onResize: _this.handleResize,
        disabled: !(autoSize || onResize2)
      }, /* @__PURE__ */ react.exports.createElement("textarea", _extends$2({}, otherProps, {
        className: cls,
        style: style2,
        ref: _this.saveTextArea
      })));
    };
    _this.state = {
      textareaStyles: {},
      resizeStatus: RESIZE_STATUS.NONE
    };
    return _this;
  }
  _createClass$2(ResizableTextArea2, [{
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      if (prevProps.value !== this.props.value || !shallowequal(prevProps.autoSize, this.props.autoSize)) {
        this.resizeTextarea();
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      cancelAnimationFrame(this.nextFrameActionId);
      cancelAnimationFrame(this.resizeFrameId);
    }
  }, {
    key: "fixFirefoxAutoScroll",
    value: function fixFirefoxAutoScroll() {
      try {
        if (document.activeElement === this.textArea) {
          var currentStart = this.textArea.selectionStart;
          var currentEnd = this.textArea.selectionEnd;
          this.textArea.setSelectionRange(currentStart, currentEnd);
        }
      } catch (e3) {
      }
    }
  }, {
    key: "render",
    value: function render2() {
      return this.renderTextArea();
    }
  }]);
  return ResizableTextArea2;
}(react.exports.Component);
var TextArea$2 = /* @__PURE__ */ function(_React$Component) {
  _inherits$1(TextArea2, _React$Component);
  var _super = _createSuper$1(TextArea2);
  function TextArea2(props) {
    var _this;
    _classCallCheck$2(this, TextArea2);
    _this = _super.call(this, props);
    _this.resizableTextArea = void 0;
    _this.focus = function() {
      _this.resizableTextArea.textArea.focus();
    };
    _this.saveTextArea = function(resizableTextArea) {
      _this.resizableTextArea = resizableTextArea;
    };
    _this.handleChange = function(e3) {
      var onChange2 = _this.props.onChange;
      _this.setValue(e3.target.value, function() {
        _this.resizableTextArea.resizeTextarea();
      });
      if (onChange2) {
        onChange2(e3);
      }
    };
    _this.handleKeyDown = function(e3) {
      var _this$props = _this.props, onPressEnter = _this$props.onPressEnter, onKeyDown2 = _this$props.onKeyDown;
      if (e3.keyCode === 13 && onPressEnter) {
        onPressEnter(e3);
      }
      if (onKeyDown2) {
        onKeyDown2(e3);
      }
    };
    var value2 = typeof props.value === "undefined" || props.value === null ? props.defaultValue : props.value;
    _this.state = {
      value: value2
    };
    return _this;
  }
  _createClass$2(TextArea2, [{
    key: "setValue",
    value: function setValue2(value2, callback) {
      if (!("value" in this.props)) {
        this.setState({
          value: value2
        }, callback);
      }
    }
  }, {
    key: "blur",
    value: function blur() {
      this.resizableTextArea.textArea.blur();
    }
  }, {
    key: "render",
    value: function render2() {
      return /* @__PURE__ */ react.exports.createElement(ResizableTextArea, _extends$2({}, this.props, {
        value: this.state.value,
        onKeyDown: this.handleKeyDown,
        onChange: this.handleChange,
        ref: this.saveTextArea
      }));
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function getDerivedStateFromProps(nextProps) {
      if ("value" in nextProps) {
        return {
          value: nextProps.value
        };
      }
      return null;
    }
  }]);
  return TextArea2;
}(react.exports.Component);
var ClearableInputType = tuple("text", "input");
function hasAddon(props) {
  return !!(props.addonBefore || props.addonAfter);
}
var ClearableLabeledInput = /* @__PURE__ */ function(_React$Component) {
  _inherits$1(ClearableLabeledInput2, _React$Component);
  var _super = _createSuper$1(ClearableLabeledInput2);
  function ClearableLabeledInput2() {
    _classCallCheck$2(this, ClearableLabeledInput2);
    return _super.apply(this, arguments);
  }
  _createClass$2(ClearableLabeledInput2, [{
    key: "renderClearIcon",
    value: function renderClearIcon(prefixCls) {
      var _classNames;
      var _this$props = this.props, value2 = _this$props.value, disabled = _this$props.disabled, readOnly = _this$props.readOnly, handleReset = _this$props.handleReset, suffix = _this$props.suffix;
      var needClear = !disabled && !readOnly && value2;
      var className = "".concat(prefixCls, "-clear-icon");
      return /* @__PURE__ */ react.exports.createElement(CloseCircleFilled$1, {
        onClick: handleReset,
        onMouseDown: function onMouseDown(e3) {
          return e3.preventDefault();
        },
        className: classNames((_classNames = {}, _defineProperty$4(_classNames, "".concat(className, "-hidden"), !needClear), _defineProperty$4(_classNames, "".concat(className, "-has-suffix"), !!suffix), _classNames), className),
        role: "button"
      });
    }
  }, {
    key: "renderTextAreaWithClearIcon",
    value: function renderTextAreaWithClearIcon(prefixCls, element, statusContext) {
      var _classNames2;
      var _this$props2 = this.props, value2 = _this$props2.value, allowClear = _this$props2.allowClear, className = _this$props2.className, style2 = _this$props2.style, direction2 = _this$props2.direction, bordered = _this$props2.bordered, hidden = _this$props2.hidden, customStatus = _this$props2.status;
      var contextStatus = statusContext.status, hasFeedback = statusContext.hasFeedback;
      if (!allowClear) {
        return cloneElement(element, {
          value: value2
        });
      }
      var affixWrapperCls = classNames("".concat(prefixCls, "-affix-wrapper"), "".concat(prefixCls, "-affix-wrapper-textarea-with-clear-btn"), getStatusClassNames("".concat(prefixCls, "-affix-wrapper"), getMergedStatus(contextStatus, customStatus), hasFeedback), (_classNames2 = {}, _defineProperty$4(_classNames2, "".concat(prefixCls, "-affix-wrapper-rtl"), direction2 === "rtl"), _defineProperty$4(_classNames2, "".concat(prefixCls, "-affix-wrapper-borderless"), !bordered), _defineProperty$4(_classNames2, "".concat(className), !hasAddon(this.props) && className), _classNames2));
      return /* @__PURE__ */ react.exports.createElement("span", {
        className: affixWrapperCls,
        style: style2,
        hidden
      }, cloneElement(element, {
        style: null,
        value: value2
      }), this.renderClearIcon(prefixCls));
    }
  }, {
    key: "render",
    value: function render2() {
      var _this = this;
      return /* @__PURE__ */ react.exports.createElement(FormItemInputContext.Consumer, null, function(statusContext) {
        var _this$props3 = _this.props, prefixCls = _this$props3.prefixCls, inputType = _this$props3.inputType, element = _this$props3.element;
        if (inputType === ClearableInputType[0]) {
          return _this.renderTextAreaWithClearIcon(prefixCls, element, statusContext);
        }
      });
    }
  }]);
  return ClearableLabeledInput2;
}(react.exports.Component);
var ClearableLabeledInput$1 = ClearableLabeledInput;
var __rest$a = globalThis && globalThis.__rest || function(s2, e3) {
  var t2 = {};
  for (var p2 in s2) {
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  }
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e3.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
function fixEmojiLength(value2, maxLength) {
  return _toConsumableArray(value2 || "").slice(0, maxLength).join("");
}
function setTriggerValue(isCursorInEnd, preValue, triggerValue, maxLength) {
  var newTriggerValue = triggerValue;
  if (isCursorInEnd) {
    newTriggerValue = fixEmojiLength(triggerValue, maxLength);
  } else if (_toConsumableArray(preValue || "").length < triggerValue.length && _toConsumableArray(triggerValue || "").length > maxLength) {
    newTriggerValue = preValue;
  }
  return newTriggerValue;
}
var TextArea = /* @__PURE__ */ react.exports.forwardRef(function(_a2, ref) {
  var _classNames;
  var customizePrefixCls = _a2.prefixCls, _a$bordered = _a2.bordered, bordered = _a$bordered === void 0 ? true : _a$bordered, _a$showCount = _a2.showCount, showCount = _a$showCount === void 0 ? false : _a$showCount, maxLength = _a2.maxLength, className = _a2.className, style2 = _a2.style, customizeSize = _a2.size, customDisabled = _a2.disabled, onCompositionStart = _a2.onCompositionStart, onCompositionEnd = _a2.onCompositionEnd, onChange2 = _a2.onChange, customStatus = _a2.status, props = __rest$a(_a2, ["prefixCls", "bordered", "showCount", "maxLength", "className", "style", "size", "disabled", "onCompositionStart", "onCompositionEnd", "onChange", "status"]);
  var _React$useContext = react.exports.useContext(ConfigContext), getPrefixCls = _React$useContext.getPrefixCls, direction2 = _React$useContext.direction;
  var size2 = react.exports.useContext(SizeContext$1);
  var disabled = react.exports.useContext(DisabledContext$1);
  var mergedDisabled = customDisabled || disabled;
  var _React$useContext2 = react.exports.useContext(FormItemInputContext), contextStatus = _React$useContext2.status, hasFeedback = _React$useContext2.hasFeedback, isFormItemInput = _React$useContext2.isFormItemInput, feedbackIcon = _React$useContext2.feedbackIcon;
  var mergedStatus = getMergedStatus(contextStatus, customStatus);
  var innerRef = react.exports.useRef(null);
  var clearableInputRef = react.exports.useRef(null);
  var _React$useState = react.exports.useState(false), _React$useState2 = _slicedToArray$4(_React$useState, 2), compositing = _React$useState2[0], setCompositing = _React$useState2[1];
  var oldCompositionValueRef = react.exports.useRef();
  var oldSelectionStartRef = react.exports.useRef(0);
  var _useMergedState = useMergedState(props.defaultValue, {
    value: props.value
  }), _useMergedState2 = _slicedToArray$4(_useMergedState, 2), value2 = _useMergedState2[0], setValue2 = _useMergedState2[1];
  var hidden = props.hidden;
  var handleSetValue = function handleSetValue2(val2, callback) {
    if (props.value === void 0) {
      setValue2(val2);
      callback === null || callback === void 0 ? void 0 : callback();
    }
  };
  var hasMaxLength = Number(maxLength) > 0;
  var onInternalCompositionStart = function onInternalCompositionStart2(e3) {
    setCompositing(true);
    oldCompositionValueRef.current = value2;
    oldSelectionStartRef.current = e3.currentTarget.selectionStart;
    onCompositionStart === null || onCompositionStart === void 0 ? void 0 : onCompositionStart(e3);
  };
  var onInternalCompositionEnd = function onInternalCompositionEnd2(e3) {
    var _a3;
    setCompositing(false);
    var triggerValue = e3.currentTarget.value;
    if (hasMaxLength) {
      var isCursorInEnd = oldSelectionStartRef.current >= maxLength + 1 || oldSelectionStartRef.current === ((_a3 = oldCompositionValueRef.current) === null || _a3 === void 0 ? void 0 : _a3.length);
      triggerValue = setTriggerValue(isCursorInEnd, oldCompositionValueRef.current, triggerValue, maxLength);
    }
    if (triggerValue !== value2) {
      handleSetValue(triggerValue);
      resolveOnChange(e3.currentTarget, e3, onChange2, triggerValue);
    }
    onCompositionEnd === null || onCompositionEnd === void 0 ? void 0 : onCompositionEnd(e3);
  };
  var handleChange = function handleChange2(e3) {
    var triggerValue = e3.target.value;
    if (!compositing && hasMaxLength) {
      var isCursorInEnd = e3.target.selectionStart >= maxLength + 1 || e3.target.selectionStart === triggerValue.length || !e3.target.selectionStart;
      triggerValue = setTriggerValue(isCursorInEnd, value2, triggerValue, maxLength);
    }
    handleSetValue(triggerValue);
    resolveOnChange(e3.currentTarget, e3, onChange2, triggerValue);
  };
  var handleReset = function handleReset2(e3) {
    var _a3, _b, _c;
    handleSetValue("");
    (_a3 = innerRef.current) === null || _a3 === void 0 ? void 0 : _a3.focus();
    resolveOnChange((_c = (_b = innerRef.current) === null || _b === void 0 ? void 0 : _b.resizableTextArea) === null || _c === void 0 ? void 0 : _c.textArea, e3, onChange2);
  };
  var prefixCls = getPrefixCls("input", customizePrefixCls);
  react.exports.useImperativeHandle(ref, function() {
    var _a3;
    return {
      resizableTextArea: (_a3 = innerRef.current) === null || _a3 === void 0 ? void 0 : _a3.resizableTextArea,
      focus: function focus(option) {
        var _a4, _b;
        triggerFocus((_b = (_a4 = innerRef.current) === null || _a4 === void 0 ? void 0 : _a4.resizableTextArea) === null || _b === void 0 ? void 0 : _b.textArea, option);
      },
      blur: function blur() {
        var _a4;
        return (_a4 = innerRef.current) === null || _a4 === void 0 ? void 0 : _a4.blur();
      }
    };
  });
  var textArea = /* @__PURE__ */ react.exports.createElement(TextArea$2, _extends$2({}, omit$2(props, ["allowClear"]), {
    disabled: mergedDisabled,
    className: classNames((_classNames = {}, _defineProperty$4(_classNames, "".concat(prefixCls, "-borderless"), !bordered), _defineProperty$4(_classNames, className, className && !showCount), _defineProperty$4(_classNames, "".concat(prefixCls, "-sm"), size2 === "small" || customizeSize === "small"), _defineProperty$4(_classNames, "".concat(prefixCls, "-lg"), size2 === "large" || customizeSize === "large"), _classNames), getStatusClassNames(prefixCls, mergedStatus)),
    style: showCount ? void 0 : style2,
    prefixCls,
    onCompositionStart: onInternalCompositionStart,
    onChange: handleChange,
    onCompositionEnd: onInternalCompositionEnd,
    ref: innerRef
  }));
  var val = fixControlledValue(value2);
  if (!compositing && hasMaxLength && (props.value === null || props.value === void 0)) {
    val = fixEmojiLength(val, maxLength);
  }
  var textareaNode = /* @__PURE__ */ react.exports.createElement(ClearableLabeledInput$1, _extends$2({
    disabled: mergedDisabled
  }, props, {
    prefixCls,
    direction: direction2,
    inputType: "text",
    value: val,
    element: textArea,
    handleReset,
    ref: clearableInputRef,
    bordered,
    status: customStatus,
    style: showCount ? void 0 : style2
  }));
  if (showCount || hasFeedback) {
    var _classNames2;
    var valueLength = _toConsumableArray(val).length;
    var dataCount = "";
    if (_typeof$4(showCount) === "object") {
      dataCount = showCount.formatter({
        value: val,
        count: valueLength,
        maxLength
      });
    } else {
      dataCount = "".concat(valueLength).concat(hasMaxLength ? " / ".concat(maxLength) : "");
    }
    return /* @__PURE__ */ react.exports.createElement("div", {
      hidden,
      className: classNames("".concat(prefixCls, "-textarea"), (_classNames2 = {}, _defineProperty$4(_classNames2, "".concat(prefixCls, "-textarea-rtl"), direction2 === "rtl"), _defineProperty$4(_classNames2, "".concat(prefixCls, "-textarea-show-count"), showCount), _defineProperty$4(_classNames2, "".concat(prefixCls, "-textarea-in-form-item"), isFormItemInput), _classNames2), getStatusClassNames("".concat(prefixCls, "-textarea"), mergedStatus, hasFeedback), className),
      style: style2,
      "data-count": dataCount
    }, textareaNode, hasFeedback && /* @__PURE__ */ react.exports.createElement("span", {
      className: "".concat(prefixCls, "-textarea-suffix")
    }, feedbackIcon));
  }
  return textareaNode;
});
var TextArea$1 = TextArea;
var Input = InternalInput;
Input.Group = Group$3;
Input.Search = Search$2;
Input.TextArea = TextArea$1;
Input.Password = Password$1;
var Input$1 = Input;
var DoubleLeftOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M272.9 512l265.4-339.1c4.1-5.2.4-12.9-6.3-12.9h-77.3c-4.9 0-9.6 2.3-12.6 6.1L186.8 492.3a31.99 31.99 0 000 39.5l255.3 326.1c3 3.9 7.7 6.1 12.6 6.1H532c6.7 0 10.4-7.7 6.3-12.9L272.9 512zm304 0l265.4-339.1c4.1-5.2.4-12.9-6.3-12.9h-77.3c-4.9 0-9.6 2.3-12.6 6.1L490.8 492.3a31.99 31.99 0 000 39.5l255.3 326.1c3 3.9 7.7 6.1 12.6 6.1H836c6.7 0 10.4-7.7 6.3-12.9L576.9 512z" } }] }, "name": "double-left", "theme": "outlined" };
var DoubleLeftOutlinedSvg = DoubleLeftOutlined$2;
var DoubleLeftOutlined = function DoubleLeftOutlined2(props, ref) {
  return /* @__PURE__ */ react.exports.createElement(AntdIcon, _objectSpread2$1(_objectSpread2$1({}, props), {}, {
    ref,
    icon: DoubleLeftOutlinedSvg
  }));
};
DoubleLeftOutlined.displayName = "DoubleLeftOutlined";
var DoubleLeftOutlined$1 = /* @__PURE__ */ react.exports.forwardRef(DoubleLeftOutlined);
var DoubleRightOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M533.2 492.3L277.9 166.1c-3-3.9-7.7-6.1-12.6-6.1H188c-6.7 0-10.4 7.7-6.3 12.9L447.1 512 181.7 851.1A7.98 7.98 0 00188 864h77.3c4.9 0 9.6-2.3 12.6-6.1l255.3-326.1c9.1-11.7 9.1-27.9 0-39.5zm304 0L581.9 166.1c-3-3.9-7.7-6.1-12.6-6.1H492c-6.7 0-10.4 7.7-6.3 12.9L751.1 512 485.7 851.1A7.98 7.98 0 00492 864h77.3c4.9 0 9.6-2.3 12.6-6.1l255.3-326.1c9.1-11.7 9.1-27.9 0-39.5z" } }] }, "name": "double-right", "theme": "outlined" };
var DoubleRightOutlinedSvg = DoubleRightOutlined$2;
var DoubleRightOutlined = function DoubleRightOutlined2(props, ref) {
  return /* @__PURE__ */ react.exports.createElement(AntdIcon, _objectSpread2$1(_objectSpread2$1({}, props), {}, {
    ref,
    icon: DoubleRightOutlinedSvg
  }));
};
DoubleRightOutlined.displayName = "DoubleRightOutlined";
var DoubleRightOutlined$1 = /* @__PURE__ */ react.exports.forwardRef(DoubleRightOutlined);
var Pager = function Pager2(props) {
  var _classNames;
  var prefixCls = "".concat(props.rootPrefixCls, "-item");
  var cls = classNames(prefixCls, "".concat(prefixCls, "-").concat(props.page), (_classNames = {}, _defineProperty$4(_classNames, "".concat(prefixCls, "-active"), props.active), _defineProperty$4(_classNames, "".concat(prefixCls, "-disabled"), !props.page), _defineProperty$4(_classNames, props.className, !!props.className), _classNames));
  var handleClick = function handleClick2() {
    props.onClick(props.page);
  };
  var handleKeyPress = function handleKeyPress2(e3) {
    props.onKeyPress(e3, props.onClick, props.page);
  };
  return /* @__PURE__ */ React.createElement("li", {
    title: props.showTitle ? props.page : null,
    className: cls,
    onClick: handleClick,
    onKeyPress: handleKeyPress,
    tabIndex: "0"
  }, props.itemRender(props.page, "page", /* @__PURE__ */ React.createElement("a", {
    rel: "nofollow"
  }, props.page)));
};
var KEYCODE = {
  ZERO: 48,
  NINE: 57,
  NUMPAD_ZERO: 96,
  NUMPAD_NINE: 105,
  BACKSPACE: 8,
  DELETE: 46,
  ENTER: 13,
  ARROW_UP: 38,
  ARROW_DOWN: 40
};
var Options = /* @__PURE__ */ function(_React$Component) {
  _inherits$1(Options2, _React$Component);
  var _super = _createSuper$1(Options2);
  function Options2() {
    var _this;
    _classCallCheck$2(this, Options2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _this.state = {
      goInputText: ""
    };
    _this.buildOptionText = function(value2) {
      return "".concat(value2, " ").concat(_this.props.locale.items_per_page);
    };
    _this.changeSize = function(value2) {
      _this.props.changeSize(Number(value2));
    };
    _this.handleChange = function(e3) {
      _this.setState({
        goInputText: e3.target.value
      });
    };
    _this.handleBlur = function(e3) {
      var _this$props = _this.props, goButton = _this$props.goButton, quickGo = _this$props.quickGo, rootPrefixCls = _this$props.rootPrefixCls;
      var goInputText = _this.state.goInputText;
      if (goButton || goInputText === "") {
        return;
      }
      _this.setState({
        goInputText: ""
      });
      if (e3.relatedTarget && (e3.relatedTarget.className.indexOf("".concat(rootPrefixCls, "-item-link")) >= 0 || e3.relatedTarget.className.indexOf("".concat(rootPrefixCls, "-item")) >= 0)) {
        return;
      }
      quickGo(_this.getValidValue());
    };
    _this.go = function(e3) {
      var goInputText = _this.state.goInputText;
      if (goInputText === "") {
        return;
      }
      if (e3.keyCode === KEYCODE.ENTER || e3.type === "click") {
        _this.setState({
          goInputText: ""
        });
        _this.props.quickGo(_this.getValidValue());
      }
    };
    return _this;
  }
  _createClass$2(Options2, [{
    key: "getValidValue",
    value: function getValidValue() {
      var goInputText = this.state.goInputText;
      return !goInputText || isNaN(goInputText) ? void 0 : Number(goInputText);
    }
  }, {
    key: "getPageSizeOptions",
    value: function getPageSizeOptions() {
      var _this$props2 = this.props, pageSize = _this$props2.pageSize, pageSizeOptions = _this$props2.pageSizeOptions;
      if (pageSizeOptions.some(function(option) {
        return option.toString() === pageSize.toString();
      })) {
        return pageSizeOptions;
      }
      return pageSizeOptions.concat([pageSize.toString()]).sort(function(a2, b10) {
        var numberA = isNaN(Number(a2)) ? 0 : Number(a2);
        var numberB = isNaN(Number(b10)) ? 0 : Number(b10);
        return numberA - numberB;
      });
    }
  }, {
    key: "render",
    value: function render2() {
      var _this2 = this;
      var _this$props3 = this.props, pageSize = _this$props3.pageSize, locale2 = _this$props3.locale, rootPrefixCls = _this$props3.rootPrefixCls, changeSize = _this$props3.changeSize, quickGo = _this$props3.quickGo, goButton = _this$props3.goButton, selectComponentClass = _this$props3.selectComponentClass, buildOptionText = _this$props3.buildOptionText, selectPrefixCls = _this$props3.selectPrefixCls, disabled = _this$props3.disabled;
      var goInputText = this.state.goInputText;
      var prefixCls = "".concat(rootPrefixCls, "-options");
      var Select2 = selectComponentClass;
      var changeSelect = null;
      var goInput = null;
      var gotoButton = null;
      if (!changeSize && !quickGo) {
        return null;
      }
      var pageSizeOptions = this.getPageSizeOptions();
      if (changeSize && Select2) {
        var options = pageSizeOptions.map(function(opt, i2) {
          return /* @__PURE__ */ React.createElement(Select2.Option, {
            key: i2,
            value: opt.toString()
          }, (buildOptionText || _this2.buildOptionText)(opt));
        });
        changeSelect = /* @__PURE__ */ React.createElement(Select2, {
          disabled,
          prefixCls: selectPrefixCls,
          showSearch: false,
          className: "".concat(prefixCls, "-size-changer"),
          optionLabelProp: "children",
          dropdownMatchSelectWidth: false,
          value: (pageSize || pageSizeOptions[0]).toString(),
          onChange: this.changeSize,
          getPopupContainer: function getPopupContainer(triggerNode) {
            return triggerNode.parentNode;
          },
          "aria-label": locale2.page_size,
          defaultOpen: false
        }, options);
      }
      if (quickGo) {
        if (goButton) {
          gotoButton = typeof goButton === "boolean" ? /* @__PURE__ */ React.createElement("button", {
            type: "button",
            onClick: this.go,
            onKeyUp: this.go,
            disabled,
            className: "".concat(prefixCls, "-quick-jumper-button")
          }, locale2.jump_to_confirm) : /* @__PURE__ */ React.createElement("span", {
            onClick: this.go,
            onKeyUp: this.go
          }, goButton);
        }
        goInput = /* @__PURE__ */ React.createElement("div", {
          className: "".concat(prefixCls, "-quick-jumper")
        }, locale2.jump_to, /* @__PURE__ */ React.createElement("input", {
          disabled,
          type: "text",
          value: goInputText,
          onChange: this.handleChange,
          onKeyUp: this.go,
          onBlur: this.handleBlur,
          "aria-label": locale2.page
        }), locale2.page, gotoButton);
      }
      return /* @__PURE__ */ React.createElement("li", {
        className: "".concat(prefixCls)
      }, changeSelect, goInput);
    }
  }]);
  return Options2;
}(React.Component);
Options.defaultProps = {
  pageSizeOptions: ["10", "20", "50", "100"]
};
var LOCALE = {
  items_per_page: "\u6761/\u9875",
  jump_to: "\u8DF3\u81F3",
  jump_to_confirm: "\u786E\u5B9A",
  page: "\u9875",
  prev_page: "\u4E0A\u4E00\u9875",
  next_page: "\u4E0B\u4E00\u9875",
  prev_5: "\u5411\u524D 5 \u9875",
  next_5: "\u5411\u540E 5 \u9875",
  prev_3: "\u5411\u524D 3 \u9875",
  next_3: "\u5411\u540E 3 \u9875",
  page_size: "\u9875\u7801"
};
function noop$3() {
}
function isInteger(v2) {
  var value2 = Number(v2);
  return typeof value2 === "number" && !isNaN(value2) && isFinite(value2) && Math.floor(value2) === value2;
}
function defaultItemRender(page, type4, element) {
  return element;
}
function calculatePage(p2, state2, props) {
  var pageSize = typeof p2 === "undefined" ? state2.pageSize : p2;
  return Math.floor((props.total - 1) / pageSize) + 1;
}
var Pagination$2 = /* @__PURE__ */ function(_React$Component) {
  _inherits$1(Pagination3, _React$Component);
  var _super = _createSuper$1(Pagination3);
  function Pagination3(props) {
    var _this;
    _classCallCheck$2(this, Pagination3);
    _this = _super.call(this, props);
    _this.getJumpPrevPage = function() {
      return Math.max(1, _this.state.current - (_this.props.showLessItems ? 3 : 5));
    };
    _this.getJumpNextPage = function() {
      return Math.min(calculatePage(void 0, _this.state, _this.props), _this.state.current + (_this.props.showLessItems ? 3 : 5));
    };
    _this.getItemIcon = function(icon, label2) {
      var prefixCls = _this.props.prefixCls;
      var iconNode = icon || /* @__PURE__ */ jsx("button", {
        type: "button",
        "aria-label": label2,
        className: "".concat(prefixCls, "-item-link")
      });
      if (typeof icon === "function") {
        iconNode = /* @__PURE__ */ React.createElement(icon, _objectSpread2$1({}, _this.props));
      }
      return iconNode;
    };
    _this.savePaginationNode = function(node) {
      _this.paginationNode = node;
    };
    _this.isValid = function(page) {
      var total = _this.props.total;
      return isInteger(page) && page !== _this.state.current && isInteger(total) && total > 0;
    };
    _this.shouldDisplayQuickJumper = function() {
      var _this$props = _this.props, showQuickJumper = _this$props.showQuickJumper, total = _this$props.total;
      var pageSize = _this.state.pageSize;
      if (total <= pageSize) {
        return false;
      }
      return showQuickJumper;
    };
    _this.handleKeyDown = function(e3) {
      if (e3.keyCode === KEYCODE.ARROW_UP || e3.keyCode === KEYCODE.ARROW_DOWN) {
        e3.preventDefault();
      }
    };
    _this.handleKeyUp = function(e3) {
      var value2 = _this.getValidValue(e3);
      var currentInputValue = _this.state.currentInputValue;
      if (value2 !== currentInputValue) {
        _this.setState({
          currentInputValue: value2
        });
      }
      if (e3.keyCode === KEYCODE.ENTER) {
        _this.handleChange(value2);
      } else if (e3.keyCode === KEYCODE.ARROW_UP) {
        _this.handleChange(value2 - 1);
      } else if (e3.keyCode === KEYCODE.ARROW_DOWN) {
        _this.handleChange(value2 + 1);
      }
    };
    _this.handleBlur = function(e3) {
      var value2 = _this.getValidValue(e3);
      _this.handleChange(value2);
    };
    _this.changePageSize = function(size2) {
      var current = _this.state.current;
      var newCurrent = calculatePage(size2, _this.state, _this.props);
      current = current > newCurrent ? newCurrent : current;
      if (newCurrent === 0) {
        current = _this.state.current;
      }
      if (typeof size2 === "number") {
        if (!("pageSize" in _this.props)) {
          _this.setState({
            pageSize: size2
          });
        }
        if (!("current" in _this.props)) {
          _this.setState({
            current,
            currentInputValue: current
          });
        }
      }
      _this.props.onShowSizeChange(current, size2);
      if ("onChange" in _this.props && _this.props.onChange) {
        _this.props.onChange(current, size2);
      }
    };
    _this.handleChange = function(page) {
      var _this$props2 = _this.props, disabled = _this$props2.disabled, onChange2 = _this$props2.onChange;
      var _this$state = _this.state, pageSize = _this$state.pageSize, current = _this$state.current, currentInputValue = _this$state.currentInputValue;
      if (_this.isValid(page) && !disabled) {
        var currentPage = calculatePage(void 0, _this.state, _this.props);
        var newPage = page;
        if (page > currentPage) {
          newPage = currentPage;
        } else if (page < 1) {
          newPage = 1;
        }
        if (!("current" in _this.props)) {
          _this.setState({
            current: newPage
          });
        }
        if (newPage !== currentInputValue) {
          _this.setState({
            currentInputValue: newPage
          });
        }
        onChange2(newPage, pageSize);
        return newPage;
      }
      return current;
    };
    _this.prev = function() {
      if (_this.hasPrev()) {
        _this.handleChange(_this.state.current - 1);
      }
    };
    _this.next = function() {
      if (_this.hasNext()) {
        _this.handleChange(_this.state.current + 1);
      }
    };
    _this.jumpPrev = function() {
      _this.handleChange(_this.getJumpPrevPage());
    };
    _this.jumpNext = function() {
      _this.handleChange(_this.getJumpNextPage());
    };
    _this.hasPrev = function() {
      return _this.state.current > 1;
    };
    _this.hasNext = function() {
      return _this.state.current < calculatePage(void 0, _this.state, _this.props);
    };
    _this.runIfEnter = function(event, callback) {
      if (event.key === "Enter" || event.charCode === 13) {
        for (var _len = arguments.length, restParams = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
          restParams[_key - 2] = arguments[_key];
        }
        callback.apply(void 0, restParams);
      }
    };
    _this.runIfEnterPrev = function(e3) {
      _this.runIfEnter(e3, _this.prev);
    };
    _this.runIfEnterNext = function(e3) {
      _this.runIfEnter(e3, _this.next);
    };
    _this.runIfEnterJumpPrev = function(e3) {
      _this.runIfEnter(e3, _this.jumpPrev);
    };
    _this.runIfEnterJumpNext = function(e3) {
      _this.runIfEnter(e3, _this.jumpNext);
    };
    _this.handleGoTO = function(e3) {
      if (e3.keyCode === KEYCODE.ENTER || e3.type === "click") {
        _this.handleChange(_this.state.currentInputValue);
      }
    };
    var hasOnChange = props.onChange !== noop$3;
    var hasCurrent = "current" in props;
    if (hasCurrent && !hasOnChange) {
      console.warn("Warning: You provided a `current` prop to a Pagination component without an `onChange` handler. This will render a read-only component.");
    }
    var _current = props.defaultCurrent;
    if ("current" in props) {
      _current = props.current;
    }
    var _pageSize = props.defaultPageSize;
    if ("pageSize" in props) {
      _pageSize = props.pageSize;
    }
    _current = Math.min(_current, calculatePage(_pageSize, void 0, props));
    _this.state = {
      current: _current,
      currentInputValue: _current,
      pageSize: _pageSize
    };
    return _this;
  }
  _createClass$2(Pagination3, [{
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps, prevState) {
      var prefixCls = this.props.prefixCls;
      if (prevState.current !== this.state.current && this.paginationNode) {
        var lastCurrentNode = this.paginationNode.querySelector(".".concat(prefixCls, "-item-").concat(prevState.current));
        if (lastCurrentNode && document.activeElement === lastCurrentNode) {
          lastCurrentNode.blur();
        }
      }
    }
  }, {
    key: "getValidValue",
    value: function getValidValue(e3) {
      var inputValue = e3.target.value;
      var allPages = calculatePage(void 0, this.state, this.props);
      var currentInputValue = this.state.currentInputValue;
      var value2;
      if (inputValue === "") {
        value2 = inputValue;
      } else if (isNaN(Number(inputValue))) {
        value2 = currentInputValue;
      } else if (inputValue >= allPages) {
        value2 = allPages;
      } else {
        value2 = Number(inputValue);
      }
      return value2;
    }
  }, {
    key: "getShowSizeChanger",
    value: function getShowSizeChanger() {
      var _this$props3 = this.props, showSizeChanger = _this$props3.showSizeChanger, total = _this$props3.total, totalBoundaryShowSizeChanger = _this$props3.totalBoundaryShowSizeChanger;
      if (typeof showSizeChanger !== "undefined") {
        return showSizeChanger;
      }
      return total > totalBoundaryShowSizeChanger;
    }
  }, {
    key: "renderPrev",
    value: function renderPrev(prevPage) {
      var _this$props4 = this.props, prevIcon = _this$props4.prevIcon, itemRender = _this$props4.itemRender;
      var prevButton = itemRender(prevPage, "prev", this.getItemIcon(prevIcon, "prev page"));
      var disabled = !this.hasPrev();
      return /* @__PURE__ */ react.exports.isValidElement(prevButton) ? /* @__PURE__ */ react.exports.cloneElement(prevButton, {
        disabled
      }) : prevButton;
    }
  }, {
    key: "renderNext",
    value: function renderNext(nextPage) {
      var _this$props5 = this.props, nextIcon = _this$props5.nextIcon, itemRender = _this$props5.itemRender;
      var nextButton = itemRender(nextPage, "next", this.getItemIcon(nextIcon, "next page"));
      var disabled = !this.hasNext();
      return /* @__PURE__ */ react.exports.isValidElement(nextButton) ? /* @__PURE__ */ react.exports.cloneElement(nextButton, {
        disabled
      }) : nextButton;
    }
  }, {
    key: "render",
    value: function render2() {
      var _this2 = this;
      var _this$props6 = this.props, prefixCls = _this$props6.prefixCls, className = _this$props6.className, style2 = _this$props6.style, disabled = _this$props6.disabled, hideOnSinglePage = _this$props6.hideOnSinglePage, total = _this$props6.total, locale2 = _this$props6.locale, showQuickJumper = _this$props6.showQuickJumper, showLessItems = _this$props6.showLessItems, showTitle = _this$props6.showTitle, showTotal = _this$props6.showTotal, simple = _this$props6.simple, itemRender = _this$props6.itemRender, showPrevNextJumpers = _this$props6.showPrevNextJumpers, jumpPrevIcon = _this$props6.jumpPrevIcon, jumpNextIcon = _this$props6.jumpNextIcon, selectComponentClass = _this$props6.selectComponentClass, selectPrefixCls = _this$props6.selectPrefixCls, pageSizeOptions = _this$props6.pageSizeOptions;
      var _this$state2 = this.state, current = _this$state2.current, pageSize = _this$state2.pageSize, currentInputValue = _this$state2.currentInputValue;
      if (hideOnSinglePage === true && total <= pageSize) {
        return null;
      }
      var allPages = calculatePage(void 0, this.state, this.props);
      var pagerList = [];
      var jumpPrev = null;
      var jumpNext = null;
      var firstPager = null;
      var lastPager = null;
      var gotoButton = null;
      var goButton = showQuickJumper && showQuickJumper.goButton;
      var pageBufferSize = showLessItems ? 1 : 2;
      var prevPage = current - 1 > 0 ? current - 1 : 0;
      var nextPage = current + 1 < allPages ? current + 1 : allPages;
      var dataOrAriaAttributeProps = Object.keys(this.props).reduce(function(prev, key2) {
        if (key2.substr(0, 5) === "data-" || key2.substr(0, 5) === "aria-" || key2 === "role") {
          prev[key2] = _this2.props[key2];
        }
        return prev;
      }, {});
      if (simple) {
        if (goButton) {
          if (typeof goButton === "boolean") {
            gotoButton = /* @__PURE__ */ jsx("button", {
              type: "button",
              onClick: this.handleGoTO,
              onKeyUp: this.handleGoTO,
              children: locale2.jump_to_confirm
            });
          } else {
            gotoButton = /* @__PURE__ */ jsx("span", {
              onClick: this.handleGoTO,
              onKeyUp: this.handleGoTO,
              children: goButton
            });
          }
          gotoButton = /* @__PURE__ */ jsx("li", {
            title: showTitle ? "".concat(locale2.jump_to).concat(current, "/").concat(allPages) : null,
            className: "".concat(prefixCls, "-simple-pager"),
            children: gotoButton
          });
        }
        return /* @__PURE__ */ jsxs("ul", {
          className: classNames(prefixCls, "".concat(prefixCls, "-simple"), _defineProperty$4({}, "".concat(prefixCls, "-disabled"), disabled), className),
          style: style2,
          ref: this.savePaginationNode,
          ...dataOrAriaAttributeProps,
          children: [/* @__PURE__ */ jsx("li", {
            title: showTitle ? locale2.prev_page : null,
            onClick: this.prev,
            tabIndex: this.hasPrev() ? 0 : null,
            onKeyPress: this.runIfEnterPrev,
            className: classNames("".concat(prefixCls, "-prev"), _defineProperty$4({}, "".concat(prefixCls, "-disabled"), !this.hasPrev())),
            "aria-disabled": !this.hasPrev(),
            children: this.renderPrev(prevPage)
          }), /* @__PURE__ */ jsxs("li", {
            title: showTitle ? "".concat(current, "/").concat(allPages) : null,
            className: "".concat(prefixCls, "-simple-pager"),
            children: [/* @__PURE__ */ jsx("input", {
              type: "text",
              value: currentInputValue,
              disabled,
              onKeyDown: this.handleKeyDown,
              onKeyUp: this.handleKeyUp,
              onChange: this.handleKeyUp,
              onBlur: this.handleBlur,
              size: "3"
            }), /* @__PURE__ */ jsx("span", {
              className: "".concat(prefixCls, "-slash"),
              children: "/"
            }), allPages]
          }), /* @__PURE__ */ jsx("li", {
            title: showTitle ? locale2.next_page : null,
            onClick: this.next,
            tabIndex: this.hasPrev() ? 0 : null,
            onKeyPress: this.runIfEnterNext,
            className: classNames("".concat(prefixCls, "-next"), _defineProperty$4({}, "".concat(prefixCls, "-disabled"), !this.hasNext())),
            "aria-disabled": !this.hasNext(),
            children: this.renderNext(nextPage)
          }), gotoButton]
        });
      }
      if (allPages <= 3 + pageBufferSize * 2) {
        var pagerProps = {
          locale: locale2,
          rootPrefixCls: prefixCls,
          onClick: this.handleChange,
          onKeyPress: this.runIfEnter,
          showTitle,
          itemRender
        };
        if (!allPages) {
          pagerList.push(
            /* @__PURE__ */ react.exports.createElement(Pager, {
              ...pagerProps,
              key: "noPager",
              page: 1,
              className: "".concat(prefixCls, "-item-disabled")
            })
          );
        }
        for (var i2 = 1; i2 <= allPages; i2 += 1) {
          var active = current === i2;
          pagerList.push(
            /* @__PURE__ */ react.exports.createElement(Pager, {
              ...pagerProps,
              key: i2,
              page: i2,
              active
            })
          );
        }
      } else {
        var prevItemTitle = showLessItems ? locale2.prev_3 : locale2.prev_5;
        var nextItemTitle = showLessItems ? locale2.next_3 : locale2.next_5;
        if (showPrevNextJumpers) {
          jumpPrev = /* @__PURE__ */ jsx("li", {
            title: showTitle ? prevItemTitle : null,
            onClick: this.jumpPrev,
            tabIndex: "0",
            onKeyPress: this.runIfEnterJumpPrev,
            className: classNames("".concat(prefixCls, "-jump-prev"), _defineProperty$4({}, "".concat(prefixCls, "-jump-prev-custom-icon"), !!jumpPrevIcon)),
            children: itemRender(this.getJumpPrevPage(), "jump-prev", this.getItemIcon(jumpPrevIcon, "prev page"))
          }, "prev");
          jumpNext = /* @__PURE__ */ jsx("li", {
            title: showTitle ? nextItemTitle : null,
            tabIndex: "0",
            onClick: this.jumpNext,
            onKeyPress: this.runIfEnterJumpNext,
            className: classNames("".concat(prefixCls, "-jump-next"), _defineProperty$4({}, "".concat(prefixCls, "-jump-next-custom-icon"), !!jumpNextIcon)),
            children: itemRender(this.getJumpNextPage(), "jump-next", this.getItemIcon(jumpNextIcon, "next page"))
          }, "next");
        }
        lastPager = /* @__PURE__ */ jsx(Pager, {
          locale: locale2,
          last: true,
          rootPrefixCls: prefixCls,
          onClick: this.handleChange,
          onKeyPress: this.runIfEnter,
          page: allPages,
          active: false,
          showTitle,
          itemRender
        }, allPages);
        firstPager = /* @__PURE__ */ jsx(Pager, {
          locale: locale2,
          rootPrefixCls: prefixCls,
          onClick: this.handleChange,
          onKeyPress: this.runIfEnter,
          page: 1,
          active: false,
          showTitle,
          itemRender
        }, 1);
        var left2 = Math.max(1, current - pageBufferSize);
        var right2 = Math.min(current + pageBufferSize, allPages);
        if (current - 1 <= pageBufferSize) {
          right2 = 1 + pageBufferSize * 2;
        }
        if (allPages - current <= pageBufferSize) {
          left2 = allPages - pageBufferSize * 2;
        }
        for (var _i = left2; _i <= right2; _i += 1) {
          var _active = current === _i;
          pagerList.push(
            /* @__PURE__ */ jsx(Pager, {
              locale: locale2,
              rootPrefixCls: prefixCls,
              onClick: this.handleChange,
              onKeyPress: this.runIfEnter,
              page: _i,
              active: _active,
              showTitle,
              itemRender
            }, _i)
          );
        }
        if (current - 1 >= pageBufferSize * 2 && current !== 1 + 2) {
          pagerList[0] = /* @__PURE__ */ react.exports.cloneElement(pagerList[0], {
            className: "".concat(prefixCls, "-item-after-jump-prev")
          });
          pagerList.unshift(jumpPrev);
        }
        if (allPages - current >= pageBufferSize * 2 && current !== allPages - 2) {
          pagerList[pagerList.length - 1] = /* @__PURE__ */ react.exports.cloneElement(pagerList[pagerList.length - 1], {
            className: "".concat(prefixCls, "-item-before-jump-next")
          });
          pagerList.push(jumpNext);
        }
        if (left2 !== 1) {
          pagerList.unshift(firstPager);
        }
        if (right2 !== allPages) {
          pagerList.push(lastPager);
        }
      }
      var totalText = null;
      if (showTotal) {
        totalText = /* @__PURE__ */ jsx("li", {
          className: "".concat(prefixCls, "-total-text"),
          children: showTotal(total, [total === 0 ? 0 : (current - 1) * pageSize + 1, current * pageSize > total ? total : current * pageSize])
        });
      }
      var prevDisabled = !this.hasPrev() || !allPages;
      var nextDisabled = !this.hasNext() || !allPages;
      return /* @__PURE__ */ jsxs("ul", {
        className: classNames(prefixCls, className, _defineProperty$4({}, "".concat(prefixCls, "-disabled"), disabled)),
        style: style2,
        unselectable: "unselectable",
        ref: this.savePaginationNode,
        ...dataOrAriaAttributeProps,
        children: [totalText, /* @__PURE__ */ jsx("li", {
          title: showTitle ? locale2.prev_page : null,
          onClick: this.prev,
          tabIndex: prevDisabled ? null : 0,
          onKeyPress: this.runIfEnterPrev,
          className: classNames("".concat(prefixCls, "-prev"), _defineProperty$4({}, "".concat(prefixCls, "-disabled"), prevDisabled)),
          "aria-disabled": prevDisabled,
          children: this.renderPrev(prevPage)
        }), pagerList, /* @__PURE__ */ jsx("li", {
          title: showTitle ? locale2.next_page : null,
          onClick: this.next,
          tabIndex: nextDisabled ? null : 0,
          onKeyPress: this.runIfEnterNext,
          className: classNames("".concat(prefixCls, "-next"), _defineProperty$4({}, "".concat(prefixCls, "-disabled"), nextDisabled)),
          "aria-disabled": nextDisabled,
          children: this.renderNext(nextPage)
        }), /* @__PURE__ */ jsx(Options, {
          disabled,
          locale: locale2,
          rootPrefixCls: prefixCls,
          selectComponentClass,
          selectPrefixCls,
          changeSize: this.getShowSizeChanger() ? this.changePageSize : null,
          current,
          pageSize,
          pageSizeOptions,
          quickGo: this.shouldDisplayQuickJumper() ? this.handleChange : null,
          goButton
        })]
      });
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function getDerivedStateFromProps(props, prevState) {
      var newState = {};
      if ("current" in props) {
        newState.current = props.current;
        if (props.current !== prevState.current) {
          newState.currentInputValue = newState.current;
        }
      }
      if ("pageSize" in props && props.pageSize !== prevState.pageSize) {
        var current = prevState.current;
        var newCurrent = calculatePage(props.pageSize, prevState, props);
        current = current > newCurrent ? newCurrent : current;
        if (!("current" in props)) {
          newState.current = current;
          newState.currentInputValue = current;
        }
        newState.pageSize = props.pageSize;
      }
      return newState;
    }
  }]);
  return Pagination3;
}(React.Component);
Pagination$2.defaultProps = {
  defaultCurrent: 1,
  total: 0,
  defaultPageSize: 10,
  onChange: noop$3,
  className: "",
  selectPrefixCls: "rc-select",
  prefixCls: "rc-pagination",
  selectComponentClass: null,
  hideOnSinglePage: false,
  showPrevNextJumpers: true,
  showQuickJumper: false,
  showLessItems: false,
  showTitle: true,
  onShowSizeChange: noop$3,
  locale: LOCALE,
  style: {},
  itemRender: defaultItemRender,
  totalBoundaryShowSizeChanger: 50
};
var MiniSelect = function MiniSelect2(props) {
  return /* @__PURE__ */ react.exports.createElement(Select$1, _extends$2({}, props, {
    size: "small"
  }));
};
var MiddleSelect = function MiddleSelect2(props) {
  return /* @__PURE__ */ react.exports.createElement(Select$1, _extends$2({}, props, {
    size: "middle"
  }));
};
MiniSelect.Option = Select$1.Option;
MiddleSelect.Option = Select$1.Option;
var __rest$9 = globalThis && globalThis.__rest || function(s2, e3) {
  var t2 = {};
  for (var p2 in s2) {
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  }
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e3.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
var Pagination = function Pagination2(_a2) {
  var customizePrefixCls = _a2.prefixCls, customizeSelectPrefixCls = _a2.selectPrefixCls, className = _a2.className, size2 = _a2.size, customLocale = _a2.locale, selectComponentClass = _a2.selectComponentClass, responsive = _a2.responsive, showSizeChanger = _a2.showSizeChanger, restProps = __rest$9(_a2, ["prefixCls", "selectPrefixCls", "className", "size", "locale", "selectComponentClass", "responsive", "showSizeChanger"]);
  var _useBreakpoint = useBreakpoint(responsive), xs = _useBreakpoint.xs;
  var _React$useContext = react.exports.useContext(ConfigContext), getPrefixCls = _React$useContext.getPrefixCls, direction2 = _React$useContext.direction, _React$useContext$pag = _React$useContext.pagination, pagination = _React$useContext$pag === void 0 ? {} : _React$useContext$pag;
  var prefixCls = getPrefixCls("pagination", customizePrefixCls);
  var mergedShowSizeChanger = showSizeChanger !== null && showSizeChanger !== void 0 ? showSizeChanger : pagination.showSizeChanger;
  var getIconsProps = function getIconsProps2() {
    var ellipsis = /* @__PURE__ */ react.exports.createElement("span", {
      className: "".concat(prefixCls, "-item-ellipsis")
    }, "\u2022\u2022\u2022");
    var prevIcon = /* @__PURE__ */ react.exports.createElement("button", {
      className: "".concat(prefixCls, "-item-link"),
      type: "button",
      tabIndex: -1
    }, /* @__PURE__ */ react.exports.createElement(LeftOutlined$1, null));
    var nextIcon = /* @__PURE__ */ react.exports.createElement("button", {
      className: "".concat(prefixCls, "-item-link"),
      type: "button",
      tabIndex: -1
    }, /* @__PURE__ */ react.exports.createElement(RightOutlined$1, null));
    var jumpPrevIcon = /* @__PURE__ */ react.exports.createElement("a", {
      className: "".concat(prefixCls, "-item-link")
    }, /* @__PURE__ */ react.exports.createElement("div", {
      className: "".concat(prefixCls, "-item-container")
    }, /* @__PURE__ */ react.exports.createElement(DoubleLeftOutlined$1, {
      className: "".concat(prefixCls, "-item-link-icon")
    }), ellipsis));
    var jumpNextIcon = /* @__PURE__ */ react.exports.createElement("a", {
      className: "".concat(prefixCls, "-item-link")
    }, /* @__PURE__ */ react.exports.createElement("div", {
      className: "".concat(prefixCls, "-item-container")
    }, /* @__PURE__ */ react.exports.createElement(DoubleRightOutlined$1, {
      className: "".concat(prefixCls, "-item-link-icon")
    }), ellipsis));
    if (direction2 === "rtl") {
      var _ref = [nextIcon, prevIcon];
      prevIcon = _ref[0];
      nextIcon = _ref[1];
      var _ref2 = [jumpNextIcon, jumpPrevIcon];
      jumpPrevIcon = _ref2[0];
      jumpNextIcon = _ref2[1];
    }
    return {
      prevIcon,
      nextIcon,
      jumpPrevIcon,
      jumpNextIcon
    };
  };
  return /* @__PURE__ */ react.exports.createElement(LocaleReceiver, {
    componentName: "Pagination",
    defaultLocale: enUS$1
  }, function(contextLocale) {
    var _classNames;
    var locale2 = _extends$2(_extends$2({}, contextLocale), customLocale);
    var isSmall = size2 === "small" || !!(xs && !size2 && responsive);
    var selectPrefixCls = getPrefixCls("select", customizeSelectPrefixCls);
    var extendedClassName = classNames((_classNames = {}, _defineProperty$4(_classNames, "".concat(prefixCls, "-mini"), isSmall), _defineProperty$4(_classNames, "".concat(prefixCls, "-rtl"), direction2 === "rtl"), _classNames), className);
    return /* @__PURE__ */ react.exports.createElement(Pagination$2, _extends$2({}, getIconsProps(), restProps, {
      prefixCls,
      selectPrefixCls,
      className: extendedClassName,
      selectComponentClass: selectComponentClass || (isSmall ? MiniSelect : MiddleSelect),
      locale: locale2,
      showSizeChanger: mergedShowSizeChanger
    }));
  });
};
var Pagination$1 = Pagination;
var __rest$8 = globalThis && globalThis.__rest || function(s2, e3) {
  var t2 = {};
  for (var p2 in s2) {
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  }
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e3.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
tuple("small", "default", "large");
var defaultIndicator = null;
function renderIndicator(prefixCls, props) {
  var indicator = props.indicator;
  var dotClassName = "".concat(prefixCls, "-dot");
  if (indicator === null) {
    return null;
  }
  if (isValidElement(indicator)) {
    return cloneElement(indicator, {
      className: classNames(indicator.props.className, dotClassName)
    });
  }
  if (isValidElement(defaultIndicator)) {
    return cloneElement(defaultIndicator, {
      className: classNames(defaultIndicator.props.className, dotClassName)
    });
  }
  return /* @__PURE__ */ react.exports.createElement("span", {
    className: classNames(dotClassName, "".concat(prefixCls, "-dot-spin"))
  }, /* @__PURE__ */ react.exports.createElement("i", {
    className: "".concat(prefixCls, "-dot-item")
  }), /* @__PURE__ */ react.exports.createElement("i", {
    className: "".concat(prefixCls, "-dot-item")
  }), /* @__PURE__ */ react.exports.createElement("i", {
    className: "".concat(prefixCls, "-dot-item")
  }), /* @__PURE__ */ react.exports.createElement("i", {
    className: "".concat(prefixCls, "-dot-item")
  }));
}
function shouldDelay(spinning, delay) {
  return !!spinning && !!delay && !isNaN(Number(delay));
}
var Spin = /* @__PURE__ */ function(_React$Component) {
  _inherits$1(Spin2, _React$Component);
  var _super = _createSuper$1(Spin2);
  function Spin2(props) {
    var _this;
    _classCallCheck$2(this, Spin2);
    _this = _super.call(this, props);
    _this.debouncifyUpdateSpinning = function(props2) {
      var _ref = props2 || _this.props, delay2 = _ref.delay;
      if (delay2) {
        _this.cancelExistingSpin();
        _this.updateSpinning = debounce_1(_this.originalUpdateSpinning, delay2);
      }
    };
    _this.updateSpinning = function() {
      var spinning2 = _this.props.spinning;
      var currentSpinning = _this.state.spinning;
      if (currentSpinning !== spinning2) {
        _this.setState({
          spinning: spinning2
        });
      }
    };
    _this.renderSpin = function(_ref2) {
      var _classNames;
      var direction2 = _ref2.direction;
      var _a2 = _this.props, prefixCls = _a2.spinPrefixCls, className = _a2.className, size2 = _a2.size, tip = _a2.tip, wrapperClassName = _a2.wrapperClassName, style2 = _a2.style, restProps = __rest$8(_a2, ["spinPrefixCls", "className", "size", "tip", "wrapperClassName", "style"]);
      var spinning2 = _this.state.spinning;
      var spinClassName = classNames(prefixCls, (_classNames = {}, _defineProperty$4(_classNames, "".concat(prefixCls, "-sm"), size2 === "small"), _defineProperty$4(_classNames, "".concat(prefixCls, "-lg"), size2 === "large"), _defineProperty$4(_classNames, "".concat(prefixCls, "-spinning"), spinning2), _defineProperty$4(_classNames, "".concat(prefixCls, "-show-text"), !!tip), _defineProperty$4(_classNames, "".concat(prefixCls, "-rtl"), direction2 === "rtl"), _classNames), className);
      var divProps = omit$2(restProps, ["spinning", "delay", "indicator", "prefixCls"]);
      var spinElement = /* @__PURE__ */ react.exports.createElement("div", _extends$2({}, divProps, {
        style: style2,
        className: spinClassName,
        "aria-live": "polite",
        "aria-busy": spinning2
      }), renderIndicator(prefixCls, _this.props), tip ? /* @__PURE__ */ react.exports.createElement("div", {
        className: "".concat(prefixCls, "-text")
      }, tip) : null);
      if (_this.isNestedPattern()) {
        var containerClassName = classNames("".concat(prefixCls, "-container"), _defineProperty$4({}, "".concat(prefixCls, "-blur"), spinning2));
        return /* @__PURE__ */ react.exports.createElement("div", _extends$2({}, divProps, {
          className: classNames("".concat(prefixCls, "-nested-loading"), wrapperClassName)
        }), spinning2 && /* @__PURE__ */ react.exports.createElement("div", {
          key: "loading"
        }, spinElement), /* @__PURE__ */ react.exports.createElement("div", {
          className: containerClassName,
          key: "container"
        }, _this.props.children));
      }
      return spinElement;
    };
    var spinning = props.spinning, delay = props.delay;
    var shouldBeDelayed = shouldDelay(spinning, delay);
    _this.state = {
      spinning: spinning && !shouldBeDelayed
    };
    _this.originalUpdateSpinning = _this.updateSpinning;
    _this.debouncifyUpdateSpinning(props);
    return _this;
  }
  _createClass$2(Spin2, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this.updateSpinning();
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate() {
      this.debouncifyUpdateSpinning();
      this.updateSpinning();
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.cancelExistingSpin();
    }
  }, {
    key: "cancelExistingSpin",
    value: function cancelExistingSpin() {
      var updateSpinning = this.updateSpinning;
      if (updateSpinning && updateSpinning.cancel) {
        updateSpinning.cancel();
      }
    }
  }, {
    key: "isNestedPattern",
    value: function isNestedPattern() {
      return !!(this.props && typeof this.props.children !== "undefined");
    }
  }, {
    key: "render",
    value: function render2() {
      return /* @__PURE__ */ react.exports.createElement(ConfigConsumer, null, this.renderSpin);
    }
  }]);
  return Spin2;
}(react.exports.Component);
Spin.defaultProps = {
  spinning: true,
  size: "default",
  wrapperClassName: ""
};
var SpinFC = function SpinFC2(props) {
  var customizePrefixCls = props.prefixCls;
  var _React$useContext = react.exports.useContext(ConfigContext), getPrefixCls = _React$useContext.getPrefixCls;
  var spinPrefixCls = getPrefixCls("spin", customizePrefixCls);
  var spinClassProps = _extends$2(_extends$2({}, props), {
    spinPrefixCls
  });
  return /* @__PURE__ */ react.exports.createElement(Spin, _extends$2({}, spinClassProps));
};
SpinFC.setDefaultIndicator = function(indicator) {
  defaultIndicator = indicator;
};
var Spin$1 = SpinFC;
var __rest$7 = globalThis && globalThis.__rest || function(s2, e3) {
  var t2 = {};
  for (var p2 in s2) {
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  }
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e3.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
var Meta = function Meta2(_a2) {
  var customizePrefixCls = _a2.prefixCls, className = _a2.className, avatar = _a2.avatar, title = _a2.title, description = _a2.description, others = __rest$7(_a2, ["prefixCls", "className", "avatar", "title", "description"]);
  var _useContext = react.exports.useContext(ConfigContext), getPrefixCls = _useContext.getPrefixCls;
  var prefixCls = getPrefixCls("list", customizePrefixCls);
  var classString = classNames("".concat(prefixCls, "-item-meta"), className);
  var content = /* @__PURE__ */ jsxs("div", {
    className: "".concat(prefixCls, "-item-meta-content"),
    children: [title && /* @__PURE__ */ jsx("h4", {
      className: "".concat(prefixCls, "-item-meta-title"),
      children: title
    }), description && /* @__PURE__ */ jsx("div", {
      className: "".concat(prefixCls, "-item-meta-description"),
      children: description
    })]
  });
  return /* @__PURE__ */ jsxs("div", {
    ...others,
    className: classString,
    children: [avatar && /* @__PURE__ */ jsx("div", {
      className: "".concat(prefixCls, "-item-meta-avatar"),
      children: avatar
    }), (title || description) && content]
  });
};
var InternalItem = function InternalItem2(_a2, ref) {
  var customizePrefixCls = _a2.prefixCls, children = _a2.children, actions = _a2.actions, extra = _a2.extra, className = _a2.className, colStyle = _a2.colStyle, others = __rest$7(_a2, ["prefixCls", "children", "actions", "extra", "className", "colStyle"]);
  var _useContext2 = react.exports.useContext(ListContext), grid = _useContext2.grid, itemLayout = _useContext2.itemLayout;
  var _useContext3 = react.exports.useContext(ConfigContext), getPrefixCls = _useContext3.getPrefixCls;
  var isItemContainsTextNodeAndNotSingular = function isItemContainsTextNodeAndNotSingular2() {
    var result;
    react.exports.Children.forEach(children, function(element) {
      if (typeof element === "string") {
        result = true;
      }
    });
    return result && react.exports.Children.count(children) > 1;
  };
  var isFlexMode = function isFlexMode2() {
    if (itemLayout === "vertical") {
      return !!extra;
    }
    return !isItemContainsTextNodeAndNotSingular();
  };
  var prefixCls = getPrefixCls("list", customizePrefixCls);
  var actionsContent = actions && actions.length > 0 && /* @__PURE__ */ jsx("ul", {
    className: "".concat(prefixCls, "-item-action"),
    children: actions.map(function(action, i2) {
      return /* @__PURE__ */ jsxs("li", {
        children: [action, i2 !== actions.length - 1 && /* @__PURE__ */ jsx("em", {
          className: "".concat(prefixCls, "-item-action-split")
        })]
      }, "".concat(prefixCls, "-item-action-").concat(i2));
    })
  }, "actions");
  var Element2 = grid ? "div" : "li";
  var itemChildren = /* @__PURE__ */ jsx(Element2, {
    ...others,
    ...!grid ? {
      ref
    } : {},
    className: classNames("".concat(prefixCls, "-item"), _defineProperty$4({}, "".concat(prefixCls, "-item-no-flex"), !isFlexMode()), className),
    children: itemLayout === "vertical" && extra ? [
      /* @__PURE__ */ jsxs("div", {
        className: "".concat(prefixCls, "-item-main"),
        children: [children, actionsContent]
      }, "content"),
      /* @__PURE__ */ jsx("div", {
        className: "".concat(prefixCls, "-item-extra"),
        children: extra
      }, "extra")
    ] : [children, actionsContent, cloneElement(extra, {
      key: "extra"
    })]
  });
  return grid ? /* @__PURE__ */ jsx(Col$1, {
    ref,
    flex: 1,
    style: colStyle,
    children: itemChildren
  }) : itemChildren;
};
var Item = /* @__PURE__ */ react.exports.forwardRef(InternalItem);
Item.Meta = Meta;
var Item$1 = Item;
var __rest$6 = globalThis && globalThis.__rest || function(s2, e3) {
  var t2 = {};
  for (var p2 in s2) {
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  }
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e3.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
var ListContext = /* @__PURE__ */ react.exports.createContext({});
ListContext.Consumer;
function List$1(_a2) {
  var _classNames;
  var _a$pagination = _a2.pagination, pagination = _a$pagination === void 0 ? false : _a$pagination, customizePrefixCls = _a2.prefixCls, _a$bordered = _a2.bordered, bordered = _a$bordered === void 0 ? false : _a$bordered, _a$split = _a2.split, split = _a$split === void 0 ? true : _a$split, className = _a2.className, children = _a2.children, itemLayout = _a2.itemLayout, loadMore = _a2.loadMore, grid = _a2.grid, _a$dataSource = _a2.dataSource, dataSource = _a$dataSource === void 0 ? [] : _a$dataSource, size2 = _a2.size, header = _a2.header, footer = _a2.footer, _a$loading = _a2.loading, loading = _a$loading === void 0 ? false : _a$loading, rowKey = _a2.rowKey, renderItem = _a2.renderItem, locale2 = _a2.locale, rest = __rest$6(_a2, ["pagination", "prefixCls", "bordered", "split", "className", "children", "itemLayout", "loadMore", "grid", "dataSource", "size", "header", "footer", "loading", "rowKey", "renderItem", "locale"]);
  var paginationObj = pagination && _typeof$4(pagination) === "object" ? pagination : {};
  var _React$useState = react.exports.useState(paginationObj.defaultCurrent || 1), _React$useState2 = _slicedToArray$4(_React$useState, 2), paginationCurrent = _React$useState2[0], setPaginationCurrent = _React$useState2[1];
  var _React$useState3 = react.exports.useState(paginationObj.defaultPageSize || 10), _React$useState4 = _slicedToArray$4(_React$useState3, 2), paginationSize = _React$useState4[0], setPaginationSize = _React$useState4[1];
  var _React$useContext = react.exports.useContext(ConfigContext), getPrefixCls = _React$useContext.getPrefixCls, renderEmpty = _React$useContext.renderEmpty, direction2 = _React$useContext.direction;
  var defaultPaginationProps = {
    current: 1,
    total: 0
  };
  var listItemsKeys = {};
  var triggerPaginationEvent = function triggerPaginationEvent2(eventName) {
    return function(page, pageSize) {
      setPaginationCurrent(page);
      setPaginationSize(pageSize);
      if (pagination && pagination[eventName]) {
        pagination[eventName](page, pageSize);
      }
    };
  };
  var onPaginationChange = triggerPaginationEvent("onChange");
  var onPaginationShowSizeChange = triggerPaginationEvent("onShowSizeChange");
  var renderInnerItem = function renderInnerItem2(item, index2) {
    if (!renderItem)
      return null;
    var key2;
    if (typeof rowKey === "function") {
      key2 = rowKey(item);
    } else if (rowKey) {
      key2 = item[rowKey];
    } else {
      key2 = item.key;
    }
    if (!key2) {
      key2 = "list-item-".concat(index2);
    }
    listItemsKeys[index2] = key2;
    return renderItem(item, index2);
  };
  var isSomethingAfterLastItem = function isSomethingAfterLastItem2() {
    return !!(loadMore || pagination || footer);
  };
  var renderEmptyFunc = function renderEmptyFunc2(prefixCls2, renderEmptyHandler) {
    return /* @__PURE__ */ react.exports.createElement("div", {
      className: "".concat(prefixCls2, "-empty-text")
    }, locale2 && locale2.emptyText || renderEmptyHandler("List"));
  };
  var prefixCls = getPrefixCls("list", customizePrefixCls);
  var loadingProp = loading;
  if (typeof loadingProp === "boolean") {
    loadingProp = {
      spinning: loadingProp
    };
  }
  var isLoading = loadingProp && loadingProp.spinning;
  var sizeCls = "";
  switch (size2) {
    case "large":
      sizeCls = "lg";
      break;
    case "small":
      sizeCls = "sm";
      break;
  }
  var classString = classNames(prefixCls, (_classNames = {}, _defineProperty$4(_classNames, "".concat(prefixCls, "-vertical"), itemLayout === "vertical"), _defineProperty$4(_classNames, "".concat(prefixCls, "-").concat(sizeCls), sizeCls), _defineProperty$4(_classNames, "".concat(prefixCls, "-split"), split), _defineProperty$4(_classNames, "".concat(prefixCls, "-bordered"), bordered), _defineProperty$4(_classNames, "".concat(prefixCls, "-loading"), isLoading), _defineProperty$4(_classNames, "".concat(prefixCls, "-grid"), !!grid), _defineProperty$4(_classNames, "".concat(prefixCls, "-something-after-last-item"), isSomethingAfterLastItem()), _defineProperty$4(_classNames, "".concat(prefixCls, "-rtl"), direction2 === "rtl"), _classNames), className);
  var paginationProps = _extends$2(_extends$2(_extends$2({}, defaultPaginationProps), {
    total: dataSource.length,
    current: paginationCurrent,
    pageSize: paginationSize
  }), pagination || {});
  var largestPage = Math.ceil(paginationProps.total / paginationProps.pageSize);
  if (paginationProps.current > largestPage) {
    paginationProps.current = largestPage;
  }
  var paginationContent = pagination ? /* @__PURE__ */ react.exports.createElement("div", {
    className: "".concat(prefixCls, "-pagination")
  }, /* @__PURE__ */ react.exports.createElement(Pagination$1, _extends$2({}, paginationProps, {
    onChange: onPaginationChange,
    onShowSizeChange: onPaginationShowSizeChange
  }))) : null;
  var splitDataSource = _toConsumableArray(dataSource);
  if (pagination) {
    if (dataSource.length > (paginationProps.current - 1) * paginationProps.pageSize) {
      splitDataSource = _toConsumableArray(dataSource).splice((paginationProps.current - 1) * paginationProps.pageSize, paginationProps.pageSize);
    }
  }
  var needResponsive = Object.keys(grid || {}).some(function(key2) {
    return ["xs", "sm", "md", "lg", "xl", "xxl"].includes(key2);
  });
  var screens2 = useBreakpoint(needResponsive);
  var currentBreakpoint = react.exports.useMemo(function() {
    for (var i2 = 0; i2 < responsiveArray.length; i2 += 1) {
      var breakpoint = responsiveArray[i2];
      if (screens2[breakpoint]) {
        return breakpoint;
      }
    }
    return void 0;
  }, [screens2]);
  var colStyle = react.exports.useMemo(function() {
    if (!grid) {
      return void 0;
    }
    var columnCount = currentBreakpoint && grid[currentBreakpoint] ? grid[currentBreakpoint] : grid.column;
    if (columnCount) {
      return {
        width: "".concat(100 / columnCount, "%"),
        maxWidth: "".concat(100 / columnCount, "%")
      };
    }
  }, [grid === null || grid === void 0 ? void 0 : grid.column, currentBreakpoint]);
  var childrenContent = isLoading && /* @__PURE__ */ react.exports.createElement("div", {
    style: {
      minHeight: 53
    }
  });
  if (splitDataSource.length > 0) {
    var items = splitDataSource.map(function(item, index2) {
      return renderInnerItem(item, index2);
    });
    var childrenList = react.exports.Children.map(items, function(child, index2) {
      return /* @__PURE__ */ react.exports.createElement("div", {
        key: listItemsKeys[index2],
        style: colStyle
      }, child);
    });
    childrenContent = grid ? /* @__PURE__ */ react.exports.createElement(Row$1, {
      gutter: grid.gutter
    }, childrenList) : /* @__PURE__ */ react.exports.createElement("ul", {
      className: "".concat(prefixCls, "-items")
    }, items);
  } else if (!children && !isLoading) {
    childrenContent = renderEmptyFunc(prefixCls, renderEmpty || defaultRenderEmpty$1);
  }
  var paginationPosition = paginationProps.position || "bottom";
  var contextValue = react.exports.useMemo(function() {
    return {
      grid,
      itemLayout
    };
  }, [JSON.stringify(grid), itemLayout]);
  return /* @__PURE__ */ react.exports.createElement(ListContext.Provider, {
    value: contextValue
  }, /* @__PURE__ */ react.exports.createElement("div", _extends$2({
    className: classString
  }, rest), (paginationPosition === "top" || paginationPosition === "both") && paginationContent, header && /* @__PURE__ */ react.exports.createElement("div", {
    className: "".concat(prefixCls, "-header")
  }, header), /* @__PURE__ */ react.exports.createElement(Spin$1, _extends$2({}, loadingProp), childrenContent, children), footer && /* @__PURE__ */ react.exports.createElement("div", {
    className: "".concat(prefixCls, "-footer")
  }, footer), loadMore || (paginationPosition === "bottom" || paginationPosition === "both") && paginationContent));
}
List$1.Item = Item$1;
function ColumnGroup$1(_2) {
  return null;
}
function Column$2(_2) {
  return null;
}
var INTERNAL_KEY_PREFIX = "RC_TABLE_KEY";
function toArray$2(arr) {
  if (arr === void 0 || arr === null) {
    return [];
  }
  return Array.isArray(arr) ? arr : [arr];
}
function getPathValue(record, path2) {
  if (!path2 && typeof path2 !== "number") {
    return record;
  }
  var pathList = toArray$2(path2);
  var current = record;
  for (var i2 = 0; i2 < pathList.length; i2 += 1) {
    if (!current) {
      return null;
    }
    var prop = pathList[i2];
    current = current[prop];
  }
  return current;
}
function getColumnsKey(columns2) {
  var columnKeys = [];
  var keys2 = {};
  columns2.forEach(function(column) {
    var _ref = column || {}, key2 = _ref.key, dataIndex = _ref.dataIndex;
    var mergedKey = key2 || toArray$2(dataIndex).join("-") || INTERNAL_KEY_PREFIX;
    while (keys2[mergedKey]) {
      mergedKey = "".concat(mergedKey, "_next");
    }
    keys2[mergedKey] = true;
    columnKeys.push(mergedKey);
  });
  return columnKeys;
}
function validateValue(val) {
  return val !== null && val !== void 0;
}
var StickyContext = /* @__PURE__ */ react.exports.createContext(false);
function createContext() {
  var Context2 = /* @__PURE__ */ react.exports.createContext(null);
  var Provider2 = function Provider3(_ref) {
    var value2 = _ref.value, children = _ref.children;
    var valueRef = react.exports.useRef(value2);
    valueRef.current = value2;
    var _React$useState = react.exports.useState(function() {
      return {
        getValue: function getValue2() {
          return valueRef.current;
        },
        listeners: /* @__PURE__ */ new Set()
      };
    }), _React$useState2 = _slicedToArray$4(_React$useState, 1), context2 = _React$useState2[0];
    useLayoutEffect$1(function() {
      context2.listeners.forEach(function(listener) {
        listener(value2);
      });
    }, [value2]);
    return /* @__PURE__ */ react.exports.createElement(Context2.Provider, {
      value: context2
    }, children);
  };
  return {
    Context: Context2,
    Provider: Provider2
  };
}
function useContextSelector(holder, selector) {
  var eventSelector = useEvent(selector);
  var context2 = react.exports.useContext(holder === null || holder === void 0 ? void 0 : holder.Context);
  var _ref2 = context2 || {}, listeners = _ref2.listeners, getValue2 = _ref2.getValue;
  var _React$useState3 = react.exports.useState(function() {
    return eventSelector(context2 ? getValue2() : null);
  }), _React$useState4 = _slicedToArray$4(_React$useState3, 2), value2 = _React$useState4[0], setValue2 = _React$useState4[1];
  useLayoutEffect$1(function() {
    if (!context2) {
      return;
    }
    function trigger(nextValue) {
      setValue2(function(prev) {
        var selectedValue = eventSelector(nextValue);
        return shallowequal(prev, selectedValue) ? prev : selectedValue;
      });
    }
    listeners.add(trigger);
    return function() {
      listeners.delete(trigger);
    };
  }, [context2]);
  return value2;
}
var HoverContext = createContext();
var BodyContext = /* @__PURE__ */ react.exports.createContext(null);
var PerfContext = /* @__PURE__ */ react.exports.createContext({
  renderWithProps: false
});
var _excluded$7 = ["colSpan", "rowSpan", "style", "className"];
function inHoverRange(cellStartRow, cellRowSpan, startRow, endRow) {
  var cellEndRow = cellStartRow + cellRowSpan - 1;
  return cellStartRow <= endRow && cellEndRow >= startRow;
}
function isRenderCell(data2) {
  return data2 && _typeof$4(data2) === "object" && !Array.isArray(data2) && !/* @__PURE__ */ react.exports.isValidElement(data2);
}
function isRefComponent(component2) {
  if (typeof component2 === "string") {
    return true;
  }
  return supportRef(component2);
}
var getTitleFromCellRenderChildren = function getTitleFromCellRenderChildren2(_ref) {
  var ellipsis = _ref.ellipsis, rowType = _ref.rowType, children = _ref.children;
  var title;
  var ellipsisConfig = ellipsis === true ? {
    showTitle: true
  } : ellipsis;
  if (ellipsisConfig && (ellipsisConfig.showTitle || rowType === "header")) {
    if (typeof children === "string" || typeof children === "number") {
      title = children.toString();
    } else if (/* @__PURE__ */ react.exports.isValidElement(children) && typeof children.props.children === "string") {
      title = children.props.children;
    }
  }
  return title;
};
function Cell(_ref2, ref) {
  var _ref4, _ref5, _classNames;
  var prefixCls = _ref2.prefixCls, className = _ref2.className, record = _ref2.record, index2 = _ref2.index, renderIndex = _ref2.renderIndex, dataIndex = _ref2.dataIndex, render2 = _ref2.render, children = _ref2.children, _ref2$component = _ref2.component, Component2 = _ref2$component === void 0 ? "td" : _ref2$component, colSpan = _ref2.colSpan, rowSpan = _ref2.rowSpan, fixLeft = _ref2.fixLeft, fixRight = _ref2.fixRight, firstFixLeft = _ref2.firstFixLeft, lastFixLeft = _ref2.lastFixLeft, firstFixRight = _ref2.firstFixRight, lastFixRight = _ref2.lastFixRight, appendNode = _ref2.appendNode, _ref2$additionalProps = _ref2.additionalProps, additionalProps = _ref2$additionalProps === void 0 ? {} : _ref2$additionalProps, ellipsis = _ref2.ellipsis, align = _ref2.align, rowType = _ref2.rowType, isSticky = _ref2.isSticky, hovering = _ref2.hovering, onHover = _ref2.onHover;
  var cellPrefixCls = "".concat(prefixCls, "-cell");
  var perfRecord = react.exports.useContext(PerfContext);
  var supportSticky = react.exports.useContext(StickyContext);
  var _React$useContext = react.exports.useContext(BodyContext), allColumnsFixedLeft = _React$useContext.allColumnsFixedLeft;
  var _React$useMemo = react.exports.useMemo(function() {
    if (validateValue(children)) {
      return [children];
    }
    var value2 = getPathValue(record, dataIndex);
    var returnChildNode = value2;
    var returnCellProps = void 0;
    if (render2) {
      var renderData = render2(value2, record, renderIndex);
      if (isRenderCell(renderData)) {
        returnChildNode = renderData.children;
        returnCellProps = renderData.props;
        perfRecord.renderWithProps = true;
      } else {
        returnChildNode = renderData;
      }
    }
    return [returnChildNode, returnCellProps];
  }, [
    perfRecord.renderWithProps ? Math.random() : 0,
    children,
    dataIndex,
    perfRecord,
    record,
    render2,
    renderIndex
  ]), _React$useMemo2 = _slicedToArray$4(_React$useMemo, 2), childNode = _React$useMemo2[0], legacyCellProps = _React$useMemo2[1];
  var mergedChildNode = childNode;
  if (_typeof$4(mergedChildNode) === "object" && !Array.isArray(mergedChildNode) && !/* @__PURE__ */ react.exports.isValidElement(mergedChildNode)) {
    mergedChildNode = null;
  }
  if (ellipsis && (lastFixLeft || firstFixRight)) {
    mergedChildNode = /* @__PURE__ */ react.exports.createElement("span", {
      className: "".concat(cellPrefixCls, "-content")
    }, mergedChildNode);
  }
  var _ref3 = legacyCellProps || {}, cellColSpan = _ref3.colSpan, cellRowSpan = _ref3.rowSpan, cellStyle = _ref3.style, cellClassName = _ref3.className, restCellProps = _objectWithoutProperties$1(_ref3, _excluded$7);
  var mergedColSpan = (_ref4 = cellColSpan !== void 0 ? cellColSpan : colSpan) !== null && _ref4 !== void 0 ? _ref4 : 1;
  var mergedRowSpan = (_ref5 = cellRowSpan !== void 0 ? cellRowSpan : rowSpan) !== null && _ref5 !== void 0 ? _ref5 : 1;
  if (mergedColSpan === 0 || mergedRowSpan === 0) {
    return null;
  }
  var fixedStyle = {};
  var isFixLeft = typeof fixLeft === "number" && supportSticky;
  var isFixRight = typeof fixRight === "number" && supportSticky;
  if (isFixLeft) {
    fixedStyle.position = "sticky";
    fixedStyle.left = fixLeft;
  }
  if (isFixRight) {
    fixedStyle.position = "sticky";
    fixedStyle.right = fixRight;
  }
  var alignStyle = {};
  if (align) {
    alignStyle.textAlign = align;
  }
  var onMouseEnter = function onMouseEnter2(event) {
    var _additionalProps$onMo;
    if (record) {
      onHover(index2, index2 + mergedRowSpan - 1);
    }
    additionalProps === null || additionalProps === void 0 ? void 0 : (_additionalProps$onMo = additionalProps.onMouseEnter) === null || _additionalProps$onMo === void 0 ? void 0 : _additionalProps$onMo.call(additionalProps, event);
  };
  var onMouseLeave = function onMouseLeave2(event) {
    var _additionalProps$onMo2;
    if (record) {
      onHover(-1, -1);
    }
    additionalProps === null || additionalProps === void 0 ? void 0 : (_additionalProps$onMo2 = additionalProps.onMouseLeave) === null || _additionalProps$onMo2 === void 0 ? void 0 : _additionalProps$onMo2.call(additionalProps, event);
  };
  var title = getTitleFromCellRenderChildren({
    rowType,
    ellipsis,
    children: childNode
  });
  var componentProps = _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({
    title
  }, restCellProps), additionalProps), {}, {
    colSpan: mergedColSpan !== 1 ? mergedColSpan : null,
    rowSpan: mergedRowSpan !== 1 ? mergedRowSpan : null,
    className: classNames(cellPrefixCls, className, (_classNames = {}, _defineProperty$4(_classNames, "".concat(cellPrefixCls, "-fix-left"), isFixLeft && supportSticky), _defineProperty$4(_classNames, "".concat(cellPrefixCls, "-fix-left-first"), firstFixLeft && supportSticky), _defineProperty$4(_classNames, "".concat(cellPrefixCls, "-fix-left-last"), lastFixLeft && supportSticky), _defineProperty$4(_classNames, "".concat(cellPrefixCls, "-fix-left-all"), lastFixLeft && allColumnsFixedLeft && supportSticky), _defineProperty$4(_classNames, "".concat(cellPrefixCls, "-fix-right"), isFixRight && supportSticky), _defineProperty$4(_classNames, "".concat(cellPrefixCls, "-fix-right-first"), firstFixRight && supportSticky), _defineProperty$4(_classNames, "".concat(cellPrefixCls, "-fix-right-last"), lastFixRight && supportSticky), _defineProperty$4(_classNames, "".concat(cellPrefixCls, "-ellipsis"), ellipsis), _defineProperty$4(_classNames, "".concat(cellPrefixCls, "-with-append"), appendNode), _defineProperty$4(_classNames, "".concat(cellPrefixCls, "-fix-sticky"), (isFixLeft || isFixRight) && isSticky && supportSticky), _defineProperty$4(_classNames, "".concat(cellPrefixCls, "-row-hover"), !legacyCellProps && hovering), _classNames), additionalProps.className, cellClassName),
    style: _objectSpread2$1(_objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, additionalProps.style), alignStyle), fixedStyle), cellStyle),
    onMouseEnter,
    onMouseLeave,
    ref: isRefComponent(Component2) ? ref : null
  });
  return /* @__PURE__ */ react.exports.createElement(Component2, componentProps, appendNode, mergedChildNode);
}
var RefCell = /* @__PURE__ */ react.exports.forwardRef(Cell);
RefCell.displayName = "Cell";
var comparePropList = ["expanded", "className", "hovering"];
var MemoCell = /* @__PURE__ */ react.exports.memo(RefCell, function(prev, next) {
  if (next.shouldCellUpdate) {
    return comparePropList.every(function(propName) {
      return prev[propName] === next[propName];
    }) && !next.shouldCellUpdate(next.record, prev.record);
  }
  return shallowequal(prev, next);
});
var WrappedCell = /* @__PURE__ */ react.exports.forwardRef(function(props, ref) {
  var index2 = props.index, _props$additionalProp = props.additionalProps, additionalProps = _props$additionalProp === void 0 ? {} : _props$additionalProp, colSpan = props.colSpan, rowSpan = props.rowSpan;
  var cellColSpan = additionalProps.colSpan, cellRowSpan = additionalProps.rowSpan;
  var mergedColSpan = colSpan !== null && colSpan !== void 0 ? colSpan : cellColSpan;
  var mergedRowSpan = rowSpan !== null && rowSpan !== void 0 ? rowSpan : cellRowSpan;
  var _useContextSelector = useContextSelector(HoverContext, function(cxt) {
    var isHovering = inHoverRange(index2, mergedRowSpan || 1, cxt === null || cxt === void 0 ? void 0 : cxt.startRow, cxt === null || cxt === void 0 ? void 0 : cxt.endRow);
    return {
      onHover: cxt === null || cxt === void 0 ? void 0 : cxt.onHover,
      hovering: isHovering
    };
  }), onHover = _useContextSelector.onHover, hovering = _useContextSelector.hovering;
  return /* @__PURE__ */ react.exports.createElement(MemoCell, _extends$2({}, props, {
    colSpan: mergedColSpan,
    rowSpan: mergedRowSpan,
    hovering,
    ref,
    onHover
  }));
});
WrappedCell.displayName = "WrappedCell";
var TableContext = /* @__PURE__ */ react.exports.createContext(null);
function getCellFixedInfo(colStart, colEnd, columns2, stickyOffsets, direction2) {
  var startColumn = columns2[colStart] || {};
  var endColumn = columns2[colEnd] || {};
  var fixLeft;
  var fixRight;
  if (startColumn.fixed === "left") {
    fixLeft = stickyOffsets.left[colStart];
  } else if (endColumn.fixed === "right") {
    fixRight = stickyOffsets.right[colEnd];
  }
  var lastFixLeft = false;
  var firstFixRight = false;
  var lastFixRight = false;
  var firstFixLeft = false;
  var nextColumn = columns2[colEnd + 1];
  var prevColumn = columns2[colStart - 1];
  if (direction2 === "rtl") {
    if (fixLeft !== void 0) {
      var prevFixLeft = prevColumn && prevColumn.fixed === "left";
      firstFixLeft = !prevFixLeft;
    } else if (fixRight !== void 0) {
      var nextFixRight = nextColumn && nextColumn.fixed === "right";
      lastFixRight = !nextFixRight;
    }
  } else if (fixLeft !== void 0) {
    var nextFixLeft = nextColumn && nextColumn.fixed === "left";
    lastFixLeft = !nextFixLeft;
  } else if (fixRight !== void 0) {
    var prevFixRight = prevColumn && prevColumn.fixed === "right";
    firstFixRight = !prevFixRight;
  }
  return {
    fixLeft,
    fixRight,
    lastFixLeft,
    firstFixRight,
    lastFixRight,
    firstFixLeft,
    isSticky: stickyOffsets.isSticky
  };
}
function HeaderRow(_ref) {
  var cells = _ref.cells, stickyOffsets = _ref.stickyOffsets, flattenColumns = _ref.flattenColumns, RowComponent = _ref.rowComponent, CellComponent = _ref.cellComponent, onHeaderRow = _ref.onHeaderRow, index2 = _ref.index;
  var _React$useContext = react.exports.useContext(TableContext), prefixCls = _React$useContext.prefixCls, direction2 = _React$useContext.direction;
  var rowProps;
  if (onHeaderRow) {
    rowProps = onHeaderRow(cells.map(function(cell) {
      return cell.column;
    }), index2);
  }
  var columnsKey = getColumnsKey(cells.map(function(cell) {
    return cell.column;
  }));
  return /* @__PURE__ */ react.exports.createElement(RowComponent, rowProps, cells.map(function(cell, cellIndex) {
    var column = cell.column;
    var fixedInfo = getCellFixedInfo(cell.colStart, cell.colEnd, flattenColumns, stickyOffsets, direction2);
    var additionalProps;
    if (column && column.onHeaderCell) {
      additionalProps = cell.column.onHeaderCell(column);
    }
    return /* @__PURE__ */ react.exports.createElement(WrappedCell, _extends$2({}, cell, {
      ellipsis: column.ellipsis,
      align: column.align,
      component: CellComponent,
      prefixCls,
      key: columnsKey[cellIndex]
    }, fixedInfo, {
      additionalProps,
      rowType: "header"
    }));
  }));
}
HeaderRow.displayName = "HeaderRow";
function parseHeaderRows(rootColumns) {
  var rows = [];
  function fillRowCells(columns2, colIndex) {
    var rowIndex2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
    rows[rowIndex2] = rows[rowIndex2] || [];
    var currentColIndex = colIndex;
    var colSpans = columns2.filter(Boolean).map(function(column) {
      var cell = {
        key: column.key,
        className: column.className || "",
        children: column.title,
        column,
        colStart: currentColIndex
      };
      var colSpan = 1;
      var subColumns = column.children;
      if (subColumns && subColumns.length > 0) {
        colSpan = fillRowCells(subColumns, currentColIndex, rowIndex2 + 1).reduce(function(total, count2) {
          return total + count2;
        }, 0);
        cell.hasSubColumns = true;
      }
      if ("colSpan" in column) {
        colSpan = column.colSpan;
      }
      if ("rowSpan" in column) {
        cell.rowSpan = column.rowSpan;
      }
      cell.colSpan = colSpan;
      cell.colEnd = cell.colStart + colSpan - 1;
      rows[rowIndex2].push(cell);
      currentColIndex += colSpan;
      return colSpan;
    });
    return colSpans;
  }
  fillRowCells(rootColumns, 0);
  var rowCount = rows.length;
  var _loop = function _loop2(rowIndex2) {
    rows[rowIndex2].forEach(function(cell) {
      if (!("rowSpan" in cell) && !cell.hasSubColumns) {
        cell.rowSpan = rowCount - rowIndex2;
      }
    });
  };
  for (var rowIndex = 0; rowIndex < rowCount; rowIndex += 1) {
    _loop(rowIndex);
  }
  return rows;
}
function Header(_ref) {
  var stickyOffsets = _ref.stickyOffsets, columns2 = _ref.columns, flattenColumns = _ref.flattenColumns, onHeaderRow = _ref.onHeaderRow;
  var _React$useContext = react.exports.useContext(TableContext), prefixCls = _React$useContext.prefixCls, getComponent = _React$useContext.getComponent;
  var rows = react.exports.useMemo(function() {
    return parseHeaderRows(columns2);
  }, [columns2]);
  var WrapperComponent = getComponent(["header", "wrapper"], "thead");
  var trComponent = getComponent(["header", "row"], "tr");
  var thComponent = getComponent(["header", "cell"], "th");
  return /* @__PURE__ */ react.exports.createElement(WrapperComponent, {
    className: "".concat(prefixCls, "-thead")
  }, rows.map(function(row, rowIndex) {
    var rowNode = /* @__PURE__ */ react.exports.createElement(HeaderRow, {
      key: rowIndex,
      flattenColumns,
      cells: row,
      stickyOffsets,
      rowComponent: trComponent,
      cellComponent: thComponent,
      onHeaderRow,
      index: rowIndex
    });
    return rowNode;
  }));
}
var ExpandedRowContext = /* @__PURE__ */ react.exports.createContext(null);
function ExpandedRow(_ref) {
  var prefixCls = _ref.prefixCls, children = _ref.children, Component2 = _ref.component, cellComponent = _ref.cellComponent, className = _ref.className, expanded = _ref.expanded, colSpan = _ref.colSpan, isEmpty2 = _ref.isEmpty;
  var _React$useContext = react.exports.useContext(TableContext), scrollbarSize = _React$useContext.scrollbarSize;
  var _React$useContext2 = react.exports.useContext(ExpandedRowContext), fixHeader = _React$useContext2.fixHeader, fixColumn = _React$useContext2.fixColumn, componentWidth = _React$useContext2.componentWidth, horizonScroll = _React$useContext2.horizonScroll;
  return react.exports.useMemo(function() {
    var contentNode = children;
    if (isEmpty2 ? horizonScroll : fixColumn) {
      contentNode = /* @__PURE__ */ react.exports.createElement("div", {
        style: {
          width: componentWidth - (fixHeader ? scrollbarSize : 0),
          position: "sticky",
          left: 0,
          overflow: "hidden"
        },
        className: "".concat(prefixCls, "-expanded-row-fixed")
      }, componentWidth !== 0 && contentNode);
    }
    return /* @__PURE__ */ react.exports.createElement(Component2, {
      className,
      style: {
        display: expanded ? null : "none"
      }
    }, /* @__PURE__ */ react.exports.createElement(WrappedCell, {
      component: cellComponent,
      prefixCls,
      colSpan
    }, contentNode));
  }, [children, Component2, className, expanded, colSpan, isEmpty2, scrollbarSize, componentWidth, fixColumn, fixHeader, horizonScroll]);
}
var ResizeContext = /* @__PURE__ */ react.exports.createContext(null);
function BodyRow(props) {
  var className = props.className, style2 = props.style, record = props.record, index2 = props.index, renderIndex = props.renderIndex, rowKey = props.rowKey, rowExpandable = props.rowExpandable, expandedKeys = props.expandedKeys, onRow = props.onRow, _props$indent = props.indent, indent = _props$indent === void 0 ? 0 : _props$indent, RowComponent = props.rowComponent, cellComponent = props.cellComponent, childrenColumnName = props.childrenColumnName;
  var _React$useContext = react.exports.useContext(TableContext), prefixCls = _React$useContext.prefixCls, fixedInfoList = _React$useContext.fixedInfoList;
  var _React$useContext2 = react.exports.useContext(BodyContext), flattenColumns = _React$useContext2.flattenColumns, expandableType = _React$useContext2.expandableType, expandRowByClick = _React$useContext2.expandRowByClick, onTriggerExpand = _React$useContext2.onTriggerExpand, rowClassName = _React$useContext2.rowClassName, expandedRowClassName = _React$useContext2.expandedRowClassName, indentSize = _React$useContext2.indentSize, expandIcon = _React$useContext2.expandIcon, expandedRowRender = _React$useContext2.expandedRowRender, expandIconColumnIndex = _React$useContext2.expandIconColumnIndex;
  var _React$useState = react.exports.useState(false), _React$useState2 = _slicedToArray$4(_React$useState, 2), expandRended = _React$useState2[0], setExpandRended = _React$useState2[1];
  var expanded = expandedKeys && expandedKeys.has(props.recordKey);
  react.exports.useEffect(function() {
    if (expanded) {
      setExpandRended(true);
    }
  }, [expanded]);
  var rowSupportExpand = expandableType === "row" && (!rowExpandable || rowExpandable(record));
  var nestExpandable = expandableType === "nest";
  var hasNestChildren = childrenColumnName && record && record[childrenColumnName];
  var mergedExpandable = rowSupportExpand || nestExpandable;
  var onExpandRef = react.exports.useRef(onTriggerExpand);
  onExpandRef.current = onTriggerExpand;
  var onInternalTriggerExpand = function onInternalTriggerExpand2() {
    onExpandRef.current.apply(onExpandRef, arguments);
  };
  var additionalProps = onRow === null || onRow === void 0 ? void 0 : onRow(record, index2);
  var onClick = function onClick2(event) {
    var _additionalProps$onCl;
    if (expandRowByClick && mergedExpandable) {
      onInternalTriggerExpand(record, event);
    }
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    additionalProps === null || additionalProps === void 0 ? void 0 : (_additionalProps$onCl = additionalProps.onClick) === null || _additionalProps$onCl === void 0 ? void 0 : _additionalProps$onCl.call.apply(_additionalProps$onCl, [additionalProps, event].concat(args));
  };
  var computeRowClassName;
  if (typeof rowClassName === "string") {
    computeRowClassName = rowClassName;
  } else if (typeof rowClassName === "function") {
    computeRowClassName = rowClassName(record, index2, indent);
  }
  var columnsKey = getColumnsKey(flattenColumns);
  var baseRowNode = /* @__PURE__ */ react.exports.createElement(RowComponent, _extends$2({}, additionalProps, {
    "data-row-key": rowKey,
    className: classNames(className, "".concat(prefixCls, "-row"), "".concat(prefixCls, "-row-level-").concat(indent), computeRowClassName, additionalProps && additionalProps.className),
    style: _objectSpread2$1(_objectSpread2$1({}, style2), additionalProps ? additionalProps.style : null),
    onClick
  }), flattenColumns.map(function(column, colIndex) {
    var render2 = column.render, dataIndex = column.dataIndex, columnClassName = column.className;
    var key2 = columnsKey[colIndex];
    var fixedInfo = fixedInfoList[colIndex];
    var appendCellNode;
    if (colIndex === (expandIconColumnIndex || 0) && nestExpandable) {
      appendCellNode = /* @__PURE__ */ react.exports.createElement(react.exports.Fragment, null, /* @__PURE__ */ react.exports.createElement("span", {
        style: {
          paddingLeft: "".concat(indentSize * indent, "px")
        },
        className: "".concat(prefixCls, "-row-indent indent-level-").concat(indent)
      }), expandIcon({
        prefixCls,
        expanded,
        expandable: hasNestChildren,
        record,
        onExpand: onInternalTriggerExpand
      }));
    }
    var additionalCellProps;
    if (column.onCell) {
      additionalCellProps = column.onCell(record, index2);
    }
    return /* @__PURE__ */ react.exports.createElement(WrappedCell, _extends$2({
      className: columnClassName,
      ellipsis: column.ellipsis,
      align: column.align,
      component: cellComponent,
      prefixCls,
      key: key2,
      record,
      index: index2,
      renderIndex,
      dataIndex,
      render: render2,
      shouldCellUpdate: column.shouldCellUpdate,
      expanded: appendCellNode && expanded
    }, fixedInfo, {
      appendNode: appendCellNode,
      additionalProps: additionalCellProps
    }));
  }));
  var expandRowNode;
  if (rowSupportExpand && (expandRended || expanded)) {
    var expandContent = expandedRowRender(record, index2, indent + 1, expanded);
    var computedExpandedRowClassName = expandedRowClassName && expandedRowClassName(record, index2, indent);
    expandRowNode = /* @__PURE__ */ react.exports.createElement(ExpandedRow, {
      expanded,
      className: classNames("".concat(prefixCls, "-expanded-row"), "".concat(prefixCls, "-expanded-row-level-").concat(indent + 1), computedExpandedRowClassName),
      prefixCls,
      component: RowComponent,
      cellComponent,
      colSpan: flattenColumns.length,
      isEmpty: false
    }, expandContent);
  }
  return /* @__PURE__ */ react.exports.createElement(react.exports.Fragment, null, baseRowNode, expandRowNode);
}
BodyRow.displayName = "BodyRow";
function flatRecord(record, indent, childrenColumnName, expandedKeys, getRowKey, index2) {
  var arr = [];
  arr.push({
    record,
    indent,
    index: index2
  });
  var key2 = getRowKey(record);
  var expanded = expandedKeys === null || expandedKeys === void 0 ? void 0 : expandedKeys.has(key2);
  if (record && Array.isArray(record[childrenColumnName]) && expanded) {
    for (var i2 = 0; i2 < record[childrenColumnName].length; i2 += 1) {
      var tempArr = flatRecord(record[childrenColumnName][i2], indent + 1, childrenColumnName, expandedKeys, getRowKey, i2);
      arr.push.apply(arr, _toConsumableArray(tempArr));
    }
  }
  return arr;
}
function useFlattenRecords(data2, childrenColumnName, expandedKeys, getRowKey) {
  var arr = react.exports.useMemo(function() {
    if (expandedKeys === null || expandedKeys === void 0 ? void 0 : expandedKeys.size) {
      var temp = [];
      for (var i2 = 0; i2 < (data2 === null || data2 === void 0 ? void 0 : data2.length); i2 += 1) {
        var record = data2[i2];
        temp.push.apply(temp, _toConsumableArray(flatRecord(record, 0, childrenColumnName, expandedKeys, getRowKey, i2)));
      }
      return temp;
    }
    return data2 === null || data2 === void 0 ? void 0 : data2.map(function(item, index2) {
      return {
        record: item,
        indent: 0,
        index: index2
      };
    });
  }, [data2, childrenColumnName, expandedKeys, getRowKey]);
  return arr;
}
function MeasureCell(_ref) {
  var columnKey = _ref.columnKey, onColumnResize = _ref.onColumnResize;
  var cellRef = react.exports.useRef();
  react.exports.useEffect(function() {
    if (cellRef.current) {
      onColumnResize(columnKey, cellRef.current.offsetWidth);
    }
  }, []);
  return /* @__PURE__ */ react.exports.createElement(ResizeObserver$1, {
    data: columnKey
  }, /* @__PURE__ */ react.exports.createElement("td", {
    ref: cellRef,
    style: {
      padding: 0,
      border: 0,
      height: 0
    }
  }, /* @__PURE__ */ react.exports.createElement("div", {
    style: {
      height: 0,
      overflow: "hidden"
    }
  }, "\xA0")));
}
function MeasureRow(_ref) {
  var prefixCls = _ref.prefixCls, columnsKey = _ref.columnsKey, onColumnResize = _ref.onColumnResize;
  return /* @__PURE__ */ react.exports.createElement("tr", {
    "aria-hidden": "true",
    className: "".concat(prefixCls, "-measure-row"),
    style: {
      height: 0,
      fontSize: 0
    }
  }, /* @__PURE__ */ react.exports.createElement(ResizeObserver$1.Collection, {
    onBatchResize: function onBatchResize(infoList) {
      infoList.forEach(function(_ref2) {
        var columnKey = _ref2.data, size2 = _ref2.size;
        onColumnResize(columnKey, size2.offsetWidth);
      });
    }
  }, columnsKey.map(function(columnKey) {
    return /* @__PURE__ */ react.exports.createElement(MeasureCell, {
      key: columnKey,
      columnKey,
      onColumnResize
    });
  })));
}
function Body(_ref) {
  var data2 = _ref.data, getRowKey = _ref.getRowKey, measureColumnWidth = _ref.measureColumnWidth, expandedKeys = _ref.expandedKeys, onRow = _ref.onRow, rowExpandable = _ref.rowExpandable, emptyNode = _ref.emptyNode, childrenColumnName = _ref.childrenColumnName;
  var _React$useContext = react.exports.useContext(ResizeContext), onColumnResize = _React$useContext.onColumnResize;
  var _React$useContext2 = react.exports.useContext(TableContext), prefixCls = _React$useContext2.prefixCls, getComponent = _React$useContext2.getComponent;
  var _React$useContext3 = react.exports.useContext(BodyContext), flattenColumns = _React$useContext3.flattenColumns;
  var flattenData2 = useFlattenRecords(data2, childrenColumnName, expandedKeys, getRowKey);
  var perfRef = react.exports.useRef({
    renderWithProps: false
  });
  var _React$useState = react.exports.useState(-1), _React$useState2 = _slicedToArray$4(_React$useState, 2), startRow = _React$useState2[0], setStartRow = _React$useState2[1];
  var _React$useState3 = react.exports.useState(-1), _React$useState4 = _slicedToArray$4(_React$useState3, 2), endRow = _React$useState4[0], setEndRow = _React$useState4[1];
  var onHover = react.exports.useCallback(function(start, end) {
    setStartRow(start);
    setEndRow(end);
  }, []);
  var bodyNode = react.exports.useMemo(function() {
    var WrapperComponent = getComponent(["body", "wrapper"], "tbody");
    var trComponent = getComponent(["body", "row"], "tr");
    var tdComponent = getComponent(["body", "cell"], "td");
    var rows;
    if (data2.length) {
      rows = flattenData2.map(function(item, idx) {
        var record = item.record, indent = item.indent, renderIndex = item.index;
        var key2 = getRowKey(record, idx);
        return /* @__PURE__ */ react.exports.createElement(BodyRow, {
          key: key2,
          rowKey: key2,
          record,
          recordKey: key2,
          index: idx,
          renderIndex,
          rowComponent: trComponent,
          cellComponent: tdComponent,
          expandedKeys,
          onRow,
          getRowKey,
          rowExpandable,
          childrenColumnName,
          indent
        });
      });
    } else {
      rows = /* @__PURE__ */ react.exports.createElement(ExpandedRow, {
        expanded: true,
        className: "".concat(prefixCls, "-placeholder"),
        prefixCls,
        component: trComponent,
        cellComponent: tdComponent,
        colSpan: flattenColumns.length,
        isEmpty: true
      }, emptyNode);
    }
    var columnsKey = getColumnsKey(flattenColumns);
    return /* @__PURE__ */ react.exports.createElement(WrapperComponent, {
      className: "".concat(prefixCls, "-tbody")
    }, measureColumnWidth && /* @__PURE__ */ react.exports.createElement(MeasureRow, {
      prefixCls,
      columnsKey,
      onColumnResize
    }), rows);
  }, [data2, prefixCls, onRow, measureColumnWidth, expandedKeys, getRowKey, getComponent, emptyNode, flattenColumns, childrenColumnName, onColumnResize, rowExpandable, flattenData2]);
  return /* @__PURE__ */ react.exports.createElement(PerfContext.Provider, {
    value: perfRef.current
  }, /* @__PURE__ */ react.exports.createElement(HoverContext.Provider, {
    value: {
      startRow,
      endRow,
      onHover
    }
  }, bodyNode));
}
var MemoBody = /* @__PURE__ */ react.exports.memo(Body);
MemoBody.displayName = "Body";
var _excluded$6 = ["expandable"];
var INTERNAL_COL_DEFINE = "RC_TABLE_INTERNAL_COL_DEFINE";
function getExpandableProps(props) {
  var expandable = props.expandable, legacyExpandableConfig = _objectWithoutProperties$1(props, _excluded$6);
  var config;
  if ("expandable" in props) {
    config = _objectSpread2$1(_objectSpread2$1({}, legacyExpandableConfig), expandable);
  } else {
    config = legacyExpandableConfig;
  }
  if (config.showExpandColumn === false) {
    config.expandIconColumnIndex = -1;
  }
  return config;
}
var EXPAND_COLUMN = {};
var _excluded$5 = ["children"], _excluded2 = ["fixed"];
function convertChildrenToColumns(children) {
  return toArray$5(children).filter(function(node) {
    return /* @__PURE__ */ react.exports.isValidElement(node);
  }).map(function(_ref) {
    var key2 = _ref.key, props = _ref.props;
    var nodeChildren = props.children, restProps = _objectWithoutProperties$1(props, _excluded$5);
    var column = _objectSpread2$1({
      key: key2
    }, restProps);
    if (nodeChildren) {
      column.children = convertChildrenToColumns(nodeChildren);
    }
    return column;
  });
}
function flatColumns(columns2) {
  return columns2.reduce(function(list, column) {
    var fixed = column.fixed;
    var parsedFixed = fixed === true ? "left" : fixed;
    var subColumns = column.children;
    if (subColumns && subColumns.length > 0) {
      return [].concat(_toConsumableArray(list), _toConsumableArray(flatColumns(subColumns).map(function(subColum) {
        return _objectSpread2$1({
          fixed: parsedFixed
        }, subColum);
      })));
    }
    return [].concat(_toConsumableArray(list), [_objectSpread2$1(_objectSpread2$1({}, column), {}, {
      fixed: parsedFixed
    })]);
  }, []);
}
function revertForRtl(columns2) {
  return columns2.map(function(column) {
    var fixed = column.fixed, restProps = _objectWithoutProperties$1(column, _excluded2);
    var parsedFixed = fixed;
    if (fixed === "left") {
      parsedFixed = "right";
    } else if (fixed === "right") {
      parsedFixed = "left";
    }
    return _objectSpread2$1({
      fixed: parsedFixed
    }, restProps);
  });
}
function useColumns(_ref2, transformColumns) {
  var prefixCls = _ref2.prefixCls, columns2 = _ref2.columns, children = _ref2.children, expandable = _ref2.expandable, expandedKeys = _ref2.expandedKeys, columnTitle = _ref2.columnTitle, getRowKey = _ref2.getRowKey, onTriggerExpand = _ref2.onTriggerExpand, expandIcon = _ref2.expandIcon, rowExpandable = _ref2.rowExpandable, expandIconColumnIndex = _ref2.expandIconColumnIndex, direction2 = _ref2.direction, expandRowByClick = _ref2.expandRowByClick, columnWidth = _ref2.columnWidth, fixed = _ref2.fixed;
  var baseColumns = react.exports.useMemo(function() {
    return columns2 || convertChildrenToColumns(children);
  }, [columns2, children]);
  var withExpandColumns = react.exports.useMemo(function() {
    if (expandable) {
      var _expandColumn;
      var cloneColumns = baseColumns.slice();
      if (!cloneColumns.includes(EXPAND_COLUMN)) {
        var expandColIndex = expandIconColumnIndex || 0;
        if (expandColIndex >= 0) {
          cloneColumns.splice(expandColIndex, 0, EXPAND_COLUMN);
        }
      }
      var expandColumnIndex = cloneColumns.indexOf(EXPAND_COLUMN);
      cloneColumns = cloneColumns.filter(function(column, index2) {
        return column !== EXPAND_COLUMN || index2 === expandColumnIndex;
      });
      var prevColumn = baseColumns[expandColumnIndex];
      var fixedColumn;
      if ((fixed === "left" || fixed) && !expandIconColumnIndex) {
        fixedColumn = "left";
      } else if ((fixed === "right" || fixed) && expandIconColumnIndex === baseColumns.length) {
        fixedColumn = "right";
      } else {
        fixedColumn = prevColumn ? prevColumn.fixed : null;
      }
      var expandColumn = (_expandColumn = {}, _defineProperty$4(_expandColumn, INTERNAL_COL_DEFINE, {
        className: "".concat(prefixCls, "-expand-icon-col"),
        columnType: "EXPAND_COLUMN"
      }), _defineProperty$4(_expandColumn, "title", columnTitle), _defineProperty$4(_expandColumn, "fixed", fixedColumn), _defineProperty$4(_expandColumn, "className", "".concat(prefixCls, "-row-expand-icon-cell")), _defineProperty$4(_expandColumn, "width", columnWidth), _defineProperty$4(_expandColumn, "render", function render2(_2, record, index2) {
        var rowKey = getRowKey(record, index2);
        var expanded = expandedKeys.has(rowKey);
        var recordExpandable = rowExpandable ? rowExpandable(record) : true;
        var icon = expandIcon({
          prefixCls,
          expanded,
          expandable: recordExpandable,
          record,
          onExpand: onTriggerExpand
        });
        if (expandRowByClick) {
          return /* @__PURE__ */ react.exports.createElement("span", {
            onClick: function onClick(e3) {
              return e3.stopPropagation();
            }
          }, icon);
        }
        return icon;
      }), _expandColumn);
      return cloneColumns.map(function(col) {
        return col === EXPAND_COLUMN ? expandColumn : col;
      });
    }
    return baseColumns.filter(function(col) {
      return col !== EXPAND_COLUMN;
    });
  }, [expandable, baseColumns, getRowKey, expandedKeys, expandIcon, direction2]);
  var mergedColumns = react.exports.useMemo(function() {
    var finalColumns = withExpandColumns;
    if (transformColumns) {
      finalColumns = transformColumns(finalColumns);
    }
    if (!finalColumns.length) {
      finalColumns = [{
        render: function render2() {
          return null;
        }
      }];
    }
    return finalColumns;
  }, [transformColumns, withExpandColumns, direction2]);
  var flattenColumns = react.exports.useMemo(function() {
    if (direction2 === "rtl") {
      return revertForRtl(flatColumns(mergedColumns));
    }
    return flatColumns(mergedColumns);
  }, [mergedColumns, direction2]);
  return [mergedColumns, flattenColumns];
}
function useLayoutState(defaultState) {
  var stateRef = react.exports.useRef(defaultState);
  var _useState = react.exports.useState({}), _useState2 = _slicedToArray$4(_useState, 2), forceUpdate = _useState2[1];
  var lastPromiseRef = react.exports.useRef(null);
  var updateBatchRef = react.exports.useRef([]);
  function setFrameState(updater) {
    updateBatchRef.current.push(updater);
    var promise = Promise.resolve();
    lastPromiseRef.current = promise;
    promise.then(function() {
      if (lastPromiseRef.current === promise) {
        var prevBatch = updateBatchRef.current;
        var prevState = stateRef.current;
        updateBatchRef.current = [];
        prevBatch.forEach(function(batchUpdater) {
          stateRef.current = batchUpdater(stateRef.current);
        });
        lastPromiseRef.current = null;
        if (prevState !== stateRef.current) {
          forceUpdate({});
        }
      }
    });
  }
  react.exports.useEffect(function() {
    return function() {
      lastPromiseRef.current = null;
    };
  }, []);
  return [stateRef.current, setFrameState];
}
function useTimeoutLock(defaultState) {
  var frameRef = react.exports.useRef(defaultState || null);
  var timeoutRef = react.exports.useRef();
  function cleanUp() {
    window.clearTimeout(timeoutRef.current);
  }
  function setState(newState) {
    frameRef.current = newState;
    cleanUp();
    timeoutRef.current = window.setTimeout(function() {
      frameRef.current = null;
      timeoutRef.current = void 0;
    }, 100);
  }
  function getState() {
    return frameRef.current;
  }
  react.exports.useEffect(function() {
    return cleanUp;
  }, []);
  return [setState, getState];
}
function useStickyOffsets(colWidths, columnCount, direction2) {
  var stickyOffsets = react.exports.useMemo(function() {
    var leftOffsets = [];
    var rightOffsets = [];
    var left2 = 0;
    var right2 = 0;
    for (var start = 0; start < columnCount; start += 1) {
      if (direction2 === "rtl") {
        rightOffsets[start] = right2;
        right2 += colWidths[start] || 0;
        var end = columnCount - start - 1;
        leftOffsets[end] = left2;
        left2 += colWidths[end] || 0;
      } else {
        leftOffsets[start] = left2;
        left2 += colWidths[start] || 0;
        var _end = columnCount - start - 1;
        rightOffsets[_end] = right2;
        right2 += colWidths[_end] || 0;
      }
    }
    return {
      left: leftOffsets,
      right: rightOffsets
    };
  }, [colWidths, columnCount, direction2]);
  return stickyOffsets;
}
var _excluded$4 = ["columnType"];
function ColGroup(_ref) {
  var colWidths = _ref.colWidths, columns2 = _ref.columns, columCount = _ref.columCount;
  var cols = [];
  var len = columCount || columns2.length;
  var mustInsert = false;
  for (var i2 = len - 1; i2 >= 0; i2 -= 1) {
    var width = colWidths[i2];
    var column = columns2 && columns2[i2];
    var additionalProps = column && column[INTERNAL_COL_DEFINE];
    if (width || additionalProps || mustInsert) {
      var _ref2 = additionalProps || {};
      _ref2.columnType;
      var restAdditionalProps = _objectWithoutProperties$1(_ref2, _excluded$4);
      cols.unshift(/* @__PURE__ */ react.exports.createElement("col", _extends$2({
        key: i2,
        style: {
          width
        }
      }, restAdditionalProps)));
      mustInsert = true;
    }
  }
  return /* @__PURE__ */ react.exports.createElement("colgroup", null, cols);
}
function Panel(_ref) {
  var className = _ref.className, children = _ref.children;
  return /* @__PURE__ */ react.exports.createElement("div", {
    className
  }, children);
}
var SummaryContext = /* @__PURE__ */ react.exports.createContext({});
function SummaryCell(_ref) {
  var className = _ref.className, index2 = _ref.index, children = _ref.children, _ref$colSpan = _ref.colSpan, colSpan = _ref$colSpan === void 0 ? 1 : _ref$colSpan, rowSpan = _ref.rowSpan, align = _ref.align;
  var _React$useContext = react.exports.useContext(TableContext), prefixCls = _React$useContext.prefixCls, direction2 = _React$useContext.direction;
  var _React$useContext2 = react.exports.useContext(SummaryContext), scrollColumnIndex = _React$useContext2.scrollColumnIndex, stickyOffsets = _React$useContext2.stickyOffsets, flattenColumns = _React$useContext2.flattenColumns;
  var lastIndex = index2 + colSpan - 1;
  var mergedColSpan = lastIndex + 1 === scrollColumnIndex ? colSpan + 1 : colSpan;
  var fixedInfo = getCellFixedInfo(index2, index2 + mergedColSpan - 1, flattenColumns, stickyOffsets, direction2);
  return /* @__PURE__ */ react.exports.createElement(WrappedCell, _extends$2({
    className,
    index: index2,
    component: "td",
    prefixCls,
    record: null,
    dataIndex: null,
    align,
    colSpan: mergedColSpan,
    rowSpan,
    render: function render2() {
      return children;
    }
  }, fixedInfo));
}
var _excluded$3 = ["children"];
function FooterRow(_ref) {
  var children = _ref.children, props = _objectWithoutProperties$1(_ref, _excluded$3);
  return /* @__PURE__ */ react.exports.createElement("tr", props, children);
}
function Summary(_ref) {
  var children = _ref.children;
  return children;
}
Summary.Row = FooterRow;
Summary.Cell = SummaryCell;
function Footer(_ref) {
  var children = _ref.children, stickyOffsets = _ref.stickyOffsets, flattenColumns = _ref.flattenColumns;
  var tableContext = react.exports.useContext(TableContext);
  var prefixCls = tableContext.prefixCls;
  var lastColumnIndex = flattenColumns.length - 1;
  var scrollColumn = flattenColumns[lastColumnIndex];
  var summaryContext = react.exports.useMemo(function() {
    return {
      stickyOffsets,
      flattenColumns,
      scrollColumnIndex: (scrollColumn === null || scrollColumn === void 0 ? void 0 : scrollColumn.scrollbar) ? lastColumnIndex : null
    };
  }, [scrollColumn, flattenColumns, lastColumnIndex, stickyOffsets]);
  return /* @__PURE__ */ react.exports.createElement(SummaryContext.Provider, {
    value: summaryContext
  }, /* @__PURE__ */ react.exports.createElement("tfoot", {
    className: "".concat(prefixCls, "-summary")
  }, children));
}
var FooterComponents = Summary;
function renderExpandIcon$1(_ref) {
  var _classNames;
  var prefixCls = _ref.prefixCls, record = _ref.record, onExpand = _ref.onExpand, expanded = _ref.expanded, expandable = _ref.expandable;
  var expandClassName = "".concat(prefixCls, "-row-expand-icon");
  if (!expandable) {
    return /* @__PURE__ */ react.exports.createElement("span", {
      className: classNames(expandClassName, "".concat(prefixCls, "-row-spaced"))
    });
  }
  var onClick = function onClick2(event) {
    onExpand(record, event);
    event.stopPropagation();
  };
  return /* @__PURE__ */ react.exports.createElement("span", {
    className: classNames(expandClassName, (_classNames = {}, _defineProperty$4(_classNames, "".concat(prefixCls, "-row-expanded"), expanded), _defineProperty$4(_classNames, "".concat(prefixCls, "-row-collapsed"), !expanded), _classNames)),
    onClick
  });
}
function findAllChildrenKeys(data2, getRowKey, childrenColumnName) {
  var keys2 = [];
  function dig(list) {
    (list || []).forEach(function(item, index2) {
      keys2.push(getRowKey(item, index2));
      dig(item[childrenColumnName]);
    });
  }
  dig(data2);
  return keys2;
}
var StickyScrollBar = function StickyScrollBar2(_ref, ref) {
  var _scrollBodyRef$curren, _scrollBodyRef$curren2;
  var scrollBodyRef = _ref.scrollBodyRef, onScroll = _ref.onScroll, offsetScroll = _ref.offsetScroll, container = _ref.container;
  var _React$useContext = react.exports.useContext(TableContext), prefixCls = _React$useContext.prefixCls;
  var bodyScrollWidth = ((_scrollBodyRef$curren = scrollBodyRef.current) === null || _scrollBodyRef$curren === void 0 ? void 0 : _scrollBodyRef$curren.scrollWidth) || 0;
  var bodyWidth = ((_scrollBodyRef$curren2 = scrollBodyRef.current) === null || _scrollBodyRef$curren2 === void 0 ? void 0 : _scrollBodyRef$curren2.clientWidth) || 0;
  var scrollBarWidth = bodyScrollWidth && bodyWidth * (bodyWidth / bodyScrollWidth);
  var scrollBarRef = react.exports.useRef();
  var _useLayoutState = useLayoutState({
    scrollLeft: 0,
    isHiddenScrollBar: false
  }), _useLayoutState2 = _slicedToArray$4(_useLayoutState, 2), scrollState = _useLayoutState2[0], setScrollState = _useLayoutState2[1];
  var refState = react.exports.useRef({
    delta: 0,
    x: 0
  });
  var _React$useState = react.exports.useState(false), _React$useState2 = _slicedToArray$4(_React$useState, 2), isActive2 = _React$useState2[0], setActive = _React$useState2[1];
  var onMouseUp = function onMouseUp2() {
    setActive(false);
  };
  var onMouseDown = function onMouseDown2(event) {
    event.persist();
    refState.current.delta = event.pageX - scrollState.scrollLeft;
    refState.current.x = 0;
    setActive(true);
    event.preventDefault();
  };
  var onMouseMove = function onMouseMove2(event) {
    var _window;
    var _ref2 = event || ((_window = window) === null || _window === void 0 ? void 0 : _window.event), buttons = _ref2.buttons;
    if (!isActive2 || buttons === 0) {
      if (isActive2) {
        setActive(false);
      }
      return;
    }
    var left2 = refState.current.x + event.pageX - refState.current.x - refState.current.delta;
    if (left2 <= 0) {
      left2 = 0;
    }
    if (left2 + scrollBarWidth >= bodyWidth) {
      left2 = bodyWidth - scrollBarWidth;
    }
    onScroll({
      scrollLeft: left2 / bodyWidth * (bodyScrollWidth + 2)
    });
    refState.current.x = event.pageX;
  };
  var onContainerScroll = function onContainerScroll2() {
    if (!scrollBodyRef.current) {
      return;
    }
    var tableOffsetTop = getOffset(scrollBodyRef.current).top;
    var tableBottomOffset = tableOffsetTop + scrollBodyRef.current.offsetHeight;
    var currentClientOffset = container === window ? document.documentElement.scrollTop + window.innerHeight : getOffset(container).top + container.clientHeight;
    if (tableBottomOffset - getScrollBarSize() <= currentClientOffset || tableOffsetTop >= currentClientOffset - offsetScroll) {
      setScrollState(function(state2) {
        return _objectSpread2$1(_objectSpread2$1({}, state2), {}, {
          isHiddenScrollBar: true
        });
      });
    } else {
      setScrollState(function(state2) {
        return _objectSpread2$1(_objectSpread2$1({}, state2), {}, {
          isHiddenScrollBar: false
        });
      });
    }
  };
  var setScrollLeft = function setScrollLeft2(left2) {
    setScrollState(function(state2) {
      return _objectSpread2$1(_objectSpread2$1({}, state2), {}, {
        scrollLeft: left2 / bodyScrollWidth * bodyWidth || 0
      });
    });
  };
  react.exports.useImperativeHandle(ref, function() {
    return {
      setScrollLeft
    };
  });
  react.exports.useEffect(function() {
    var onMouseUpListener = addEventListenerWrap(document.body, "mouseup", onMouseUp, false);
    var onMouseMoveListener = addEventListenerWrap(document.body, "mousemove", onMouseMove, false);
    onContainerScroll();
    return function() {
      onMouseUpListener.remove();
      onMouseMoveListener.remove();
    };
  }, [scrollBarWidth, isActive2]);
  react.exports.useEffect(function() {
    var onScrollListener = addEventListenerWrap(container, "scroll", onContainerScroll, false);
    var onResizeListener = addEventListenerWrap(window, "resize", onContainerScroll, false);
    return function() {
      onScrollListener.remove();
      onResizeListener.remove();
    };
  }, [container]);
  react.exports.useEffect(function() {
    if (!scrollState.isHiddenScrollBar) {
      setScrollState(function(state2) {
        var bodyNode = scrollBodyRef.current;
        if (!bodyNode) {
          return state2;
        }
        return _objectSpread2$1(_objectSpread2$1({}, state2), {}, {
          scrollLeft: bodyNode.scrollLeft / bodyNode.scrollWidth * bodyNode.clientWidth
        });
      });
    }
  }, [scrollState.isHiddenScrollBar]);
  if (bodyScrollWidth <= bodyWidth || !scrollBarWidth || scrollState.isHiddenScrollBar) {
    return null;
  }
  return /* @__PURE__ */ react.exports.createElement("div", {
    style: {
      height: getScrollBarSize(),
      width: bodyWidth,
      bottom: offsetScroll
    },
    className: "".concat(prefixCls, "-sticky-scroll")
  }, /* @__PURE__ */ react.exports.createElement("div", {
    onMouseDown,
    ref: scrollBarRef,
    className: classNames("".concat(prefixCls, "-sticky-scroll-bar"), _defineProperty$4({}, "".concat(prefixCls, "-sticky-scroll-bar-active"), isActive2)),
    style: {
      width: "".concat(scrollBarWidth, "px"),
      transform: "translate3d(".concat(scrollState.scrollLeft, "px, 0, 0)")
    }
  }));
};
var StickyScrollBar$1 = /* @__PURE__ */ react.exports.forwardRef(StickyScrollBar);
var defaultContainer = canUseDom() ? window : null;
function useSticky(sticky, prefixCls) {
  var _ref = _typeof$4(sticky) === "object" ? sticky : {}, _ref$offsetHeader = _ref.offsetHeader, offsetHeader = _ref$offsetHeader === void 0 ? 0 : _ref$offsetHeader, _ref$offsetSummary = _ref.offsetSummary, offsetSummary = _ref$offsetSummary === void 0 ? 0 : _ref$offsetSummary, _ref$offsetScroll = _ref.offsetScroll, offsetScroll = _ref$offsetScroll === void 0 ? 0 : _ref$offsetScroll, _ref$getContainer = _ref.getContainer, getContainer2 = _ref$getContainer === void 0 ? function() {
    return defaultContainer;
  } : _ref$getContainer;
  var container = getContainer2() || defaultContainer;
  return react.exports.useMemo(function() {
    var isSticky = !!sticky;
    return {
      isSticky,
      stickyClassName: isSticky ? "".concat(prefixCls, "-sticky-holder") : "",
      offsetHeader,
      offsetSummary,
      offsetScroll,
      container
    };
  }, [offsetScroll, offsetHeader, offsetSummary, prefixCls, container]);
}
var _excluded$2 = ["className", "noData", "columns", "flattenColumns", "colWidths", "columCount", "stickyOffsets", "direction", "fixHeader", "stickyTopOffset", "stickyBottomOffset", "stickyClassName", "onScroll", "maxContentScroll", "children"];
function useColumnWidth(colWidths, columCount) {
  return react.exports.useMemo(function() {
    var cloneColumns = [];
    for (var i2 = 0; i2 < columCount; i2 += 1) {
      var val = colWidths[i2];
      if (val !== void 0) {
        cloneColumns[i2] = val;
      } else {
        return null;
      }
    }
    return cloneColumns;
  }, [colWidths.join("_"), columCount]);
}
var FixedHolder = /* @__PURE__ */ react.exports.forwardRef(function(_ref, ref) {
  var className = _ref.className, noData = _ref.noData, columns2 = _ref.columns, flattenColumns = _ref.flattenColumns, colWidths = _ref.colWidths, columCount = _ref.columCount, stickyOffsets = _ref.stickyOffsets, direction2 = _ref.direction, fixHeader = _ref.fixHeader, stickyTopOffset = _ref.stickyTopOffset, stickyBottomOffset = _ref.stickyBottomOffset, stickyClassName = _ref.stickyClassName, onScroll = _ref.onScroll, maxContentScroll = _ref.maxContentScroll, children = _ref.children, props = _objectWithoutProperties$1(_ref, _excluded$2);
  var _React$useContext = react.exports.useContext(TableContext), prefixCls = _React$useContext.prefixCls, scrollbarSize = _React$useContext.scrollbarSize, isSticky = _React$useContext.isSticky;
  var combinationScrollBarSize = isSticky && !fixHeader ? 0 : scrollbarSize;
  var scrollRef = react.exports.useRef(null);
  var setScrollRef = react.exports.useCallback(function(element) {
    fillRef(ref, element);
    fillRef(scrollRef, element);
  }, []);
  react.exports.useEffect(function() {
    var _scrollRef$current;
    function onWheel(e3) {
      var currentTarget = e3.currentTarget, deltaX = e3.deltaX;
      if (deltaX) {
        onScroll({
          currentTarget,
          scrollLeft: currentTarget.scrollLeft + deltaX
        });
        e3.preventDefault();
      }
    }
    (_scrollRef$current = scrollRef.current) === null || _scrollRef$current === void 0 ? void 0 : _scrollRef$current.addEventListener("wheel", onWheel);
    return function() {
      var _scrollRef$current2;
      (_scrollRef$current2 = scrollRef.current) === null || _scrollRef$current2 === void 0 ? void 0 : _scrollRef$current2.removeEventListener("wheel", onWheel);
    };
  }, []);
  var allFlattenColumnsWithWidth = react.exports.useMemo(function() {
    return flattenColumns.every(function(column) {
      return column.width >= 0;
    });
  }, [flattenColumns]);
  var lastColumn = flattenColumns[flattenColumns.length - 1];
  var ScrollBarColumn = {
    fixed: lastColumn ? lastColumn.fixed : null,
    scrollbar: true,
    onHeaderCell: function onHeaderCell() {
      return {
        className: "".concat(prefixCls, "-cell-scrollbar")
      };
    }
  };
  var columnsWithScrollbar = react.exports.useMemo(function() {
    return combinationScrollBarSize ? [].concat(_toConsumableArray(columns2), [ScrollBarColumn]) : columns2;
  }, [combinationScrollBarSize, columns2]);
  var flattenColumnsWithScrollbar = react.exports.useMemo(function() {
    return combinationScrollBarSize ? [].concat(_toConsumableArray(flattenColumns), [ScrollBarColumn]) : flattenColumns;
  }, [combinationScrollBarSize, flattenColumns]);
  var headerStickyOffsets = react.exports.useMemo(function() {
    var right2 = stickyOffsets.right, left2 = stickyOffsets.left;
    return _objectSpread2$1(_objectSpread2$1({}, stickyOffsets), {}, {
      left: direction2 === "rtl" ? [].concat(_toConsumableArray(left2.map(function(width) {
        return width + combinationScrollBarSize;
      })), [0]) : left2,
      right: direction2 === "rtl" ? right2 : [].concat(_toConsumableArray(right2.map(function(width) {
        return width + combinationScrollBarSize;
      })), [0]),
      isSticky
    });
  }, [combinationScrollBarSize, stickyOffsets, isSticky]);
  var mergedColumnWidth = useColumnWidth(colWidths, columCount);
  return /* @__PURE__ */ react.exports.createElement("div", {
    style: _objectSpread2$1({
      overflow: "hidden"
    }, isSticky ? {
      top: stickyTopOffset,
      bottom: stickyBottomOffset
    } : {}),
    ref: setScrollRef,
    className: classNames(className, _defineProperty$4({}, stickyClassName, !!stickyClassName))
  }, /* @__PURE__ */ react.exports.createElement("table", {
    style: {
      tableLayout: "fixed",
      visibility: noData || mergedColumnWidth ? null : "hidden"
    }
  }, (!noData || !maxContentScroll || allFlattenColumnsWithWidth) && /* @__PURE__ */ react.exports.createElement(ColGroup, {
    colWidths: mergedColumnWidth ? [].concat(_toConsumableArray(mergedColumnWidth), [combinationScrollBarSize]) : [],
    columCount: columCount + 1,
    columns: flattenColumnsWithScrollbar
  }), children(_objectSpread2$1(_objectSpread2$1({}, props), {}, {
    stickyOffsets: headerStickyOffsets,
    columns: columnsWithScrollbar,
    flattenColumns: flattenColumnsWithScrollbar
  }))));
});
FixedHolder.displayName = "FixedHolder";
var EMPTY_DATA = [];
var EMPTY_SCROLL_TARGET = {};
var INTERNAL_HOOKS = "rc-table-internal-hook";
var MemoTableContent = /* @__PURE__ */ react.exports.memo(function(_ref) {
  var children = _ref.children;
  return children;
}, function(prev, next) {
  if (!shallowequal(prev.props, next.props)) {
    return false;
  }
  return prev.pingLeft !== next.pingLeft || prev.pingRight !== next.pingRight;
});
function Table$2(props) {
  var _classNames;
  var prefixCls = props.prefixCls, className = props.className, rowClassName = props.rowClassName, style2 = props.style, data2 = props.data, rowKey = props.rowKey, scroll = props.scroll, tableLayout = props.tableLayout, direction2 = props.direction, title = props.title, footer = props.footer, summary = props.summary, id2 = props.id, showHeader = props.showHeader, components = props.components, emptyText2 = props.emptyText, onRow = props.onRow, onHeaderRow = props.onHeaderRow, internalHooks = props.internalHooks, transformColumns = props.transformColumns, internalRefs = props.internalRefs, sticky = props.sticky;
  var mergedData = data2 || EMPTY_DATA;
  var hasData = !!mergedData.length;
  var getComponent = react.exports.useCallback(function(path2, defaultComponent) {
    return getPathValue(components || {}, path2) || defaultComponent;
  }, [components]);
  var getRowKey = react.exports.useMemo(function() {
    if (typeof rowKey === "function") {
      return rowKey;
    }
    return function(record) {
      var key2 = record && record[rowKey];
      return key2;
    };
  }, [rowKey]);
  var expandableConfig = getExpandableProps(props);
  var expandIcon = expandableConfig.expandIcon, expandedRowKeys = expandableConfig.expandedRowKeys, defaultExpandedRowKeys = expandableConfig.defaultExpandedRowKeys, defaultExpandAllRows = expandableConfig.defaultExpandAllRows, expandedRowRender = expandableConfig.expandedRowRender, columnTitle = expandableConfig.columnTitle, onExpand = expandableConfig.onExpand, onExpandedRowsChange = expandableConfig.onExpandedRowsChange, expandRowByClick = expandableConfig.expandRowByClick, rowExpandable = expandableConfig.rowExpandable, expandIconColumnIndex = expandableConfig.expandIconColumnIndex, expandedRowClassName = expandableConfig.expandedRowClassName, childrenColumnName = expandableConfig.childrenColumnName, indentSize = expandableConfig.indentSize;
  var mergedExpandIcon = expandIcon || renderExpandIcon$1;
  var mergedChildrenColumnName = childrenColumnName || "children";
  var expandableType = react.exports.useMemo(function() {
    if (expandedRowRender) {
      return "row";
    }
    if (props.expandable && internalHooks === INTERNAL_HOOKS && props.expandable.__PARENT_RENDER_ICON__ || mergedData.some(function(record) {
      return record && _typeof$4(record) === "object" && record[mergedChildrenColumnName];
    })) {
      return "nest";
    }
    return false;
  }, [!!expandedRowRender, mergedData]);
  var _React$useState = react.exports.useState(function() {
    if (defaultExpandedRowKeys) {
      return defaultExpandedRowKeys;
    }
    if (defaultExpandAllRows) {
      return findAllChildrenKeys(mergedData, getRowKey, mergedChildrenColumnName);
    }
    return [];
  }), _React$useState2 = _slicedToArray$4(_React$useState, 2), innerExpandedKeys = _React$useState2[0], setInnerExpandedKeys = _React$useState2[1];
  var mergedExpandedKeys = react.exports.useMemo(function() {
    return new Set(expandedRowKeys || innerExpandedKeys || []);
  }, [expandedRowKeys, innerExpandedKeys]);
  var onTriggerExpand = react.exports.useCallback(function(record) {
    var key2 = getRowKey(record, mergedData.indexOf(record));
    var newExpandedKeys;
    var hasKey = mergedExpandedKeys.has(key2);
    if (hasKey) {
      mergedExpandedKeys.delete(key2);
      newExpandedKeys = _toConsumableArray(mergedExpandedKeys);
    } else {
      newExpandedKeys = [].concat(_toConsumableArray(mergedExpandedKeys), [key2]);
    }
    setInnerExpandedKeys(newExpandedKeys);
    if (onExpand) {
      onExpand(!hasKey, record);
    }
    if (onExpandedRowsChange) {
      onExpandedRowsChange(newExpandedKeys);
    }
  }, [getRowKey, mergedExpandedKeys, mergedData, onExpand, onExpandedRowsChange]);
  var _React$useState3 = react.exports.useState(0), _React$useState4 = _slicedToArray$4(_React$useState3, 2), componentWidth = _React$useState4[0], setComponentWidth = _React$useState4[1];
  var _useColumns = useColumns(_objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, props), expandableConfig), {}, {
    expandable: !!expandedRowRender,
    columnTitle,
    expandedKeys: mergedExpandedKeys,
    getRowKey,
    onTriggerExpand,
    expandIcon: mergedExpandIcon,
    expandIconColumnIndex,
    direction: direction2
  }), internalHooks === INTERNAL_HOOKS ? transformColumns : null), _useColumns2 = _slicedToArray$4(_useColumns, 2), columns2 = _useColumns2[0], flattenColumns = _useColumns2[1];
  var columnContext = react.exports.useMemo(function() {
    return {
      columns: columns2,
      flattenColumns
    };
  }, [columns2, flattenColumns]);
  var fullTableRef = react.exports.useRef();
  var scrollHeaderRef = react.exports.useRef();
  var scrollBodyRef = react.exports.useRef();
  var scrollBodyContainerRef = react.exports.useRef();
  var scrollSummaryRef = react.exports.useRef();
  var _React$useState5 = react.exports.useState(false), _React$useState6 = _slicedToArray$4(_React$useState5, 2), pingedLeft = _React$useState6[0], setPingedLeft = _React$useState6[1];
  var _React$useState7 = react.exports.useState(false), _React$useState8 = _slicedToArray$4(_React$useState7, 2), pingedRight = _React$useState8[0], setPingedRight = _React$useState8[1];
  var _useLayoutState = useLayoutState(/* @__PURE__ */ new Map()), _useLayoutState2 = _slicedToArray$4(_useLayoutState, 2), colsWidths = _useLayoutState2[0], updateColsWidths = _useLayoutState2[1];
  var colsKeys = getColumnsKey(flattenColumns);
  var pureColWidths = colsKeys.map(function(columnKey) {
    return colsWidths.get(columnKey);
  });
  var colWidths = react.exports.useMemo(function() {
    return pureColWidths;
  }, [pureColWidths.join("_")]);
  var stickyOffsets = useStickyOffsets(colWidths, flattenColumns.length, direction2);
  var fixHeader = scroll && validateValue(scroll.y);
  var horizonScroll = scroll && validateValue(scroll.x) || Boolean(expandableConfig.fixed);
  var fixColumn = horizonScroll && flattenColumns.some(function(_ref2) {
    var fixed = _ref2.fixed;
    return fixed;
  });
  var stickyRef = react.exports.useRef();
  var _useSticky = useSticky(sticky, prefixCls), isSticky = _useSticky.isSticky, offsetHeader = _useSticky.offsetHeader, offsetSummary = _useSticky.offsetSummary, offsetScroll = _useSticky.offsetScroll, stickyClassName = _useSticky.stickyClassName, container = _useSticky.container;
  var summaryNode = summary === null || summary === void 0 ? void 0 : summary(mergedData);
  var fixFooter = (fixHeader || isSticky) && /* @__PURE__ */ react.exports.isValidElement(summaryNode) && summaryNode.type === Summary && summaryNode.props.fixed;
  var scrollXStyle;
  var scrollYStyle;
  var scrollTableStyle;
  if (fixHeader) {
    scrollYStyle = {
      overflowY: "scroll",
      maxHeight: scroll.y
    };
  }
  if (horizonScroll) {
    scrollXStyle = {
      overflowX: "auto"
    };
    if (!fixHeader) {
      scrollYStyle = {
        overflowY: "hidden"
      };
    }
    scrollTableStyle = {
      width: (scroll === null || scroll === void 0 ? void 0 : scroll.x) === true ? "auto" : scroll === null || scroll === void 0 ? void 0 : scroll.x,
      minWidth: "100%"
    };
  }
  var onColumnResize = react.exports.useCallback(function(columnKey, width) {
    if (isVisible(fullTableRef.current)) {
      updateColsWidths(function(widths) {
        if (widths.get(columnKey) !== width) {
          var newWidths = new Map(widths);
          newWidths.set(columnKey, width);
          return newWidths;
        }
        return widths;
      });
    }
  }, []);
  var _useTimeoutLock = useTimeoutLock(null), _useTimeoutLock2 = _slicedToArray$4(_useTimeoutLock, 2), setScrollTarget = _useTimeoutLock2[0], getScrollTarget = _useTimeoutLock2[1];
  function forceScroll(scrollLeft, target) {
    if (!target) {
      return;
    }
    if (typeof target === "function") {
      target(scrollLeft);
    } else if (target.scrollLeft !== scrollLeft) {
      target.scrollLeft = scrollLeft;
    }
  }
  var onScroll = function onScroll2(_ref3) {
    var currentTarget = _ref3.currentTarget, scrollLeft = _ref3.scrollLeft;
    var isRTL = direction2 === "rtl";
    var mergedScrollLeft = typeof scrollLeft === "number" ? scrollLeft : currentTarget.scrollLeft;
    var compareTarget = currentTarget || EMPTY_SCROLL_TARGET;
    if (!getScrollTarget() || getScrollTarget() === compareTarget) {
      var _stickyRef$current;
      setScrollTarget(compareTarget);
      forceScroll(mergedScrollLeft, scrollHeaderRef.current);
      forceScroll(mergedScrollLeft, scrollBodyRef.current);
      forceScroll(mergedScrollLeft, scrollSummaryRef.current);
      forceScroll(mergedScrollLeft, (_stickyRef$current = stickyRef.current) === null || _stickyRef$current === void 0 ? void 0 : _stickyRef$current.setScrollLeft);
    }
    if (currentTarget) {
      var scrollWidth = currentTarget.scrollWidth, clientWidth = currentTarget.clientWidth;
      if (scrollWidth === clientWidth) {
        setPingedLeft(false);
        setPingedRight(false);
        return;
      }
      if (isRTL) {
        setPingedLeft(-mergedScrollLeft < scrollWidth - clientWidth);
        setPingedRight(-mergedScrollLeft > 0);
      } else {
        setPingedLeft(mergedScrollLeft > 0);
        setPingedRight(mergedScrollLeft < scrollWidth - clientWidth);
      }
    }
  };
  var triggerOnScroll = function triggerOnScroll2() {
    if (horizonScroll && scrollBodyRef.current) {
      onScroll({
        currentTarget: scrollBodyRef.current
      });
    } else {
      setPingedLeft(false);
      setPingedRight(false);
    }
  };
  var onFullTableResize = function onFullTableResize2(_ref4) {
    var width = _ref4.width;
    if (width !== componentWidth) {
      triggerOnScroll();
      setComponentWidth(fullTableRef.current ? fullTableRef.current.offsetWidth : width);
    }
  };
  var mounted = react.exports.useRef(false);
  react.exports.useEffect(function() {
    if (mounted.current) {
      triggerOnScroll();
    }
  }, [horizonScroll, data2, columns2.length]);
  react.exports.useEffect(function() {
    mounted.current = true;
  }, []);
  var _React$useState9 = react.exports.useState(0), _React$useState10 = _slicedToArray$4(_React$useState9, 2), scrollbarSize = _React$useState10[0], setScrollbarSize = _React$useState10[1];
  var _React$useState11 = react.exports.useState(true), _React$useState12 = _slicedToArray$4(_React$useState11, 2), supportSticky = _React$useState12[0], setSupportSticky = _React$useState12[1];
  react.exports.useEffect(function() {
    if (scrollBodyRef.current instanceof Element) {
      setScrollbarSize(getTargetScrollBarSize(scrollBodyRef.current).width);
    } else {
      setScrollbarSize(getTargetScrollBarSize(scrollBodyContainerRef.current).width);
    }
    setSupportSticky(isStyleSupport("position", "sticky"));
  }, []);
  react.exports.useEffect(function() {
    if (internalHooks === INTERNAL_HOOKS && internalRefs) {
      internalRefs.body.current = scrollBodyRef.current;
    }
  });
  var TableComponent = getComponent(["table"], "table");
  var mergedTableLayout = react.exports.useMemo(function() {
    if (tableLayout) {
      return tableLayout;
    }
    if (fixColumn) {
      return (scroll === null || scroll === void 0 ? void 0 : scroll.x) === "max-content" ? "auto" : "fixed";
    }
    if (fixHeader || isSticky || flattenColumns.some(function(_ref5) {
      var ellipsis = _ref5.ellipsis;
      return ellipsis;
    })) {
      return "fixed";
    }
    return "auto";
  }, [fixHeader, fixColumn, flattenColumns, tableLayout, isSticky]);
  var groupTableNode;
  var headerProps = {
    colWidths,
    columCount: flattenColumns.length,
    stickyOffsets,
    onHeaderRow,
    fixHeader,
    scroll
  };
  var emptyNode = react.exports.useMemo(function() {
    if (hasData) {
      return null;
    }
    if (typeof emptyText2 === "function") {
      return emptyText2();
    }
    return emptyText2;
  }, [hasData, emptyText2]);
  var bodyTable = /* @__PURE__ */ react.exports.createElement(MemoBody, {
    data: mergedData,
    measureColumnWidth: fixHeader || horizonScroll || isSticky,
    expandedKeys: mergedExpandedKeys,
    rowExpandable,
    getRowKey,
    onRow,
    emptyNode,
    childrenColumnName: mergedChildrenColumnName
  });
  var bodyColGroup = /* @__PURE__ */ react.exports.createElement(ColGroup, {
    colWidths: flattenColumns.map(function(_ref6) {
      var width = _ref6.width;
      return width;
    }),
    columns: flattenColumns
  });
  var customizeScrollBody = getComponent(["body"]);
  if (fixHeader || isSticky) {
    var bodyContent;
    if (typeof customizeScrollBody === "function") {
      bodyContent = customizeScrollBody(mergedData, {
        scrollbarSize,
        ref: scrollBodyRef,
        onScroll
      });
      headerProps.colWidths = flattenColumns.map(function(_ref7, index2) {
        var width = _ref7.width;
        var colWidth = index2 === columns2.length - 1 ? width - scrollbarSize : width;
        if (typeof colWidth === "number" && !Number.isNaN(colWidth)) {
          return colWidth;
        }
        warningOnce(false, "When use `components.body` with render props. Each column should have a fixed `width` value.");
        return 0;
      });
    } else {
      bodyContent = /* @__PURE__ */ react.exports.createElement("div", {
        style: _objectSpread2$1(_objectSpread2$1({}, scrollXStyle), scrollYStyle),
        onScroll,
        ref: scrollBodyRef,
        className: classNames("".concat(prefixCls, "-body"))
      }, /* @__PURE__ */ react.exports.createElement(TableComponent, {
        style: _objectSpread2$1(_objectSpread2$1({}, scrollTableStyle), {}, {
          tableLayout: mergedTableLayout
        })
      }, bodyColGroup, bodyTable, !fixFooter && summaryNode && /* @__PURE__ */ react.exports.createElement(Footer, {
        stickyOffsets,
        flattenColumns
      }, summaryNode)));
    }
    var fixedHolderProps = _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({
      noData: !mergedData.length,
      maxContentScroll: horizonScroll && scroll.x === "max-content"
    }, headerProps), columnContext), {}, {
      direction: direction2,
      stickyClassName,
      onScroll
    });
    groupTableNode = /* @__PURE__ */ react.exports.createElement(react.exports.Fragment, null, showHeader !== false && /* @__PURE__ */ react.exports.createElement(FixedHolder, _extends$2({}, fixedHolderProps, {
      stickyTopOffset: offsetHeader,
      className: "".concat(prefixCls, "-header"),
      ref: scrollHeaderRef
    }), function(fixedHolderPassProps) {
      return /* @__PURE__ */ react.exports.createElement(react.exports.Fragment, null, /* @__PURE__ */ react.exports.createElement(Header, fixedHolderPassProps), fixFooter === "top" && /* @__PURE__ */ react.exports.createElement(Footer, fixedHolderPassProps, summaryNode));
    }), bodyContent, fixFooter && fixFooter !== "top" && /* @__PURE__ */ react.exports.createElement(FixedHolder, _extends$2({}, fixedHolderProps, {
      stickyBottomOffset: offsetSummary,
      className: "".concat(prefixCls, "-summary"),
      ref: scrollSummaryRef
    }), function(fixedHolderPassProps) {
      return /* @__PURE__ */ react.exports.createElement(Footer, fixedHolderPassProps, summaryNode);
    }), isSticky && /* @__PURE__ */ react.exports.createElement(StickyScrollBar$1, {
      ref: stickyRef,
      offsetScroll,
      scrollBodyRef,
      onScroll,
      container
    }));
  } else {
    groupTableNode = /* @__PURE__ */ react.exports.createElement("div", {
      style: _objectSpread2$1(_objectSpread2$1({}, scrollXStyle), scrollYStyle),
      className: classNames("".concat(prefixCls, "-content")),
      onScroll,
      ref: scrollBodyRef
    }, /* @__PURE__ */ react.exports.createElement(TableComponent, {
      style: _objectSpread2$1(_objectSpread2$1({}, scrollTableStyle), {}, {
        tableLayout: mergedTableLayout
      })
    }, bodyColGroup, showHeader !== false && /* @__PURE__ */ react.exports.createElement(Header, _extends$2({}, headerProps, columnContext)), bodyTable, summaryNode && /* @__PURE__ */ react.exports.createElement(Footer, {
      stickyOffsets,
      flattenColumns
    }, summaryNode)));
  }
  var ariaProps = pickAttrs(props, {
    aria: true,
    data: true
  });
  var fullTable = /* @__PURE__ */ react.exports.createElement("div", _extends$2({
    className: classNames(prefixCls, className, (_classNames = {}, _defineProperty$4(_classNames, "".concat(prefixCls, "-rtl"), direction2 === "rtl"), _defineProperty$4(_classNames, "".concat(prefixCls, "-ping-left"), pingedLeft), _defineProperty$4(_classNames, "".concat(prefixCls, "-ping-right"), pingedRight), _defineProperty$4(_classNames, "".concat(prefixCls, "-layout-fixed"), tableLayout === "fixed"), _defineProperty$4(_classNames, "".concat(prefixCls, "-fixed-header"), fixHeader), _defineProperty$4(_classNames, "".concat(prefixCls, "-fixed-column"), fixColumn), _defineProperty$4(_classNames, "".concat(prefixCls, "-scroll-horizontal"), horizonScroll), _defineProperty$4(_classNames, "".concat(prefixCls, "-has-fix-left"), flattenColumns[0] && flattenColumns[0].fixed), _defineProperty$4(_classNames, "".concat(prefixCls, "-has-fix-right"), flattenColumns[flattenColumns.length - 1] && flattenColumns[flattenColumns.length - 1].fixed === "right"), _classNames)),
    style: style2,
    id: id2,
    ref: fullTableRef
  }, ariaProps), /* @__PURE__ */ react.exports.createElement(MemoTableContent, {
    pingLeft: pingedLeft,
    pingRight: pingedRight,
    props: _objectSpread2$1(_objectSpread2$1({}, props), {}, {
      stickyOffsets,
      mergedExpandedKeys
    })
  }, title && /* @__PURE__ */ react.exports.createElement(Panel, {
    className: "".concat(prefixCls, "-title")
  }, title(mergedData)), /* @__PURE__ */ react.exports.createElement("div", {
    ref: scrollBodyContainerRef,
    className: "".concat(prefixCls, "-container")
  }, groupTableNode), footer && /* @__PURE__ */ react.exports.createElement(Panel, {
    className: "".concat(prefixCls, "-footer")
  }, footer(mergedData))));
  if (horizonScroll) {
    fullTable = /* @__PURE__ */ react.exports.createElement(ResizeObserver$1, {
      onResize: onFullTableResize
    }, fullTable);
  }
  var TableContextValue = react.exports.useMemo(function() {
    return {
      prefixCls,
      getComponent,
      scrollbarSize,
      direction: direction2,
      fixedInfoList: flattenColumns.map(function(_2, colIndex) {
        return getCellFixedInfo(colIndex, colIndex, flattenColumns, stickyOffsets, direction2);
      }),
      isSticky
    };
  }, [prefixCls, getComponent, scrollbarSize, direction2, flattenColumns, stickyOffsets, isSticky]);
  var BodyContextValue = react.exports.useMemo(function() {
    return _objectSpread2$1(_objectSpread2$1({}, columnContext), {}, {
      tableLayout: mergedTableLayout,
      rowClassName,
      expandedRowClassName,
      expandIcon: mergedExpandIcon,
      expandableType,
      expandRowByClick,
      expandedRowRender,
      onTriggerExpand,
      expandIconColumnIndex,
      indentSize,
      allColumnsFixedLeft: columnContext.flattenColumns.every(function(col) {
        return col.fixed === "left";
      })
    });
  }, [columnContext, mergedTableLayout, rowClassName, expandedRowClassName, mergedExpandIcon, expandableType, expandRowByClick, expandedRowRender, onTriggerExpand, expandIconColumnIndex, indentSize]);
  var ExpandedRowContextValue = react.exports.useMemo(function() {
    return {
      componentWidth,
      fixHeader,
      fixColumn,
      horizonScroll
    };
  }, [componentWidth, fixHeader, fixColumn, horizonScroll]);
  var ResizeContextValue = react.exports.useMemo(function() {
    return {
      onColumnResize
    };
  }, [onColumnResize]);
  return /* @__PURE__ */ react.exports.createElement(StickyContext.Provider, {
    value: supportSticky
  }, /* @__PURE__ */ react.exports.createElement(TableContext.Provider, {
    value: TableContextValue
  }, /* @__PURE__ */ react.exports.createElement(BodyContext.Provider, {
    value: BodyContextValue
  }, /* @__PURE__ */ react.exports.createElement(ExpandedRowContext.Provider, {
    value: ExpandedRowContextValue
  }, /* @__PURE__ */ react.exports.createElement(ResizeContext.Provider, {
    value: ResizeContextValue
  }, fullTable)))));
}
Table$2.EXPAND_COLUMN = EXPAND_COLUMN;
Table$2.Column = Column$2;
Table$2.ColumnGroup = ColumnGroup$1;
Table$2.Summary = FooterComponents;
Table$2.defaultProps = {
  rowKey: "key",
  prefixCls: "rc-table",
  emptyText: function emptyText() {
    return "No Data";
  }
};
function Column$1(_2) {
  return null;
}
function ColumnGroup(_2) {
  return null;
}
function renderExpandIcon(locale2) {
  return function expandIcon(_ref) {
    var _classNames;
    var prefixCls = _ref.prefixCls, onExpand = _ref.onExpand, record = _ref.record, expanded = _ref.expanded, expandable = _ref.expandable;
    var iconPrefix = "".concat(prefixCls, "-row-expand-icon");
    return /* @__PURE__ */ react.exports.createElement("button", {
      type: "button",
      onClick: function onClick(e3) {
        onExpand(record, e3);
        e3.stopPropagation();
      },
      className: classNames(iconPrefix, (_classNames = {}, _defineProperty$4(_classNames, "".concat(iconPrefix, "-spaced"), !expandable), _defineProperty$4(_classNames, "".concat(iconPrefix, "-expanded"), expandable && expanded), _defineProperty$4(_classNames, "".concat(iconPrefix, "-collapsed"), expandable && !expanded), _classNames)),
      "aria-label": expanded ? locale2.collapse : locale2.expand,
      "aria-expanded": expanded
    });
  };
}
function getColumnKey(column, defaultKey) {
  if ("key" in column && column.key !== void 0 && column.key !== null) {
    return column.key;
  }
  if (column.dataIndex) {
    return Array.isArray(column.dataIndex) ? column.dataIndex.join(".") : column.dataIndex;
  }
  return defaultKey;
}
function getColumnPos(index2, pos) {
  return pos ? "".concat(pos, "-").concat(index2) : "".concat(index2);
}
function renderColumnTitle(title, props) {
  if (typeof title === "function") {
    return title(props);
  }
  return title;
}
var FilterFilled$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M349 838c0 17.7 14.2 32 31.8 32h262.4c17.6 0 31.8-14.3 31.8-32V642H349v196zm531.1-684H143.9c-24.5 0-39.8 26.7-27.5 48l221.3 376h348.8l221.3-376c12.1-21.3-3.2-48-27.7-48z" } }] }, "name": "filter", "theme": "filled" };
var FilterFilledSvg = FilterFilled$2;
var FilterFilled = function FilterFilled2(props, ref) {
  return /* @__PURE__ */ react.exports.createElement(AntdIcon, _objectSpread2$1(_objectSpread2$1({}, props), {}, {
    ref,
    icon: FilterFilledSvg
  }));
};
FilterFilled.displayName = "FilterFilled";
var FilterFilled$1 = /* @__PURE__ */ react.exports.forwardRef(FilterFilled);
var HolderOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M300 276.5a56 56 0 1056-97 56 56 0 00-56 97zm0 284a56 56 0 1056-97 56 56 0 00-56 97zM640 228a56 56 0 10112 0 56 56 0 00-112 0zm0 284a56 56 0 10112 0 56 56 0 00-112 0zM300 844.5a56 56 0 1056-97 56 56 0 00-56 97zM640 796a56 56 0 10112 0 56 56 0 00-112 0z" } }] }, "name": "holder", "theme": "outlined" };
var HolderOutlinedSvg = HolderOutlined$2;
var HolderOutlined = function HolderOutlined2(props, ref) {
  return /* @__PURE__ */ react.exports.createElement(AntdIcon, _objectSpread2$1(_objectSpread2$1({}, props), {}, {
    ref,
    icon: HolderOutlinedSvg
  }));
};
HolderOutlined.displayName = "HolderOutlined";
var HolderOutlined$1 = /* @__PURE__ */ react.exports.forwardRef(HolderOutlined);
var _excluded$1 = ["className", "style", "motion", "motionNodes", "motionType", "onMotionStart", "onMotionEnd", "active", "treeNodeRequiredProps"];
var MotionTreeNode = function MotionTreeNode2(_ref, ref) {
  var className = _ref.className, style2 = _ref.style, motion = _ref.motion, motionNodes = _ref.motionNodes, motionType = _ref.motionType, onOriginMotionStart = _ref.onMotionStart, onOriginMotionEnd = _ref.onMotionEnd, active = _ref.active, treeNodeRequiredProps = _ref.treeNodeRequiredProps, props = _objectWithoutProperties$1(_ref, _excluded$1);
  var _React$useState = react.exports.useState(true), _React$useState2 = _slicedToArray$4(_React$useState, 2), visible = _React$useState2[0], setVisible = _React$useState2[1];
  var _React$useContext = react.exports.useContext(TreeContext), prefixCls = _React$useContext.prefixCls;
  var motionedRef = react.exports.useRef(false);
  var onMotionEnd = function onMotionEnd2() {
    if (!motionedRef.current) {
      onOriginMotionEnd();
    }
    motionedRef.current = true;
  };
  react.exports.useEffect(function() {
    if (motionNodes && motionType === "hide" && visible) {
      setVisible(false);
    }
  }, [motionNodes]);
  react.exports.useEffect(function() {
    if (motionNodes) {
      onOriginMotionStart();
    }
    return function() {
      if (motionNodes) {
        onMotionEnd();
      }
    };
  }, []);
  if (motionNodes) {
    return /* @__PURE__ */ react.exports.createElement(CSSMotion, _extends$2({
      ref,
      visible
    }, motion, {
      motionAppear: motionType === "show",
      onAppearEnd: onMotionEnd,
      onLeaveEnd: onMotionEnd
    }), function(_ref2, motionRef) {
      var motionClassName = _ref2.className, motionStyle = _ref2.style;
      return /* @__PURE__ */ react.exports.createElement("div", {
        ref: motionRef,
        className: classNames("".concat(prefixCls, "-treenode-motion"), motionClassName),
        style: motionStyle
      }, motionNodes.map(function(treeNode) {
        var restProps = _extends$2({}, treeNode.data), title = treeNode.title, key2 = treeNode.key, isStart = treeNode.isStart, isEnd = treeNode.isEnd;
        delete restProps.children;
        var treeNodeProps = getTreeNodeProps(key2, treeNodeRequiredProps);
        return /* @__PURE__ */ react.exports.createElement(ContextTreeNode, _extends$2({}, restProps, treeNodeProps, {
          title,
          active,
          data: treeNode.data,
          key: key2,
          isStart,
          isEnd
        }));
      }));
    });
  }
  return /* @__PURE__ */ react.exports.createElement(ContextTreeNode, _extends$2({
    domRef: ref,
    className,
    style: style2
  }, props, {
    active
  }));
};
MotionTreeNode.displayName = "MotionTreeNode";
var RefMotionTreeNode = /* @__PURE__ */ react.exports.forwardRef(MotionTreeNode);
function findExpandedKeys() {
  var prev = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  var next = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  var prevLen = prev.length;
  var nextLen = next.length;
  if (Math.abs(prevLen - nextLen) !== 1) {
    return {
      add: false,
      key: null
    };
  }
  function find2(shorter, longer) {
    var cache2 = /* @__PURE__ */ new Map();
    shorter.forEach(function(key2) {
      cache2.set(key2, true);
    });
    var keys2 = longer.filter(function(key2) {
      return !cache2.has(key2);
    });
    return keys2.length === 1 ? keys2[0] : null;
  }
  if (prevLen < nextLen) {
    return {
      add: true,
      key: find2(prev, next)
    };
  }
  return {
    add: false,
    key: find2(next, prev)
  };
}
function getExpandRange(shorter, longer, key2) {
  var shorterStartIndex = shorter.findIndex(function(data2) {
    return data2.key === key2;
  });
  var shorterEndNode = shorter[shorterStartIndex + 1];
  var longerStartIndex = longer.findIndex(function(data2) {
    return data2.key === key2;
  });
  if (shorterEndNode) {
    var longerEndIndex = longer.findIndex(function(data2) {
      return data2.key === shorterEndNode.key;
    });
    return longer.slice(longerStartIndex + 1, longerEndIndex);
  }
  return longer.slice(longerStartIndex + 1);
}
var _excluded = ["prefixCls", "data", "selectable", "checkable", "expandedKeys", "selectedKeys", "checkedKeys", "loadedKeys", "loadingKeys", "halfCheckedKeys", "keyEntities", "disabled", "dragging", "dragOverNodeKey", "dropPosition", "motion", "height", "itemHeight", "virtual", "focusable", "activeItem", "focused", "tabIndex", "onKeyDown", "onFocus", "onBlur", "onActiveChange", "onListChangeStart", "onListChangeEnd"];
var HIDDEN_STYLE = {
  width: 0,
  height: 0,
  display: "flex",
  overflow: "hidden",
  opacity: 0,
  border: 0,
  padding: 0,
  margin: 0
};
var noop$2 = function noop2() {
};
var MOTION_KEY = "RC_TREE_MOTION_".concat(Math.random());
var MotionNode = {
  key: MOTION_KEY
};
var MotionEntity = {
  key: MOTION_KEY,
  level: 0,
  index: 0,
  pos: "0",
  node: MotionNode,
  nodes: [MotionNode]
};
var MotionFlattenData = {
  parent: null,
  children: [],
  pos: MotionEntity.pos,
  data: MotionNode,
  title: null,
  key: MOTION_KEY,
  isStart: [],
  isEnd: []
};
function getMinimumRangeTransitionRange(list, virtual, height, itemHeight) {
  if (virtual === false || !height) {
    return list;
  }
  return list.slice(0, Math.ceil(height / itemHeight) + 1);
}
function itemKey(item) {
  var key2 = item.key, pos = item.pos;
  return getKey(key2, pos);
}
function getAccessibilityPath(item) {
  var path2 = String(item.data.key);
  var current = item;
  while (current.parent) {
    current = current.parent;
    path2 = "".concat(current.data.key, " > ").concat(path2);
  }
  return path2;
}
var NodeList = /* @__PURE__ */ react.exports.forwardRef(function(props, ref) {
  var prefixCls = props.prefixCls, data2 = props.data;
  props.selectable;
  props.checkable;
  var expandedKeys = props.expandedKeys, selectedKeys = props.selectedKeys, checkedKeys = props.checkedKeys, loadedKeys = props.loadedKeys, loadingKeys = props.loadingKeys, halfCheckedKeys = props.halfCheckedKeys, keyEntities = props.keyEntities, disabled = props.disabled, dragging = props.dragging, dragOverNodeKey = props.dragOverNodeKey, dropPosition = props.dropPosition, motion = props.motion, height = props.height, itemHeight = props.itemHeight, virtual = props.virtual, focusable2 = props.focusable, activeItem = props.activeItem, focused = props.focused, tabIndex = props.tabIndex, onKeyDown2 = props.onKeyDown, onFocus2 = props.onFocus, onBlur2 = props.onBlur, onActiveChange = props.onActiveChange, onListChangeStart = props.onListChangeStart, onListChangeEnd = props.onListChangeEnd, domProps = _objectWithoutProperties$1(props, _excluded);
  var listRef = react.exports.useRef(null);
  var indentMeasurerRef = react.exports.useRef(null);
  react.exports.useImperativeHandle(ref, function() {
    return {
      scrollTo: function scrollTo2(scroll) {
        listRef.current.scrollTo(scroll);
      },
      getIndentWidth: function getIndentWidth() {
        return indentMeasurerRef.current.offsetWidth;
      }
    };
  });
  var _React$useState = react.exports.useState(expandedKeys), _React$useState2 = _slicedToArray$4(_React$useState, 2), prevExpandedKeys = _React$useState2[0], setPrevExpandedKeys = _React$useState2[1];
  var _React$useState3 = react.exports.useState(data2), _React$useState4 = _slicedToArray$4(_React$useState3, 2), prevData = _React$useState4[0], setPrevData = _React$useState4[1];
  var _React$useState5 = react.exports.useState(data2), _React$useState6 = _slicedToArray$4(_React$useState5, 2), transitionData = _React$useState6[0], setTransitionData = _React$useState6[1];
  var _React$useState7 = react.exports.useState([]), _React$useState8 = _slicedToArray$4(_React$useState7, 2), transitionRange = _React$useState8[0], setTransitionRange = _React$useState8[1];
  var _React$useState9 = react.exports.useState(null), _React$useState10 = _slicedToArray$4(_React$useState9, 2), motionType = _React$useState10[0], setMotionType = _React$useState10[1];
  var dataRef = react.exports.useRef(data2);
  dataRef.current = data2;
  function onMotionEnd() {
    var latestData = dataRef.current;
    setPrevData(latestData);
    setTransitionData(latestData);
    setTransitionRange([]);
    setMotionType(null);
    onListChangeEnd();
  }
  react.exports.useEffect(function() {
    setPrevExpandedKeys(expandedKeys);
    var diffExpanded = findExpandedKeys(prevExpandedKeys, expandedKeys);
    if (diffExpanded.key !== null) {
      if (diffExpanded.add) {
        var keyIndex = prevData.findIndex(function(_ref) {
          var key2 = _ref.key;
          return key2 === diffExpanded.key;
        });
        var rangeNodes = getMinimumRangeTransitionRange(getExpandRange(prevData, data2, diffExpanded.key), virtual, height, itemHeight);
        var newTransitionData = prevData.slice();
        newTransitionData.splice(keyIndex + 1, 0, MotionFlattenData);
        setTransitionData(newTransitionData);
        setTransitionRange(rangeNodes);
        setMotionType("show");
      } else {
        var _keyIndex = data2.findIndex(function(_ref2) {
          var key2 = _ref2.key;
          return key2 === diffExpanded.key;
        });
        var _rangeNodes = getMinimumRangeTransitionRange(getExpandRange(data2, prevData, diffExpanded.key), virtual, height, itemHeight);
        var _newTransitionData = data2.slice();
        _newTransitionData.splice(_keyIndex + 1, 0, MotionFlattenData);
        setTransitionData(_newTransitionData);
        setTransitionRange(_rangeNodes);
        setMotionType("hide");
      }
    } else if (prevData !== data2) {
      setPrevData(data2);
      setTransitionData(data2);
    }
  }, [expandedKeys, data2]);
  react.exports.useEffect(function() {
    if (!dragging) {
      onMotionEnd();
    }
  }, [dragging]);
  var mergedData = motion ? transitionData : data2;
  var treeNodeRequiredProps = {
    expandedKeys,
    selectedKeys,
    loadedKeys,
    loadingKeys,
    checkedKeys,
    halfCheckedKeys,
    dragOverNodeKey,
    dropPosition,
    keyEntities
  };
  return /* @__PURE__ */ react.exports.createElement(react.exports.Fragment, null, focused && activeItem && /* @__PURE__ */ react.exports.createElement("span", {
    style: HIDDEN_STYLE,
    "aria-live": "assertive"
  }, getAccessibilityPath(activeItem)), /* @__PURE__ */ react.exports.createElement("div", null, /* @__PURE__ */ react.exports.createElement("input", {
    style: HIDDEN_STYLE,
    disabled: focusable2 === false || disabled,
    tabIndex: focusable2 !== false ? tabIndex : null,
    onKeyDown: onKeyDown2,
    onFocus: onFocus2,
    onBlur: onBlur2,
    value: "",
    onChange: noop$2,
    "aria-label": "for screen reader"
  })), /* @__PURE__ */ react.exports.createElement("div", {
    className: "".concat(prefixCls, "-treenode"),
    "aria-hidden": true,
    style: {
      position: "absolute",
      pointerEvents: "none",
      visibility: "hidden",
      height: 0,
      overflow: "hidden"
    }
  }, /* @__PURE__ */ react.exports.createElement("div", {
    className: "".concat(prefixCls, "-indent")
  }, /* @__PURE__ */ react.exports.createElement("div", {
    ref: indentMeasurerRef,
    className: "".concat(prefixCls, "-indent-unit")
  }))), /* @__PURE__ */ react.exports.createElement(List$2, _extends$2({}, domProps, {
    data: mergedData,
    itemKey,
    height,
    fullHeight: false,
    virtual,
    itemHeight,
    prefixCls: "".concat(prefixCls, "-list"),
    ref: listRef,
    onVisibleChange: function onVisibleChange(originList, fullList) {
      var originSet = new Set(originList);
      var restList = fullList.filter(function(item) {
        return !originSet.has(item);
      });
      if (restList.some(function(item) {
        return itemKey(item) === MOTION_KEY;
      })) {
        onMotionEnd();
      }
    }
  }), function(treeNode) {
    var pos = treeNode.pos, restProps = _extends$2({}, treeNode.data), title = treeNode.title, key2 = treeNode.key, isStart = treeNode.isStart, isEnd = treeNode.isEnd;
    var mergedKey = getKey(key2, pos);
    delete restProps.key;
    delete restProps.children;
    var treeNodeProps = getTreeNodeProps(mergedKey, treeNodeRequiredProps);
    return /* @__PURE__ */ react.exports.createElement(RefMotionTreeNode, _extends$2({}, restProps, treeNodeProps, {
      title,
      active: !!activeItem && key2 === activeItem.key,
      pos,
      data: treeNode.data,
      isStart,
      isEnd,
      motion,
      motionNodes: key2 === MOTION_KEY ? transitionRange : null,
      motionType,
      onMotionStart: onListChangeStart,
      onMotionEnd,
      treeNodeRequiredProps,
      onMouseMove: function onMouseMove() {
        onActiveChange(null);
      }
    }));
  }));
});
NodeList.displayName = "NodeList";
function DropIndicator(_ref) {
  var dropPosition = _ref.dropPosition, dropLevelOffset = _ref.dropLevelOffset, indent = _ref.indent;
  var style2 = {
    pointerEvents: "none",
    position: "absolute",
    right: 0,
    backgroundColor: "red",
    height: 2
  };
  switch (dropPosition) {
    case -1:
      style2.top = 0;
      style2.left = -dropLevelOffset * indent;
      break;
    case 1:
      style2.bottom = 0;
      style2.left = -dropLevelOffset * indent;
      break;
    case 0:
      style2.bottom = 0;
      style2.left = indent;
      break;
  }
  return /* @__PURE__ */ react.exports.createElement("div", {
    style: style2
  });
}
var MAX_RETRY_TIMES = 10;
var Tree$3 = /* @__PURE__ */ function(_React$Component) {
  _inherits$1(Tree2, _React$Component);
  var _super = _createSuper$1(Tree2);
  function Tree2() {
    var _this;
    _classCallCheck$2(this, Tree2);
    for (var _len = arguments.length, _args = new Array(_len), _key = 0; _key < _len; _key++) {
      _args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(_args));
    _this.destroyed = false;
    _this.delayedDragEnterLogic = void 0;
    _this.loadingRetryTimes = {};
    _this.state = {
      keyEntities: {},
      indent: null,
      selectedKeys: [],
      checkedKeys: [],
      halfCheckedKeys: [],
      loadedKeys: [],
      loadingKeys: [],
      expandedKeys: [],
      draggingNodeKey: null,
      dragChildrenKeys: [],
      dropTargetKey: null,
      dropPosition: null,
      dropContainerKey: null,
      dropLevelOffset: null,
      dropTargetPos: null,
      dropAllowed: true,
      dragOverNodeKey: null,
      treeData: [],
      flattenNodes: [],
      focused: false,
      activeKey: null,
      listChanging: false,
      prevProps: null,
      fieldNames: fillFieldNames()
    };
    _this.dragStartMousePosition = null;
    _this.dragNode = void 0;
    _this.currentMouseOverDroppableNodeKey = null;
    _this.listRef = /* @__PURE__ */ react.exports.createRef();
    _this.onNodeDragStart = function(event, node) {
      var _this$state = _this.state, expandedKeys = _this$state.expandedKeys, keyEntities = _this$state.keyEntities;
      var onDragStart = _this.props.onDragStart;
      var eventKey = node.props.eventKey;
      _this.dragNode = node;
      _this.dragStartMousePosition = {
        x: event.clientX,
        y: event.clientY
      };
      var newExpandedKeys = arrDel(expandedKeys, eventKey);
      _this.setState({
        draggingNodeKey: eventKey,
        dragChildrenKeys: getDragChildrenKeys(eventKey, keyEntities),
        indent: _this.listRef.current.getIndentWidth()
      });
      _this.setExpandedKeys(newExpandedKeys);
      window.addEventListener("dragend", _this.onWindowDragEnd);
      onDragStart === null || onDragStart === void 0 ? void 0 : onDragStart({
        event,
        node: convertNodePropsToEventData(node.props)
      });
    };
    _this.onNodeDragEnter = function(event, node) {
      var _this$state2 = _this.state, expandedKeys = _this$state2.expandedKeys, keyEntities = _this$state2.keyEntities, dragChildrenKeys = _this$state2.dragChildrenKeys, flattenNodes = _this$state2.flattenNodes, indent = _this$state2.indent;
      var _this$props = _this.props, onDragEnter = _this$props.onDragEnter, onExpand = _this$props.onExpand, allowDrop2 = _this$props.allowDrop, direction2 = _this$props.direction;
      var _node$props = node.props, pos = _node$props.pos, eventKey = _node$props.eventKey;
      var _assertThisInitialize = _assertThisInitialized$1(_this), dragNode = _assertThisInitialize.dragNode;
      if (_this.currentMouseOverDroppableNodeKey !== eventKey) {
        _this.currentMouseOverDroppableNodeKey = eventKey;
      }
      if (!dragNode) {
        _this.resetDragState();
        return;
      }
      var _calcDropPosition = calcDropPosition(event, dragNode, node, indent, _this.dragStartMousePosition, allowDrop2, flattenNodes, keyEntities, expandedKeys, direction2), dropPosition = _calcDropPosition.dropPosition, dropLevelOffset = _calcDropPosition.dropLevelOffset, dropTargetKey = _calcDropPosition.dropTargetKey, dropContainerKey = _calcDropPosition.dropContainerKey, dropTargetPos = _calcDropPosition.dropTargetPos, dropAllowed = _calcDropPosition.dropAllowed, dragOverNodeKey = _calcDropPosition.dragOverNodeKey;
      if (dragChildrenKeys.indexOf(dropTargetKey) !== -1 || !dropAllowed) {
        _this.resetDragState();
        return;
      }
      if (!_this.delayedDragEnterLogic) {
        _this.delayedDragEnterLogic = {};
      }
      Object.keys(_this.delayedDragEnterLogic).forEach(function(key2) {
        clearTimeout(_this.delayedDragEnterLogic[key2]);
      });
      if (dragNode.props.eventKey !== node.props.eventKey) {
        event.persist();
        _this.delayedDragEnterLogic[pos] = window.setTimeout(function() {
          if (_this.state.draggingNodeKey === null)
            return;
          var newExpandedKeys = _toConsumableArray(expandedKeys);
          var entity = keyEntities[node.props.eventKey];
          if (entity && (entity.children || []).length) {
            newExpandedKeys = arrAdd(expandedKeys, node.props.eventKey);
          }
          if (!("expandedKeys" in _this.props)) {
            _this.setExpandedKeys(newExpandedKeys);
          }
          onExpand === null || onExpand === void 0 ? void 0 : onExpand(newExpandedKeys, {
            node: convertNodePropsToEventData(node.props),
            expanded: true,
            nativeEvent: event.nativeEvent
          });
        }, 800);
      }
      if (dragNode.props.eventKey === dropTargetKey && dropLevelOffset === 0) {
        _this.resetDragState();
        return;
      }
      _this.setState({
        dragOverNodeKey,
        dropPosition,
        dropLevelOffset,
        dropTargetKey,
        dropContainerKey,
        dropTargetPos,
        dropAllowed
      });
      onDragEnter === null || onDragEnter === void 0 ? void 0 : onDragEnter({
        event,
        node: convertNodePropsToEventData(node.props),
        expandedKeys
      });
    };
    _this.onNodeDragOver = function(event, node) {
      var _this$state3 = _this.state, dragChildrenKeys = _this$state3.dragChildrenKeys, flattenNodes = _this$state3.flattenNodes, keyEntities = _this$state3.keyEntities, expandedKeys = _this$state3.expandedKeys, indent = _this$state3.indent;
      var _this$props2 = _this.props, onDragOver = _this$props2.onDragOver, allowDrop2 = _this$props2.allowDrop, direction2 = _this$props2.direction;
      var _assertThisInitialize2 = _assertThisInitialized$1(_this), dragNode = _assertThisInitialize2.dragNode;
      if (!dragNode) {
        return;
      }
      var _calcDropPosition2 = calcDropPosition(event, dragNode, node, indent, _this.dragStartMousePosition, allowDrop2, flattenNodes, keyEntities, expandedKeys, direction2), dropPosition = _calcDropPosition2.dropPosition, dropLevelOffset = _calcDropPosition2.dropLevelOffset, dropTargetKey = _calcDropPosition2.dropTargetKey, dropContainerKey = _calcDropPosition2.dropContainerKey, dropAllowed = _calcDropPosition2.dropAllowed, dropTargetPos = _calcDropPosition2.dropTargetPos, dragOverNodeKey = _calcDropPosition2.dragOverNodeKey;
      if (dragChildrenKeys.indexOf(dropTargetKey) !== -1 || !dropAllowed) {
        return;
      }
      if (dragNode.props.eventKey === dropTargetKey && dropLevelOffset === 0) {
        if (!(_this.state.dropPosition === null && _this.state.dropLevelOffset === null && _this.state.dropTargetKey === null && _this.state.dropContainerKey === null && _this.state.dropTargetPos === null && _this.state.dropAllowed === false && _this.state.dragOverNodeKey === null)) {
          _this.resetDragState();
        }
      } else if (!(dropPosition === _this.state.dropPosition && dropLevelOffset === _this.state.dropLevelOffset && dropTargetKey === _this.state.dropTargetKey && dropContainerKey === _this.state.dropContainerKey && dropTargetPos === _this.state.dropTargetPos && dropAllowed === _this.state.dropAllowed && dragOverNodeKey === _this.state.dragOverNodeKey)) {
        _this.setState({
          dropPosition,
          dropLevelOffset,
          dropTargetKey,
          dropContainerKey,
          dropTargetPos,
          dropAllowed,
          dragOverNodeKey
        });
      }
      onDragOver === null || onDragOver === void 0 ? void 0 : onDragOver({
        event,
        node: convertNodePropsToEventData(node.props)
      });
    };
    _this.onNodeDragLeave = function(event, node) {
      if (_this.currentMouseOverDroppableNodeKey === node.props.eventKey && !event.currentTarget.contains(event.relatedTarget)) {
        _this.resetDragState();
        _this.currentMouseOverDroppableNodeKey = null;
      }
      var onDragLeave = _this.props.onDragLeave;
      onDragLeave === null || onDragLeave === void 0 ? void 0 : onDragLeave({
        event,
        node: convertNodePropsToEventData(node.props)
      });
    };
    _this.onWindowDragEnd = function(event) {
      _this.onNodeDragEnd(event, null, true);
      window.removeEventListener("dragend", _this.onWindowDragEnd);
    };
    _this.onNodeDragEnd = function(event, node) {
      var onDragEnd = _this.props.onDragEnd;
      _this.setState({
        dragOverNodeKey: null
      });
      _this.cleanDragState();
      onDragEnd === null || onDragEnd === void 0 ? void 0 : onDragEnd({
        event,
        node: convertNodePropsToEventData(node.props)
      });
      _this.dragNode = null;
      window.removeEventListener("dragend", _this.onWindowDragEnd);
    };
    _this.onNodeDrop = function(event, node) {
      var _this$getActiveItem;
      var outsideTree = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      var _this$state4 = _this.state, dragChildrenKeys = _this$state4.dragChildrenKeys, dropPosition = _this$state4.dropPosition, dropTargetKey = _this$state4.dropTargetKey, dropTargetPos = _this$state4.dropTargetPos, dropAllowed = _this$state4.dropAllowed;
      if (!dropAllowed)
        return;
      var onDrop = _this.props.onDrop;
      _this.setState({
        dragOverNodeKey: null
      });
      _this.cleanDragState();
      if (dropTargetKey === null)
        return;
      var abstractDropNodeProps = _objectSpread2$1(_objectSpread2$1({}, getTreeNodeProps(dropTargetKey, _this.getTreeNodeRequiredProps())), {}, {
        active: ((_this$getActiveItem = _this.getActiveItem()) === null || _this$getActiveItem === void 0 ? void 0 : _this$getActiveItem.key) === dropTargetKey,
        data: _this.state.keyEntities[dropTargetKey].node
      });
      var dropToChild = dragChildrenKeys.indexOf(dropTargetKey) !== -1;
      warningOnce(!dropToChild, "Can not drop to dragNode's children node. This is a bug of rc-tree. Please report an issue.");
      var posArr = posToArr(dropTargetPos);
      var dropResult = {
        event,
        node: convertNodePropsToEventData(abstractDropNodeProps),
        dragNode: _this.dragNode ? convertNodePropsToEventData(_this.dragNode.props) : null,
        dragNodesKeys: [_this.dragNode.props.eventKey].concat(dragChildrenKeys),
        dropToGap: dropPosition !== 0,
        dropPosition: dropPosition + Number(posArr[posArr.length - 1])
      };
      if (!outsideTree) {
        onDrop === null || onDrop === void 0 ? void 0 : onDrop(dropResult);
      }
      _this.dragNode = null;
    };
    _this.cleanDragState = function() {
      var draggingNodeKey = _this.state.draggingNodeKey;
      if (draggingNodeKey !== null) {
        _this.setState({
          draggingNodeKey: null,
          dropPosition: null,
          dropContainerKey: null,
          dropTargetKey: null,
          dropLevelOffset: null,
          dropAllowed: true,
          dragOverNodeKey: null
        });
      }
      _this.dragStartMousePosition = null;
      _this.currentMouseOverDroppableNodeKey = null;
    };
    _this.triggerExpandActionExpand = function(e3, treeNode) {
      var _this$state5 = _this.state, expandedKeys = _this$state5.expandedKeys, flattenNodes = _this$state5.flattenNodes;
      var expanded = treeNode.expanded, key2 = treeNode.key, isLeaf = treeNode.isLeaf;
      if (isLeaf || e3.shiftKey || e3.metaKey || e3.ctrlKey) {
        return;
      }
      var node = flattenNodes.filter(function(nodeItem) {
        return nodeItem.key === key2;
      })[0];
      var eventNode = convertNodePropsToEventData(_objectSpread2$1(_objectSpread2$1({}, getTreeNodeProps(key2, _this.getTreeNodeRequiredProps())), {}, {
        data: node.data
      }));
      _this.setExpandedKeys(expanded ? arrDel(expandedKeys, key2) : arrAdd(expandedKeys, key2));
      _this.onNodeExpand(e3, eventNode);
    };
    _this.onNodeClick = function(e3, treeNode) {
      var _this$props3 = _this.props, onClick = _this$props3.onClick, expandAction = _this$props3.expandAction;
      if (expandAction === "click") {
        _this.triggerExpandActionExpand(e3, treeNode);
      }
      onClick === null || onClick === void 0 ? void 0 : onClick(e3, treeNode);
    };
    _this.onNodeDoubleClick = function(e3, treeNode) {
      var _this$props4 = _this.props, onDoubleClick = _this$props4.onDoubleClick, expandAction = _this$props4.expandAction;
      if (expandAction === "doubleClick") {
        _this.triggerExpandActionExpand(e3, treeNode);
      }
      onDoubleClick === null || onDoubleClick === void 0 ? void 0 : onDoubleClick(e3, treeNode);
    };
    _this.onNodeSelect = function(e3, treeNode) {
      var selectedKeys = _this.state.selectedKeys;
      var _this$state6 = _this.state, keyEntities = _this$state6.keyEntities, fieldNames = _this$state6.fieldNames;
      var _this$props5 = _this.props, onSelect = _this$props5.onSelect, multiple = _this$props5.multiple;
      var selected = treeNode.selected;
      var key2 = treeNode[fieldNames.key];
      var targetSelected = !selected;
      if (!targetSelected) {
        selectedKeys = arrDel(selectedKeys, key2);
      } else if (!multiple) {
        selectedKeys = [key2];
      } else {
        selectedKeys = arrAdd(selectedKeys, key2);
      }
      var selectedNodes = selectedKeys.map(function(selectedKey) {
        var entity = keyEntities[selectedKey];
        if (!entity)
          return null;
        return entity.node;
      }).filter(function(node) {
        return node;
      });
      _this.setUncontrolledState({
        selectedKeys
      });
      onSelect === null || onSelect === void 0 ? void 0 : onSelect(selectedKeys, {
        event: "select",
        selected: targetSelected,
        node: treeNode,
        selectedNodes,
        nativeEvent: e3.nativeEvent
      });
    };
    _this.onNodeCheck = function(e3, treeNode, checked) {
      var _this$state7 = _this.state, keyEntities = _this$state7.keyEntities, oriCheckedKeys = _this$state7.checkedKeys, oriHalfCheckedKeys = _this$state7.halfCheckedKeys;
      var _this$props6 = _this.props, checkStrictly = _this$props6.checkStrictly, onCheck = _this$props6.onCheck;
      var key2 = treeNode.key;
      var checkedObj;
      var eventObj = {
        event: "check",
        node: treeNode,
        checked,
        nativeEvent: e3.nativeEvent
      };
      if (checkStrictly) {
        var checkedKeys = checked ? arrAdd(oriCheckedKeys, key2) : arrDel(oriCheckedKeys, key2);
        var halfCheckedKeys = arrDel(oriHalfCheckedKeys, key2);
        checkedObj = {
          checked: checkedKeys,
          halfChecked: halfCheckedKeys
        };
        eventObj.checkedNodes = checkedKeys.map(function(checkedKey) {
          return keyEntities[checkedKey];
        }).filter(function(entity) {
          return entity;
        }).map(function(entity) {
          return entity.node;
        });
        _this.setUncontrolledState({
          checkedKeys
        });
      } else {
        var _conductCheck = conductCheck([].concat(_toConsumableArray(oriCheckedKeys), [key2]), true, keyEntities), _checkedKeys = _conductCheck.checkedKeys, _halfCheckedKeys = _conductCheck.halfCheckedKeys;
        if (!checked) {
          var keySet = new Set(_checkedKeys);
          keySet.delete(key2);
          var _conductCheck2 = conductCheck(Array.from(keySet), {
            checked: false,
            halfCheckedKeys: _halfCheckedKeys
          }, keyEntities);
          _checkedKeys = _conductCheck2.checkedKeys;
          _halfCheckedKeys = _conductCheck2.halfCheckedKeys;
        }
        checkedObj = _checkedKeys;
        eventObj.checkedNodes = [];
        eventObj.checkedNodesPositions = [];
        eventObj.halfCheckedKeys = _halfCheckedKeys;
        _checkedKeys.forEach(function(checkedKey) {
          var entity = keyEntities[checkedKey];
          if (!entity)
            return;
          var node = entity.node, pos = entity.pos;
          eventObj.checkedNodes.push(node);
          eventObj.checkedNodesPositions.push({
            node,
            pos
          });
        });
        _this.setUncontrolledState({
          checkedKeys: _checkedKeys
        }, false, {
          halfCheckedKeys: _halfCheckedKeys
        });
      }
      onCheck === null || onCheck === void 0 ? void 0 : onCheck(checkedObj, eventObj);
    };
    _this.onNodeLoad = function(treeNode) {
      var key2 = treeNode.key;
      var loadPromise = new Promise(function(resolve, reject) {
        _this.setState(function(_ref) {
          var _ref$loadedKeys = _ref.loadedKeys, loadedKeys = _ref$loadedKeys === void 0 ? [] : _ref$loadedKeys, _ref$loadingKeys = _ref.loadingKeys, loadingKeys = _ref$loadingKeys === void 0 ? [] : _ref$loadingKeys;
          var _this$props7 = _this.props, loadData = _this$props7.loadData, onLoad = _this$props7.onLoad;
          if (!loadData || loadedKeys.indexOf(key2) !== -1 || loadingKeys.indexOf(key2) !== -1) {
            return null;
          }
          var promise = loadData(treeNode);
          promise.then(function() {
            var currentLoadedKeys = _this.state.loadedKeys;
            var newLoadedKeys = arrAdd(currentLoadedKeys, key2);
            onLoad === null || onLoad === void 0 ? void 0 : onLoad(newLoadedKeys, {
              event: "load",
              node: treeNode
            });
            _this.setUncontrolledState({
              loadedKeys: newLoadedKeys
            });
            _this.setState(function(prevState) {
              return {
                loadingKeys: arrDel(prevState.loadingKeys, key2)
              };
            });
            resolve();
          }).catch(function(e3) {
            _this.setState(function(prevState) {
              return {
                loadingKeys: arrDel(prevState.loadingKeys, key2)
              };
            });
            _this.loadingRetryTimes[key2] = (_this.loadingRetryTimes[key2] || 0) + 1;
            if (_this.loadingRetryTimes[key2] >= MAX_RETRY_TIMES) {
              var currentLoadedKeys = _this.state.loadedKeys;
              warningOnce(false, "Retry for `loadData` many times but still failed. No more retry.");
              _this.setUncontrolledState({
                loadedKeys: arrAdd(currentLoadedKeys, key2)
              });
              resolve();
            }
            reject(e3);
          });
          return {
            loadingKeys: arrAdd(loadingKeys, key2)
          };
        });
      });
      loadPromise.catch(function() {
      });
      return loadPromise;
    };
    _this.onNodeMouseEnter = function(event, node) {
      var onMouseEnter = _this.props.onMouseEnter;
      onMouseEnter === null || onMouseEnter === void 0 ? void 0 : onMouseEnter({
        event,
        node
      });
    };
    _this.onNodeMouseLeave = function(event, node) {
      var onMouseLeave = _this.props.onMouseLeave;
      onMouseLeave === null || onMouseLeave === void 0 ? void 0 : onMouseLeave({
        event,
        node
      });
    };
    _this.onNodeContextMenu = function(event, node) {
      var onRightClick = _this.props.onRightClick;
      if (onRightClick) {
        event.preventDefault();
        onRightClick({
          event,
          node
        });
      }
    };
    _this.onFocus = function() {
      var onFocus2 = _this.props.onFocus;
      _this.setState({
        focused: true
      });
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      onFocus2 === null || onFocus2 === void 0 ? void 0 : onFocus2.apply(void 0, args);
    };
    _this.onBlur = function() {
      var onBlur2 = _this.props.onBlur;
      _this.setState({
        focused: false
      });
      _this.onActiveChange(null);
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }
      onBlur2 === null || onBlur2 === void 0 ? void 0 : onBlur2.apply(void 0, args);
    };
    _this.getTreeNodeRequiredProps = function() {
      var _this$state8 = _this.state, expandedKeys = _this$state8.expandedKeys, selectedKeys = _this$state8.selectedKeys, loadedKeys = _this$state8.loadedKeys, loadingKeys = _this$state8.loadingKeys, checkedKeys = _this$state8.checkedKeys, halfCheckedKeys = _this$state8.halfCheckedKeys, dragOverNodeKey = _this$state8.dragOverNodeKey, dropPosition = _this$state8.dropPosition, keyEntities = _this$state8.keyEntities;
      return {
        expandedKeys: expandedKeys || [],
        selectedKeys: selectedKeys || [],
        loadedKeys: loadedKeys || [],
        loadingKeys: loadingKeys || [],
        checkedKeys: checkedKeys || [],
        halfCheckedKeys: halfCheckedKeys || [],
        dragOverNodeKey,
        dropPosition,
        keyEntities
      };
    };
    _this.setExpandedKeys = function(expandedKeys) {
      var _this$state9 = _this.state, treeData = _this$state9.treeData, fieldNames = _this$state9.fieldNames;
      var flattenNodes = flattenTreeData(treeData, expandedKeys, fieldNames);
      _this.setUncontrolledState({
        expandedKeys,
        flattenNodes
      }, true);
    };
    _this.onNodeExpand = function(e3, treeNode) {
      var expandedKeys = _this.state.expandedKeys;
      var _this$state10 = _this.state, listChanging = _this$state10.listChanging, fieldNames = _this$state10.fieldNames;
      var _this$props8 = _this.props, onExpand = _this$props8.onExpand, loadData = _this$props8.loadData;
      var expanded = treeNode.expanded;
      var key2 = treeNode[fieldNames.key];
      if (listChanging) {
        return;
      }
      var index2 = expandedKeys.indexOf(key2);
      var targetExpanded = !expanded;
      warningOnce(expanded && index2 !== -1 || !expanded && index2 === -1, "Expand state not sync with index check");
      if (targetExpanded) {
        expandedKeys = arrAdd(expandedKeys, key2);
      } else {
        expandedKeys = arrDel(expandedKeys, key2);
      }
      _this.setExpandedKeys(expandedKeys);
      onExpand === null || onExpand === void 0 ? void 0 : onExpand(expandedKeys, {
        node: treeNode,
        expanded: targetExpanded,
        nativeEvent: e3.nativeEvent
      });
      if (targetExpanded && loadData) {
        var loadPromise = _this.onNodeLoad(treeNode);
        if (loadPromise) {
          loadPromise.then(function() {
            var newFlattenTreeData = flattenTreeData(_this.state.treeData, expandedKeys, fieldNames);
            _this.setUncontrolledState({
              flattenNodes: newFlattenTreeData
            });
          }).catch(function() {
            var currentExpandedKeys = _this.state.expandedKeys;
            var expandedKeysToRestore = arrDel(currentExpandedKeys, key2);
            _this.setExpandedKeys(expandedKeysToRestore);
          });
        }
      }
    };
    _this.onListChangeStart = function() {
      _this.setUncontrolledState({
        listChanging: true
      });
    };
    _this.onListChangeEnd = function() {
      setTimeout(function() {
        _this.setUncontrolledState({
          listChanging: false
        });
      });
    };
    _this.onActiveChange = function(newActiveKey) {
      var activeKey = _this.state.activeKey;
      var onActiveChange = _this.props.onActiveChange;
      if (activeKey === newActiveKey) {
        return;
      }
      _this.setState({
        activeKey: newActiveKey
      });
      if (newActiveKey !== null) {
        _this.scrollTo({
          key: newActiveKey
        });
      }
      onActiveChange === null || onActiveChange === void 0 ? void 0 : onActiveChange(newActiveKey);
    };
    _this.getActiveItem = function() {
      var _this$state11 = _this.state, activeKey = _this$state11.activeKey, flattenNodes = _this$state11.flattenNodes;
      if (activeKey === null) {
        return null;
      }
      return flattenNodes.find(function(_ref2) {
        var key2 = _ref2.key;
        return key2 === activeKey;
      }) || null;
    };
    _this.offsetActiveKey = function(offset3) {
      var _this$state12 = _this.state, flattenNodes = _this$state12.flattenNodes, activeKey = _this$state12.activeKey;
      var index2 = flattenNodes.findIndex(function(_ref3) {
        var key3 = _ref3.key;
        return key3 === activeKey;
      });
      if (index2 === -1 && offset3 < 0) {
        index2 = flattenNodes.length;
      }
      index2 = (index2 + offset3 + flattenNodes.length) % flattenNodes.length;
      var item = flattenNodes[index2];
      if (item) {
        var key2 = item.key;
        _this.onActiveChange(key2);
      } else {
        _this.onActiveChange(null);
      }
    };
    _this.onKeyDown = function(event) {
      var _this$state13 = _this.state, activeKey = _this$state13.activeKey, expandedKeys = _this$state13.expandedKeys, checkedKeys = _this$state13.checkedKeys, fieldNames = _this$state13.fieldNames;
      var _this$props9 = _this.props, onKeyDown2 = _this$props9.onKeyDown, checkable = _this$props9.checkable, selectable = _this$props9.selectable;
      switch (event.which) {
        case KeyCode.UP: {
          _this.offsetActiveKey(-1);
          event.preventDefault();
          break;
        }
        case KeyCode.DOWN: {
          _this.offsetActiveKey(1);
          event.preventDefault();
          break;
        }
      }
      var activeItem = _this.getActiveItem();
      if (activeItem && activeItem.data) {
        var treeNodeRequiredProps = _this.getTreeNodeRequiredProps();
        var expandable = activeItem.data.isLeaf === false || !!(activeItem.data[fieldNames.children] || []).length;
        var eventNode = convertNodePropsToEventData(_objectSpread2$1(_objectSpread2$1({}, getTreeNodeProps(activeKey, treeNodeRequiredProps)), {}, {
          data: activeItem.data,
          active: true
        }));
        switch (event.which) {
          case KeyCode.LEFT: {
            if (expandable && expandedKeys.includes(activeKey)) {
              _this.onNodeExpand({}, eventNode);
            } else if (activeItem.parent) {
              _this.onActiveChange(activeItem.parent.key);
            }
            event.preventDefault();
            break;
          }
          case KeyCode.RIGHT: {
            if (expandable && !expandedKeys.includes(activeKey)) {
              _this.onNodeExpand({}, eventNode);
            } else if (activeItem.children && activeItem.children.length) {
              _this.onActiveChange(activeItem.children[0].key);
            }
            event.preventDefault();
            break;
          }
          case KeyCode.ENTER:
          case KeyCode.SPACE: {
            if (checkable && !eventNode.disabled && eventNode.checkable !== false && !eventNode.disableCheckbox) {
              _this.onNodeCheck({}, eventNode, !checkedKeys.includes(activeKey));
            } else if (!checkable && selectable && !eventNode.disabled && eventNode.selectable !== false) {
              _this.onNodeSelect({}, eventNode);
            }
            break;
          }
        }
      }
      onKeyDown2 === null || onKeyDown2 === void 0 ? void 0 : onKeyDown2(event);
    };
    _this.setUncontrolledState = function(state2) {
      var atomic = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var forceState = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
      if (!_this.destroyed) {
        var needSync = false;
        var allPassed = true;
        var newState = {};
        Object.keys(state2).forEach(function(name) {
          if (name in _this.props) {
            allPassed = false;
            return;
          }
          needSync = true;
          newState[name] = state2[name];
        });
        if (needSync && (!atomic || allPassed)) {
          _this.setState(_objectSpread2$1(_objectSpread2$1({}, newState), forceState));
        }
      }
    };
    _this.scrollTo = function(scroll) {
      _this.listRef.current.scrollTo(scroll);
    };
    return _this;
  }
  _createClass$2(Tree2, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this.destroyed = false;
      this.onUpdated();
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate() {
      this.onUpdated();
    }
  }, {
    key: "onUpdated",
    value: function onUpdated() {
      var activeKey = this.props.activeKey;
      if (activeKey !== void 0 && activeKey !== this.state.activeKey) {
        this.setState({
          activeKey
        });
        if (activeKey !== null) {
          this.scrollTo({
            key: activeKey
          });
        }
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      window.removeEventListener("dragend", this.onWindowDragEnd);
      this.destroyed = true;
    }
  }, {
    key: "resetDragState",
    value: function resetDragState() {
      this.setState({
        dragOverNodeKey: null,
        dropPosition: null,
        dropLevelOffset: null,
        dropTargetKey: null,
        dropContainerKey: null,
        dropTargetPos: null,
        dropAllowed: false
      });
    }
  }, {
    key: "render",
    value: function render2() {
      var _classNames;
      var _this$state14 = this.state, focused = _this$state14.focused, flattenNodes = _this$state14.flattenNodes, keyEntities = _this$state14.keyEntities, draggingNodeKey = _this$state14.draggingNodeKey, activeKey = _this$state14.activeKey, dropLevelOffset = _this$state14.dropLevelOffset, dropContainerKey = _this$state14.dropContainerKey, dropTargetKey = _this$state14.dropTargetKey, dropPosition = _this$state14.dropPosition, dragOverNodeKey = _this$state14.dragOverNodeKey, indent = _this$state14.indent;
      var _this$props10 = this.props, prefixCls = _this$props10.prefixCls, className = _this$props10.className, style2 = _this$props10.style, showLine = _this$props10.showLine, focusable2 = _this$props10.focusable, _this$props10$tabInde = _this$props10.tabIndex, tabIndex = _this$props10$tabInde === void 0 ? 0 : _this$props10$tabInde, selectable = _this$props10.selectable, showIcon = _this$props10.showIcon, icon = _this$props10.icon, switcherIcon = _this$props10.switcherIcon, draggable = _this$props10.draggable, checkable = _this$props10.checkable, checkStrictly = _this$props10.checkStrictly, disabled = _this$props10.disabled, motion = _this$props10.motion, loadData = _this$props10.loadData, filterTreeNode = _this$props10.filterTreeNode, height = _this$props10.height, itemHeight = _this$props10.itemHeight, virtual = _this$props10.virtual, titleRender = _this$props10.titleRender, dropIndicatorRender2 = _this$props10.dropIndicatorRender, onContextMenu = _this$props10.onContextMenu, onScroll = _this$props10.onScroll, direction2 = _this$props10.direction, rootClassName = _this$props10.rootClassName, rootStyle = _this$props10.rootStyle;
      var domProps = pickAttrs(this.props, {
        aria: true,
        data: true
      });
      var draggableConfig;
      if (draggable) {
        if (_typeof$4(draggable) === "object") {
          draggableConfig = draggable;
        } else if (typeof draggable === "function") {
          draggableConfig = {
            nodeDraggable: draggable
          };
        } else {
          draggableConfig = {};
        }
      }
      return /* @__PURE__ */ react.exports.createElement(TreeContext.Provider, {
        value: {
          prefixCls,
          selectable,
          showIcon,
          icon,
          switcherIcon,
          draggable: draggableConfig,
          draggingNodeKey,
          checkable,
          checkStrictly,
          disabled,
          keyEntities,
          dropLevelOffset,
          dropContainerKey,
          dropTargetKey,
          dropPosition,
          dragOverNodeKey,
          indent,
          direction: direction2,
          dropIndicatorRender: dropIndicatorRender2,
          loadData,
          filterTreeNode,
          titleRender,
          onNodeClick: this.onNodeClick,
          onNodeDoubleClick: this.onNodeDoubleClick,
          onNodeExpand: this.onNodeExpand,
          onNodeSelect: this.onNodeSelect,
          onNodeCheck: this.onNodeCheck,
          onNodeLoad: this.onNodeLoad,
          onNodeMouseEnter: this.onNodeMouseEnter,
          onNodeMouseLeave: this.onNodeMouseLeave,
          onNodeContextMenu: this.onNodeContextMenu,
          onNodeDragStart: this.onNodeDragStart,
          onNodeDragEnter: this.onNodeDragEnter,
          onNodeDragOver: this.onNodeDragOver,
          onNodeDragLeave: this.onNodeDragLeave,
          onNodeDragEnd: this.onNodeDragEnd,
          onNodeDrop: this.onNodeDrop
        }
      }, /* @__PURE__ */ react.exports.createElement("div", {
        role: "tree",
        className: classNames(prefixCls, className, rootClassName, (_classNames = {}, _defineProperty$4(_classNames, "".concat(prefixCls, "-show-line"), showLine), _defineProperty$4(_classNames, "".concat(prefixCls, "-focused"), focused), _defineProperty$4(_classNames, "".concat(prefixCls, "-active-focused"), activeKey !== null), _classNames)),
        style: rootStyle
      }, /* @__PURE__ */ react.exports.createElement(NodeList, _extends$2({
        ref: this.listRef,
        prefixCls,
        style: style2,
        data: flattenNodes,
        disabled,
        selectable,
        checkable: !!checkable,
        motion,
        dragging: draggingNodeKey !== null,
        height,
        itemHeight,
        virtual,
        focusable: focusable2,
        focused,
        tabIndex,
        activeItem: this.getActiveItem(),
        onFocus: this.onFocus,
        onBlur: this.onBlur,
        onKeyDown: this.onKeyDown,
        onActiveChange: this.onActiveChange,
        onListChangeStart: this.onListChangeStart,
        onListChangeEnd: this.onListChangeEnd,
        onContextMenu,
        onScroll
      }, this.getTreeNodeRequiredProps(), domProps))));
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function getDerivedStateFromProps(props, prevState) {
      var prevProps = prevState.prevProps;
      var newState = {
        prevProps: props
      };
      function needSync(name) {
        return !prevProps && name in props || prevProps && prevProps[name] !== props[name];
      }
      var treeData;
      var fieldNames = prevState.fieldNames;
      if (needSync("fieldNames")) {
        fieldNames = fillFieldNames(props.fieldNames);
        newState.fieldNames = fieldNames;
      }
      if (needSync("treeData")) {
        treeData = props.treeData;
      } else if (needSync("children")) {
        warningOnce(false, "`children` of Tree is deprecated. Please use `treeData` instead.");
        treeData = convertTreeToData(props.children);
      }
      if (treeData) {
        newState.treeData = treeData;
        var entitiesMap = convertDataToEntities(treeData, {
          fieldNames
        });
        newState.keyEntities = _objectSpread2$1(_defineProperty$4({}, MOTION_KEY, MotionEntity), entitiesMap.keyEntities);
      }
      var keyEntities = newState.keyEntities || prevState.keyEntities;
      if (needSync("expandedKeys") || prevProps && needSync("autoExpandParent")) {
        newState.expandedKeys = props.autoExpandParent || !prevProps && props.defaultExpandParent ? conductExpandParent(props.expandedKeys, keyEntities) : props.expandedKeys;
      } else if (!prevProps && props.defaultExpandAll) {
        var cloneKeyEntities = _objectSpread2$1({}, keyEntities);
        delete cloneKeyEntities[MOTION_KEY];
        newState.expandedKeys = Object.keys(cloneKeyEntities).map(function(key2) {
          return cloneKeyEntities[key2].key;
        });
      } else if (!prevProps && props.defaultExpandedKeys) {
        newState.expandedKeys = props.autoExpandParent || props.defaultExpandParent ? conductExpandParent(props.defaultExpandedKeys, keyEntities) : props.defaultExpandedKeys;
      }
      if (!newState.expandedKeys) {
        delete newState.expandedKeys;
      }
      if (treeData || newState.expandedKeys) {
        var flattenNodes = flattenTreeData(treeData || prevState.treeData, newState.expandedKeys || prevState.expandedKeys, fieldNames);
        newState.flattenNodes = flattenNodes;
      }
      if (props.selectable) {
        if (needSync("selectedKeys")) {
          newState.selectedKeys = calcSelectedKeys(props.selectedKeys, props);
        } else if (!prevProps && props.defaultSelectedKeys) {
          newState.selectedKeys = calcSelectedKeys(props.defaultSelectedKeys, props);
        }
      }
      if (props.checkable) {
        var checkedKeyEntity;
        if (needSync("checkedKeys")) {
          checkedKeyEntity = parseCheckedKeys(props.checkedKeys) || {};
        } else if (!prevProps && props.defaultCheckedKeys) {
          checkedKeyEntity = parseCheckedKeys(props.defaultCheckedKeys) || {};
        } else if (treeData) {
          checkedKeyEntity = parseCheckedKeys(props.checkedKeys) || {
            checkedKeys: prevState.checkedKeys,
            halfCheckedKeys: prevState.halfCheckedKeys
          };
        }
        if (checkedKeyEntity) {
          var _checkedKeyEntity = checkedKeyEntity, _checkedKeyEntity$che = _checkedKeyEntity.checkedKeys, checkedKeys = _checkedKeyEntity$che === void 0 ? [] : _checkedKeyEntity$che, _checkedKeyEntity$hal = _checkedKeyEntity.halfCheckedKeys, halfCheckedKeys = _checkedKeyEntity$hal === void 0 ? [] : _checkedKeyEntity$hal;
          if (!props.checkStrictly) {
            var conductKeys = conductCheck(checkedKeys, true, keyEntities);
            checkedKeys = conductKeys.checkedKeys;
            halfCheckedKeys = conductKeys.halfCheckedKeys;
          }
          newState.checkedKeys = checkedKeys;
          newState.halfCheckedKeys = halfCheckedKeys;
        }
      }
      if (needSync("loadedKeys")) {
        newState.loadedKeys = props.loadedKeys;
      }
      return newState;
    }
  }]);
  return Tree2;
}(react.exports.Component);
Tree$3.defaultProps = {
  prefixCls: "rc-tree",
  showLine: false,
  showIcon: true,
  selectable: true,
  multiple: false,
  checkable: false,
  disabled: false,
  checkStrictly: false,
  draggable: false,
  defaultExpandParent: true,
  autoExpandParent: false,
  defaultExpandAll: false,
  defaultExpandedKeys: [],
  defaultCheckedKeys: [],
  defaultSelectedKeys: [],
  dropIndicatorRender: DropIndicator,
  allowDrop: function allowDrop() {
    return true;
  },
  expandAction: false
};
Tree$3.TreeNode = ContextTreeNode;
var FileOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M854.6 288.6L639.4 73.4c-6-6-14.1-9.4-22.6-9.4H192c-17.7 0-32 14.3-32 32v832c0 17.7 14.3 32 32 32h640c17.7 0 32-14.3 32-32V311.3c0-8.5-3.4-16.7-9.4-22.7zM790.2 326H602V137.8L790.2 326zm1.8 562H232V136h302v216a42 42 0 0042 42h216v494z" } }] }, "name": "file", "theme": "outlined" };
var FileOutlinedSvg = FileOutlined$2;
var FileOutlined = function FileOutlined2(props, ref) {
  return /* @__PURE__ */ react.exports.createElement(AntdIcon, _objectSpread2$1(_objectSpread2$1({}, props), {}, {
    ref,
    icon: FileOutlinedSvg
  }));
};
FileOutlined.displayName = "FileOutlined";
var FileOutlined$1 = /* @__PURE__ */ react.exports.forwardRef(FileOutlined);
var FolderOpenOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M928 444H820V330.4c0-17.7-14.3-32-32-32H473L355.7 186.2a8.15 8.15 0 00-5.5-2.2H96c-17.7 0-32 14.3-32 32v592c0 17.7 14.3 32 32 32h698c13 0 24.8-7.9 29.7-20l134-332c1.5-3.8 2.3-7.9 2.3-12 0-17.7-14.3-32-32-32zM136 256h188.5l119.6 114.4H748V444H238c-13 0-24.8 7.9-29.7 20L136 643.2V256zm635.3 512H159l103.3-256h612.4L771.3 768z" } }] }, "name": "folder-open", "theme": "outlined" };
var FolderOpenOutlinedSvg = FolderOpenOutlined$2;
var FolderOpenOutlined = function FolderOpenOutlined2(props, ref) {
  return /* @__PURE__ */ react.exports.createElement(AntdIcon, _objectSpread2$1(_objectSpread2$1({}, props), {}, {
    ref,
    icon: FolderOpenOutlinedSvg
  }));
};
FolderOpenOutlined.displayName = "FolderOpenOutlined";
var FolderOpenOutlined$1 = /* @__PURE__ */ react.exports.forwardRef(FolderOpenOutlined);
var FolderOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M880 298.4H521L403.7 186.2a8.15 8.15 0 00-5.5-2.2H144c-17.7 0-32 14.3-32 32v592c0 17.7 14.3 32 32 32h736c17.7 0 32-14.3 32-32V330.4c0-17.7-14.3-32-32-32zM840 768H184V256h188.5l119.6 114.4H840V768z" } }] }, "name": "folder", "theme": "outlined" };
var FolderOutlinedSvg = FolderOutlined$2;
var FolderOutlined = function FolderOutlined2(props, ref) {
  return /* @__PURE__ */ react.exports.createElement(AntdIcon, _objectSpread2$1(_objectSpread2$1({}, props), {}, {
    ref,
    icon: FolderOutlinedSvg
  }));
};
FolderOutlined.displayName = "FolderOutlined";
var FolderOutlined$1 = /* @__PURE__ */ react.exports.forwardRef(FolderOutlined);
var Record;
(function(Record2) {
  Record2[Record2["None"] = 0] = "None";
  Record2[Record2["Start"] = 1] = "Start";
  Record2[Record2["End"] = 2] = "End";
})(Record || (Record = {}));
function traverseNodesKey(treeData, callback) {
  function processNode(dataNode) {
    var key2 = dataNode.key, children = dataNode.children;
    if (callback(key2, dataNode) !== false) {
      traverseNodesKey(children || [], callback);
    }
  }
  treeData.forEach(processNode);
}
function calcRangeKeys(_ref) {
  var treeData = _ref.treeData, expandedKeys = _ref.expandedKeys, startKey = _ref.startKey, endKey = _ref.endKey;
  var keys2 = [];
  var record = Record.None;
  if (startKey && startKey === endKey) {
    return [startKey];
  }
  if (!startKey || !endKey) {
    return [];
  }
  function matchKey(key2) {
    return key2 === startKey || key2 === endKey;
  }
  traverseNodesKey(treeData, function(key2) {
    if (record === Record.End) {
      return false;
    }
    if (matchKey(key2)) {
      keys2.push(key2);
      if (record === Record.None) {
        record = Record.Start;
      } else if (record === Record.Start) {
        record = Record.End;
        return false;
      }
    } else if (record === Record.Start) {
      keys2.push(key2);
    }
    if (expandedKeys.indexOf(key2) === -1) {
      return false;
    }
    return true;
  });
  return keys2;
}
function convertDirectoryKeysToNodes(treeData, keys2) {
  var restKeys = _toConsumableArray(keys2);
  var nodes = [];
  traverseNodesKey(treeData, function(key2, node) {
    var index2 = restKeys.indexOf(key2);
    if (index2 !== -1) {
      nodes.push(node);
      restKeys.splice(index2, 1);
    }
    return !!restKeys.length;
  });
  return nodes;
}
var __rest$5 = globalThis && globalThis.__rest || function(s2, e3) {
  var t2 = {};
  for (var p2 in s2) {
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  }
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e3.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
function getIcon(props) {
  var isLeaf = props.isLeaf, expanded = props.expanded;
  if (isLeaf) {
    return /* @__PURE__ */ react.exports.createElement(FileOutlined$1, null);
  }
  return expanded ? /* @__PURE__ */ react.exports.createElement(FolderOpenOutlined$1, null) : /* @__PURE__ */ react.exports.createElement(FolderOutlined$1, null);
}
function getTreeData(_ref) {
  var treeData = _ref.treeData, children = _ref.children;
  return treeData || convertTreeToData(children);
}
var DirectoryTree = function DirectoryTree2(_a2, ref) {
  var defaultExpandAll = _a2.defaultExpandAll, defaultExpandParent = _a2.defaultExpandParent, defaultExpandedKeys = _a2.defaultExpandedKeys, props = __rest$5(_a2, ["defaultExpandAll", "defaultExpandParent", "defaultExpandedKeys"]);
  var lastSelectedKey = react.exports.useRef();
  var cachedSelectedKeys = react.exports.useRef();
  var treeRef = /* @__PURE__ */ react.exports.createRef();
  react.exports.useImperativeHandle(ref, function() {
    return treeRef.current;
  });
  var getInitExpandedKeys = function getInitExpandedKeys2() {
    var _convertDataToEntitie = convertDataToEntities(getTreeData(props)), keyEntities = _convertDataToEntitie.keyEntities;
    var initExpandedKeys;
    if (defaultExpandAll) {
      initExpandedKeys = Object.keys(keyEntities);
    } else if (defaultExpandParent) {
      initExpandedKeys = conductExpandParent(props.expandedKeys || defaultExpandedKeys || [], keyEntities);
    } else {
      initExpandedKeys = props.expandedKeys || defaultExpandedKeys;
    }
    return initExpandedKeys;
  };
  var _React$useState = react.exports.useState(props.selectedKeys || props.defaultSelectedKeys || []), _React$useState2 = _slicedToArray$4(_React$useState, 2), selectedKeys = _React$useState2[0], setSelectedKeys = _React$useState2[1];
  var _React$useState3 = react.exports.useState(getInitExpandedKeys()), _React$useState4 = _slicedToArray$4(_React$useState3, 2), expandedKeys = _React$useState4[0], setExpandedKeys = _React$useState4[1];
  react.exports.useEffect(function() {
    if ("selectedKeys" in props) {
      setSelectedKeys(props.selectedKeys);
    }
  }, [props.selectedKeys]);
  react.exports.useEffect(function() {
    if ("expandedKeys" in props) {
      setExpandedKeys(props.expandedKeys);
    }
  }, [props.expandedKeys]);
  var onExpand = function onExpand2(keys2, info) {
    var _a3;
    if (!("expandedKeys" in props)) {
      setExpandedKeys(keys2);
    }
    return (_a3 = props.onExpand) === null || _a3 === void 0 ? void 0 : _a3.call(props, keys2, info);
  };
  var onSelect = function onSelect2(keys2, event) {
    var _a3;
    var multiple = props.multiple;
    var node = event.node, nativeEvent = event.nativeEvent;
    var _node$key = node.key, key2 = _node$key === void 0 ? "" : _node$key;
    var treeData = getTreeData(props);
    var newEvent = _extends$2(_extends$2({}, event), {
      selected: true
    });
    var ctrlPick = (nativeEvent === null || nativeEvent === void 0 ? void 0 : nativeEvent.ctrlKey) || (nativeEvent === null || nativeEvent === void 0 ? void 0 : nativeEvent.metaKey);
    var shiftPick = nativeEvent === null || nativeEvent === void 0 ? void 0 : nativeEvent.shiftKey;
    var newSelectedKeys;
    if (multiple && ctrlPick) {
      newSelectedKeys = keys2;
      lastSelectedKey.current = key2;
      cachedSelectedKeys.current = newSelectedKeys;
      newEvent.selectedNodes = convertDirectoryKeysToNodes(treeData, newSelectedKeys);
    } else if (multiple && shiftPick) {
      newSelectedKeys = Array.from(new Set([].concat(_toConsumableArray(cachedSelectedKeys.current || []), _toConsumableArray(calcRangeKeys({
        treeData,
        expandedKeys,
        startKey: key2,
        endKey: lastSelectedKey.current
      })))));
      newEvent.selectedNodes = convertDirectoryKeysToNodes(treeData, newSelectedKeys);
    } else {
      newSelectedKeys = [key2];
      lastSelectedKey.current = key2;
      cachedSelectedKeys.current = newSelectedKeys;
      newEvent.selectedNodes = convertDirectoryKeysToNodes(treeData, newSelectedKeys);
    }
    (_a3 = props.onSelect) === null || _a3 === void 0 ? void 0 : _a3.call(props, newSelectedKeys, newEvent);
    if (!("selectedKeys" in props)) {
      setSelectedKeys(newSelectedKeys);
    }
  };
  var _React$useContext = react.exports.useContext(ConfigContext), getPrefixCls = _React$useContext.getPrefixCls, direction2 = _React$useContext.direction;
  var customizePrefixCls = props.prefixCls, className = props.className, otherProps = __rest$5(props, ["prefixCls", "className"]);
  var prefixCls = getPrefixCls("tree", customizePrefixCls);
  var connectClassName = classNames("".concat(prefixCls, "-directory"), _defineProperty$4({}, "".concat(prefixCls, "-directory-rtl"), direction2 === "rtl"), className);
  return /* @__PURE__ */ react.exports.createElement(Tree$2, _extends$2({
    icon: getIcon,
    ref: treeRef,
    blockNode: true
  }, otherProps, {
    prefixCls,
    className: connectClassName,
    expandedKeys,
    selectedKeys,
    onSelect,
    onExpand
  }));
};
var ForwardDirectoryTree = /* @__PURE__ */ react.exports.forwardRef(DirectoryTree);
ForwardDirectoryTree.defaultProps = {
  showIcon: true,
  expandAction: "click"
};
var DirectoryTree$1 = ForwardDirectoryTree;
var offset = 4;
function dropIndicatorRender(props) {
  var _style;
  var dropPosition = props.dropPosition, dropLevelOffset = props.dropLevelOffset, prefixCls = props.prefixCls, indent = props.indent, _props$direction = props.direction, direction2 = _props$direction === void 0 ? "ltr" : _props$direction;
  var startPosition = direction2 === "ltr" ? "left" : "right";
  var endPosition = direction2 === "ltr" ? "right" : "left";
  var style2 = (_style = {}, _defineProperty$4(_style, startPosition, -dropLevelOffset * indent + offset), _defineProperty$4(_style, endPosition, 0), _style);
  switch (dropPosition) {
    case -1:
      style2.top = -3;
      break;
    case 1:
      style2.bottom = -3;
      break;
    default:
      style2.bottom = -3;
      style2[startPosition] = indent + offset;
      break;
  }
  return /* @__PURE__ */ React.createElement("div", {
    style: style2,
    className: "".concat(prefixCls, "-drop-indicator")
  });
}
var CaretDownFilled$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "0 0 1024 1024", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M840.4 300H183.6c-19.7 0-30.7 20.8-18.5 35l328.4 380.8c9.4 10.9 27.5 10.9 37 0L858.9 335c12.2-14.2 1.2-35-18.5-35z" } }] }, "name": "caret-down", "theme": "filled" };
var CaretDownFilledSvg = CaretDownFilled$2;
var CaretDownFilled = function CaretDownFilled2(props, ref) {
  return /* @__PURE__ */ react.exports.createElement(AntdIcon, _objectSpread2$1(_objectSpread2$1({}, props), {}, {
    ref,
    icon: CaretDownFilledSvg
  }));
};
CaretDownFilled.displayName = "CaretDownFilled";
var CaretDownFilled$1 = /* @__PURE__ */ react.exports.forwardRef(CaretDownFilled);
var MinusSquareOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M328 544h368c4.4 0 8-3.6 8-8v-48c0-4.4-3.6-8-8-8H328c-4.4 0-8 3.6-8 8v48c0 4.4 3.6 8 8 8z" } }, { "tag": "path", "attrs": { "d": "M880 112H144c-17.7 0-32 14.3-32 32v736c0 17.7 14.3 32 32 32h736c17.7 0 32-14.3 32-32V144c0-17.7-14.3-32-32-32zm-40 728H184V184h656v656z" } }] }, "name": "minus-square", "theme": "outlined" };
var MinusSquareOutlinedSvg = MinusSquareOutlined$2;
var MinusSquareOutlined = function MinusSquareOutlined2(props, ref) {
  return /* @__PURE__ */ react.exports.createElement(AntdIcon, _objectSpread2$1(_objectSpread2$1({}, props), {}, {
    ref,
    icon: MinusSquareOutlinedSvg
  }));
};
MinusSquareOutlined.displayName = "MinusSquareOutlined";
var MinusSquareOutlined$1 = /* @__PURE__ */ react.exports.forwardRef(MinusSquareOutlined);
var PlusSquareOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M328 544h152v152c0 4.4 3.6 8 8 8h48c4.4 0 8-3.6 8-8V544h152c4.4 0 8-3.6 8-8v-48c0-4.4-3.6-8-8-8H544V328c0-4.4-3.6-8-8-8h-48c-4.4 0-8 3.6-8 8v152H328c-4.4 0-8 3.6-8 8v48c0 4.4 3.6 8 8 8z" } }, { "tag": "path", "attrs": { "d": "M880 112H144c-17.7 0-32 14.3-32 32v736c0 17.7 14.3 32 32 32h736c17.7 0 32-14.3 32-32V144c0-17.7-14.3-32-32-32zm-40 728H184V184h656v656z" } }] }, "name": "plus-square", "theme": "outlined" };
var PlusSquareOutlinedSvg = PlusSquareOutlined$2;
var PlusSquareOutlined = function PlusSquareOutlined2(props, ref) {
  return /* @__PURE__ */ react.exports.createElement(AntdIcon, _objectSpread2$1(_objectSpread2$1({}, props), {}, {
    ref,
    icon: PlusSquareOutlinedSvg
  }));
};
PlusSquareOutlined.displayName = "PlusSquareOutlined";
var PlusSquareOutlined$1 = /* @__PURE__ */ react.exports.forwardRef(PlusSquareOutlined);
function renderSwitcherIcon(prefixCls, switcherIcon, showLine, treeNodeProps) {
  var isLeaf = treeNodeProps.isLeaf, expanded = treeNodeProps.expanded, loading = treeNodeProps.loading;
  if (loading) {
    return /* @__PURE__ */ react.exports.createElement(LoadingOutlined$1, {
      className: "".concat(prefixCls, "-switcher-loading-icon")
    });
  }
  var showLeafIcon;
  if (showLine && _typeof$4(showLine) === "object") {
    showLeafIcon = showLine.showLeafIcon;
  }
  if (isLeaf) {
    if (!showLine) {
      return null;
    }
    if (typeof showLeafIcon !== "boolean" && !!showLeafIcon) {
      var leafIcon = typeof showLeafIcon === "function" ? showLeafIcon(treeNodeProps) : showLeafIcon;
      var leafCls = "".concat(prefixCls, "-switcher-line-custom-icon");
      if (isValidElement(leafIcon)) {
        return cloneElement(leafIcon, {
          className: classNames(leafIcon.props.className || "", leafCls)
        });
      }
      return leafIcon;
    }
    return showLeafIcon ? /* @__PURE__ */ react.exports.createElement(FileOutlined$1, {
      className: "".concat(prefixCls, "-switcher-line-icon")
    }) : /* @__PURE__ */ react.exports.createElement("span", {
      className: "".concat(prefixCls, "-switcher-leaf-line")
    });
  }
  var switcherCls = "".concat(prefixCls, "-switcher-icon");
  var switcher = typeof switcherIcon === "function" ? switcherIcon(treeNodeProps) : switcherIcon;
  if (isValidElement(switcher)) {
    return cloneElement(switcher, {
      className: classNames(switcher.props.className || "", switcherCls)
    });
  }
  if (switcher) {
    return switcher;
  }
  if (showLine) {
    return expanded ? /* @__PURE__ */ react.exports.createElement(MinusSquareOutlined$1, {
      className: "".concat(prefixCls, "-switcher-line-icon")
    }) : /* @__PURE__ */ react.exports.createElement(PlusSquareOutlined$1, {
      className: "".concat(prefixCls, "-switcher-line-icon")
    });
  }
  return /* @__PURE__ */ react.exports.createElement(CaretDownFilled$1, {
    className: switcherCls
  });
}
var Tree$1 = /* @__PURE__ */ react.exports.forwardRef(function(props, ref) {
  var _classNames;
  var _React$useContext = react.exports.useContext(ConfigContext), getPrefixCls = _React$useContext.getPrefixCls, direction2 = _React$useContext.direction, virtual = _React$useContext.virtual;
  var customizePrefixCls = props.prefixCls, className = props.className, showIcon = props.showIcon, showLine = props.showLine, _switcherIcon = props.switcherIcon, blockNode = props.blockNode, children = props.children, checkable = props.checkable, selectable = props.selectable, draggable = props.draggable;
  var prefixCls = getPrefixCls("tree", customizePrefixCls);
  var newProps = _extends$2(_extends$2({}, props), {
    showLine: Boolean(showLine),
    dropIndicatorRender
  });
  var draggableConfig = react.exports.useMemo(function() {
    if (!draggable) {
      return false;
    }
    var mergedDraggable = {};
    switch (_typeof$4(draggable)) {
      case "function":
        mergedDraggable.nodeDraggable = draggable;
        break;
      case "object":
        mergedDraggable = _extends$2({}, draggable);
        break;
    }
    if (mergedDraggable.icon !== false) {
      mergedDraggable.icon = mergedDraggable.icon || /* @__PURE__ */ react.exports.createElement(HolderOutlined$1, null);
    }
    return mergedDraggable;
  }, [draggable]);
  return /* @__PURE__ */ react.exports.createElement(Tree$3, _extends$2({
    itemHeight: 20,
    ref,
    virtual
  }, newProps, {
    prefixCls,
    className: classNames((_classNames = {}, _defineProperty$4(_classNames, "".concat(prefixCls, "-icon-hide"), !showIcon), _defineProperty$4(_classNames, "".concat(prefixCls, "-block-node"), blockNode), _defineProperty$4(_classNames, "".concat(prefixCls, "-unselectable"), !selectable), _defineProperty$4(_classNames, "".concat(prefixCls, "-rtl"), direction2 === "rtl"), _classNames), className),
    direction: direction2,
    checkable: checkable ? /* @__PURE__ */ react.exports.createElement("span", {
      className: "".concat(prefixCls, "-checkbox-inner")
    }) : checkable,
    selectable,
    switcherIcon: function switcherIcon(nodeProps) {
      return renderSwitcherIcon(prefixCls, _switcherIcon, showLine, nodeProps);
    },
    draggable: draggableConfig
  }), children);
});
Tree$1.TreeNode = ContextTreeNode;
Tree$1.DirectoryTree = DirectoryTree$1;
Tree$1.defaultProps = {
  checkable: false,
  selectable: true,
  showIcon: false,
  motion: _extends$2(_extends$2({}, collapseMotion), {
    motionAppear: false
  }),
  blockNode: false
};
var Tree$2 = Tree$1;
function useSyncState(initialValue) {
  var ref = react.exports.useRef(initialValue);
  var forceUpdate = useForceUpdate();
  return [function() {
    return ref.current;
  }, function(newValue) {
    ref.current = newValue;
    forceUpdate();
  }];
}
function FilterSearch(_ref) {
  var value2 = _ref.value, onChange2 = _ref.onChange, filterSearch = _ref.filterSearch, tablePrefixCls = _ref.tablePrefixCls, locale2 = _ref.locale;
  if (!filterSearch) {
    return null;
  }
  return /* @__PURE__ */ react.exports.createElement("div", {
    className: "".concat(tablePrefixCls, "-filter-dropdown-search")
  }, /* @__PURE__ */ react.exports.createElement(Input$1, {
    prefix: /* @__PURE__ */ react.exports.createElement(SearchOutlined$1, null),
    placeholder: locale2.filterSearchPlaceholder,
    onChange: onChange2,
    value: value2,
    htmlSize: 1,
    className: "".concat(tablePrefixCls, "-filter-dropdown-search-input")
  }));
}
var FilterDropdownMenuWrapper = function FilterDropdownMenuWrapper2(props) {
  return /* @__PURE__ */ react.exports.createElement("div", {
    className: props.className,
    onClick: function onClick(e3) {
      return e3.stopPropagation();
    }
  }, props.children);
};
var FilterDropdownMenuWrapper$1 = FilterDropdownMenuWrapper;
function hasSubMenu(filters) {
  return filters.some(function(_ref) {
    var children = _ref.children;
    return children;
  });
}
function searchValueMatched(searchValue, text2) {
  if (typeof text2 === "string" || typeof text2 === "number") {
    return text2 === null || text2 === void 0 ? void 0 : text2.toString().toLowerCase().includes(searchValue.trim().toLowerCase());
  }
  return false;
}
function renderFilterItems(_ref2) {
  var filters = _ref2.filters, prefixCls = _ref2.prefixCls, filteredKeys = _ref2.filteredKeys, filterMultiple = _ref2.filterMultiple, searchValue = _ref2.searchValue, filterSearch = _ref2.filterSearch;
  return filters.map(function(filter3, index2) {
    var key2 = String(filter3.value);
    if (filter3.children) {
      return {
        key: key2 || index2,
        label: filter3.text,
        popupClassName: "".concat(prefixCls, "-dropdown-submenu"),
        children: renderFilterItems({
          filters: filter3.children,
          prefixCls,
          filteredKeys,
          filterMultiple,
          searchValue,
          filterSearch
        })
      };
    }
    var Component2 = filterMultiple ? Checkbox$1 : Radio$1;
    var item = {
      key: filter3.value !== void 0 ? key2 : index2,
      label: /* @__PURE__ */ react.exports.createElement(react.exports.Fragment, null, /* @__PURE__ */ react.exports.createElement(Component2, {
        checked: filteredKeys.includes(key2)
      }), /* @__PURE__ */ react.exports.createElement("span", null, filter3.text))
    };
    if (searchValue.trim()) {
      if (typeof filterSearch === "function") {
        return filterSearch(searchValue, filter3) ? item : null;
      }
      return searchValueMatched(searchValue, filter3.text) ? item : null;
    }
    return item;
  });
}
function FilterDropdown(props) {
  var _a2;
  var tablePrefixCls = props.tablePrefixCls, prefixCls = props.prefixCls, column = props.column, dropdownPrefixCls = props.dropdownPrefixCls, columnKey = props.columnKey, filterMultiple = props.filterMultiple, _props$filterMode = props.filterMode, filterMode = _props$filterMode === void 0 ? "menu" : _props$filterMode, _props$filterSearch = props.filterSearch, filterSearch = _props$filterSearch === void 0 ? false : _props$filterSearch, filterState = props.filterState, triggerFilter = props.triggerFilter, locale2 = props.locale, children = props.children, getPopupContainer = props.getPopupContainer;
  var filterDropdownOpen = column.filterDropdownOpen, onFilterDropdownOpenChange = column.onFilterDropdownOpenChange, filterDropdownVisible = column.filterDropdownVisible, onFilterDropdownVisibleChange = column.onFilterDropdownVisibleChange, filterResetToDefaultFilteredValue = column.filterResetToDefaultFilteredValue, defaultFilteredValue = column.defaultFilteredValue;
  var _React$useState = react.exports.useState(false), _React$useState2 = _slicedToArray$4(_React$useState, 2), visible = _React$useState2[0], setVisible = _React$useState2[1];
  var filtered = !!(filterState && (((_a2 = filterState.filteredKeys) === null || _a2 === void 0 ? void 0 : _a2.length) || filterState.forceFiltered));
  var triggerVisible = function triggerVisible2(newVisible) {
    setVisible(newVisible);
    onFilterDropdownOpenChange === null || onFilterDropdownOpenChange === void 0 ? void 0 : onFilterDropdownOpenChange(newVisible);
    onFilterDropdownVisibleChange === null || onFilterDropdownVisibleChange === void 0 ? void 0 : onFilterDropdownVisibleChange(newVisible);
  };
  var mergedVisible;
  if (typeof filterDropdownOpen === "boolean") {
    mergedVisible = filterDropdownOpen;
  } else {
    mergedVisible = typeof filterDropdownVisible === "boolean" ? filterDropdownVisible : visible;
  }
  var propFilteredKeys = filterState === null || filterState === void 0 ? void 0 : filterState.filteredKeys;
  var _useSyncState = useSyncState(propFilteredKeys || []), _useSyncState2 = _slicedToArray$4(_useSyncState, 2), getFilteredKeysSync = _useSyncState2[0], setFilteredKeysSync = _useSyncState2[1];
  var onSelectKeys = function onSelectKeys2(_ref3) {
    var selectedKeys2 = _ref3.selectedKeys;
    setFilteredKeysSync(selectedKeys2);
  };
  var onCheck = function onCheck2(keys2, _ref4) {
    var node = _ref4.node, checked = _ref4.checked;
    if (!filterMultiple) {
      onSelectKeys({
        selectedKeys: checked && node.key ? [node.key] : []
      });
    } else {
      onSelectKeys({
        selectedKeys: keys2
      });
    }
  };
  react.exports.useEffect(function() {
    if (!visible) {
      return;
    }
    onSelectKeys({
      selectedKeys: propFilteredKeys || []
    });
  }, [propFilteredKeys]);
  var _React$useState3 = react.exports.useState([]), _React$useState4 = _slicedToArray$4(_React$useState3, 2), openKeys = _React$useState4[0], setOpenKeys = _React$useState4[1];
  var onOpenChange = function onOpenChange2(keys2) {
    setOpenKeys(keys2);
  };
  var _React$useState5 = react.exports.useState(""), _React$useState6 = _slicedToArray$4(_React$useState5, 2), searchValue = _React$useState6[0], setSearchValue = _React$useState6[1];
  var onSearch = function onSearch2(e3) {
    var value2 = e3.target.value;
    setSearchValue(value2);
  };
  react.exports.useEffect(function() {
    if (!visible) {
      setSearchValue("");
    }
  }, [visible]);
  var internalTriggerFilter = function internalTriggerFilter2(keys2) {
    var mergedKeys = keys2 && keys2.length ? keys2 : null;
    if (mergedKeys === null && (!filterState || !filterState.filteredKeys)) {
      return null;
    }
    if (isEqual_1(mergedKeys, filterState === null || filterState === void 0 ? void 0 : filterState.filteredKeys)) {
      return null;
    }
    triggerFilter({
      column,
      key: columnKey,
      filteredKeys: mergedKeys
    });
  };
  var onConfirm = function onConfirm2() {
    triggerVisible(false);
    internalTriggerFilter(getFilteredKeysSync());
  };
  var onReset = function onReset2() {
    var _ref5 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
      confirm: false,
      closeDropdown: false
    }, confirm = _ref5.confirm, closeDropdown = _ref5.closeDropdown;
    if (confirm) {
      internalTriggerFilter([]);
    }
    if (closeDropdown) {
      triggerVisible(false);
    }
    setSearchValue("");
    if (filterResetToDefaultFilteredValue) {
      setFilteredKeysSync((defaultFilteredValue || []).map(function(key2) {
        return String(key2);
      }));
    } else {
      setFilteredKeysSync([]);
    }
  };
  var doFilter = function doFilter2() {
    var _ref6 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
      closeDropdown: true
    }, closeDropdown = _ref6.closeDropdown;
    if (closeDropdown) {
      triggerVisible(false);
    }
    internalTriggerFilter(getFilteredKeysSync());
  };
  var onVisibleChange = function onVisibleChange2(newVisible) {
    if (newVisible && propFilteredKeys !== void 0) {
      setFilteredKeysSync(propFilteredKeys || []);
    }
    triggerVisible(newVisible);
    if (!newVisible && !column.filterDropdown) {
      onConfirm();
    }
  };
  var dropdownMenuClass = classNames(_defineProperty$4({}, "".concat(dropdownPrefixCls, "-menu-without-submenu"), !hasSubMenu(column.filters || [])));
  var onCheckAll = function onCheckAll2(e3) {
    if (e3.target.checked) {
      var allFilterKeys = flattenKeys(column === null || column === void 0 ? void 0 : column.filters).map(function(key2) {
        return String(key2);
      });
      setFilteredKeysSync(allFilterKeys);
    } else {
      setFilteredKeysSync([]);
    }
  };
  var getTreeData2 = function getTreeData3(_ref7) {
    var filters = _ref7.filters;
    return (filters || []).map(function(filter3, index2) {
      var key2 = String(filter3.value);
      var item = {
        title: filter3.text,
        key: filter3.value !== void 0 ? key2 : index2
      };
      if (filter3.children) {
        item.children = getTreeData3({
          filters: filter3.children
        });
      }
      return item;
    });
  };
  var getFilterData2 = function getFilterData3(node) {
    var _a3;
    return _extends$2(_extends$2({}, node), {
      text: node.title,
      value: node.key,
      children: ((_a3 = node.children) === null || _a3 === void 0 ? void 0 : _a3.map(function(item) {
        return getFilterData3(item);
      })) || []
    });
  };
  var dropdownContent;
  if (typeof column.filterDropdown === "function") {
    dropdownContent = column.filterDropdown({
      prefixCls: "".concat(dropdownPrefixCls, "-custom"),
      setSelectedKeys: function setSelectedKeys(selectedKeys2) {
        return onSelectKeys({
          selectedKeys: selectedKeys2
        });
      },
      selectedKeys: getFilteredKeysSync(),
      confirm: doFilter,
      clearFilters: onReset,
      filters: column.filters,
      visible: mergedVisible
    });
  } else if (column.filterDropdown) {
    dropdownContent = column.filterDropdown;
  } else {
    var selectedKeys = getFilteredKeysSync() || [];
    var getFilterComponent = function getFilterComponent2() {
      if ((column.filters || []).length === 0) {
        return /* @__PURE__ */ react.exports.createElement(Empty$1, {
          image: Empty$1.PRESENTED_IMAGE_SIMPLE,
          description: locale2.filterEmptyText,
          imageStyle: {
            height: 24
          },
          style: {
            margin: 0,
            padding: "16px 0"
          }
        });
      }
      if (filterMode === "tree") {
        return /* @__PURE__ */ react.exports.createElement(react.exports.Fragment, null, /* @__PURE__ */ react.exports.createElement(FilterSearch, {
          filterSearch,
          value: searchValue,
          onChange: onSearch,
          tablePrefixCls,
          locale: locale2
        }), /* @__PURE__ */ react.exports.createElement("div", {
          className: "".concat(tablePrefixCls, "-filter-dropdown-tree")
        }, filterMultiple ? /* @__PURE__ */ react.exports.createElement(Checkbox$1, {
          checked: selectedKeys.length === flattenKeys(column.filters).length,
          indeterminate: selectedKeys.length > 0 && selectedKeys.length < flattenKeys(column.filters).length,
          className: "".concat(tablePrefixCls, "-filter-dropdown-checkall"),
          onChange: onCheckAll
        }, locale2.filterCheckall) : null, /* @__PURE__ */ react.exports.createElement(Tree$2, {
          checkable: true,
          selectable: false,
          blockNode: true,
          multiple: filterMultiple,
          checkStrictly: !filterMultiple,
          className: "".concat(dropdownPrefixCls, "-menu"),
          onCheck,
          checkedKeys: selectedKeys,
          selectedKeys,
          showIcon: false,
          treeData: getTreeData2({
            filters: column.filters
          }),
          autoExpandParent: true,
          defaultExpandAll: true,
          filterTreeNode: searchValue.trim() ? function(node) {
            if (typeof filterSearch === "function") {
              return filterSearch(searchValue, getFilterData2(node));
            }
            return searchValueMatched(searchValue, node.title);
          } : void 0
        })));
      }
      return /* @__PURE__ */ react.exports.createElement(react.exports.Fragment, null, /* @__PURE__ */ react.exports.createElement(FilterSearch, {
        filterSearch,
        value: searchValue,
        onChange: onSearch,
        tablePrefixCls,
        locale: locale2
      }), /* @__PURE__ */ react.exports.createElement(Menu$1, {
        selectable: true,
        multiple: filterMultiple,
        prefixCls: "".concat(dropdownPrefixCls, "-menu"),
        className: dropdownMenuClass,
        onSelect: onSelectKeys,
        onDeselect: onSelectKeys,
        selectedKeys,
        getPopupContainer,
        openKeys,
        onOpenChange,
        items: renderFilterItems({
          filters: column.filters || [],
          filterSearch,
          prefixCls,
          filteredKeys: getFilteredKeysSync(),
          filterMultiple,
          searchValue
        })
      }));
    };
    var getResetDisabled = function getResetDisabled2() {
      if (filterResetToDefaultFilteredValue) {
        return isEqual_1((defaultFilteredValue || []).map(function(key2) {
          return String(key2);
        }), selectedKeys);
      }
      return selectedKeys.length === 0;
    };
    dropdownContent = /* @__PURE__ */ react.exports.createElement(react.exports.Fragment, null, getFilterComponent(), /* @__PURE__ */ react.exports.createElement("div", {
      className: "".concat(prefixCls, "-dropdown-btns")
    }, /* @__PURE__ */ react.exports.createElement(Button$2, {
      type: "link",
      size: "small",
      disabled: getResetDisabled(),
      onClick: function onClick() {
        return onReset();
      }
    }, locale2.filterReset), /* @__PURE__ */ react.exports.createElement(Button$2, {
      type: "primary",
      size: "small",
      onClick: onConfirm
    }, locale2.filterConfirm)));
  }
  if (column.filterDropdown) {
    dropdownContent = /* @__PURE__ */ react.exports.createElement(OverrideProvider, {
      selectable: void 0
    }, dropdownContent);
  }
  var menu = /* @__PURE__ */ react.exports.createElement(FilterDropdownMenuWrapper$1, {
    className: "".concat(prefixCls, "-dropdown")
  }, dropdownContent);
  var filterIcon;
  if (typeof column.filterIcon === "function") {
    filterIcon = column.filterIcon(filtered);
  } else if (column.filterIcon) {
    filterIcon = column.filterIcon;
  } else {
    filterIcon = /* @__PURE__ */ react.exports.createElement(FilterFilled$1, null);
  }
  var _React$useContext = react.exports.useContext(ConfigContext), direction2 = _React$useContext.direction;
  return /* @__PURE__ */ react.exports.createElement("div", {
    className: "".concat(prefixCls, "-column")
  }, /* @__PURE__ */ react.exports.createElement("span", {
    className: "".concat(tablePrefixCls, "-column-title")
  }, children), /* @__PURE__ */ react.exports.createElement(Dropdown$1, {
    overlay: menu,
    trigger: ["click"],
    open: mergedVisible,
    onOpenChange: onVisibleChange,
    getPopupContainer,
    placement: direction2 === "rtl" ? "bottomLeft" : "bottomRight"
  }, /* @__PURE__ */ react.exports.createElement("span", {
    role: "button",
    tabIndex: -1,
    className: classNames("".concat(prefixCls, "-trigger"), {
      active: filtered
    }),
    onClick: function onClick(e3) {
      e3.stopPropagation();
    }
  }, filterIcon)));
}
function collectFilterStates(columns2, init, pos) {
  var filterStates = [];
  (columns2 || []).forEach(function(column, index2) {
    var _a2;
    var columnPos = getColumnPos(index2, pos);
    if (column.filters || "filterDropdown" in column || "onFilter" in column) {
      if ("filteredValue" in column) {
        var filteredValues = column.filteredValue;
        if (!("filterDropdown" in column)) {
          filteredValues = (_a2 = filteredValues === null || filteredValues === void 0 ? void 0 : filteredValues.map(String)) !== null && _a2 !== void 0 ? _a2 : filteredValues;
        }
        filterStates.push({
          column,
          key: getColumnKey(column, columnPos),
          filteredKeys: filteredValues,
          forceFiltered: column.filtered
        });
      } else {
        filterStates.push({
          column,
          key: getColumnKey(column, columnPos),
          filteredKeys: init && column.defaultFilteredValue ? column.defaultFilteredValue : void 0,
          forceFiltered: column.filtered
        });
      }
    }
    if ("children" in column) {
      filterStates = [].concat(_toConsumableArray(filterStates), _toConsumableArray(collectFilterStates(column.children, init, columnPos)));
    }
  });
  return filterStates;
}
function injectFilter(prefixCls, dropdownPrefixCls, columns2, filterStates, triggerFilter, getPopupContainer, locale2, pos) {
  return columns2.map(function(column, index2) {
    var columnPos = getColumnPos(index2, pos);
    var _column$filterMultipl = column.filterMultiple, filterMultiple = _column$filterMultipl === void 0 ? true : _column$filterMultipl, filterMode = column.filterMode, filterSearch = column.filterSearch;
    var newColumn = column;
    if (newColumn.filters || newColumn.filterDropdown) {
      var columnKey = getColumnKey(newColumn, columnPos);
      var filterState = filterStates.find(function(_ref) {
        var key2 = _ref.key;
        return columnKey === key2;
      });
      newColumn = _extends$2(_extends$2({}, newColumn), {
        title: function title(renderProps) {
          return /* @__PURE__ */ react.exports.createElement(FilterDropdown, {
            tablePrefixCls: prefixCls,
            prefixCls: "".concat(prefixCls, "-filter"),
            dropdownPrefixCls,
            column: newColumn,
            columnKey,
            filterState,
            filterMultiple,
            filterMode,
            filterSearch,
            triggerFilter,
            locale: locale2,
            getPopupContainer
          }, renderColumnTitle(column.title, renderProps));
        }
      });
    }
    if ("children" in newColumn) {
      newColumn = _extends$2(_extends$2({}, newColumn), {
        children: injectFilter(prefixCls, dropdownPrefixCls, newColumn.children, filterStates, triggerFilter, getPopupContainer, locale2, columnPos)
      });
    }
    return newColumn;
  });
}
function flattenKeys(filters) {
  var keys2 = [];
  (filters || []).forEach(function(_ref2) {
    var value2 = _ref2.value, children = _ref2.children;
    keys2.push(value2);
    if (children) {
      keys2 = [].concat(_toConsumableArray(keys2), _toConsumableArray(flattenKeys(children)));
    }
  });
  return keys2;
}
function generateFilterInfo(filterStates) {
  var currentFilters = {};
  filterStates.forEach(function(_ref3) {
    var key2 = _ref3.key, filteredKeys = _ref3.filteredKeys, column = _ref3.column;
    var filters = column.filters, filterDropdown = column.filterDropdown;
    if (filterDropdown) {
      currentFilters[key2] = filteredKeys || null;
    } else if (Array.isArray(filteredKeys)) {
      var keys2 = flattenKeys(filters);
      currentFilters[key2] = keys2.filter(function(originKey) {
        return filteredKeys.includes(String(originKey));
      });
    } else {
      currentFilters[key2] = null;
    }
  });
  return currentFilters;
}
function getFilterData(data2, filterStates) {
  return filterStates.reduce(function(currentData, filterState) {
    var _filterState$column = filterState.column, onFilter = _filterState$column.onFilter, filters = _filterState$column.filters, filteredKeys = filterState.filteredKeys;
    if (onFilter && filteredKeys && filteredKeys.length) {
      return currentData.filter(function(record) {
        return filteredKeys.some(function(key2) {
          var keys2 = flattenKeys(filters);
          var keyIndex = keys2.findIndex(function(k2) {
            return String(k2) === String(key2);
          });
          var realKey = keyIndex !== -1 ? keys2[keyIndex] : key2;
          return onFilter(realKey, record);
        });
      });
    }
    return currentData;
  }, data2);
}
function useFilter(_ref4) {
  var prefixCls = _ref4.prefixCls, dropdownPrefixCls = _ref4.dropdownPrefixCls, mergedColumns = _ref4.mergedColumns, onFilterChange = _ref4.onFilterChange, getPopupContainer = _ref4.getPopupContainer, tableLocale = _ref4.locale;
  var _React$useState = react.exports.useState(collectFilterStates(mergedColumns, true)), _React$useState2 = _slicedToArray$4(_React$useState, 2), filterStates = _React$useState2[0], setFilterStates = _React$useState2[1];
  var mergedFilterStates = react.exports.useMemo(function() {
    var collectedStates = collectFilterStates(mergedColumns, false);
    var filteredKeysIsAllNotControlled = true;
    collectedStates.forEach(function(_ref5) {
      var filteredKeys = _ref5.filteredKeys;
      if (filteredKeys !== void 0) {
        filteredKeysIsAllNotControlled = false;
      }
    });
    if (filteredKeysIsAllNotControlled) {
      return filterStates;
    }
    return collectedStates;
  }, [mergedColumns, filterStates]);
  var filters = react.exports.useMemo(function() {
    return generateFilterInfo(mergedFilterStates);
  }, [mergedFilterStates]);
  var triggerFilter = function triggerFilter2(filterState) {
    var newFilterStates = mergedFilterStates.filter(function(_ref6) {
      var key2 = _ref6.key;
      return key2 !== filterState.key;
    });
    newFilterStates.push(filterState);
    setFilterStates(newFilterStates);
    onFilterChange(generateFilterInfo(newFilterStates), newFilterStates);
  };
  var transformColumns = function transformColumns2(innerColumns) {
    return injectFilter(prefixCls, dropdownPrefixCls, innerColumns, mergedFilterStates, triggerFilter, getPopupContainer, tableLocale);
  };
  return [transformColumns, mergedFilterStates, filters];
}
function useLazyKVMap(data2, childrenColumnName, getRowKey) {
  var mapCacheRef = react.exports.useRef({});
  function getRecordByKey(key2) {
    if (!mapCacheRef.current || mapCacheRef.current.data !== data2 || mapCacheRef.current.childrenColumnName !== childrenColumnName || mapCacheRef.current.getRowKey !== getRowKey) {
      let dig2 = function(records) {
        records.forEach(function(record, index2) {
          var rowKey = getRowKey(record, index2);
          kvMap.set(rowKey, record);
          if (record && _typeof$4(record) === "object" && childrenColumnName in record) {
            dig2(record[childrenColumnName] || []);
          }
        });
      };
      var dig = dig2;
      var kvMap = /* @__PURE__ */ new Map();
      dig2(data2);
      mapCacheRef.current = {
        data: data2,
        childrenColumnName,
        kvMap,
        getRowKey
      };
    }
    return mapCacheRef.current.kvMap.get(key2);
  }
  return [getRecordByKey];
}
var __rest$4 = globalThis && globalThis.__rest || function(s2, e3) {
  var t2 = {};
  for (var p2 in s2) {
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  }
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e3.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
var DEFAULT_PAGE_SIZE = 10;
function getPaginationParam(pagination, mergedPagination) {
  var param = {
    current: mergedPagination.current,
    pageSize: mergedPagination.pageSize
  };
  var paginationObj = pagination && _typeof$4(pagination) === "object" ? pagination : {};
  Object.keys(paginationObj).forEach(function(pageProp) {
    var value2 = mergedPagination[pageProp];
    if (typeof value2 !== "function") {
      param[pageProp] = value2;
    }
  });
  return param;
}
function extendsObject() {
  var result = {};
  for (var _len = arguments.length, list = new Array(_len), _key = 0; _key < _len; _key++) {
    list[_key] = arguments[_key];
  }
  list.forEach(function(obj) {
    if (obj) {
      Object.keys(obj).forEach(function(key2) {
        var val = obj[key2];
        if (val !== void 0) {
          result[key2] = val;
        }
      });
    }
  });
  return result;
}
function usePagination(total, pagination, onChange2) {
  var _a2 = pagination && _typeof$4(pagination) === "object" ? pagination : {}, _a$total = _a2.total, paginationTotal = _a$total === void 0 ? 0 : _a$total, paginationObj = __rest$4(_a2, ["total"]);
  var _useState = react.exports.useState(function() {
    return {
      current: "defaultCurrent" in paginationObj ? paginationObj.defaultCurrent : 1,
      pageSize: "defaultPageSize" in paginationObj ? paginationObj.defaultPageSize : DEFAULT_PAGE_SIZE
    };
  }), _useState2 = _slicedToArray$4(_useState, 2), innerPagination = _useState2[0], setInnerPagination = _useState2[1];
  var mergedPagination = extendsObject(innerPagination, paginationObj, {
    total: paginationTotal > 0 ? paginationTotal : total
  });
  var maxPage = Math.ceil((paginationTotal || total) / mergedPagination.pageSize);
  if (mergedPagination.current > maxPage) {
    mergedPagination.current = maxPage || 1;
  }
  var refreshPagination = function refreshPagination2(current, pageSize) {
    setInnerPagination({
      current: current !== null && current !== void 0 ? current : 1,
      pageSize: pageSize || mergedPagination.pageSize
    });
  };
  var onInternalChange = function onInternalChange2(current, pageSize) {
    var _a3;
    if (pagination) {
      (_a3 = pagination.onChange) === null || _a3 === void 0 ? void 0 : _a3.call(pagination, current, pageSize);
    }
    refreshPagination(current, pageSize);
    onChange2(current, pageSize || (mergedPagination === null || mergedPagination === void 0 ? void 0 : mergedPagination.pageSize));
  };
  if (pagination === false) {
    return [{}, function() {
    }];
  }
  return [_extends$2(_extends$2({}, mergedPagination), {
    onChange: onInternalChange
  }), refreshPagination];
}
var SELECTION_COLUMN = {};
var SELECTION_ALL = "SELECT_ALL";
var SELECTION_INVERT = "SELECT_INVERT";
var SELECTION_NONE = "SELECT_NONE";
var EMPTY_LIST$1 = [];
function flattenData(data2, childrenColumnName) {
  var list = [];
  (data2 || []).forEach(function(record) {
    list.push(record);
    if (record && _typeof$4(record) === "object" && childrenColumnName in record) {
      list = [].concat(_toConsumableArray(list), _toConsumableArray(flattenData(record[childrenColumnName], childrenColumnName)));
    }
  });
  return list;
}
function useSelection(rowSelection, config) {
  var _ref = rowSelection || {}, preserveSelectedRowKeys = _ref.preserveSelectedRowKeys, selectedRowKeys = _ref.selectedRowKeys, defaultSelectedRowKeys = _ref.defaultSelectedRowKeys, getCheckboxProps = _ref.getCheckboxProps, onSelectionChange = _ref.onChange, onSelect = _ref.onSelect, onSelectAll = _ref.onSelectAll, onSelectInvert = _ref.onSelectInvert, onSelectNone = _ref.onSelectNone, onSelectMultiple = _ref.onSelectMultiple, selectionColWidth = _ref.columnWidth, selectionType = _ref.type, selections = _ref.selections, fixed = _ref.fixed, customizeRenderCell = _ref.renderCell, hideSelectAll = _ref.hideSelectAll, _ref$checkStrictly = _ref.checkStrictly, checkStrictly = _ref$checkStrictly === void 0 ? true : _ref$checkStrictly;
  var prefixCls = config.prefixCls, data2 = config.data, pageData = config.pageData, getRecordByKey = config.getRecordByKey, getRowKey = config.getRowKey, expandType = config.expandType, childrenColumnName = config.childrenColumnName, tableLocale = config.locale, getPopupContainer = config.getPopupContainer;
  var _useMergedState = useMergedState(selectedRowKeys || defaultSelectedRowKeys || EMPTY_LIST$1, {
    value: selectedRowKeys
  }), _useMergedState2 = _slicedToArray$4(_useMergedState, 2), mergedSelectedKeys = _useMergedState2[0], setMergedSelectedKeys = _useMergedState2[1];
  var preserveRecordsRef = react.exports.useRef(/* @__PURE__ */ new Map());
  var updatePreserveRecordsCache = react.exports.useCallback(function(keys2) {
    if (preserveSelectedRowKeys) {
      var newCache = /* @__PURE__ */ new Map();
      keys2.forEach(function(key2) {
        var record = getRecordByKey(key2);
        if (!record && preserveRecordsRef.current.has(key2)) {
          record = preserveRecordsRef.current.get(key2);
        }
        newCache.set(key2, record);
      });
      preserveRecordsRef.current = newCache;
    }
  }, [getRecordByKey, preserveSelectedRowKeys]);
  react.exports.useEffect(function() {
    updatePreserveRecordsCache(mergedSelectedKeys);
  }, [mergedSelectedKeys]);
  var _useMemo = react.exports.useMemo(function() {
    return checkStrictly ? {
      keyEntities: null
    } : convertDataToEntities(data2, {
      externalGetKey: getRowKey,
      childrenPropName: childrenColumnName
    });
  }, [data2, getRowKey, checkStrictly, childrenColumnName]), keyEntities = _useMemo.keyEntities;
  var flattedData = react.exports.useMemo(function() {
    return flattenData(pageData, childrenColumnName);
  }, [pageData, childrenColumnName]);
  var checkboxPropsMap = react.exports.useMemo(function() {
    var map2 = /* @__PURE__ */ new Map();
    flattedData.forEach(function(record, index2) {
      var key2 = getRowKey(record, index2);
      var checkboxProps = (getCheckboxProps ? getCheckboxProps(record) : null) || {};
      map2.set(key2, checkboxProps);
    });
    return map2;
  }, [flattedData, getRowKey, getCheckboxProps]);
  var isCheckboxDisabled = react.exports.useCallback(function(r2) {
    var _a2;
    return !!((_a2 = checkboxPropsMap.get(getRowKey(r2))) === null || _a2 === void 0 ? void 0 : _a2.disabled);
  }, [checkboxPropsMap, getRowKey]);
  var _useMemo2 = react.exports.useMemo(function() {
    if (checkStrictly) {
      return [mergedSelectedKeys || [], []];
    }
    var _conductCheck = conductCheck(mergedSelectedKeys, true, keyEntities, isCheckboxDisabled), checkedKeys = _conductCheck.checkedKeys, halfCheckedKeys = _conductCheck.halfCheckedKeys;
    return [checkedKeys || [], halfCheckedKeys];
  }, [mergedSelectedKeys, checkStrictly, keyEntities, isCheckboxDisabled]), _useMemo3 = _slicedToArray$4(_useMemo2, 2), derivedSelectedKeys = _useMemo3[0], derivedHalfSelectedKeys = _useMemo3[1];
  var derivedSelectedKeySet = react.exports.useMemo(function() {
    var keys2 = selectionType === "radio" ? derivedSelectedKeys.slice(0, 1) : derivedSelectedKeys;
    return new Set(keys2);
  }, [derivedSelectedKeys, selectionType]);
  var derivedHalfSelectedKeySet = react.exports.useMemo(function() {
    return selectionType === "radio" ? /* @__PURE__ */ new Set() : new Set(derivedHalfSelectedKeys);
  }, [derivedHalfSelectedKeys, selectionType]);
  var _useState = react.exports.useState(null), _useState2 = _slicedToArray$4(_useState, 2), lastSelectedKey = _useState2[0], setLastSelectedKey = _useState2[1];
  react.exports.useEffect(function() {
    if (!rowSelection) {
      setMergedSelectedKeys(EMPTY_LIST$1);
    }
  }, [!!rowSelection]);
  var setSelectedKeys = react.exports.useCallback(function(keys2, method4) {
    var availableKeys;
    var records;
    updatePreserveRecordsCache(keys2);
    if (preserveSelectedRowKeys) {
      availableKeys = keys2;
      records = keys2.map(function(key2) {
        return preserveRecordsRef.current.get(key2);
      });
    } else {
      availableKeys = [];
      records = [];
      keys2.forEach(function(key2) {
        var record = getRecordByKey(key2);
        if (record !== void 0) {
          availableKeys.push(key2);
          records.push(record);
        }
      });
    }
    setMergedSelectedKeys(availableKeys);
    onSelectionChange === null || onSelectionChange === void 0 ? void 0 : onSelectionChange(availableKeys, records, {
      type: method4
    });
  }, [setMergedSelectedKeys, getRecordByKey, onSelectionChange, preserveSelectedRowKeys]);
  var triggerSingleSelection = react.exports.useCallback(function(key2, selected, keys2, event) {
    if (onSelect) {
      var rows = keys2.map(function(k2) {
        return getRecordByKey(k2);
      });
      onSelect(getRecordByKey(key2), selected, rows, event);
    }
    setSelectedKeys(keys2, "single");
  }, [onSelect, getRecordByKey, setSelectedKeys]);
  var mergedSelections = react.exports.useMemo(function() {
    if (!selections || hideSelectAll) {
      return null;
    }
    var selectionList = selections === true ? [SELECTION_ALL, SELECTION_INVERT, SELECTION_NONE] : selections;
    return selectionList.map(function(selection) {
      if (selection === SELECTION_ALL) {
        return {
          key: "all",
          text: tableLocale.selectionAll,
          onSelect: function onSelect2() {
            setSelectedKeys(data2.map(function(record, index2) {
              return getRowKey(record, index2);
            }).filter(function(key2) {
              var checkProps = checkboxPropsMap.get(key2);
              return !(checkProps === null || checkProps === void 0 ? void 0 : checkProps.disabled) || derivedSelectedKeySet.has(key2);
            }), "all");
          }
        };
      }
      if (selection === SELECTION_INVERT) {
        return {
          key: "invert",
          text: tableLocale.selectInvert,
          onSelect: function onSelect2() {
            var keySet = new Set(derivedSelectedKeySet);
            pageData.forEach(function(record, index2) {
              var key2 = getRowKey(record, index2);
              var checkProps = checkboxPropsMap.get(key2);
              if (!(checkProps === null || checkProps === void 0 ? void 0 : checkProps.disabled)) {
                if (keySet.has(key2)) {
                  keySet["delete"](key2);
                } else {
                  keySet.add(key2);
                }
              }
            });
            var keys2 = Array.from(keySet);
            if (onSelectInvert) {
              onSelectInvert(keys2);
            }
            setSelectedKeys(keys2, "invert");
          }
        };
      }
      if (selection === SELECTION_NONE) {
        return {
          key: "none",
          text: tableLocale.selectNone,
          onSelect: function onSelect2() {
            onSelectNone === null || onSelectNone === void 0 ? void 0 : onSelectNone();
            setSelectedKeys(Array.from(derivedSelectedKeySet).filter(function(key2) {
              var checkProps = checkboxPropsMap.get(key2);
              return checkProps === null || checkProps === void 0 ? void 0 : checkProps.disabled;
            }), "none");
          }
        };
      }
      return selection;
    }).map(function(selection) {
      return _extends$2(_extends$2({}, selection), {
        onSelect: function onSelect2() {
          var _a2;
          var _a3;
          for (var _len = arguments.length, rest = new Array(_len), _key = 0; _key < _len; _key++) {
            rest[_key] = arguments[_key];
          }
          (_a3 = selection.onSelect) === null || _a3 === void 0 ? void 0 : (_a2 = _a3).call.apply(_a2, [selection].concat(rest));
          setLastSelectedKey(null);
        }
      });
    });
  }, [selections, derivedSelectedKeySet, pageData, getRowKey, onSelectInvert, setSelectedKeys]);
  var transformColumns = react.exports.useCallback(function(columns2) {
    var _a2;
    if (!rowSelection) {
      return columns2.filter(function(col) {
        return col !== SELECTION_COLUMN;
      });
    }
    var cloneColumns = _toConsumableArray(columns2);
    var keySet = new Set(derivedSelectedKeySet);
    var recordKeys = flattedData.map(getRowKey).filter(function(key2) {
      return !checkboxPropsMap.get(key2).disabled;
    });
    var checkedCurrentAll = recordKeys.every(function(key2) {
      return keySet.has(key2);
    });
    var checkedCurrentSome = recordKeys.some(function(key2) {
      return keySet.has(key2);
    });
    var onSelectAllChange = function onSelectAllChange2() {
      var changeKeys = [];
      if (checkedCurrentAll) {
        recordKeys.forEach(function(key2) {
          keySet["delete"](key2);
          changeKeys.push(key2);
        });
      } else {
        recordKeys.forEach(function(key2) {
          if (!keySet.has(key2)) {
            keySet.add(key2);
            changeKeys.push(key2);
          }
        });
      }
      var keys2 = Array.from(keySet);
      onSelectAll === null || onSelectAll === void 0 ? void 0 : onSelectAll(!checkedCurrentAll, keys2.map(function(k2) {
        return getRecordByKey(k2);
      }), changeKeys.map(function(k2) {
        return getRecordByKey(k2);
      }));
      setSelectedKeys(keys2, "all");
      setLastSelectedKey(null);
    };
    var title;
    if (selectionType !== "radio") {
      var customizeSelections;
      if (mergedSelections) {
        var menu = /* @__PURE__ */ react.exports.createElement(Menu$1, {
          getPopupContainer,
          items: mergedSelections.map(function(selection, index2) {
            var key2 = selection.key, text2 = selection.text, onSelectionClick = selection.onSelect;
            return {
              key: key2 || index2,
              onClick: function onClick() {
                onSelectionClick === null || onSelectionClick === void 0 ? void 0 : onSelectionClick(recordKeys);
              },
              label: text2
            };
          })
        });
        customizeSelections = /* @__PURE__ */ react.exports.createElement("div", {
          className: "".concat(prefixCls, "-selection-extra")
        }, /* @__PURE__ */ react.exports.createElement(Dropdown$1, {
          overlay: menu,
          getPopupContainer
        }, /* @__PURE__ */ react.exports.createElement("span", null, /* @__PURE__ */ react.exports.createElement(DownOutlined$1, null))));
      }
      var allDisabledData = flattedData.map(function(record, index2) {
        var key2 = getRowKey(record, index2);
        var checkboxProps = checkboxPropsMap.get(key2) || {};
        return _extends$2({
          checked: keySet.has(key2)
        }, checkboxProps);
      }).filter(function(_ref2) {
        var disabled = _ref2.disabled;
        return disabled;
      });
      var allDisabled = !!allDisabledData.length && allDisabledData.length === flattedData.length;
      var allDisabledAndChecked = allDisabled && allDisabledData.every(function(_ref3) {
        var checked = _ref3.checked;
        return checked;
      });
      var allDisabledSomeChecked = allDisabled && allDisabledData.some(function(_ref4) {
        var checked = _ref4.checked;
        return checked;
      });
      title = !hideSelectAll && /* @__PURE__ */ react.exports.createElement("div", {
        className: "".concat(prefixCls, "-selection")
      }, /* @__PURE__ */ react.exports.createElement(Checkbox$1, {
        checked: !allDisabled ? !!flattedData.length && checkedCurrentAll : allDisabledAndChecked,
        indeterminate: !allDisabled ? !checkedCurrentAll && checkedCurrentSome : !allDisabledAndChecked && allDisabledSomeChecked,
        onChange: onSelectAllChange,
        disabled: flattedData.length === 0 || allDisabled,
        skipGroup: true
      }), customizeSelections);
    }
    var renderCell;
    if (selectionType === "radio") {
      renderCell = function renderCell2(_2, record, index2) {
        var key2 = getRowKey(record, index2);
        var checked = keySet.has(key2);
        return {
          node: /* @__PURE__ */ react.exports.createElement(Radio$1, _extends$2({}, checkboxPropsMap.get(key2), {
            checked,
            onClick: function onClick(e3) {
              return e3.stopPropagation();
            },
            onChange: function onChange2(event) {
              if (!keySet.has(key2)) {
                triggerSingleSelection(key2, true, [key2], event.nativeEvent);
              }
            }
          })),
          checked
        };
      };
    } else {
      renderCell = function renderCell2(_2, record, index2) {
        var _a3;
        var key2 = getRowKey(record, index2);
        var checked = keySet.has(key2);
        var indeterminate = derivedHalfSelectedKeySet.has(key2);
        var checkboxProps = checkboxPropsMap.get(key2);
        var mergedIndeterminate;
        if (expandType === "nest") {
          mergedIndeterminate = indeterminate;
        } else {
          mergedIndeterminate = (_a3 = checkboxProps === null || checkboxProps === void 0 ? void 0 : checkboxProps.indeterminate) !== null && _a3 !== void 0 ? _a3 : indeterminate;
        }
        return {
          node: /* @__PURE__ */ react.exports.createElement(Checkbox$1, _extends$2({}, checkboxProps, {
            indeterminate: mergedIndeterminate,
            checked,
            skipGroup: true,
            onClick: function onClick(e3) {
              return e3.stopPropagation();
            },
            onChange: function onChange2(_ref5) {
              var nativeEvent = _ref5.nativeEvent;
              var shiftKey = nativeEvent.shiftKey;
              var startIndex = -1;
              var endIndex = -1;
              if (shiftKey && checkStrictly) {
                var pointKeys = /* @__PURE__ */ new Set([lastSelectedKey, key2]);
                recordKeys.some(function(recordKey, recordIndex) {
                  if (pointKeys.has(recordKey)) {
                    if (startIndex === -1) {
                      startIndex = recordIndex;
                    } else {
                      endIndex = recordIndex;
                      return true;
                    }
                  }
                  return false;
                });
              }
              if (endIndex !== -1 && startIndex !== endIndex && checkStrictly) {
                var rangeKeys = recordKeys.slice(startIndex, endIndex + 1);
                var changedKeys = [];
                if (checked) {
                  rangeKeys.forEach(function(recordKey) {
                    if (keySet.has(recordKey)) {
                      changedKeys.push(recordKey);
                      keySet["delete"](recordKey);
                    }
                  });
                } else {
                  rangeKeys.forEach(function(recordKey) {
                    if (!keySet.has(recordKey)) {
                      changedKeys.push(recordKey);
                      keySet.add(recordKey);
                    }
                  });
                }
                var keys2 = Array.from(keySet);
                onSelectMultiple === null || onSelectMultiple === void 0 ? void 0 : onSelectMultiple(!checked, keys2.map(function(recordKey) {
                  return getRecordByKey(recordKey);
                }), changedKeys.map(function(recordKey) {
                  return getRecordByKey(recordKey);
                }));
                setSelectedKeys(keys2, "multiple");
              } else {
                var originCheckedKeys = derivedSelectedKeys;
                if (checkStrictly) {
                  var checkedKeys = checked ? arrDel(originCheckedKeys, key2) : arrAdd(originCheckedKeys, key2);
                  triggerSingleSelection(key2, !checked, checkedKeys, nativeEvent);
                } else {
                  var result = conductCheck([].concat(_toConsumableArray(originCheckedKeys), [key2]), true, keyEntities, isCheckboxDisabled);
                  var _checkedKeys = result.checkedKeys, halfCheckedKeys = result.halfCheckedKeys;
                  var nextCheckedKeys = _checkedKeys;
                  if (checked) {
                    var tempKeySet = new Set(_checkedKeys);
                    tempKeySet["delete"](key2);
                    nextCheckedKeys = conductCheck(Array.from(tempKeySet), {
                      checked: false,
                      halfCheckedKeys
                    }, keyEntities, isCheckboxDisabled).checkedKeys;
                  }
                  triggerSingleSelection(key2, !checked, nextCheckedKeys, nativeEvent);
                }
              }
              if (checked) {
                setLastSelectedKey(null);
              } else {
                setLastSelectedKey(key2);
              }
            }
          })),
          checked
        };
      };
    }
    var renderSelectionCell = function renderSelectionCell2(_2, record, index2) {
      var _renderCell = renderCell(_2, record, index2), node = _renderCell.node, checked = _renderCell.checked;
      if (customizeRenderCell) {
        return customizeRenderCell(checked, record, index2, node);
      }
      return node;
    };
    if (!cloneColumns.includes(SELECTION_COLUMN)) {
      if (cloneColumns.findIndex(function(col) {
        var _a3;
        return ((_a3 = col[INTERNAL_COL_DEFINE]) === null || _a3 === void 0 ? void 0 : _a3.columnType) === "EXPAND_COLUMN";
      }) === 0) {
        var _cloneColumns = cloneColumns, _cloneColumns2 = _toArray(_cloneColumns), expandColumn = _cloneColumns2[0], restColumns = _cloneColumns2.slice(1);
        cloneColumns = [expandColumn, SELECTION_COLUMN].concat(_toConsumableArray(restColumns));
      } else {
        cloneColumns = [SELECTION_COLUMN].concat(_toConsumableArray(cloneColumns));
      }
    }
    var selectionColumnIndex = cloneColumns.indexOf(SELECTION_COLUMN);
    cloneColumns = cloneColumns.filter(function(column, index2) {
      return column !== SELECTION_COLUMN || index2 === selectionColumnIndex;
    });
    var prevCol = cloneColumns[selectionColumnIndex - 1];
    var nextCol = cloneColumns[selectionColumnIndex + 1];
    var mergedFixed = fixed;
    if (mergedFixed === void 0) {
      if ((nextCol === null || nextCol === void 0 ? void 0 : nextCol.fixed) !== void 0) {
        mergedFixed = nextCol.fixed;
      } else if ((prevCol === null || prevCol === void 0 ? void 0 : prevCol.fixed) !== void 0) {
        mergedFixed = prevCol.fixed;
      }
    }
    if (mergedFixed && prevCol && ((_a2 = prevCol[INTERNAL_COL_DEFINE]) === null || _a2 === void 0 ? void 0 : _a2.columnType) === "EXPAND_COLUMN" && prevCol.fixed === void 0) {
      prevCol.fixed = mergedFixed;
    }
    var selectionColumn = _defineProperty$4({
      fixed: mergedFixed,
      width: selectionColWidth,
      className: "".concat(prefixCls, "-selection-column"),
      title: rowSelection.columnTitle || title,
      render: renderSelectionCell
    }, INTERNAL_COL_DEFINE, {
      className: "".concat(prefixCls, "-selection-col")
    });
    return cloneColumns.map(function(col) {
      return col === SELECTION_COLUMN ? selectionColumn : col;
    });
  }, [getRowKey, flattedData, rowSelection, derivedSelectedKeys, derivedSelectedKeySet, derivedHalfSelectedKeySet, selectionColWidth, mergedSelections, expandType, lastSelectedKey, checkboxPropsMap, onSelectMultiple, triggerSingleSelection, isCheckboxDisabled]);
  return [transformColumns, derivedSelectedKeySet];
}
var CaretDownOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "0 0 1024 1024", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M840.4 300H183.6c-19.7 0-30.7 20.8-18.5 35l328.4 380.8c9.4 10.9 27.5 10.9 37 0L858.9 335c12.2-14.2 1.2-35-18.5-35z" } }] }, "name": "caret-down", "theme": "outlined" };
var CaretDownOutlinedSvg = CaretDownOutlined$2;
var CaretDownOutlined = function CaretDownOutlined2(props, ref) {
  return /* @__PURE__ */ react.exports.createElement(AntdIcon, _objectSpread2$1(_objectSpread2$1({}, props), {}, {
    ref,
    icon: CaretDownOutlinedSvg
  }));
};
CaretDownOutlined.displayName = "CaretDownOutlined";
var CaretDownOutlined$1 = /* @__PURE__ */ react.exports.forwardRef(CaretDownOutlined);
var CaretUpOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "0 0 1024 1024", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M858.9 689L530.5 308.2c-9.4-10.9-27.5-10.9-37 0L165.1 689c-12.2 14.2-1.2 35 18.5 35h656.8c19.7 0 30.7-20.8 18.5-35z" } }] }, "name": "caret-up", "theme": "outlined" };
var CaretUpOutlinedSvg = CaretUpOutlined$2;
var CaretUpOutlined = function CaretUpOutlined2(props, ref) {
  return /* @__PURE__ */ react.exports.createElement(AntdIcon, _objectSpread2$1(_objectSpread2$1({}, props), {}, {
    ref,
    icon: CaretUpOutlinedSvg
  }));
};
CaretUpOutlined.displayName = "CaretUpOutlined";
var CaretUpOutlined$1 = /* @__PURE__ */ react.exports.forwardRef(CaretUpOutlined);
var ASCEND = "ascend";
var DESCEND = "descend";
function getMultiplePriority(column) {
  if (_typeof$4(column.sorter) === "object" && typeof column.sorter.multiple === "number") {
    return column.sorter.multiple;
  }
  return false;
}
function getSortFunction(sorter) {
  if (typeof sorter === "function") {
    return sorter;
  }
  if (sorter && _typeof$4(sorter) === "object" && sorter.compare) {
    return sorter.compare;
  }
  return false;
}
function nextSortDirection(sortDirections, current) {
  if (!current) {
    return sortDirections[0];
  }
  return sortDirections[sortDirections.indexOf(current) + 1];
}
function collectSortStates(columns2, init, pos) {
  var sortStates = [];
  function pushState(column, columnPos) {
    sortStates.push({
      column,
      key: getColumnKey(column, columnPos),
      multiplePriority: getMultiplePriority(column),
      sortOrder: column.sortOrder
    });
  }
  (columns2 || []).forEach(function(column, index2) {
    var columnPos = getColumnPos(index2, pos);
    if (column.children) {
      if ("sortOrder" in column) {
        pushState(column, columnPos);
      }
      sortStates = [].concat(_toConsumableArray(sortStates), _toConsumableArray(collectSortStates(column.children, init, columnPos)));
    } else if (column.sorter) {
      if ("sortOrder" in column) {
        pushState(column, columnPos);
      } else if (init && column.defaultSortOrder) {
        sortStates.push({
          column,
          key: getColumnKey(column, columnPos),
          multiplePriority: getMultiplePriority(column),
          sortOrder: column.defaultSortOrder
        });
      }
    }
  });
  return sortStates;
}
function injectSorter(prefixCls, columns2, sorterStates, triggerSorter, defaultSortDirections, tableLocale, tableShowSorterTooltip, pos) {
  return (columns2 || []).map(function(column, index2) {
    var columnPos = getColumnPos(index2, pos);
    var newColumn = column;
    if (newColumn.sorter) {
      var sortDirections = newColumn.sortDirections || defaultSortDirections;
      var showSorterTooltip = newColumn.showSorterTooltip === void 0 ? tableShowSorterTooltip : newColumn.showSorterTooltip;
      var columnKey = getColumnKey(newColumn, columnPos);
      var sorterState = sorterStates.find(function(_ref) {
        var key2 = _ref.key;
        return key2 === columnKey;
      });
      var sorterOrder = sorterState ? sorterState.sortOrder : null;
      var nextSortOrder = nextSortDirection(sortDirections, sorterOrder);
      var upNode = sortDirections.includes(ASCEND) && /* @__PURE__ */ react.exports.createElement(CaretUpOutlined$1, {
        className: classNames("".concat(prefixCls, "-column-sorter-up"), {
          active: sorterOrder === ASCEND
        }),
        role: "presentation"
      });
      var downNode = sortDirections.includes(DESCEND) && /* @__PURE__ */ react.exports.createElement(CaretDownOutlined$1, {
        className: classNames("".concat(prefixCls, "-column-sorter-down"), {
          active: sorterOrder === DESCEND
        }),
        role: "presentation"
      });
      var _ref2 = tableLocale || {}, cancelSort = _ref2.cancelSort, triggerAsc = _ref2.triggerAsc, triggerDesc = _ref2.triggerDesc;
      var sortTip = cancelSort;
      if (nextSortOrder === DESCEND) {
        sortTip = triggerDesc;
      } else if (nextSortOrder === ASCEND) {
        sortTip = triggerAsc;
      }
      var tooltipProps = _typeof$4(showSorterTooltip) === "object" ? showSorterTooltip : {
        title: sortTip
      };
      newColumn = _extends$2(_extends$2({}, newColumn), {
        className: classNames(newColumn.className, _defineProperty$4({}, "".concat(prefixCls, "-column-sort"), sorterOrder)),
        title: function title(renderProps) {
          var renderSortTitle = /* @__PURE__ */ react.exports.createElement("div", {
            className: "".concat(prefixCls, "-column-sorters")
          }, /* @__PURE__ */ react.exports.createElement("span", {
            className: "".concat(prefixCls, "-column-title")
          }, renderColumnTitle(column.title, renderProps)), /* @__PURE__ */ react.exports.createElement("span", {
            className: classNames("".concat(prefixCls, "-column-sorter"), _defineProperty$4({}, "".concat(prefixCls, "-column-sorter-full"), !!(upNode && downNode)))
          }, /* @__PURE__ */ react.exports.createElement("span", {
            className: "".concat(prefixCls, "-column-sorter-inner")
          }, upNode, downNode)));
          return showSorterTooltip ? /* @__PURE__ */ react.exports.createElement(Tooltip$3, _extends$2({}, tooltipProps), renderSortTitle) : renderSortTitle;
        },
        onHeaderCell: function onHeaderCell(col) {
          var cell = column.onHeaderCell && column.onHeaderCell(col) || {};
          var originOnClick = cell.onClick;
          var originOKeyDown = cell.onKeyDown;
          cell.onClick = function(event) {
            triggerSorter({
              column,
              key: columnKey,
              sortOrder: nextSortOrder,
              multiplePriority: getMultiplePriority(column)
            });
            originOnClick === null || originOnClick === void 0 ? void 0 : originOnClick(event);
          };
          cell.onKeyDown = function(event) {
            if (event.keyCode === KeyCode.ENTER) {
              triggerSorter({
                column,
                key: columnKey,
                sortOrder: nextSortOrder,
                multiplePriority: getMultiplePriority(column)
              });
              originOKeyDown === null || originOKeyDown === void 0 ? void 0 : originOKeyDown(event);
            }
          };
          if (sorterOrder) {
            if (sorterOrder === "ascend") {
              cell["aria-sort"] = "ascending";
            } else {
              cell["aria-sort"] = "descending";
            }
          } else {
            cell["aria-label"] = "".concat(renderColumnTitle(column.title, {}), " sortable");
          }
          cell.className = classNames(cell.className, "".concat(prefixCls, "-column-has-sorters"));
          cell.tabIndex = 0;
          return cell;
        }
      });
    }
    if ("children" in newColumn) {
      newColumn = _extends$2(_extends$2({}, newColumn), {
        children: injectSorter(prefixCls, newColumn.children, sorterStates, triggerSorter, defaultSortDirections, tableLocale, tableShowSorterTooltip, columnPos)
      });
    }
    return newColumn;
  });
}
function stateToInfo(sorterStates) {
  var column = sorterStates.column, sortOrder = sorterStates.sortOrder;
  return {
    column,
    order: sortOrder,
    field: column.dataIndex,
    columnKey: column.key
  };
}
function generateSorterInfo(sorterStates) {
  var list = sorterStates.filter(function(_ref3) {
    var sortOrder = _ref3.sortOrder;
    return sortOrder;
  }).map(stateToInfo);
  if (list.length === 0 && sorterStates.length) {
    return _extends$2(_extends$2({}, stateToInfo(sorterStates[sorterStates.length - 1])), {
      column: void 0
    });
  }
  if (list.length <= 1) {
    return list[0] || {};
  }
  return list;
}
function getSortData(data2, sortStates, childrenColumnName) {
  var innerSorterStates = sortStates.slice().sort(function(a2, b10) {
    return b10.multiplePriority - a2.multiplePriority;
  });
  var cloneData = data2.slice();
  var runningSorters = innerSorterStates.filter(function(_ref4) {
    var sorter = _ref4.column.sorter, sortOrder = _ref4.sortOrder;
    return getSortFunction(sorter) && sortOrder;
  });
  if (!runningSorters.length) {
    return cloneData;
  }
  return cloneData.sort(function(record1, record2) {
    for (var i2 = 0; i2 < runningSorters.length; i2 += 1) {
      var sorterState = runningSorters[i2];
      var sorter = sorterState.column.sorter, sortOrder = sorterState.sortOrder;
      var compareFn = getSortFunction(sorter);
      if (compareFn && sortOrder) {
        var compareResult = compareFn(record1, record2, sortOrder);
        if (compareResult !== 0) {
          return sortOrder === ASCEND ? compareResult : -compareResult;
        }
      }
    }
    return 0;
  }).map(function(record) {
    var subRecords = record[childrenColumnName];
    if (subRecords) {
      return _extends$2(_extends$2({}, record), _defineProperty$4({}, childrenColumnName, getSortData(subRecords, sortStates, childrenColumnName)));
    }
    return record;
  });
}
function useFilterSorter(_ref5) {
  var prefixCls = _ref5.prefixCls, mergedColumns = _ref5.mergedColumns, onSorterChange = _ref5.onSorterChange, sortDirections = _ref5.sortDirections, tableLocale = _ref5.tableLocale, showSorterTooltip = _ref5.showSorterTooltip;
  var _React$useState = react.exports.useState(collectSortStates(mergedColumns, true)), _React$useState2 = _slicedToArray$4(_React$useState, 2), sortStates = _React$useState2[0], setSortStates = _React$useState2[1];
  var mergedSorterStates = react.exports.useMemo(function() {
    var validate = true;
    var collectedStates = collectSortStates(mergedColumns, false);
    if (!collectedStates.length) {
      return sortStates;
    }
    var validateStates = [];
    function patchStates(state2) {
      if (validate) {
        validateStates.push(state2);
      } else {
        validateStates.push(_extends$2(_extends$2({}, state2), {
          sortOrder: null
        }));
      }
    }
    var multipleMode = null;
    collectedStates.forEach(function(state2) {
      if (multipleMode === null) {
        patchStates(state2);
        if (state2.sortOrder) {
          if (state2.multiplePriority === false) {
            validate = false;
          } else {
            multipleMode = true;
          }
        }
      } else if (multipleMode && state2.multiplePriority !== false) {
        patchStates(state2);
      } else {
        validate = false;
        patchStates(state2);
      }
    });
    return validateStates;
  }, [mergedColumns, sortStates]);
  var columnTitleSorterProps = react.exports.useMemo(function() {
    var sortColumns = mergedSorterStates.map(function(_ref6) {
      var column = _ref6.column, sortOrder = _ref6.sortOrder;
      return {
        column,
        order: sortOrder
      };
    });
    return {
      sortColumns,
      sortColumn: sortColumns[0] && sortColumns[0].column,
      sortOrder: sortColumns[0] && sortColumns[0].order
    };
  }, [mergedSorterStates]);
  function triggerSorter(sortState) {
    var newSorterStates;
    if (sortState.multiplePriority === false || !mergedSorterStates.length || mergedSorterStates[0].multiplePriority === false) {
      newSorterStates = [sortState];
    } else {
      newSorterStates = [].concat(_toConsumableArray(mergedSorterStates.filter(function(_ref7) {
        var key2 = _ref7.key;
        return key2 !== sortState.key;
      })), [sortState]);
    }
    setSortStates(newSorterStates);
    onSorterChange(generateSorterInfo(newSorterStates), newSorterStates);
  }
  var transformColumns = function transformColumns2(innerColumns) {
    return injectSorter(prefixCls, innerColumns, mergedSorterStates, triggerSorter, sortDirections, tableLocale, showSorterTooltip);
  };
  var getSorters = function getSorters2() {
    return generateSorterInfo(mergedSorterStates);
  };
  return [transformColumns, mergedSorterStates, columnTitleSorterProps, getSorters];
}
function fillTitle(columns2, columnTitleProps) {
  return columns2.map(function(column) {
    var cloneColumn = _extends$2({}, column);
    cloneColumn.title = renderColumnTitle(column.title, columnTitleProps);
    if ("children" in cloneColumn) {
      cloneColumn.children = fillTitle(cloneColumn.children, columnTitleProps);
    }
    return cloneColumn;
  });
}
function useTitleColumns(columnTitleProps) {
  var filledColumns = react.exports.useCallback(function(columns2) {
    return fillTitle(columns2, columnTitleProps);
  }, [columnTitleProps]);
  return [filledColumns];
}
var EMPTY_LIST = [];
function InternalTable(props, ref) {
  var _classNames3;
  var customizePrefixCls = props.prefixCls, className = props.className, style2 = props.style, customizeSize = props.size, bordered = props.bordered, customizeDropdownPrefixCls = props.dropdownPrefixCls, dataSource = props.dataSource, pagination = props.pagination, rowSelection = props.rowSelection, _props$rowKey = props.rowKey, rowKey = _props$rowKey === void 0 ? "key" : _props$rowKey, rowClassName = props.rowClassName, columns2 = props.columns, children = props.children, legacyChildrenColumnName = props.childrenColumnName, onChange2 = props.onChange, getPopupContainer = props.getPopupContainer, loading = props.loading, expandIcon = props.expandIcon, expandable = props.expandable, expandedRowRender = props.expandedRowRender, expandIconColumnIndex = props.expandIconColumnIndex, indentSize = props.indentSize, scroll = props.scroll, sortDirections = props.sortDirections, locale2 = props.locale, _props$showSorterTool = props.showSorterTooltip, showSorterTooltip = _props$showSorterTool === void 0 ? true : _props$showSorterTool;
  [["filterDropdownVisible", "filterDropdownOpen"], ["onFilterDropdownVisibleChange", "onFilterDropdownOpenChange"]].forEach(function(_ref) {
    var _ref2 = _slicedToArray$4(_ref, 2);
    _ref2[0];
    _ref2[1];
  });
  var baseColumns = react.exports.useMemo(function() {
    return columns2 || convertChildrenToColumns(children);
  }, [columns2, children]);
  var needResponsive = react.exports.useMemo(function() {
    return baseColumns.some(function(col) {
      return col.responsive;
    });
  }, [baseColumns]);
  var screens2 = useBreakpoint(needResponsive);
  var mergedColumns = react.exports.useMemo(function() {
    var matched = new Set(Object.keys(screens2).filter(function(m2) {
      return screens2[m2];
    }));
    return baseColumns.filter(function(c2) {
      return !c2.responsive || c2.responsive.some(function(r2) {
        return matched.has(r2);
      });
    });
  }, [baseColumns, screens2]);
  var tableProps = omit$2(props, ["className", "style", "columns"]);
  var size2 = react.exports.useContext(SizeContext$1);
  var _React$useContext = react.exports.useContext(ConfigContext), _React$useContext$loc = _React$useContext.locale, contextLocale = _React$useContext$loc === void 0 ? defaultLocale : _React$useContext$loc, renderEmpty = _React$useContext.renderEmpty, direction2 = _React$useContext.direction;
  var mergedSize = customizeSize || size2;
  var tableLocale = _extends$2(_extends$2({}, contextLocale.Table), locale2);
  var rawData = dataSource || EMPTY_LIST;
  var _React$useContext2 = react.exports.useContext(ConfigContext), getPrefixCls = _React$useContext2.getPrefixCls;
  var prefixCls = getPrefixCls("table", customizePrefixCls);
  var dropdownPrefixCls = getPrefixCls("dropdown", customizeDropdownPrefixCls);
  var mergedExpandable = _extends$2({
    childrenColumnName: legacyChildrenColumnName,
    expandIconColumnIndex
  }, expandable);
  var _mergedExpandable$chi = mergedExpandable.childrenColumnName, childrenColumnName = _mergedExpandable$chi === void 0 ? "children" : _mergedExpandable$chi;
  var expandType = react.exports.useMemo(function() {
    if (rawData.some(function(item) {
      return item === null || item === void 0 ? void 0 : item[childrenColumnName];
    })) {
      return "nest";
    }
    if (expandedRowRender || expandable && expandable.expandedRowRender) {
      return "row";
    }
    return null;
  }, [rawData]);
  var internalRefs = {
    body: react.exports.useRef()
  };
  var getRowKey = react.exports.useMemo(function() {
    if (typeof rowKey === "function") {
      return rowKey;
    }
    return function(record) {
      return record === null || record === void 0 ? void 0 : record[rowKey];
    };
  }, [rowKey]);
  var _useLazyKVMap = useLazyKVMap(rawData, childrenColumnName, getRowKey), _useLazyKVMap2 = _slicedToArray$4(_useLazyKVMap, 1), getRecordByKey = _useLazyKVMap2[0];
  var changeEventInfo = {};
  var triggerOnChange = function triggerOnChange2(info, action) {
    var reset = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    var changeInfo = _extends$2(_extends$2({}, changeEventInfo), info);
    if (reset) {
      changeEventInfo.resetPagination();
      if (changeInfo.pagination.current) {
        changeInfo.pagination.current = 1;
      }
      if (pagination && pagination.onChange) {
        pagination.onChange(1, changeInfo.pagination.pageSize);
      }
    }
    if (scroll && scroll.scrollToFirstRowOnChange !== false && internalRefs.body.current) {
      scrollTo(0, {
        getContainer: function getContainer2() {
          return internalRefs.body.current;
        }
      });
    }
    onChange2 === null || onChange2 === void 0 ? void 0 : onChange2(changeInfo.pagination, changeInfo.filters, changeInfo.sorter, {
      currentDataSource: getFilterData(getSortData(rawData, changeInfo.sorterStates, childrenColumnName), changeInfo.filterStates),
      action
    });
  };
  var onSorterChange = function onSorterChange2(sorter, sorterStates) {
    triggerOnChange({
      sorter,
      sorterStates
    }, "sort", false);
  };
  var _useSorter = useFilterSorter({
    prefixCls,
    mergedColumns,
    onSorterChange,
    sortDirections: sortDirections || ["ascend", "descend"],
    tableLocale,
    showSorterTooltip
  }), _useSorter2 = _slicedToArray$4(_useSorter, 4), transformSorterColumns = _useSorter2[0], sortStates = _useSorter2[1], sorterTitleProps = _useSorter2[2], getSorters = _useSorter2[3];
  var sortedData = react.exports.useMemo(function() {
    return getSortData(rawData, sortStates, childrenColumnName);
  }, [rawData, sortStates]);
  changeEventInfo.sorter = getSorters();
  changeEventInfo.sorterStates = sortStates;
  var onFilterChange = function onFilterChange2(filters2, filterStates2) {
    triggerOnChange({
      filters: filters2,
      filterStates: filterStates2
    }, "filter", true);
  };
  var _useFilter = useFilter({
    prefixCls,
    locale: tableLocale,
    dropdownPrefixCls,
    mergedColumns,
    onFilterChange,
    getPopupContainer
  }), _useFilter2 = _slicedToArray$4(_useFilter, 3), transformFilterColumns = _useFilter2[0], filterStates = _useFilter2[1], filters = _useFilter2[2];
  var mergedData = getFilterData(sortedData, filterStates);
  changeEventInfo.filters = filters;
  changeEventInfo.filterStates = filterStates;
  var columnTitleProps = react.exports.useMemo(function() {
    var mergedFilters = {};
    Object.keys(filters).forEach(function(filterKey) {
      if (filters[filterKey] !== null) {
        mergedFilters[filterKey] = filters[filterKey];
      }
    });
    return _extends$2(_extends$2({}, sorterTitleProps), {
      filters: mergedFilters
    });
  }, [sorterTitleProps, filters]);
  var _useTitleColumns = useTitleColumns(columnTitleProps), _useTitleColumns2 = _slicedToArray$4(_useTitleColumns, 1), transformTitleColumns = _useTitleColumns2[0];
  var onPaginationChange = function onPaginationChange2(current, pageSize) {
    triggerOnChange({
      pagination: _extends$2(_extends$2({}, changeEventInfo.pagination), {
        current,
        pageSize
      })
    }, "paginate");
  };
  var _usePagination = usePagination(mergedData.length, pagination, onPaginationChange), _usePagination2 = _slicedToArray$4(_usePagination, 2), mergedPagination = _usePagination2[0], resetPagination = _usePagination2[1];
  changeEventInfo.pagination = pagination === false ? {} : getPaginationParam(pagination, mergedPagination);
  changeEventInfo.resetPagination = resetPagination;
  var pageData = react.exports.useMemo(function() {
    if (pagination === false || !mergedPagination.pageSize) {
      return mergedData;
    }
    var _mergedPagination$cur = mergedPagination.current, current = _mergedPagination$cur === void 0 ? 1 : _mergedPagination$cur, total = mergedPagination.total, _mergedPagination$pag = mergedPagination.pageSize, pageSize = _mergedPagination$pag === void 0 ? DEFAULT_PAGE_SIZE : _mergedPagination$pag;
    if (mergedData.length < total) {
      if (mergedData.length > pageSize) {
        return mergedData.slice((current - 1) * pageSize, current * pageSize);
      }
      return mergedData;
    }
    return mergedData.slice((current - 1) * pageSize, current * pageSize);
  }, [!!pagination, mergedData, mergedPagination && mergedPagination.current, mergedPagination && mergedPagination.pageSize, mergedPagination && mergedPagination.total]);
  var _useSelection = useSelection(rowSelection, {
    prefixCls,
    data: mergedData,
    pageData,
    getRowKey,
    getRecordByKey,
    expandType,
    childrenColumnName,
    locale: tableLocale,
    getPopupContainer
  }), _useSelection2 = _slicedToArray$4(_useSelection, 2), transformSelectionColumns = _useSelection2[0], selectedKeySet = _useSelection2[1];
  var internalRowClassName = function internalRowClassName2(record, index2, indent) {
    var mergedRowClassName;
    if (typeof rowClassName === "function") {
      mergedRowClassName = classNames(rowClassName(record, index2, indent));
    } else {
      mergedRowClassName = classNames(rowClassName);
    }
    return classNames(_defineProperty$4({}, "".concat(prefixCls, "-row-selected"), selectedKeySet.has(getRowKey(record, index2))), mergedRowClassName);
  };
  mergedExpandable.__PARENT_RENDER_ICON__ = mergedExpandable.expandIcon;
  mergedExpandable.expandIcon = mergedExpandable.expandIcon || expandIcon || renderExpandIcon(tableLocale);
  if (expandType === "nest" && mergedExpandable.expandIconColumnIndex === void 0) {
    mergedExpandable.expandIconColumnIndex = rowSelection ? 1 : 0;
  } else if (mergedExpandable.expandIconColumnIndex > 0 && rowSelection) {
    mergedExpandable.expandIconColumnIndex -= 1;
  }
  if (typeof mergedExpandable.indentSize !== "number") {
    mergedExpandable.indentSize = typeof indentSize === "number" ? indentSize : 15;
  }
  var transformColumns = react.exports.useCallback(function(innerColumns) {
    return transformTitleColumns(transformSelectionColumns(transformFilterColumns(transformSorterColumns(innerColumns))));
  }, [transformSorterColumns, transformFilterColumns, transformSelectionColumns]);
  var topPaginationNode;
  var bottomPaginationNode;
  if (pagination !== false && (mergedPagination === null || mergedPagination === void 0 ? void 0 : mergedPagination.total)) {
    var paginationSize;
    if (mergedPagination.size) {
      paginationSize = mergedPagination.size;
    } else {
      paginationSize = mergedSize === "small" || mergedSize === "middle" ? "small" : void 0;
    }
    var renderPagination = function renderPagination2(position2) {
      return /* @__PURE__ */ react.exports.createElement(Pagination$1, _extends$2({}, mergedPagination, {
        className: classNames("".concat(prefixCls, "-pagination ").concat(prefixCls, "-pagination-").concat(position2), mergedPagination.className),
        size: paginationSize
      }));
    };
    var defaultPosition = direction2 === "rtl" ? "left" : "right";
    var position = mergedPagination.position;
    if (position !== null && Array.isArray(position)) {
      var topPos = position.find(function(p2) {
        return p2.indexOf("top") !== -1;
      });
      var bottomPos = position.find(function(p2) {
        return p2.indexOf("bottom") !== -1;
      });
      var isDisable = position.every(function(p2) {
        return "".concat(p2) === "none";
      });
      if (!topPos && !bottomPos && !isDisable) {
        bottomPaginationNode = renderPagination(defaultPosition);
      }
      if (topPos) {
        topPaginationNode = renderPagination(topPos.toLowerCase().replace("top", ""));
      }
      if (bottomPos) {
        bottomPaginationNode = renderPagination(bottomPos.toLowerCase().replace("bottom", ""));
      }
    } else {
      bottomPaginationNode = renderPagination(defaultPosition);
    }
  }
  var spinProps;
  if (typeof loading === "boolean") {
    spinProps = {
      spinning: loading
    };
  } else if (_typeof$4(loading) === "object") {
    spinProps = _extends$2({
      spinning: true
    }, loading);
  }
  var wrapperClassNames = classNames("".concat(prefixCls, "-wrapper"), _defineProperty$4({}, "".concat(prefixCls, "-wrapper-rtl"), direction2 === "rtl"), className);
  return /* @__PURE__ */ react.exports.createElement("div", {
    ref,
    className: wrapperClassNames,
    style: style2
  }, /* @__PURE__ */ react.exports.createElement(Spin$1, _extends$2({
    spinning: false
  }, spinProps), topPaginationNode, /* @__PURE__ */ react.exports.createElement(Table$2, _extends$2({}, tableProps, {
    columns: mergedColumns,
    direction: direction2,
    expandable: mergedExpandable,
    prefixCls,
    className: classNames((_classNames3 = {}, _defineProperty$4(_classNames3, "".concat(prefixCls, "-middle"), mergedSize === "middle"), _defineProperty$4(_classNames3, "".concat(prefixCls, "-small"), mergedSize === "small"), _defineProperty$4(_classNames3, "".concat(prefixCls, "-bordered"), bordered), _defineProperty$4(_classNames3, "".concat(prefixCls, "-empty"), rawData.length === 0), _classNames3)),
    data: pageData,
    rowKey: getRowKey,
    rowClassName: internalRowClassName,
    emptyText: locale2 && locale2.emptyText || (renderEmpty || defaultRenderEmpty$1)("Table"),
    internalHooks: INTERNAL_HOOKS,
    internalRefs,
    transformColumns
  })), bottomPaginationNode));
}
var ForwardTable = /* @__PURE__ */ react.exports.forwardRef(InternalTable);
var Table = ForwardTable;
Table.SELECTION_COLUMN = SELECTION_COLUMN;
Table.EXPAND_COLUMN = Table$2.EXPAND_COLUMN;
Table.SELECTION_ALL = SELECTION_ALL;
Table.SELECTION_INVERT = SELECTION_INVERT;
Table.SELECTION_NONE = SELECTION_NONE;
Table.Column = Column$1;
Table.ColumnGroup = ColumnGroup;
Table.Summary = FooterComponents;
var Table$1 = Table;
var CopyOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M832 64H296c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h496v688c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8V96c0-17.7-14.3-32-32-32zM704 192H192c-17.7 0-32 14.3-32 32v530.7c0 8.5 3.4 16.6 9.4 22.6l173.3 173.3c2.2 2.2 4.7 4 7.4 5.5v1.9h4.2c3.5 1.3 7.2 2 11 2H704c17.7 0 32-14.3 32-32V224c0-17.7-14.3-32-32-32zM350 856.2L263.9 770H350v86.2zM664 888H414V746c0-22.1-17.9-40-40-40H232V264h432v624z" } }] }, "name": "copy", "theme": "outlined" };
var CopyOutlinedSvg = CopyOutlined$2;
var CopyOutlined = function CopyOutlined2(props, ref) {
  return /* @__PURE__ */ react.exports.createElement(AntdIcon, _objectSpread2$1(_objectSpread2$1({}, props), {}, {
    ref,
    icon: CopyOutlinedSvg
  }));
};
CopyOutlined.displayName = "CopyOutlined";
var CopyOutlined$1 = /* @__PURE__ */ react.exports.forwardRef(CopyOutlined);
var ArrowDownOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M862 465.3h-81c-4.6 0-9 2-12.1 5.5L550 723.1V160c0-4.4-3.6-8-8-8h-60c-4.4 0-8 3.6-8 8v563.1L255.1 470.8c-3-3.5-7.4-5.5-12.1-5.5h-81c-6.8 0-10.5 8.1-6 13.2L487.9 861a31.96 31.96 0 0048.3 0L868 478.5c4.5-5.2.8-13.2-6-13.2z" } }] }, "name": "arrow-down", "theme": "outlined" };
var ArrowDownOutlinedSvg = ArrowDownOutlined$2;
var ArrowDownOutlined = function ArrowDownOutlined2(props, ref) {
  return /* @__PURE__ */ react.exports.createElement(AntdIcon, _objectSpread2$1(_objectSpread2$1({}, props), {}, {
    ref,
    icon: ArrowDownOutlinedSvg
  }));
};
ArrowDownOutlined.displayName = "ArrowDownOutlined";
var ArrowDownOutlined$1 = /* @__PURE__ */ react.exports.forwardRef(ArrowDownOutlined);
function CopyText(props) {
  function copy(data2) {
    navigator.clipboard.writeText(data2);
    message.success("\u590D\u5236\u6210\u529F");
  }
  return /* @__PURE__ */ jsxs("div", {
    children: [/* @__PURE__ */ jsx("span", {
      style: {
        marginRight: 8
      },
      children: props.children
    }), /* @__PURE__ */ jsx(CopyOutlined$1, {
      onClick: () => {
        copy(props.text);
      }
    })]
  });
}
function bind$1(fn2, thisArg) {
  return function wrap() {
    return fn2.apply(thisArg, arguments);
  };
}
const { toString: toString$4 } = Object.prototype;
const { getPrototypeOf } = Object;
const kindOf = ((cache2) => (thing) => {
  const str = toString$4.call(thing);
  return cache2[str] || (cache2[str] = str.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null));
const kindOfTest = (type4) => {
  type4 = type4.toLowerCase();
  return (thing) => kindOf(thing) === type4;
};
const typeOfTest = (type4) => (thing) => typeof thing === type4;
const { isArray: isArray$2 } = Array;
const isUndefined$1 = typeOfTest("undefined");
function isBuffer(val) {
  return val !== null && !isUndefined$1(val) && val.constructor !== null && !isUndefined$1(val.constructor) && isFunction$1(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}
const isArrayBuffer = kindOfTest("ArrayBuffer");
function isArrayBufferView(val) {
  let result;
  if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && isArrayBuffer(val.buffer);
  }
  return result;
}
const isString$1 = typeOfTest("string");
const isFunction$1 = typeOfTest("function");
const isNumber$2 = typeOfTest("number");
const isObject$1 = (thing) => thing !== null && typeof thing === "object";
const isBoolean$2 = (thing) => thing === true || thing === false;
const isPlainObject$4 = (val) => {
  if (kindOf(val) !== "object") {
    return false;
  }
  const prototype2 = getPrototypeOf(val);
  return (prototype2 === null || prototype2 === Object.prototype || Object.getPrototypeOf(prototype2) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
};
const isDate$1 = kindOfTest("Date");
const isFile = kindOfTest("File");
const isBlob = kindOfTest("Blob");
const isFileList = kindOfTest("FileList");
const isStream = (val) => isObject$1(val) && isFunction$1(val.pipe);
const isFormData = (thing) => {
  const pattern4 = "[object FormData]";
  return thing && (typeof FormData === "function" && thing instanceof FormData || toString$4.call(thing) === pattern4 || isFunction$1(thing.toString) && thing.toString() === pattern4);
};
const isURLSearchParams = kindOfTest("URLSearchParams");
const trim = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function forEach(obj, fn2, { allOwnKeys = false } = {}) {
  if (obj === null || typeof obj === "undefined") {
    return;
  }
  let i2;
  let l2;
  if (typeof obj !== "object") {
    obj = [obj];
  }
  if (isArray$2(obj)) {
    for (i2 = 0, l2 = obj.length; i2 < l2; i2++) {
      fn2.call(null, obj[i2], i2, obj);
    }
  } else {
    const keys2 = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
    const len = keys2.length;
    let key2;
    for (i2 = 0; i2 < len; i2++) {
      key2 = keys2[i2];
      fn2.call(null, obj[key2], key2, obj);
    }
  }
}
function merge() {
  const result = {};
  const assignValue = (val, key2) => {
    if (isPlainObject$4(result[key2]) && isPlainObject$4(val)) {
      result[key2] = merge(result[key2], val);
    } else if (isPlainObject$4(val)) {
      result[key2] = merge({}, val);
    } else if (isArray$2(val)) {
      result[key2] = val.slice();
    } else {
      result[key2] = val;
    }
  };
  for (let i2 = 0, l2 = arguments.length; i2 < l2; i2++) {
    arguments[i2] && forEach(arguments[i2], assignValue);
  }
  return result;
}
const extend$1 = (a2, b10, thisArg, { allOwnKeys } = {}) => {
  forEach(b10, (val, key2) => {
    if (thisArg && isFunction$1(val)) {
      a2[key2] = bind$1(val, thisArg);
    } else {
      a2[key2] = val;
    }
  }, { allOwnKeys });
  return a2;
};
const stripBOM = (content) => {
  if (content.charCodeAt(0) === 65279) {
    content = content.slice(1);
  }
  return content;
};
const inherits = (constructor, superConstructor, props, descriptors2) => {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
  constructor.prototype.constructor = constructor;
  Object.defineProperty(constructor, "super", {
    value: superConstructor.prototype
  });
  props && Object.assign(constructor.prototype, props);
};
const toFlatObject = (sourceObj, destObj, filter3, propFilter) => {
  let props;
  let i2;
  let prop;
  const merged = {};
  destObj = destObj || {};
  if (sourceObj == null)
    return destObj;
  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i2 = props.length;
    while (i2-- > 0) {
      prop = props[i2];
      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = filter3 !== false && getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter3 || filter3(sourceObj, destObj)) && sourceObj !== Object.prototype);
  return destObj;
};
const endsWith = (str, searchString, position) => {
  str = String(str);
  if (position === void 0 || position > str.length) {
    position = str.length;
  }
  position -= searchString.length;
  const lastIndex = str.indexOf(searchString, position);
  return lastIndex !== -1 && lastIndex === position;
};
const toArray$1 = (thing) => {
  if (!thing)
    return null;
  if (isArray$2(thing))
    return thing;
  let i2 = thing.length;
  if (!isNumber$2(i2))
    return null;
  const arr = new Array(i2);
  while (i2-- > 0) {
    arr[i2] = thing[i2];
  }
  return arr;
};
const isTypedArray = ((TypedArray) => {
  return (thing) => {
    return TypedArray && thing instanceof TypedArray;
  };
})(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
const forEachEntry = (obj, fn2) => {
  const generator = obj && obj[Symbol.iterator];
  const iterator = generator.call(obj);
  let result;
  while ((result = iterator.next()) && !result.done) {
    const pair = result.value;
    fn2.call(obj, pair[0], pair[1]);
  }
};
const matchAll = (regExp, str) => {
  let matches;
  const arr = [];
  while ((matches = regExp.exec(str)) !== null) {
    arr.push(matches);
  }
  return arr;
};
const isHTMLForm = kindOfTest("HTMLFormElement");
const toCamelCase = (str) => {
  return str.toLowerCase().replace(
    /[_-\s]([a-z\d])(\w*)/g,
    function replacer(m2, p1, p2) {
      return p1.toUpperCase() + p2;
    }
  );
};
const hasOwnProperty$3 = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop) => hasOwnProperty2.call(obj, prop))(Object.prototype);
const isRegExp = kindOfTest("RegExp");
const reduceDescriptors = (obj, reducer) => {
  const descriptors2 = Object.getOwnPropertyDescriptors(obj);
  const reducedDescriptors = {};
  forEach(descriptors2, (descriptor, name) => {
    if (reducer(descriptor, name, obj) !== false) {
      reducedDescriptors[name] = descriptor;
    }
  });
  Object.defineProperties(obj, reducedDescriptors);
};
const freezeMethods = (obj) => {
  reduceDescriptors(obj, (descriptor, name) => {
    const value2 = obj[name];
    if (!isFunction$1(value2))
      return;
    descriptor.enumerable = false;
    if ("writable" in descriptor) {
      descriptor.writable = false;
      return;
    }
    if (!descriptor.set) {
      descriptor.set = () => {
        throw Error("Can not read-only method '" + name + "'");
      };
    }
  });
};
const toObjectSet = (arrayOrString, delimiter) => {
  const obj = {};
  const define2 = (arr) => {
    arr.forEach((value2) => {
      obj[value2] = true;
    });
  };
  isArray$2(arrayOrString) ? define2(arrayOrString) : define2(String(arrayOrString).split(delimiter));
  return obj;
};
const noop$1 = () => {
};
const toFiniteNumber = (value2, defaultValue) => {
  value2 = +value2;
  return Number.isFinite(value2) ? value2 : defaultValue;
};
var utils = {
  isArray: isArray$2,
  isArrayBuffer,
  isBuffer,
  isFormData,
  isArrayBufferView,
  isString: isString$1,
  isNumber: isNumber$2,
  isBoolean: isBoolean$2,
  isObject: isObject$1,
  isPlainObject: isPlainObject$4,
  isUndefined: isUndefined$1,
  isDate: isDate$1,
  isFile,
  isBlob,
  isRegExp,
  isFunction: isFunction$1,
  isStream,
  isURLSearchParams,
  isTypedArray,
  isFileList,
  forEach,
  merge,
  extend: extend$1,
  trim,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray: toArray$1,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty: hasOwnProperty$3,
  hasOwnProp: hasOwnProperty$3,
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop: noop$1,
  toFiniteNumber
};
function AxiosError(message2, code2, config, request2, response) {
  Error.call(this);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack;
  }
  this.message = message2;
  this.name = "AxiosError";
  code2 && (this.code = code2);
  config && (this.config = config);
  request2 && (this.request = request2);
  response && (this.response = response);
}
utils.inherits(AxiosError, Error, {
  toJSON: function toJSON() {
    return {
      message: this.message,
      name: this.name,
      description: this.description,
      number: this.number,
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      config: this.config,
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  }
});
const prototype$1 = AxiosError.prototype;
const descriptors = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
].forEach((code2) => {
  descriptors[code2] = { value: code2 };
});
Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype$1, "isAxiosError", { value: true });
AxiosError.from = (error, code2, config, request2, response, customProps) => {
  const axiosError = Object.create(prototype$1);
  utils.toFlatObject(error, axiosError, function filter3(obj) {
    return obj !== Error.prototype;
  }, (prop) => {
    return prop !== "isAxiosError";
  });
  AxiosError.call(axiosError, error.message, code2, config, request2, response);
  axiosError.cause = error;
  axiosError.name = error.name;
  customProps && Object.assign(axiosError, customProps);
  return axiosError;
};
var browser$1 = typeof self == "object" ? self.FormData : window.FormData;
function isVisitable(thing) {
  return utils.isPlainObject(thing) || utils.isArray(thing);
}
function removeBrackets(key2) {
  return utils.endsWith(key2, "[]") ? key2.slice(0, -2) : key2;
}
function renderKey(path2, key2, dots) {
  if (!path2)
    return key2;
  return path2.concat(key2).map(function each2(token2, i2) {
    token2 = removeBrackets(token2);
    return !dots && i2 ? "[" + token2 + "]" : token2;
  }).join(dots ? "." : "");
}
function isFlatArray(arr) {
  return utils.isArray(arr) && !arr.some(isVisitable);
}
const predicates = utils.toFlatObject(utils, {}, null, function filter2(prop) {
  return /^is[A-Z]/.test(prop);
});
function isSpecCompliant(thing) {
  return thing && utils.isFunction(thing.append) && thing[Symbol.toStringTag] === "FormData" && thing[Symbol.iterator];
}
function toFormData(obj, formData, options) {
  if (!utils.isObject(obj)) {
    throw new TypeError("target must be an object");
  }
  formData = formData || new (browser$1 || FormData)();
  options = utils.toFlatObject(options, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function defined(option, source) {
    return !utils.isUndefined(source[option]);
  });
  const metaTokens = options.metaTokens;
  const visitor = options.visitor || defaultVisitor;
  const dots = options.dots;
  const indexes = options.indexes;
  const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
  const useBlob = _Blob && isSpecCompliant(formData);
  if (!utils.isFunction(visitor)) {
    throw new TypeError("visitor must be a function");
  }
  function convertValue(value2) {
    if (value2 === null)
      return "";
    if (utils.isDate(value2)) {
      return value2.toISOString();
    }
    if (!useBlob && utils.isBlob(value2)) {
      throw new AxiosError("Blob is not supported. Use a Buffer instead.");
    }
    if (utils.isArrayBuffer(value2) || utils.isTypedArray(value2)) {
      return useBlob && typeof Blob === "function" ? new Blob([value2]) : Buffer.from(value2);
    }
    return value2;
  }
  function defaultVisitor(value2, key2, path2) {
    let arr = value2;
    if (value2 && !path2 && typeof value2 === "object") {
      if (utils.endsWith(key2, "{}")) {
        key2 = metaTokens ? key2 : key2.slice(0, -2);
        value2 = JSON.stringify(value2);
      } else if (utils.isArray(value2) && isFlatArray(value2) || (utils.isFileList(value2) || utils.endsWith(key2, "[]") && (arr = utils.toArray(value2)))) {
        key2 = removeBrackets(key2);
        arr.forEach(function each2(el, index2) {
          !utils.isUndefined(el) && formData.append(
            indexes === true ? renderKey([key2], index2, dots) : indexes === null ? key2 : key2 + "[]",
            convertValue(el)
          );
        });
        return false;
      }
    }
    if (isVisitable(value2)) {
      return true;
    }
    formData.append(renderKey(path2, key2, dots), convertValue(value2));
    return false;
  }
  const stack = [];
  const exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue,
    isVisitable
  });
  function build(value2, path2) {
    if (utils.isUndefined(value2))
      return;
    if (stack.indexOf(value2) !== -1) {
      throw Error("Circular reference detected in " + path2.join("."));
    }
    stack.push(value2);
    utils.forEach(value2, function each2(el, key2) {
      const result = !utils.isUndefined(el) && visitor.call(
        formData,
        el,
        utils.isString(key2) ? key2.trim() : key2,
        path2,
        exposedHelpers
      );
      if (result === true) {
        build(el, path2 ? path2.concat(key2) : [key2]);
      }
    });
    stack.pop();
  }
  if (!utils.isObject(obj)) {
    throw new TypeError("data must be an object");
  }
  build(obj);
  return formData;
}
function encode$1(str) {
  const charMap = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match2) {
    return charMap[match2];
  });
}
function AxiosURLSearchParams(params, options) {
  this._pairs = [];
  params && toFormData(params, this, options);
}
const prototype = AxiosURLSearchParams.prototype;
prototype.append = function append(name, value2) {
  this._pairs.push([name, value2]);
};
prototype.toString = function toString2(encoder) {
  const _encode = encoder ? function(value2) {
    return encoder.call(this, value2, encode$1);
  } : encode$1;
  return this._pairs.map(function each2(pair) {
    return _encode(pair[0]) + "=" + _encode(pair[1]);
  }, "").join("&");
};
function encode(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function buildURL(url2, params, options) {
  if (!params) {
    return url2;
  }
  const hashmarkIndex = url2.indexOf("#");
  if (hashmarkIndex !== -1) {
    url2 = url2.slice(0, hashmarkIndex);
  }
  const _encode = options && options.encode || encode;
  const serializerParams = utils.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams(params, options).toString(_encode);
  if (serializerParams) {
    url2 += (url2.indexOf("?") === -1 ? "?" : "&") + serializerParams;
  }
  return url2;
}
class InterceptorManager {
  constructor() {
    this.handlers = [];
  }
  use(fulfilled, rejected, options) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options ? options.synchronous : false,
      runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
  }
  eject(id2) {
    if (this.handlers[id2]) {
      this.handlers[id2] = null;
    }
  }
  clear() {
    if (this.handlers) {
      this.handlers = [];
    }
  }
  forEach(fn2) {
    utils.forEach(this.handlers, function forEachHandler(h2) {
      if (h2 !== null) {
        fn2(h2);
      }
    });
  }
}
var transitionalDefaults = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};
var URLSearchParams$1 = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams;
var FormData$1 = FormData;
const isStandardBrowserEnv = (() => {
  let product;
  if (typeof navigator !== "undefined" && ((product = navigator.product) === "ReactNative" || product === "NativeScript" || product === "NS")) {
    return false;
  }
  return typeof window !== "undefined" && typeof document !== "undefined";
})();
var platform = {
  isBrowser: true,
  classes: {
    URLSearchParams: URLSearchParams$1,
    FormData: FormData$1,
    Blob
  },
  isStandardBrowserEnv,
  protocols: ["http", "https", "file", "blob", "url", "data"]
};
function toURLEncodedForm(data2, options) {
  return toFormData(data2, new platform.classes.URLSearchParams(), Object.assign({
    visitor: function(value2, key2, path2, helpers) {
      if (platform.isNode && utils.isBuffer(value2)) {
        this.append(key2, value2.toString("base64"));
        return false;
      }
      return helpers.defaultVisitor.apply(this, arguments);
    }
  }, options));
}
function parsePropPath(name) {
  return utils.matchAll(/\w+|\[(\w*)]/g, name).map((match2) => {
    return match2[0] === "[]" ? "" : match2[1] || match2[0];
  });
}
function arrayToObject(arr) {
  const obj = {};
  const keys2 = Object.keys(arr);
  let i2;
  const len = keys2.length;
  let key2;
  for (i2 = 0; i2 < len; i2++) {
    key2 = keys2[i2];
    obj[key2] = arr[key2];
  }
  return obj;
}
function formDataToJSON(formData) {
  function buildPath(path2, value2, target, index2) {
    let name = path2[index2++];
    const isNumericKey = Number.isFinite(+name);
    const isLast = index2 >= path2.length;
    name = !name && utils.isArray(target) ? target.length : name;
    if (isLast) {
      if (utils.hasOwnProp(target, name)) {
        target[name] = [target[name], value2];
      } else {
        target[name] = value2;
      }
      return !isNumericKey;
    }
    if (!target[name] || !utils.isObject(target[name])) {
      target[name] = [];
    }
    const result = buildPath(path2, value2, target[name], index2);
    if (result && utils.isArray(target[name])) {
      target[name] = arrayToObject(target[name]);
    }
    return !isNumericKey;
  }
  if (utils.isFormData(formData) && utils.isFunction(formData.entries)) {
    const obj = {};
    utils.forEachEntry(formData, (name, value2) => {
      buildPath(parsePropPath(name), value2, obj, 0);
    });
    return obj;
  }
  return null;
}
function settle(resolve, reject, response) {
  const validateStatus2 = response.config.validateStatus;
  if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
    resolve(response);
  } else {
    reject(new AxiosError(
      "Request failed with status code " + response.status,
      [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
      response.config,
      response.request,
      response
    ));
  }
}
var cookies = platform.isStandardBrowserEnv ? function standardBrowserEnv() {
  return {
    write: function write(name, value2, expires, path2, domain, secure) {
      const cookie = [];
      cookie.push(name + "=" + encodeURIComponent(value2));
      if (utils.isNumber(expires)) {
        cookie.push("expires=" + new Date(expires).toGMTString());
      }
      if (utils.isString(path2)) {
        cookie.push("path=" + path2);
      }
      if (utils.isString(domain)) {
        cookie.push("domain=" + domain);
      }
      if (secure === true) {
        cookie.push("secure");
      }
      document.cookie = cookie.join("; ");
    },
    read: function read(name) {
      const match2 = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
      return match2 ? decodeURIComponent(match2[3]) : null;
    },
    remove: function remove2(name) {
      this.write(name, "", Date.now() - 864e5);
    }
  };
}() : function nonStandardBrowserEnv() {
  return {
    write: function write() {
    },
    read: function read() {
      return null;
    },
    remove: function remove2() {
    }
  };
}();
function isAbsoluteURL(url2) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url2);
}
function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
}
function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
}
var isURLSameOrigin = platform.isStandardBrowserEnv ? function standardBrowserEnv2() {
  const msie = /(msie|trident)/i.test(navigator.userAgent);
  const urlParsingNode = document.createElement("a");
  let originURL;
  function resolveURL(url2) {
    let href = url2;
    if (msie) {
      urlParsingNode.setAttribute("href", href);
      href = urlParsingNode.href;
    }
    urlParsingNode.setAttribute("href", href);
    return {
      href: urlParsingNode.href,
      protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
      host: urlParsingNode.host,
      search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
      hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
      hostname: urlParsingNode.hostname,
      port: urlParsingNode.port,
      pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
    };
  }
  originURL = resolveURL(window.location.href);
  return function isURLSameOrigin2(requestURL) {
    const parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;
    return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
  };
}() : function nonStandardBrowserEnv2() {
  return function isURLSameOrigin2() {
    return true;
  };
}();
function CanceledError(message2, config, request2) {
  AxiosError.call(this, message2 == null ? "canceled" : message2, AxiosError.ERR_CANCELED, config, request2);
  this.name = "CanceledError";
}
utils.inherits(CanceledError, AxiosError, {
  __CANCEL__: true
});
function parseProtocol(url2) {
  const match2 = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url2);
  return match2 && match2[1] || "";
}
const ignoreDuplicateOf = utils.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]);
var parseHeaders = (rawHeaders) => {
  const parsed = {};
  let key2;
  let val;
  let i2;
  rawHeaders && rawHeaders.split("\n").forEach(function parser(line2) {
    i2 = line2.indexOf(":");
    key2 = line2.substring(0, i2).trim().toLowerCase();
    val = line2.substring(i2 + 1).trim();
    if (!key2 || parsed[key2] && ignoreDuplicateOf[key2]) {
      return;
    }
    if (key2 === "set-cookie") {
      if (parsed[key2]) {
        parsed[key2].push(val);
      } else {
        parsed[key2] = [val];
      }
    } else {
      parsed[key2] = parsed[key2] ? parsed[key2] + ", " + val : val;
    }
  });
  return parsed;
};
const $internals = Symbol("internals");
const $defaults = Symbol("defaults");
function normalizeHeader(header) {
  return header && String(header).trim().toLowerCase();
}
function normalizeValue(value2) {
  if (value2 === false || value2 == null) {
    return value2;
  }
  return String(value2);
}
function parseTokens(str) {
  const tokens = /* @__PURE__ */ Object.create(null);
  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let match2;
  while (match2 = tokensRE.exec(str)) {
    tokens[match2[1]] = match2[2];
  }
  return tokens;
}
function matchHeaderValue(context2, value2, header, filter3) {
  if (utils.isFunction(filter3)) {
    return filter3.call(this, value2, header);
  }
  if (!utils.isString(value2))
    return;
  if (utils.isString(filter3)) {
    return value2.indexOf(filter3) !== -1;
  }
  if (utils.isRegExp(filter3)) {
    return filter3.test(value2);
  }
}
function formatHeader(header) {
  return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w2, char, str) => {
    return char.toUpperCase() + str;
  });
}
function buildAccessors(obj, header) {
  const accessorName = utils.toCamelCase(" " + header);
  ["get", "set", "has"].forEach((methodName) => {
    Object.defineProperty(obj, methodName + accessorName, {
      value: function(arg1, arg2, arg3) {
        return this[methodName].call(this, header, arg1, arg2, arg3);
      },
      configurable: true
    });
  });
}
function findKey(obj, key2) {
  key2 = key2.toLowerCase();
  const keys2 = Object.keys(obj);
  let i2 = keys2.length;
  let _key;
  while (i2-- > 0) {
    _key = keys2[i2];
    if (key2 === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}
function AxiosHeaders(headers, defaults2) {
  headers && this.set(headers);
  this[$defaults] = defaults2 || null;
}
Object.assign(AxiosHeaders.prototype, {
  set: function(header, valueOrRewrite, rewrite) {
    const self2 = this;
    function setHeader(_value, _header, _rewrite) {
      const lHeader = normalizeHeader(_header);
      if (!lHeader) {
        throw new Error("header name must be a non-empty string");
      }
      const key2 = findKey(self2, lHeader);
      if (key2 && _rewrite !== true && (self2[key2] === false || _rewrite === false)) {
        return;
      }
      if (utils.isArray(_value)) {
        _value = _value.map(normalizeValue);
      } else {
        _value = normalizeValue(_value);
      }
      self2[key2 || _header] = _value;
    }
    if (utils.isPlainObject(header)) {
      utils.forEach(header, (_value, _header) => {
        setHeader(_value, _header, valueOrRewrite);
      });
    } else {
      setHeader(valueOrRewrite, header, rewrite);
    }
    return this;
  },
  get: function(header, parser) {
    header = normalizeHeader(header);
    if (!header)
      return void 0;
    const key2 = findKey(this, header);
    if (key2) {
      const value2 = this[key2];
      if (!parser) {
        return value2;
      }
      if (parser === true) {
        return parseTokens(value2);
      }
      if (utils.isFunction(parser)) {
        return parser.call(this, value2, key2);
      }
      if (utils.isRegExp(parser)) {
        return parser.exec(value2);
      }
      throw new TypeError("parser must be boolean|regexp|function");
    }
  },
  has: function(header, matcher) {
    header = normalizeHeader(header);
    if (header) {
      const key2 = findKey(this, header);
      return !!(key2 && (!matcher || matchHeaderValue(this, this[key2], key2, matcher)));
    }
    return false;
  },
  delete: function(header, matcher) {
    const self2 = this;
    let deleted = false;
    function deleteHeader(_header) {
      _header = normalizeHeader(_header);
      if (_header) {
        const key2 = findKey(self2, _header);
        if (key2 && (!matcher || matchHeaderValue(self2, self2[key2], key2, matcher))) {
          delete self2[key2];
          deleted = true;
        }
      }
    }
    if (utils.isArray(header)) {
      header.forEach(deleteHeader);
    } else {
      deleteHeader(header);
    }
    return deleted;
  },
  clear: function() {
    return Object.keys(this).forEach(this.delete.bind(this));
  },
  normalize: function(format2) {
    const self2 = this;
    const headers = {};
    utils.forEach(this, (value2, header) => {
      const key2 = findKey(headers, header);
      if (key2) {
        self2[key2] = normalizeValue(value2);
        delete self2[header];
        return;
      }
      const normalized = format2 ? formatHeader(header) : String(header).trim();
      if (normalized !== header) {
        delete self2[header];
      }
      self2[normalized] = normalizeValue(value2);
      headers[normalized] = true;
    });
    return this;
  },
  toJSON: function() {
    const obj = /* @__PURE__ */ Object.create(null);
    utils.forEach(
      Object.assign({}, this[$defaults] || null, this),
      (value2, header) => {
        if (value2 == null || value2 === false)
          return;
        obj[header] = utils.isArray(value2) ? value2.join(", ") : value2;
      }
    );
    return obj;
  }
});
Object.assign(AxiosHeaders, {
  from: function(thing) {
    if (utils.isString(thing)) {
      return new this(parseHeaders(thing));
    }
    return thing instanceof this ? thing : new this(thing);
  },
  accessor: function(header) {
    const internals = this[$internals] = this[$internals] = {
      accessors: {}
    };
    const accessors = internals.accessors;
    const prototype2 = this.prototype;
    function defineAccessor(_header) {
      const lHeader = normalizeHeader(_header);
      if (!accessors[lHeader]) {
        buildAccessors(prototype2, _header);
        accessors[lHeader] = true;
      }
    }
    utils.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
    return this;
  }
});
AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent"]);
utils.freezeMethods(AxiosHeaders.prototype);
utils.freezeMethods(AxiosHeaders);
function speedometer(samplesCount, min2) {
  samplesCount = samplesCount || 10;
  const bytes = new Array(samplesCount);
  const timestamps = new Array(samplesCount);
  let head2 = 0;
  let tail = 0;
  let firstSampleTS;
  min2 = min2 !== void 0 ? min2 : 1e3;
  return function push(chunkLength) {
    const now2 = Date.now();
    const startedAt = timestamps[tail];
    if (!firstSampleTS) {
      firstSampleTS = now2;
    }
    bytes[head2] = chunkLength;
    timestamps[head2] = now2;
    let i2 = tail;
    let bytesCount = 0;
    while (i2 !== head2) {
      bytesCount += bytes[i2++];
      i2 = i2 % samplesCount;
    }
    head2 = (head2 + 1) % samplesCount;
    if (head2 === tail) {
      tail = (tail + 1) % samplesCount;
    }
    if (now2 - firstSampleTS < min2) {
      return;
    }
    const passed = startedAt && now2 - startedAt;
    return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
  };
}
function progressEventReducer(listener, isDownloadStream) {
  let bytesNotified = 0;
  const _speedometer = speedometer(50, 250);
  return (e3) => {
    const loaded = e3.loaded;
    const total = e3.lengthComputable ? e3.total : void 0;
    const progressBytes = loaded - bytesNotified;
    const rate = _speedometer(progressBytes);
    const inRange = loaded <= total;
    bytesNotified = loaded;
    const data2 = {
      loaded,
      total,
      progress: total ? loaded / total : void 0,
      bytes: progressBytes,
      rate: rate ? rate : void 0,
      estimated: rate && total && inRange ? (total - loaded) / rate : void 0
    };
    data2[isDownloadStream ? "download" : "upload"] = true;
    listener(data2);
  };
}
function xhrAdapter(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    let requestData = config.data;
    const requestHeaders = AxiosHeaders.from(config.headers).normalize();
    const responseType = config.responseType;
    let onCanceled;
    function done() {
      if (config.cancelToken) {
        config.cancelToken.unsubscribe(onCanceled);
      }
      if (config.signal) {
        config.signal.removeEventListener("abort", onCanceled);
      }
    }
    if (utils.isFormData(requestData) && platform.isStandardBrowserEnv) {
      requestHeaders.setContentType(false);
    }
    let request2 = new XMLHttpRequest();
    if (config.auth) {
      const username = config.auth.username || "";
      const password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : "";
      requestHeaders.set("Authorization", "Basic " + btoa(username + ":" + password));
    }
    const fullPath = buildFullPath(config.baseURL, config.url);
    request2.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);
    request2.timeout = config.timeout;
    function onloadend() {
      if (!request2) {
        return;
      }
      const responseHeaders = AxiosHeaders.from(
        "getAllResponseHeaders" in request2 && request2.getAllResponseHeaders()
      );
      const responseData = !responseType || responseType === "text" || responseType === "json" ? request2.responseText : request2.response;
      const response = {
        data: responseData,
        status: request2.status,
        statusText: request2.statusText,
        headers: responseHeaders,
        config,
        request: request2
      };
      settle(function _resolve(value2) {
        resolve(value2);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response);
      request2 = null;
    }
    if ("onloadend" in request2) {
      request2.onloadend = onloadend;
    } else {
      request2.onreadystatechange = function handleLoad() {
        if (!request2 || request2.readyState !== 4) {
          return;
        }
        if (request2.status === 0 && !(request2.responseURL && request2.responseURL.indexOf("file:") === 0)) {
          return;
        }
        setTimeout(onloadend);
      };
    }
    request2.onabort = function handleAbort() {
      if (!request2) {
        return;
      }
      reject(new AxiosError("Request aborted", AxiosError.ECONNABORTED, config, request2));
      request2 = null;
    };
    request2.onerror = function handleError() {
      reject(new AxiosError("Network Error", AxiosError.ERR_NETWORK, config, request2));
      request2 = null;
    };
    request2.ontimeout = function handleTimeout() {
      let timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded";
      const transitional2 = config.transitional || transitionalDefaults;
      if (config.timeoutErrorMessage) {
        timeoutErrorMessage = config.timeoutErrorMessage;
      }
      reject(new AxiosError(
        timeoutErrorMessage,
        transitional2.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
        config,
        request2
      ));
      request2 = null;
    };
    if (platform.isStandardBrowserEnv) {
      const xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName && cookies.read(config.xsrfCookieName);
      if (xsrfValue) {
        requestHeaders.set(config.xsrfHeaderName, xsrfValue);
      }
    }
    requestData === void 0 && requestHeaders.setContentType(null);
    if ("setRequestHeader" in request2) {
      utils.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key2) {
        request2.setRequestHeader(key2, val);
      });
    }
    if (!utils.isUndefined(config.withCredentials)) {
      request2.withCredentials = !!config.withCredentials;
    }
    if (responseType && responseType !== "json") {
      request2.responseType = config.responseType;
    }
    if (typeof config.onDownloadProgress === "function") {
      request2.addEventListener("progress", progressEventReducer(config.onDownloadProgress, true));
    }
    if (typeof config.onUploadProgress === "function" && request2.upload) {
      request2.upload.addEventListener("progress", progressEventReducer(config.onUploadProgress));
    }
    if (config.cancelToken || config.signal) {
      onCanceled = (cancel2) => {
        if (!request2) {
          return;
        }
        reject(!cancel2 || cancel2.type ? new CanceledError(null, config, request2) : cancel2);
        request2.abort();
        request2 = null;
      };
      config.cancelToken && config.cancelToken.subscribe(onCanceled);
      if (config.signal) {
        config.signal.aborted ? onCanceled() : config.signal.addEventListener("abort", onCanceled);
      }
    }
    const protocol = parseProtocol(fullPath);
    if (protocol && platform.protocols.indexOf(protocol) === -1) {
      reject(new AxiosError("Unsupported protocol " + protocol + ":", AxiosError.ERR_BAD_REQUEST, config));
      return;
    }
    request2.send(requestData || null);
  });
}
const adapters = {
  http: xhrAdapter,
  xhr: xhrAdapter
};
var adapters$1 = {
  getAdapter: (nameOrAdapter) => {
    if (utils.isString(nameOrAdapter)) {
      const adapter = adapters[nameOrAdapter];
      if (!nameOrAdapter) {
        throw Error(
          utils.hasOwnProp(nameOrAdapter) ? `Adapter '${nameOrAdapter}' is not available in the build` : `Can not resolve adapter '${nameOrAdapter}'`
        );
      }
      return adapter;
    }
    if (!utils.isFunction(nameOrAdapter)) {
      throw new TypeError("adapter is not a function");
    }
    return nameOrAdapter;
  },
  adapters
};
const DEFAULT_CONTENT_TYPE = {
  "Content-Type": "application/x-www-form-urlencoded"
};
function getDefaultAdapter() {
  let adapter;
  if (typeof XMLHttpRequest !== "undefined") {
    adapter = adapters$1.getAdapter("xhr");
  } else if (typeof process !== "undefined" && utils.kindOf(process) === "process") {
    adapter = adapters$1.getAdapter("http");
  }
  return adapter;
}
function stringifySafely(rawValue, parser, encoder) {
  if (utils.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils.trim(rawValue);
    } catch (e3) {
      if (e3.name !== "SyntaxError") {
        throw e3;
      }
    }
  }
  return (encoder || JSON.stringify)(rawValue);
}
const defaults = {
  transitional: transitionalDefaults,
  adapter: getDefaultAdapter(),
  transformRequest: [function transformRequest(data2, headers) {
    const contentType = headers.getContentType() || "";
    const hasJSONContentType = contentType.indexOf("application/json") > -1;
    const isObjectPayload = utils.isObject(data2);
    if (isObjectPayload && utils.isHTMLForm(data2)) {
      data2 = new FormData(data2);
    }
    const isFormData2 = utils.isFormData(data2);
    if (isFormData2) {
      if (!hasJSONContentType) {
        return data2;
      }
      return hasJSONContentType ? JSON.stringify(formDataToJSON(data2)) : data2;
    }
    if (utils.isArrayBuffer(data2) || utils.isBuffer(data2) || utils.isStream(data2) || utils.isFile(data2) || utils.isBlob(data2)) {
      return data2;
    }
    if (utils.isArrayBufferView(data2)) {
      return data2.buffer;
    }
    if (utils.isURLSearchParams(data2)) {
      headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
      return data2.toString();
    }
    let isFileList2;
    if (isObjectPayload) {
      if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
        return toURLEncodedForm(data2, this.formSerializer).toString();
      }
      if ((isFileList2 = utils.isFileList(data2)) || contentType.indexOf("multipart/form-data") > -1) {
        const _FormData = this.env && this.env.FormData;
        return toFormData(
          isFileList2 ? { "files[]": data2 } : data2,
          _FormData && new _FormData(),
          this.formSerializer
        );
      }
    }
    if (isObjectPayload || hasJSONContentType) {
      headers.setContentType("application/json", false);
      return stringifySafely(data2);
    }
    return data2;
  }],
  transformResponse: [function transformResponse(data2) {
    const transitional2 = this.transitional || defaults.transitional;
    const forcedJSONParsing = transitional2 && transitional2.forcedJSONParsing;
    const JSONRequested = this.responseType === "json";
    if (data2 && utils.isString(data2) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
      const silentJSONParsing = transitional2 && transitional2.silentJSONParsing;
      const strictJSONParsing = !silentJSONParsing && JSONRequested;
      try {
        return JSON.parse(data2);
      } catch (e3) {
        if (strictJSONParsing) {
          if (e3.name === "SyntaxError") {
            throw AxiosError.from(e3, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e3;
        }
      }
    }
    return data2;
  }],
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: platform.classes.FormData,
    Blob: platform.classes.Blob
  },
  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },
  headers: {
    common: {
      "Accept": "application/json, text/plain, */*"
    }
  }
};
utils.forEach(["delete", "get", "head"], function forEachMethodNoData(method4) {
  defaults.headers[method4] = {};
});
utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method4) {
  defaults.headers[method4] = utils.merge(DEFAULT_CONTENT_TYPE);
});
function transformData$9(fns, response) {
  const config = this || defaults;
  const context2 = response || config;
  const headers = AxiosHeaders.from(context2.headers);
  let data2 = context2.data;
  utils.forEach(fns, function transform2(fn2) {
    data2 = fn2.call(config, data2, headers.normalize(), response ? response.status : void 0);
  });
  headers.normalize();
  return data2;
}
function isCancel(value2) {
  return !!(value2 && value2.__CANCEL__);
}
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
  if (config.signal && config.signal.aborted) {
    throw new CanceledError();
  }
}
function dispatchRequest(config) {
  throwIfCancellationRequested(config);
  config.headers = AxiosHeaders.from(config.headers);
  config.data = transformData$9.call(
    config,
    config.transformRequest
  );
  const adapter = config.adapter || defaults.adapter;
  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);
    response.data = transformData$9.call(
      config,
      config.transformResponse,
      response
    );
    response.headers = AxiosHeaders.from(response.headers);
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);
      if (reason && reason.response) {
        reason.response.data = transformData$9.call(
          config,
          config.transformResponse,
          reason.response
        );
        reason.response.headers = AxiosHeaders.from(reason.response.headers);
      }
    }
    return Promise.reject(reason);
  });
}
function mergeConfig(config1, config2) {
  config2 = config2 || {};
  const config = {};
  function getMergedValue(target, source) {
    if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
      return utils.merge(target, source);
    } else if (utils.isPlainObject(source)) {
      return utils.merge({}, source);
    } else if (utils.isArray(source)) {
      return source.slice();
    }
    return source;
  }
  function mergeDeepProperties(prop) {
    if (!utils.isUndefined(config2[prop])) {
      return getMergedValue(config1[prop], config2[prop]);
    } else if (!utils.isUndefined(config1[prop])) {
      return getMergedValue(void 0, config1[prop]);
    }
  }
  function valueFromConfig2(prop) {
    if (!utils.isUndefined(config2[prop])) {
      return getMergedValue(void 0, config2[prop]);
    }
  }
  function defaultToConfig2(prop) {
    if (!utils.isUndefined(config2[prop])) {
      return getMergedValue(void 0, config2[prop]);
    } else if (!utils.isUndefined(config1[prop])) {
      return getMergedValue(void 0, config1[prop]);
    }
  }
  function mergeDirectKeys(prop) {
    if (prop in config2) {
      return getMergedValue(config1[prop], config2[prop]);
    } else if (prop in config1) {
      return getMergedValue(void 0, config1[prop]);
    }
  }
  const mergeMap = {
    "url": valueFromConfig2,
    "method": valueFromConfig2,
    "data": valueFromConfig2,
    "baseURL": defaultToConfig2,
    "transformRequest": defaultToConfig2,
    "transformResponse": defaultToConfig2,
    "paramsSerializer": defaultToConfig2,
    "timeout": defaultToConfig2,
    "timeoutMessage": defaultToConfig2,
    "withCredentials": defaultToConfig2,
    "adapter": defaultToConfig2,
    "responseType": defaultToConfig2,
    "xsrfCookieName": defaultToConfig2,
    "xsrfHeaderName": defaultToConfig2,
    "onUploadProgress": defaultToConfig2,
    "onDownloadProgress": defaultToConfig2,
    "decompress": defaultToConfig2,
    "maxContentLength": defaultToConfig2,
    "maxBodyLength": defaultToConfig2,
    "beforeRedirect": defaultToConfig2,
    "transport": defaultToConfig2,
    "httpAgent": defaultToConfig2,
    "httpsAgent": defaultToConfig2,
    "cancelToken": defaultToConfig2,
    "socketPath": defaultToConfig2,
    "responseEncoding": defaultToConfig2,
    "validateStatus": mergeDirectKeys
  };
  utils.forEach(Object.keys(config1).concat(Object.keys(config2)), function computeConfigValue(prop) {
    const merge3 = mergeMap[prop] || mergeDeepProperties;
    const configValue = merge3(prop);
    utils.isUndefined(configValue) && merge3 !== mergeDirectKeys || (config[prop] = configValue);
  });
  return config;
}
const VERSION = "1.1.2";
const validators$1 = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((type4, i2) => {
  validators$1[type4] = function validator2(thing) {
    return typeof thing === type4 || "a" + (i2 < 1 ? "n " : " ") + type4;
  };
});
const deprecatedWarnings = {};
validators$1.transitional = function transitional(validator2, version2, message2) {
  function formatMessage(opt, desc) {
    return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message2 ? ". " + message2 : "");
  }
  return (value2, opt, opts) => {
    if (validator2 === false) {
      throw new AxiosError(
        formatMessage(opt, " has been removed" + (version2 ? " in " + version2 : "")),
        AxiosError.ERR_DEPRECATED
      );
    }
    if (version2 && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      console.warn(
        formatMessage(
          opt,
          " has been deprecated since v" + version2 + " and will be removed in the near future"
        )
      );
    }
    return validator2 ? validator2(value2, opt, opts) : true;
  };
};
function assertOptions(options, schema2, allowUnknown) {
  if (typeof options !== "object") {
    throw new AxiosError("options must be an object", AxiosError.ERR_BAD_OPTION_VALUE);
  }
  const keys2 = Object.keys(options);
  let i2 = keys2.length;
  while (i2-- > 0) {
    const opt = keys2[i2];
    const validator2 = schema2[opt];
    if (validator2) {
      const value2 = options[opt];
      const result = value2 === void 0 || validator2(value2, opt, options);
      if (result !== true) {
        throw new AxiosError("option " + opt + " must be " + result, AxiosError.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError("Unknown option " + opt, AxiosError.ERR_BAD_OPTION);
    }
  }
}
var validator = {
  assertOptions,
  validators: validators$1
};
const validators = validator.validators;
class Axios {
  constructor(instanceConfig) {
    this.defaults = instanceConfig;
    this.interceptors = {
      request: new InterceptorManager(),
      response: new InterceptorManager()
    };
  }
  request(configOrUrl, config) {
    if (typeof configOrUrl === "string") {
      config = config || {};
      config.url = configOrUrl;
    } else {
      config = configOrUrl || {};
    }
    config = mergeConfig(this.defaults, config);
    const transitional2 = config.transitional;
    if (transitional2 !== void 0) {
      validator.assertOptions(transitional2, {
        silentJSONParsing: validators.transitional(validators.boolean),
        forcedJSONParsing: validators.transitional(validators.boolean),
        clarifyTimeoutError: validators.transitional(validators.boolean)
      }, false);
    }
    config.method = (config.method || this.defaults.method || "get").toLowerCase();
    const defaultHeaders = config.headers && utils.merge(
      config.headers.common,
      config.headers[config.method]
    );
    defaultHeaders && utils.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      function cleanHeaderConfig(method4) {
        delete config.headers[method4];
      }
    );
    config.headers = new AxiosHeaders(config.headers, defaultHeaders);
    const requestInterceptorChain = [];
    let synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
        return;
      }
      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });
    const responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });
    let promise;
    let i2 = 0;
    let len;
    if (!synchronousRequestInterceptors) {
      const chain = [dispatchRequest.bind(this), void 0];
      chain.unshift.apply(chain, requestInterceptorChain);
      chain.push.apply(chain, responseInterceptorChain);
      len = chain.length;
      promise = Promise.resolve(config);
      while (i2 < len) {
        promise = promise.then(chain[i2++], chain[i2++]);
      }
      return promise;
    }
    len = requestInterceptorChain.length;
    let newConfig = config;
    i2 = 0;
    while (i2 < len) {
      const onFulfilled = requestInterceptorChain[i2++];
      const onRejected = requestInterceptorChain[i2++];
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error) {
        onRejected.call(this, error);
        break;
      }
    }
    try {
      promise = dispatchRequest.call(this, newConfig);
    } catch (error) {
      return Promise.reject(error);
    }
    i2 = 0;
    len = responseInterceptorChain.length;
    while (i2 < len) {
      promise = promise.then(responseInterceptorChain[i2++], responseInterceptorChain[i2++]);
    }
    return promise;
  }
  getUri(config) {
    config = mergeConfig(this.defaults, config);
    const fullPath = buildFullPath(config.baseURL, config.url);
    return buildURL(fullPath, config.params, config.paramsSerializer);
  }
}
utils.forEach(["delete", "get", "head", "options"], function forEachMethodNoData2(method4) {
  Axios.prototype[method4] = function(url2, config) {
    return this.request(mergeConfig(config || {}, {
      method: method4,
      url: url2,
      data: (config || {}).data
    }));
  };
});
utils.forEach(["post", "put", "patch"], function forEachMethodWithData2(method4) {
  function generateHTTPMethod(isForm) {
    return function httpMethod(url2, data2, config) {
      return this.request(mergeConfig(config || {}, {
        method: method4,
        headers: isForm ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url: url2,
        data: data2
      }));
    };
  }
  Axios.prototype[method4] = generateHTTPMethod();
  Axios.prototype[method4 + "Form"] = generateHTTPMethod(true);
});
class CancelToken {
  constructor(executor) {
    if (typeof executor !== "function") {
      throw new TypeError("executor must be a function.");
    }
    let resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve) {
      resolvePromise = resolve;
    });
    const token2 = this;
    this.promise.then((cancel2) => {
      if (!token2._listeners)
        return;
      let i2 = token2._listeners.length;
      while (i2-- > 0) {
        token2._listeners[i2](cancel2);
      }
      token2._listeners = null;
    });
    this.promise.then = (onfulfilled) => {
      let _resolve;
      const promise = new Promise((resolve) => {
        token2.subscribe(resolve);
        _resolve = resolve;
      }).then(onfulfilled);
      promise.cancel = function reject() {
        token2.unsubscribe(_resolve);
      };
      return promise;
    };
    executor(function cancel2(message2, config, request2) {
      if (token2.reason) {
        return;
      }
      token2.reason = new CanceledError(message2, config, request2);
      resolvePromise(token2.reason);
    });
  }
  throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  }
  subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }
    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  }
  unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    const index2 = this._listeners.indexOf(listener);
    if (index2 !== -1) {
      this._listeners.splice(index2, 1);
    }
  }
  static source() {
    let cancel2;
    const token2 = new CancelToken(function executor(c2) {
      cancel2 = c2;
    });
    return {
      token: token2,
      cancel: cancel2
    };
  }
}
function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
}
function isAxiosError(payload) {
  return utils.isObject(payload) && payload.isAxiosError === true;
}
function createInstance(defaultConfig) {
  const context2 = new Axios(defaultConfig);
  const instance = bind$1(Axios.prototype.request, context2);
  utils.extend(instance, Axios.prototype, context2, { allOwnKeys: true });
  utils.extend(instance, context2, null, { allOwnKeys: true });
  instance.create = function create2(instanceConfig) {
    return createInstance(mergeConfig(defaultConfig, instanceConfig));
  };
  return instance;
}
const axios = createInstance(defaults);
axios.Axios = Axios;
axios.CanceledError = CanceledError;
axios.CancelToken = CancelToken;
axios.isCancel = isCancel;
axios.VERSION = VERSION;
axios.toFormData = toFormData;
axios.AxiosError = AxiosError;
axios.Cancel = axios.CanceledError;
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = spread;
axios.isAxiosError = isAxiosError;
axios.formToJSON = (thing) => {
  return formDataToJSON(utils.isHTMLForm(thing) ? new FormData(thing) : thing);
};
const APIHOST = {
  local: "http://192.168.1.56:8888",
  uat: "http://www.baidu.com"
};
let HOST_NAME = "";
const NODE_ENV = typeof process !== "undefined" ? "production" : window.LOCAL_ENV;
HOST_NAME = APIHOST[NODE_ENV.toLocaleLowerCase()];
var HOST_NAME$1 = HOST_NAME;
const TIMEOUT = 1e4, SUCCESS_STATUS = 200;
let axiosIns = axios.create({
  timeout: TIMEOUT
});
const PREFIX = "/api";
function request({ method: method4, url: url2, options, config = {} }) {
  return new Promise(function(resolve, reject) {
    console.log(`${HOST_NAME$1}${PREFIX}${url2}`);
    axiosIns[method4](`${HOST_NAME$1}${PREFIX}${url2}`, options, config).then(function(res) {
      let result = res.data, error;
      if (res && res.status === SUCCESS_STATUS) {
        const data2 = res.data;
        res.data = typeof data2 === "undefined" ? {} : data2;
        if (res.data.code === 99) {
          throw res.data.message;
        }
        resolve(res.data);
      } else {
        error = new Error();
        error.message = result.message;
        error.data = res.data;
        error.code = res.status;
        throw error;
      }
    }).catch(function(error) {
      message.error(error);
      if (!axios.isCancel(error)) {
        reject(error);
      }
    });
  });
}
function get$1(params) {
  const { url: url2, query, config } = params;
  return request({
    method: "get",
    url: url2,
    options: query || {},
    config
  });
}
function post(params) {
  const { url: url2, query, config } = params;
  return request({
    method: "post",
    url: url2,
    options: Object.assign({
      ...query
    }, config)
  });
}
var request$1 = {
  get: get$1,
  post
};
function useSearchNavigate() {
  const navigate = useNavigate();
  const jumpToAddress = react.exports.useCallback((address) => {
    request$1.post({
      url: "/dashboard/search",
      query: {
        address
      }
    }).then((res) => {
      const {
        code: code2,
        address: address2,
        message: message2 = ""
      } = (res == null ? void 0 : res.data) || {};
      switch (code2) {
        case 0:
          navigate(`/walletDetail/${address2}`);
          break;
        case 1:
          navigate(`/contractDetail/${address2}`);
          break;
        case 2:
          navigate(`/transaction/${address2}`);
          break;
        case 3:
          navigate(`/blockHeight/${address2}`);
          break;
        default:
          return "";
      }
    }).catch((e3) => {
    });
  }, []);
  return jumpToAddress;
}
var index$c = "";
const Search = Input$1.Search;
function CommonSearch(props) {
  const jumpToAddress = useSearchNavigate();
  const {
    type: type4 = ""
  } = useParams();
  const onSearch = react.exports.useCallback((address) => {
    if (type4 === address) {
      return;
    }
    jumpToAddress(address);
  }, [type4]);
  return /* @__PURE__ */ jsx(Search, {
    className: "common-search-btn",
    placeholder: "\u641C\u7D22\u94B1\u5305\u5730\u5740/\u8F6C\u8D26\u54C8\u5E0C/\u5408\u7EA6/\u533A\u5757\u9AD8\u5EA6",
    onSearch
  });
}
const TEXT_MAX_LEN = 12;
const TEXT_SPLIT_LEN = 6;
const overLenTextShow = (text2 = "") => {
  if (text2.length > TEXT_MAX_LEN) {
    return text2.replace(text2.slice(TEXT_SPLIT_LEN, text2.length - TEXT_SPLIT_LEN), "...");
  }
  return text2;
};
function NavigateAddress({
  address
}) {
  const jumpToAddress = useSearchNavigate();
  const handleBtn = react.exports.useCallback(() => {
    jumpToAddress(address);
  }, [address]);
  return /* @__PURE__ */ jsx(Button$2, {
    style: {
      paddingLeft: 0
    },
    type: "link",
    onClick: handleBtn,
    children: overLenTextShow(address)
  });
}
function n(n2) {
  for (var r2 = arguments.length, t2 = Array(r2 > 1 ? r2 - 1 : 0), e3 = 1; e3 < r2; e3++)
    t2[e3 - 1] = arguments[e3];
  throw Error("[Immer] minified error nr: " + n2 + (t2.length ? " " + t2.map(function(n3) {
    return "'" + n3 + "'";
  }).join(",") : "") + ". Find the full error at: https://bit.ly/3cXEKWf");
}
function r(n2) {
  return !!n2 && !!n2[Q];
}
function t(n2) {
  return !!n2 && (function(n3) {
    if (!n3 || "object" != typeof n3)
      return false;
    var r2 = Object.getPrototypeOf(n3);
    if (null === r2)
      return true;
    var t2 = Object.hasOwnProperty.call(r2, "constructor") && r2.constructor;
    return t2 === Object || "function" == typeof t2 && Function.toString.call(t2) === Z;
  }(n2) || Array.isArray(n2) || !!n2[L] || !!n2.constructor[L] || s(n2) || v(n2));
}
function i(n2, r2, t2) {
  void 0 === t2 && (t2 = false), 0 === o(n2) ? (t2 ? Object.keys : nn)(n2).forEach(function(e3) {
    t2 && "symbol" == typeof e3 || r2(e3, n2[e3], n2);
  }) : n2.forEach(function(t3, e3) {
    return r2(e3, t3, n2);
  });
}
function o(n2) {
  var r2 = n2[Q];
  return r2 ? r2.i > 3 ? r2.i - 4 : r2.i : Array.isArray(n2) ? 1 : s(n2) ? 2 : v(n2) ? 3 : 0;
}
function u(n2, r2) {
  return 2 === o(n2) ? n2.has(r2) : Object.prototype.hasOwnProperty.call(n2, r2);
}
function a(n2, r2) {
  return 2 === o(n2) ? n2.get(r2) : n2[r2];
}
function f(n2, r2, t2) {
  var e3 = o(n2);
  2 === e3 ? n2.set(r2, t2) : 3 === e3 ? (n2.delete(r2), n2.add(t2)) : n2[r2] = t2;
}
function c(n2, r2) {
  return n2 === r2 ? 0 !== n2 || 1 / n2 == 1 / r2 : n2 != n2 && r2 != r2;
}
function s(n2) {
  return X && n2 instanceof Map;
}
function v(n2) {
  return q && n2 instanceof Set;
}
function p(n2) {
  return n2.o || n2.t;
}
function l(n2) {
  if (Array.isArray(n2))
    return Array.prototype.slice.call(n2);
  var r2 = rn(n2);
  delete r2[Q];
  for (var t2 = nn(r2), e3 = 0; e3 < t2.length; e3++) {
    var i2 = t2[e3], o2 = r2[i2];
    false === o2.writable && (o2.writable = true, o2.configurable = true), (o2.get || o2.set) && (r2[i2] = { configurable: true, writable: true, enumerable: o2.enumerable, value: n2[i2] });
  }
  return Object.create(Object.getPrototypeOf(n2), r2);
}
function d(n2, e3) {
  return void 0 === e3 && (e3 = false), y(n2) || r(n2) || !t(n2) ? n2 : (o(n2) > 1 && (n2.set = n2.add = n2.clear = n2.delete = h), Object.freeze(n2), e3 && i(n2, function(n3, r2) {
    return d(r2, true);
  }, true), n2);
}
function h() {
  n(2);
}
function y(n2) {
  return null == n2 || "object" != typeof n2 || Object.isFrozen(n2);
}
function b(r2) {
  var t2 = tn[r2];
  return t2 || n(18, r2), t2;
}
function m(n2, r2) {
  tn[n2] || (tn[n2] = r2);
}
function _() {
  return U;
}
function j(n2, r2) {
  r2 && (b("Patches"), n2.u = [], n2.s = [], n2.v = r2);
}
function O(n2) {
  g(n2), n2.p.forEach(S), n2.p = null;
}
function g(n2) {
  n2 === U && (U = n2.l);
}
function w(n2) {
  return U = { p: [], l: U, h: n2, m: true, _: 0 };
}
function S(n2) {
  var r2 = n2[Q];
  0 === r2.i || 1 === r2.i ? r2.j() : r2.O = true;
}
function P(r2, e3) {
  e3._ = e3.p.length;
  var i2 = e3.p[0], o2 = void 0 !== r2 && r2 !== i2;
  return e3.h.g || b("ES5").S(e3, r2, o2), o2 ? (i2[Q].P && (O(e3), n(4)), t(r2) && (r2 = M(e3, r2), e3.l || x(e3, r2)), e3.u && b("Patches").M(i2[Q].t, r2, e3.u, e3.s)) : r2 = M(e3, i2, []), O(e3), e3.u && e3.v(e3.u, e3.s), r2 !== H ? r2 : void 0;
}
function M(n2, r2, t2) {
  if (y(r2))
    return r2;
  var e3 = r2[Q];
  if (!e3)
    return i(r2, function(i2, o3) {
      return A(n2, e3, r2, i2, o3, t2);
    }, true), r2;
  if (e3.A !== n2)
    return r2;
  if (!e3.P)
    return x(n2, e3.t, true), e3.t;
  if (!e3.I) {
    e3.I = true, e3.A._--;
    var o2 = 4 === e3.i || 5 === e3.i ? e3.o = l(e3.k) : e3.o;
    i(3 === e3.i ? new Set(o2) : o2, function(r3, i2) {
      return A(n2, e3, o2, r3, i2, t2);
    }), x(n2, o2, false), t2 && n2.u && b("Patches").R(e3, t2, n2.u, n2.s);
  }
  return e3.o;
}
function A(e3, i2, o2, a2, c2, s2) {
  if (r(c2)) {
    var v2 = M(e3, c2, s2 && i2 && 3 !== i2.i && !u(i2.D, a2) ? s2.concat(a2) : void 0);
    if (f(o2, a2, v2), !r(v2))
      return;
    e3.m = false;
  }
  if (t(c2) && !y(c2)) {
    if (!e3.h.F && e3._ < 1)
      return;
    M(e3, c2), i2 && i2.A.l || x(e3, c2);
  }
}
function x(n2, r2, t2) {
  void 0 === t2 && (t2 = false), n2.h.F && n2.m && d(r2, t2);
}
function z(n2, r2) {
  var t2 = n2[Q];
  return (t2 ? p(t2) : n2)[r2];
}
function I(n2, r2) {
  if (r2 in n2)
    for (var t2 = Object.getPrototypeOf(n2); t2; ) {
      var e3 = Object.getOwnPropertyDescriptor(t2, r2);
      if (e3)
        return e3;
      t2 = Object.getPrototypeOf(t2);
    }
}
function k(n2) {
  n2.P || (n2.P = true, n2.l && k(n2.l));
}
function E(n2) {
  n2.o || (n2.o = l(n2.t));
}
function R(n2, r2, t2) {
  var e3 = s(r2) ? b("MapSet").N(r2, t2) : v(r2) ? b("MapSet").T(r2, t2) : n2.g ? function(n3, r3) {
    var t3 = Array.isArray(n3), e4 = { i: t3 ? 1 : 0, A: r3 ? r3.A : _(), P: false, I: false, D: {}, l: r3, t: n3, k: null, o: null, j: null, C: false }, i2 = e4, o2 = en;
    t3 && (i2 = [e4], o2 = on);
    var u2 = Proxy.revocable(i2, o2), a2 = u2.revoke, f2 = u2.proxy;
    return e4.k = f2, e4.j = a2, f2;
  }(r2, t2) : b("ES5").J(r2, t2);
  return (t2 ? t2.A : _()).p.push(e3), e3;
}
function D(e3) {
  return r(e3) || n(22, e3), function n2(r2) {
    if (!t(r2))
      return r2;
    var e4, u2 = r2[Q], c2 = o(r2);
    if (u2) {
      if (!u2.P && (u2.i < 4 || !b("ES5").K(u2)))
        return u2.t;
      u2.I = true, e4 = F(r2, c2), u2.I = false;
    } else
      e4 = F(r2, c2);
    return i(e4, function(r3, t2) {
      u2 && a(u2.t, r3) === t2 || f(e4, r3, n2(t2));
    }), 3 === c2 ? new Set(e4) : e4;
  }(e3);
}
function F(n2, r2) {
  switch (r2) {
    case 2:
      return new Map(n2);
    case 3:
      return Array.from(n2);
  }
  return l(n2);
}
function N() {
  function t2(n2, r2) {
    var t3 = s2[n2];
    return t3 ? t3.enumerable = r2 : s2[n2] = t3 = { configurable: true, enumerable: r2, get: function() {
      var r3 = this[Q];
      return en.get(r3, n2);
    }, set: function(r3) {
      var t4 = this[Q];
      en.set(t4, n2, r3);
    } }, t3;
  }
  function e3(n2) {
    for (var r2 = n2.length - 1; r2 >= 0; r2--) {
      var t3 = n2[r2][Q];
      if (!t3.P)
        switch (t3.i) {
          case 5:
            a2(t3) && k(t3);
            break;
          case 4:
            o2(t3) && k(t3);
        }
    }
  }
  function o2(n2) {
    for (var r2 = n2.t, t3 = n2.k, e4 = nn(t3), i2 = e4.length - 1; i2 >= 0; i2--) {
      var o3 = e4[i2];
      if (o3 !== Q) {
        var a3 = r2[o3];
        if (void 0 === a3 && !u(r2, o3))
          return true;
        var f2 = t3[o3], s3 = f2 && f2[Q];
        if (s3 ? s3.t !== a3 : !c(f2, a3))
          return true;
      }
    }
    var v2 = !!r2[Q];
    return e4.length !== nn(r2).length + (v2 ? 0 : 1);
  }
  function a2(n2) {
    var r2 = n2.k;
    if (r2.length !== n2.t.length)
      return true;
    var t3 = Object.getOwnPropertyDescriptor(r2, r2.length - 1);
    if (t3 && !t3.get)
      return true;
    for (var e4 = 0; e4 < r2.length; e4++)
      if (!r2.hasOwnProperty(e4))
        return true;
    return false;
  }
  var s2 = {};
  m("ES5", { J: function(n2, r2) {
    var e4 = Array.isArray(n2), i2 = function(n3, r3) {
      if (n3) {
        for (var e6 = Array(r3.length), i3 = 0; i3 < r3.length; i3++)
          Object.defineProperty(e6, "" + i3, t2(i3, true));
        return e6;
      }
      var o4 = rn(r3);
      delete o4[Q];
      for (var u2 = nn(o4), a3 = 0; a3 < u2.length; a3++) {
        var f2 = u2[a3];
        o4[f2] = t2(f2, n3 || !!o4[f2].enumerable);
      }
      return Object.create(Object.getPrototypeOf(r3), o4);
    }(e4, n2), o3 = { i: e4 ? 5 : 4, A: r2 ? r2.A : _(), P: false, I: false, D: {}, l: r2, t: n2, k: i2, o: null, O: false, C: false };
    return Object.defineProperty(i2, Q, { value: o3, writable: true }), i2;
  }, S: function(n2, t3, o3) {
    o3 ? r(t3) && t3[Q].A === n2 && e3(n2.p) : (n2.u && function n3(r2) {
      if (r2 && "object" == typeof r2) {
        var t4 = r2[Q];
        if (t4) {
          var e4 = t4.t, o4 = t4.k, f2 = t4.D, c2 = t4.i;
          if (4 === c2)
            i(o4, function(r3) {
              r3 !== Q && (void 0 !== e4[r3] || u(e4, r3) ? f2[r3] || n3(o4[r3]) : (f2[r3] = true, k(t4)));
            }), i(e4, function(n4) {
              void 0 !== o4[n4] || u(o4, n4) || (f2[n4] = false, k(t4));
            });
          else if (5 === c2) {
            if (a2(t4) && (k(t4), f2.length = true), o4.length < e4.length)
              for (var s3 = o4.length; s3 < e4.length; s3++)
                f2[s3] = false;
            else
              for (var v2 = e4.length; v2 < o4.length; v2++)
                f2[v2] = true;
            for (var p2 = Math.min(o4.length, e4.length), l2 = 0; l2 < p2; l2++)
              o4.hasOwnProperty(l2) || (f2[l2] = true), void 0 === f2[l2] && n3(o4[l2]);
          }
        }
      }
    }(n2.p[0]), e3(n2.p));
  }, K: function(n2) {
    return 4 === n2.i ? o2(n2) : a2(n2);
  } });
}
var G, U, W = "undefined" != typeof Symbol && "symbol" == typeof Symbol("x"), X = "undefined" != typeof Map, q = "undefined" != typeof Set, B = "undefined" != typeof Proxy && void 0 !== Proxy.revocable && "undefined" != typeof Reflect, H = W ? Symbol.for("immer-nothing") : ((G = {})["immer-nothing"] = true, G), L = W ? Symbol.for("immer-draftable") : "__$immer_draftable", Q = W ? Symbol.for("immer-state") : "__$immer_state", Z = "" + Object.prototype.constructor, nn = "undefined" != typeof Reflect && Reflect.ownKeys ? Reflect.ownKeys : void 0 !== Object.getOwnPropertySymbols ? function(n2) {
  return Object.getOwnPropertyNames(n2).concat(Object.getOwnPropertySymbols(n2));
} : Object.getOwnPropertyNames, rn = Object.getOwnPropertyDescriptors || function(n2) {
  var r2 = {};
  return nn(n2).forEach(function(t2) {
    r2[t2] = Object.getOwnPropertyDescriptor(n2, t2);
  }), r2;
}, tn = {}, en = { get: function(n2, r2) {
  if (r2 === Q)
    return n2;
  var e3 = p(n2);
  if (!u(e3, r2))
    return function(n3, r3, t2) {
      var e4, i3 = I(r3, t2);
      return i3 ? "value" in i3 ? i3.value : null === (e4 = i3.get) || void 0 === e4 ? void 0 : e4.call(n3.k) : void 0;
    }(n2, e3, r2);
  var i2 = e3[r2];
  return n2.I || !t(i2) ? i2 : i2 === z(n2.t, r2) ? (E(n2), n2.o[r2] = R(n2.A.h, i2, n2)) : i2;
}, has: function(n2, r2) {
  return r2 in p(n2);
}, ownKeys: function(n2) {
  return Reflect.ownKeys(p(n2));
}, set: function(n2, r2, t2) {
  var e3 = I(p(n2), r2);
  if (null == e3 ? void 0 : e3.set)
    return e3.set.call(n2.k, t2), true;
  if (!n2.P) {
    var i2 = z(p(n2), r2), o2 = null == i2 ? void 0 : i2[Q];
    if (o2 && o2.t === t2)
      return n2.o[r2] = t2, n2.D[r2] = false, true;
    if (c(t2, i2) && (void 0 !== t2 || u(n2.t, r2)))
      return true;
    E(n2), k(n2);
  }
  return n2.o[r2] === t2 && "number" != typeof t2 && (void 0 !== t2 || r2 in n2.o) || (n2.o[r2] = t2, n2.D[r2] = true, true);
}, deleteProperty: function(n2, r2) {
  return void 0 !== z(n2.t, r2) || r2 in n2.t ? (n2.D[r2] = false, E(n2), k(n2)) : delete n2.D[r2], n2.o && delete n2.o[r2], true;
}, getOwnPropertyDescriptor: function(n2, r2) {
  var t2 = p(n2), e3 = Reflect.getOwnPropertyDescriptor(t2, r2);
  return e3 ? { writable: true, configurable: 1 !== n2.i || "length" !== r2, enumerable: e3.enumerable, value: t2[r2] } : e3;
}, defineProperty: function() {
  n(11);
}, getPrototypeOf: function(n2) {
  return Object.getPrototypeOf(n2.t);
}, setPrototypeOf: function() {
  n(12);
} }, on = {};
i(en, function(n2, r2) {
  on[n2] = function() {
    return arguments[0] = arguments[0][0], r2.apply(this, arguments);
  };
}), on.deleteProperty = function(r2, t2) {
  return on.set.call(this, r2, t2, void 0);
}, on.set = function(r2, t2, e3) {
  return en.set.call(this, r2[0], t2, e3, r2[0]);
};
var un = function() {
  function e3(r2) {
    var e4 = this;
    this.g = B, this.F = true, this.produce = function(r3, i3, o2) {
      if ("function" == typeof r3 && "function" != typeof i3) {
        var u2 = i3;
        i3 = r3;
        var a2 = e4;
        return function(n2) {
          var r4 = this;
          void 0 === n2 && (n2 = u2);
          for (var t2 = arguments.length, e6 = Array(t2 > 1 ? t2 - 1 : 0), o3 = 1; o3 < t2; o3++)
            e6[o3 - 1] = arguments[o3];
          return a2.produce(n2, function(n3) {
            var t3;
            return (t3 = i3).call.apply(t3, [r4, n3].concat(e6));
          });
        };
      }
      var f2;
      if ("function" != typeof i3 && n(6), void 0 !== o2 && "function" != typeof o2 && n(7), t(r3)) {
        var c2 = w(e4), s2 = R(e4, r3, void 0), v2 = true;
        try {
          f2 = i3(s2), v2 = false;
        } finally {
          v2 ? O(c2) : g(c2);
        }
        return "undefined" != typeof Promise && f2 instanceof Promise ? f2.then(function(n2) {
          return j(c2, o2), P(n2, c2);
        }, function(n2) {
          throw O(c2), n2;
        }) : (j(c2, o2), P(f2, c2));
      }
      if (!r3 || "object" != typeof r3) {
        if (void 0 === (f2 = i3(r3)) && (f2 = r3), f2 === H && (f2 = void 0), e4.F && d(f2, true), o2) {
          var p2 = [], l2 = [];
          b("Patches").M(r3, f2, p2, l2), o2(p2, l2);
        }
        return f2;
      }
      n(21, r3);
    }, this.produceWithPatches = function(n2, r3) {
      if ("function" == typeof n2)
        return function(r4) {
          for (var t3 = arguments.length, i4 = Array(t3 > 1 ? t3 - 1 : 0), o3 = 1; o3 < t3; o3++)
            i4[o3 - 1] = arguments[o3];
          return e4.produceWithPatches(r4, function(r5) {
            return n2.apply(void 0, [r5].concat(i4));
          });
        };
      var t2, i3, o2 = e4.produce(n2, r3, function(n3, r4) {
        t2 = n3, i3 = r4;
      });
      return "undefined" != typeof Promise && o2 instanceof Promise ? o2.then(function(n3) {
        return [n3, t2, i3];
      }) : [o2, t2, i3];
    }, "boolean" == typeof (null == r2 ? void 0 : r2.useProxies) && this.setUseProxies(r2.useProxies), "boolean" == typeof (null == r2 ? void 0 : r2.autoFreeze) && this.setAutoFreeze(r2.autoFreeze);
  }
  var i2 = e3.prototype;
  return i2.createDraft = function(e4) {
    t(e4) || n(8), r(e4) && (e4 = D(e4));
    var i3 = w(this), o2 = R(this, e4, void 0);
    return o2[Q].C = true, g(i3), o2;
  }, i2.finishDraft = function(r2, t2) {
    var e4 = r2 && r2[Q];
    var i3 = e4.A;
    return j(i3, t2), P(void 0, i3);
  }, i2.setAutoFreeze = function(n2) {
    this.F = n2;
  }, i2.setUseProxies = function(r2) {
    r2 && !B && n(20), this.g = r2;
  }, i2.applyPatches = function(n2, t2) {
    var e4;
    for (e4 = t2.length - 1; e4 >= 0; e4--) {
      var i3 = t2[e4];
      if (0 === i3.path.length && "replace" === i3.op) {
        n2 = i3.value;
        break;
      }
    }
    e4 > -1 && (t2 = t2.slice(e4 + 1));
    var o2 = b("Patches").$;
    return r(n2) ? o2(n2, t2) : this.produce(n2, function(n3) {
      return o2(n3, t2);
    });
  }, e3;
}(), an = new un(), fn = an.produce;
an.produceWithPatches.bind(an);
an.setAutoFreeze.bind(an);
an.setUseProxies.bind(an);
an.applyPatches.bind(an);
an.createDraft.bind(an);
an.finishDraft.bind(an);
function formatProdErrorMessage(code2) {
  return "Minified Redux error #" + code2 + "; visit https://redux.js.org/Errors?code=" + code2 + " for the full message or use the non-minified dev environment for full errors. ";
}
var $$observable = function() {
  return typeof Symbol === "function" && Symbol.observable || "@@observable";
}();
var randomString = function randomString2() {
  return Math.random().toString(36).substring(7).split("").join(".");
};
var ActionTypes = {
  INIT: "@@redux/INIT" + randomString(),
  REPLACE: "@@redux/REPLACE" + randomString(),
  PROBE_UNKNOWN_ACTION: function PROBE_UNKNOWN_ACTION() {
    return "@@redux/PROBE_UNKNOWN_ACTION" + randomString();
  }
};
function isPlainObject$3(obj) {
  if (typeof obj !== "object" || obj === null)
    return false;
  var proto = obj;
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }
  return Object.getPrototypeOf(obj) === proto;
}
function createStore(reducer, preloadedState, enhancer) {
  var _ref2;
  if (typeof preloadedState === "function" && typeof enhancer === "function" || typeof enhancer === "function" && typeof arguments[3] === "function") {
    throw new Error(formatProdErrorMessage(0));
  }
  if (typeof preloadedState === "function" && typeof enhancer === "undefined") {
    enhancer = preloadedState;
    preloadedState = void 0;
  }
  if (typeof enhancer !== "undefined") {
    if (typeof enhancer !== "function") {
      throw new Error(formatProdErrorMessage(1));
    }
    return enhancer(createStore)(reducer, preloadedState);
  }
  if (typeof reducer !== "function") {
    throw new Error(formatProdErrorMessage(2));
  }
  var currentReducer = reducer;
  var currentState = preloadedState;
  var currentListeners = [];
  var nextListeners = currentListeners;
  var isDispatching = false;
  function ensureCanMutateNextListeners() {
    if (nextListeners === currentListeners) {
      nextListeners = currentListeners.slice();
    }
  }
  function getState() {
    if (isDispatching) {
      throw new Error(formatProdErrorMessage(3));
    }
    return currentState;
  }
  function subscribe2(listener) {
    if (typeof listener !== "function") {
      throw new Error(formatProdErrorMessage(4));
    }
    if (isDispatching) {
      throw new Error(formatProdErrorMessage(5));
    }
    var isSubscribed = true;
    ensureCanMutateNextListeners();
    nextListeners.push(listener);
    return function unsubscribe2() {
      if (!isSubscribed) {
        return;
      }
      if (isDispatching) {
        throw new Error(formatProdErrorMessage(6));
      }
      isSubscribed = false;
      ensureCanMutateNextListeners();
      var index2 = nextListeners.indexOf(listener);
      nextListeners.splice(index2, 1);
      currentListeners = null;
    };
  }
  function dispatch2(action) {
    if (!isPlainObject$3(action)) {
      throw new Error(formatProdErrorMessage(7));
    }
    if (typeof action.type === "undefined") {
      throw new Error(formatProdErrorMessage(8));
    }
    if (isDispatching) {
      throw new Error(formatProdErrorMessage(9));
    }
    try {
      isDispatching = true;
      currentState = currentReducer(currentState, action);
    } finally {
      isDispatching = false;
    }
    var listeners = currentListeners = nextListeners;
    for (var i2 = 0; i2 < listeners.length; i2++) {
      var listener = listeners[i2];
      listener();
    }
    return action;
  }
  function replaceReducer(nextReducer) {
    if (typeof nextReducer !== "function") {
      throw new Error(formatProdErrorMessage(10));
    }
    currentReducer = nextReducer;
    dispatch2({
      type: ActionTypes.REPLACE
    });
  }
  function observable() {
    var _ref;
    var outerSubscribe = subscribe2;
    return _ref = {
      subscribe: function subscribe3(observer) {
        if (typeof observer !== "object" || observer === null) {
          throw new Error(formatProdErrorMessage(11));
        }
        function observeState() {
          if (observer.next) {
            observer.next(getState());
          }
        }
        observeState();
        var unsubscribe2 = outerSubscribe(observeState);
        return {
          unsubscribe: unsubscribe2
        };
      }
    }, _ref[$$observable] = function() {
      return this;
    }, _ref;
  }
  dispatch2({
    type: ActionTypes.INIT
  });
  return _ref2 = {
    dispatch: dispatch2,
    subscribe: subscribe2,
    getState,
    replaceReducer
  }, _ref2[$$observable] = observable, _ref2;
}
function assertReducerShape(reducers) {
  Object.keys(reducers).forEach(function(key2) {
    var reducer = reducers[key2];
    var initialState = reducer(void 0, {
      type: ActionTypes.INIT
    });
    if (typeof initialState === "undefined") {
      throw new Error(formatProdErrorMessage(12));
    }
    if (typeof reducer(void 0, {
      type: ActionTypes.PROBE_UNKNOWN_ACTION()
    }) === "undefined") {
      throw new Error(formatProdErrorMessage(13));
    }
  });
}
function combineReducers(reducers) {
  var reducerKeys = Object.keys(reducers);
  var finalReducers = {};
  for (var i2 = 0; i2 < reducerKeys.length; i2++) {
    var key2 = reducerKeys[i2];
    if (typeof reducers[key2] === "function") {
      finalReducers[key2] = reducers[key2];
    }
  }
  var finalReducerKeys = Object.keys(finalReducers);
  var shapeAssertionError;
  try {
    assertReducerShape(finalReducers);
  } catch (e3) {
    shapeAssertionError = e3;
  }
  return function combination(state2, action) {
    if (state2 === void 0) {
      state2 = {};
    }
    if (shapeAssertionError) {
      throw shapeAssertionError;
    }
    var hasChanged = false;
    var nextState = {};
    for (var _i = 0; _i < finalReducerKeys.length; _i++) {
      var _key = finalReducerKeys[_i];
      var reducer = finalReducers[_key];
      var previousStateForKey = state2[_key];
      var nextStateForKey = reducer(previousStateForKey, action);
      if (typeof nextStateForKey === "undefined") {
        action && action.type;
        throw new Error(formatProdErrorMessage(14));
      }
      nextState[_key] = nextStateForKey;
      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
    }
    hasChanged = hasChanged || finalReducerKeys.length !== Object.keys(state2).length;
    return hasChanged ? nextState : state2;
  };
}
function compose() {
  for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++) {
    funcs[_key] = arguments[_key];
  }
  if (funcs.length === 0) {
    return function(arg) {
      return arg;
    };
  }
  if (funcs.length === 1) {
    return funcs[0];
  }
  return funcs.reduce(function(a2, b10) {
    return function() {
      return a2(b10.apply(void 0, arguments));
    };
  });
}
function applyMiddleware() {
  for (var _len = arguments.length, middlewares = new Array(_len), _key = 0; _key < _len; _key++) {
    middlewares[_key] = arguments[_key];
  }
  return function(createStore2) {
    return function() {
      var store2 = createStore2.apply(void 0, arguments);
      var _dispatch = function dispatch2() {
        throw new Error(formatProdErrorMessage(15));
      };
      var middlewareAPI = {
        getState: store2.getState,
        dispatch: function dispatch2() {
          return _dispatch.apply(void 0, arguments);
        }
      };
      var chain = middlewares.map(function(middleware) {
        return middleware(middlewareAPI);
      });
      _dispatch = compose.apply(void 0, chain)(store2.dispatch);
      return _objectSpread2$1(_objectSpread2$1({}, store2), {}, {
        dispatch: _dispatch
      });
    };
  };
}
function createThunkMiddleware(extraArgument) {
  var middleware = function middleware2(_ref) {
    var dispatch2 = _ref.dispatch, getState = _ref.getState;
    return function(next) {
      return function(action) {
        if (typeof action === "function") {
          return action(dispatch2, getState, extraArgument);
        }
        return next(action);
      };
    };
  };
  return middleware;
}
var thunk = createThunkMiddleware();
thunk.withExtraArgument = createThunkMiddleware;
var thunkMiddleware = thunk;
var __extends$4 = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b10) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b11) {
      d3.__proto__ = b11;
    } || function(d3, b11) {
      for (var p2 in b11)
        if (Object.prototype.hasOwnProperty.call(b11, p2))
          d3[p2] = b11[p2];
    };
    return extendStatics2(d2, b10);
  };
  return function(d2, b10) {
    if (typeof b10 !== "function" && b10 !== null)
      throw new TypeError("Class extends value " + String(b10) + " is not a constructor or null");
    extendStatics2(d2, b10);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b10 === null ? Object.create(b10) : (__.prototype = b10.prototype, new __());
  };
}();
globalThis && globalThis.__generator || function(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t2[0] & 1)
      throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f2, y2, t2, g2;
  return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v2) {
      return step([n2, v2]);
    };
  }
  function step(op) {
    if (f2)
      throw new TypeError("Generator is already executing.");
    while (_2)
      try {
        if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
          return t2;
        if (y2 = 0, t2)
          op = [op[0] & 2, t2.value];
        switch (op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            _2.label++;
            return { value: op[1], done: false };
          case 5:
            _2.label++;
            y2 = op[1];
            op = [0];
            continue;
          case 7:
            op = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _2.label = op[1];
              break;
            }
            if (op[0] === 6 && _2.label < t2[1]) {
              _2.label = t2[1];
              t2 = op;
              break;
            }
            if (t2 && _2.label < t2[2]) {
              _2.label = t2[2];
              _2.ops.push(op);
              break;
            }
            if (t2[2])
              _2.ops.pop();
            _2.trys.pop();
            continue;
        }
        op = body.call(thisArg, _2);
      } catch (e3) {
        op = [6, e3];
        y2 = 0;
      } finally {
        f2 = t2 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var __spreadArray$2 = globalThis && globalThis.__spreadArray || function(to, from) {
  for (var i2 = 0, il = from.length, j2 = to.length; i2 < il; i2++, j2++)
    to[j2] = from[i2];
  return to;
};
var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = function(obj, key2, value2) {
  return key2 in obj ? __defProp(obj, key2, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key2] = value2;
};
var __spreadValues = function(a2, b10) {
  for (var prop in b10 || (b10 = {}))
    if (__hasOwnProp.call(b10, prop))
      __defNormalProp(a2, prop, b10[prop]);
  if (__getOwnPropSymbols)
    for (var _i = 0, _c = __getOwnPropSymbols(b10); _i < _c.length; _i++) {
      var prop = _c[_i];
      if (__propIsEnum.call(b10, prop))
        __defNormalProp(a2, prop, b10[prop]);
    }
  return a2;
};
var composeWithDevTools = typeof window !== "undefined" && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ : function() {
  if (arguments.length === 0)
    return void 0;
  if (typeof arguments[0] === "object")
    return compose;
  return compose.apply(null, arguments);
};
function isPlainObject$2(value2) {
  if (typeof value2 !== "object" || value2 === null)
    return false;
  var proto = Object.getPrototypeOf(value2);
  if (proto === null)
    return true;
  var baseProto = proto;
  while (Object.getPrototypeOf(baseProto) !== null) {
    baseProto = Object.getPrototypeOf(baseProto);
  }
  return proto === baseProto;
}
var MiddlewareArray = function(_super) {
  __extends$4(MiddlewareArray2, _super);
  function MiddlewareArray2() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var _this = _super.apply(this, args) || this;
    Object.setPrototypeOf(_this, MiddlewareArray2.prototype);
    return _this;
  }
  Object.defineProperty(MiddlewareArray2, Symbol.species, {
    get: function() {
      return MiddlewareArray2;
    },
    enumerable: false,
    configurable: true
  });
  MiddlewareArray2.prototype.concat = function() {
    var arr = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      arr[_i] = arguments[_i];
    }
    return _super.prototype.concat.apply(this, arr);
  };
  MiddlewareArray2.prototype.prepend = function() {
    var arr = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      arr[_i] = arguments[_i];
    }
    if (arr.length === 1 && Array.isArray(arr[0])) {
      return new (MiddlewareArray2.bind.apply(MiddlewareArray2, __spreadArray$2([void 0], arr[0].concat(this))))();
    }
    return new (MiddlewareArray2.bind.apply(MiddlewareArray2, __spreadArray$2([void 0], arr.concat(this))))();
  };
  return MiddlewareArray2;
}(Array);
function freezeDraftable(val) {
  return t(val) ? fn(val, function() {
  }) : val;
}
function isBoolean$1(x2) {
  return typeof x2 === "boolean";
}
function curryGetDefaultMiddleware() {
  return function curriedGetDefaultMiddleware(options) {
    return getDefaultMiddleware(options);
  };
}
function getDefaultMiddleware(options) {
  if (options === void 0) {
    options = {};
  }
  var _c = options.thunk, thunk2 = _c === void 0 ? true : _c;
  options.immutableCheck;
  options.serializableCheck;
  var middlewareArray = new MiddlewareArray();
  if (thunk2) {
    if (isBoolean$1(thunk2)) {
      middlewareArray.push(thunkMiddleware);
    } else {
      middlewareArray.push(thunkMiddleware.withExtraArgument(thunk2.extraArgument));
    }
  }
  return middlewareArray;
}
var IS_PRODUCTION = true;
function configureStore(options) {
  var curriedGetDefaultMiddleware = curryGetDefaultMiddleware();
  var _c = options || {}, _d = _c.reducer, reducer = _d === void 0 ? void 0 : _d, _e = _c.middleware, middleware = _e === void 0 ? curriedGetDefaultMiddleware() : _e, _f = _c.devTools, devTools = _f === void 0 ? true : _f, _g = _c.preloadedState, preloadedState = _g === void 0 ? void 0 : _g, _h = _c.enhancers, enhancers = _h === void 0 ? void 0 : _h;
  var rootReducer;
  if (typeof reducer === "function") {
    rootReducer = reducer;
  } else if (isPlainObject$2(reducer)) {
    rootReducer = combineReducers(reducer);
  } else {
    throw new Error('"reducer" is a required argument, and must be a function or an object of functions that can be passed to combineReducers');
  }
  var finalMiddleware = middleware;
  if (typeof finalMiddleware === "function") {
    finalMiddleware = finalMiddleware(curriedGetDefaultMiddleware);
  }
  var middlewareEnhancer = applyMiddleware.apply(void 0, finalMiddleware);
  var finalCompose = compose;
  if (devTools) {
    finalCompose = composeWithDevTools(__spreadValues({
      trace: !IS_PRODUCTION
    }, typeof devTools === "object" && devTools));
  }
  var storeEnhancers = [middlewareEnhancer];
  if (Array.isArray(enhancers)) {
    storeEnhancers = __spreadArray$2([middlewareEnhancer], enhancers);
  } else if (typeof enhancers === "function") {
    storeEnhancers = enhancers(storeEnhancers);
  }
  var composedEnhancer = finalCompose.apply(void 0, storeEnhancers);
  return createStore(rootReducer, preloadedState, composedEnhancer);
}
function createAction$1(type4, prepareAction) {
  function actionCreator() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    if (prepareAction) {
      var prepared = prepareAction.apply(void 0, args);
      if (!prepared) {
        throw new Error("prepareAction did not return an object");
      }
      return __spreadValues(__spreadValues({
        type: type4,
        payload: prepared.payload
      }, "meta" in prepared && { meta: prepared.meta }), "error" in prepared && { error: prepared.error });
    }
    return { type: type4, payload: args[0] };
  }
  actionCreator.toString = function() {
    return "" + type4;
  };
  actionCreator.type = type4;
  actionCreator.match = function(action) {
    return action.type === type4;
  };
  return actionCreator;
}
function executeReducerBuilderCallback(builderCallback) {
  var actionsMap = {};
  var actionMatchers = [];
  var defaultCaseReducer;
  var builder = {
    addCase: function(typeOrActionCreator, reducer) {
      var type4 = typeof typeOrActionCreator === "string" ? typeOrActionCreator : typeOrActionCreator.type;
      if (type4 in actionsMap) {
        throw new Error("addCase cannot be called with two reducers for the same action type");
      }
      actionsMap[type4] = reducer;
      return builder;
    },
    addMatcher: function(matcher, reducer) {
      actionMatchers.push({ matcher, reducer });
      return builder;
    },
    addDefaultCase: function(reducer) {
      defaultCaseReducer = reducer;
      return builder;
    }
  };
  builderCallback(builder);
  return [actionsMap, actionMatchers, defaultCaseReducer];
}
function isStateFunction(x2) {
  return typeof x2 === "function";
}
function createReducer(initialState, mapOrBuilderCallback, actionMatchers, defaultCaseReducer) {
  if (actionMatchers === void 0) {
    actionMatchers = [];
  }
  var _c = typeof mapOrBuilderCallback === "function" ? executeReducerBuilderCallback(mapOrBuilderCallback) : [mapOrBuilderCallback, actionMatchers, defaultCaseReducer], actionsMap = _c[0], finalActionMatchers = _c[1], finalDefaultCaseReducer = _c[2];
  var getInitialState;
  if (isStateFunction(initialState)) {
    getInitialState = function() {
      return freezeDraftable(initialState());
    };
  } else {
    var frozenInitialState_1 = freezeDraftable(initialState);
    getInitialState = function() {
      return frozenInitialState_1;
    };
  }
  function reducer(state2, action) {
    if (state2 === void 0) {
      state2 = getInitialState();
    }
    var caseReducers = __spreadArray$2([
      actionsMap[action.type]
    ], finalActionMatchers.filter(function(_c2) {
      var matcher = _c2.matcher;
      return matcher(action);
    }).map(function(_c2) {
      var reducer2 = _c2.reducer;
      return reducer2;
    }));
    if (caseReducers.filter(function(cr) {
      return !!cr;
    }).length === 0) {
      caseReducers = [finalDefaultCaseReducer];
    }
    return caseReducers.reduce(function(previousState, caseReducer) {
      if (caseReducer) {
        if (r(previousState)) {
          var draft = previousState;
          var result = caseReducer(draft, action);
          if (result === void 0) {
            return previousState;
          }
          return result;
        } else if (!t(previousState)) {
          var result = caseReducer(previousState, action);
          if (result === void 0) {
            if (previousState === null) {
              return previousState;
            }
            throw Error("A case reducer on a non-draftable value must not return undefined");
          }
          return result;
        } else {
          return fn(previousState, function(draft2) {
            return caseReducer(draft2, action);
          });
        }
      }
      return previousState;
    }, state2);
  }
  reducer.getInitialState = getInitialState;
  return reducer;
}
function getType2(slice, actionKey) {
  return slice + "/" + actionKey;
}
function createSlice(options) {
  var name = options.name;
  if (!name) {
    throw new Error("`name` is a required option for createSlice");
  }
  if (typeof process !== "undefined" && false) {
    if (options.initialState === void 0) {
      console.error("You must provide an `initialState` value that is not `undefined`. You may have misspelled `initialState`");
    }
  }
  var initialState = typeof options.initialState == "function" ? options.initialState : freezeDraftable(options.initialState);
  var reducers = options.reducers || {};
  var reducerNames = Object.keys(reducers);
  var sliceCaseReducersByName = {};
  var sliceCaseReducersByType = {};
  var actionCreators = {};
  reducerNames.forEach(function(reducerName) {
    var maybeReducerWithPrepare = reducers[reducerName];
    var type4 = getType2(name, reducerName);
    var caseReducer;
    var prepareCallback;
    if ("reducer" in maybeReducerWithPrepare) {
      caseReducer = maybeReducerWithPrepare.reducer;
      prepareCallback = maybeReducerWithPrepare.prepare;
    } else {
      caseReducer = maybeReducerWithPrepare;
    }
    sliceCaseReducersByName[reducerName] = caseReducer;
    sliceCaseReducersByType[type4] = caseReducer;
    actionCreators[reducerName] = prepareCallback ? createAction$1(type4, prepareCallback) : createAction$1(type4);
  });
  function buildReducer() {
    var _c = typeof options.extraReducers === "function" ? executeReducerBuilderCallback(options.extraReducers) : [options.extraReducers], _d = _c[0], extraReducers = _d === void 0 ? {} : _d, _e = _c[1], actionMatchers = _e === void 0 ? [] : _e, _f = _c[2], defaultCaseReducer = _f === void 0 ? void 0 : _f;
    var finalCaseReducers = __spreadValues(__spreadValues({}, extraReducers), sliceCaseReducersByType);
    return createReducer(initialState, finalCaseReducers, actionMatchers, defaultCaseReducer);
  }
  var _reducer;
  return {
    name,
    reducer: function(state2, action) {
      if (!_reducer)
        _reducer = buildReducer();
      return _reducer(state2, action);
    },
    actions: actionCreators,
    caseReducers: sliceCaseReducersByName,
    getInitialState: function() {
      if (!_reducer)
        _reducer = buildReducer();
      return _reducer.getInitialState();
    }
  };
}
var alm = "listenerMiddleware";
createAction$1(alm + "/add");
createAction$1(alm + "/removeAll");
createAction$1(alm + "/remove");
N();
const homeSlice = createSlice({
  name: "home",
  initialState: {
    countDetail: {},
    lastBlock: [],
    lastTransactions: []
  },
  reducers: {
    getCountDetail(state2, { payload = {} }) {
      state2.countDetail = payload;
    },
    getLastBlock(state2, { payload = {} }) {
      const { responseList = [] } = payload;
      state2.lastBlock = responseList;
    },
    getLastTransactions(state2, { payload = {} }) {
      const { responseList = [] } = payload;
      state2.lastTransactions = responseList;
    },
    getInitState(state2) {
      Object.assign(state2, {
        countDetail: {},
        lastBlock: [],
        lastTransactions: []
      });
    }
  }
});
const { getInitState: getInitState$6, getCountDetail, getLastBlock, getLastTransactions } = homeSlice.actions;
const asyncGetCountDetail = () => (dispatch2) => {
  return request$1.get({ url: "/dashboard/countDetail" }).then((res) => {
    return dispatch2(getCountDetail(res == null ? void 0 : res.data));
  }).catch((e3) => {
    console.log(e3);
  });
};
const asyncGetLastBlock = () => (dispatch2) => {
  return request$1.get({ url: "/block/getLastBlock" }).then((res) => {
    return dispatch2(getLastBlock(res == null ? void 0 : res.data));
  }).catch((e3) => {
    console.log(e3);
  });
};
const asyncGetLastTransactions = () => (dispatch2) => {
  return request$1.get({ url: "/transactions/getLastTransactions" }).then((res) => {
    return dispatch2(getLastTransactions(res == null ? void 0 : res.data));
  }).catch((e3) => {
    console.log(e3);
  });
};
var home = homeSlice.reducer;
const mainSlice = createSlice({
  name: "main",
  initialState: {
    routeParam: {},
    pathname: ""
  },
  reducers: {
    updateRoute(state2, { payload }) {
      const { params, pathname } = payload;
      state2.routeParam = params;
      state2.pathname = pathname;
    }
  }
});
var main = mainSlice.reducer;
const BLOCK_TYPE$1 = "recentBlock";
const recentInfoSlice = createSlice({
  name: "recentInfo",
  initialState: {
    list: [],
    pageInfo: {
      pageStart: 1,
      pageSize: 10,
      totalElements: 10,
      totalPages: 1
    }
  },
  reducers: {
    updateList(state2, { payload }) {
      const { responseList = [], pageStart, pageSize, totalElements, totalPages } = payload;
      state2.list = responseList.map((item) => ({ key: item.txnHash, ...item }));
      state2.pageInfo = { pageStart, pageSize, totalElements, totalPages };
    },
    updatePage(state2, { payload }) {
      const { pageInfo } = payload;
      state2.pageInfo = { ...pageInfo, ...payload };
    },
    getInitState(state2) {
      Object.assign(state2, {
        list: [],
        pageInfo: {
          pageStart: 1,
          pageSize: 10,
          totalElements: 10,
          totalPages: 1
        }
      });
    }
  }
});
const { updateList: updateList$4, getInitState: getInitState$5, updatePage: updatePage$4 } = recentInfoSlice.actions;
const changTable$4 = (page, pageSize, pageType) => async (dispatch2) => {
  dispatch2(updatePage$4({ pageStart: page, pageSize }));
  dispatch2(asyncGetPageList$4(pageType));
};
const asyncGetPageList$4 = (pageType = "") => (dispatch2, getState) => {
  const { main: main2, recentInfo: recentInfo2 } = getState();
  const { pageInfo } = recentInfo2;
  const { pageSize, pageStart } = pageInfo;
  const type4 = pageType ? pageType : main2.routeParam.type;
  const url2 = type4 === BLOCK_TYPE$1 ? "/block/queryByPage" : "/transactions/queryByPage";
  return request$1.post({ url: url2, query: { pageSize, pageStart } }).then((res) => {
    return dispatch2(updateList$4(res == null ? void 0 : res.data));
  }).catch((e3) => {
    console.log(e3);
  });
};
var recentInfo = recentInfoSlice.reducer;
const blockHeightSlice = createSlice({
  name: "blockHeight",
  initialState: {
    list: [],
    pageInfo: {
      pageStart: 1,
      pageSize: 10,
      totalElements: 10,
      totalPages: 1
    },
    info: {}
  },
  reducers: {
    updateList(state2, { payload }) {
      const { responseList = [], pageStart, pageSize, totalElements, totalPages } = payload;
      state2.list = responseList.map((item) => ({ key: item.createTime, ...item }));
      state2.pageInfo = { pageStart, pageSize, totalElements, totalPages };
    },
    updatePage(state2, { payload }) {
      const { pageInfo } = payload;
      state2.pageInfo = { ...pageInfo, ...payload };
    },
    updateInfo(state2, { payload = {} }) {
      state2.info = payload;
    },
    getInitState(state2) {
      Object.assign(state2, {
        list: [],
        pageInfo: {
          pageStart: 1,
          pageSize: 10,
          totalElements: 10,
          totalPages: 1
        },
        info: {}
      });
    }
  }
});
const { updateList: updateList$3, updatePage: updatePage$3, updateInfo: updateInfo$2, getInitState: getInitState$4 } = blockHeightSlice.actions;
const changTable$3 = (page, pageSize, hash) => async (dispatch2) => {
  dispatch2(updatePage$3({ page, pageSize }));
  dispatch2(asyncGetPageList$3(hash));
};
const asyncGetPageList$3 = (hash = "") => (dispatch2, getState) => {
  const { main: main2, blockHeight: blockHeight2 } = getState();
  const { pageInfo } = blockHeight2;
  const height = hash ? hash : main2.routeParam.type;
  return request$1.post({ url: "/transactions/queryByPage", query: { blockHeight: height, ...pageInfo } }).then((res) => {
    return dispatch2(updateList$3(res == null ? void 0 : res.data));
  }).catch((e3) => {
    console.log(e3);
  });
};
const asyncGetDetail$1 = (id2 = "") => async (dispatch2, getState) => {
  const { main: main2 } = getState();
  const address = id2 ? id2 : main2.routeParam.type;
  const res = await request$1.post({ url: "/dashboard/search", query: { address } });
  dispatch2(updateInfo$2((res == null ? void 0 : res.data) || {}));
};
var blockHeight = blockHeightSlice.reducer;
const contractDetailSlice = createSlice({
  name: "contractDetail",
  initialState: {
    list: [],
    pageInfo: {
      pageStart: 1,
      pageSize: 10,
      totalElements: 10,
      totalPages: 1
    },
    detail: {},
    info: {}
  },
  reducers: {
    updateDetail(state2, { payload }) {
      state2.detail = payload;
    },
    updateInfo(state2, { payload }) {
      state2.info = payload;
    },
    updateList(state2, { payload }) {
      const { responseList = [], pageStart, pageSize, totalElements, totalPages } = payload;
      state2.list = responseList.map((item) => ({ key: item.createTime, ...item }));
      state2.pageInfo = { pageStart, pageSize, totalElements, totalPages };
    },
    updatePage(state2, { payload }) {
      const { pageInfo } = payload;
      state2.pageInfo = { ...pageInfo, ...payload };
    },
    getInitState(state2) {
      Object.assign(state2, {
        list: [],
        pageInfo: {
          pageStart: 1,
          pageSize: 10,
          totalElements: 10,
          totalPages: 1
        },
        detail: {},
        info: {}
      });
    }
  }
});
const { updateList: updateList$2, updatePage: updatePage$2, updateDetail: updateDetail$2, getInitState: getInitState$3, updateInfo: updateInfo$1 } = contractDetailSlice.actions;
const changTable$2 = (page, pageSize, hash) => async (dispatch2) => {
  dispatch2(updatePage$2({ page, pageSize }));
  dispatch2(asyncGetPageList$2(hash));
};
const asyncGetPageList$2 = (id2 = "") => (dispatch2, getState) => {
  const { main: main2, contractDetail: contractDetail2 } = getState();
  const { pageInfo } = contractDetail2;
  const nfrIds = id2 ? id2 : main2.routeParam.type;
  return request$1.post({ url: "/transactions/queryByPage", query: { address: nfrIds, ...pageInfo } }).then((res) => {
    return dispatch2(updateList$2((res == null ? void 0 : res.data) || {}));
  }).catch((e3) => {
    console.log(e3);
  });
};
const asyncGetNfrDetail$2 = (id2 = "") => async (dispatch2, getState) => {
  const { main: main2, contractDetail: contractDetail2 } = getState();
  const nfrIds = id2 ? id2 : main2.routeParam.type;
  const infoRes = await request$1.post({ url: "/nfr/queryInfo", query: { tokenId: nfrIds } });
  dispatch2(updateDetail$2((infoRes == null ? void 0 : infoRes.data) || {}));
  const res = await request$1.post({ url: "/dashboard/search", query: { address: nfrIds } });
  dispatch2(updateInfo$1((res == null ? void 0 : res.data) || {}));
};
var contractDetail = contractDetailSlice.reducer;
const walletDetailSlice = createSlice({
  name: "walletDetail",
  initialState: {
    list: [],
    pageInfo: {
      pageStart: 1,
      pageSize: 10,
      totalElements: 10,
      totalPages: 1
    },
    info: {}
  },
  reducers: {
    updateInfo(state2, { payload }) {
      state2.info = payload;
    },
    updateList(state2, { payload }) {
      const { responseList = [], pageStart, pageSize, totalElements, totalPages } = payload;
      state2.list = responseList.map((item) => ({ key: item.createTime, ...item }));
      state2.pageInfo = { pageStart, pageSize, totalElements, totalPages };
    },
    updatePage(state2, { payload }) {
      const { pageInfo } = payload;
      state2.pageInfo = { ...pageInfo, ...payload };
    },
    getInitState(state2) {
      Object.assign(state2, {
        list: [],
        pageInfo: {
          pageStart: 1,
          pageSize: 10,
          totalElements: 10,
          totalPages: 1
        },
        info: {}
      });
    }
  }
});
const { updateList: updateList$1, getInitState: getInitState$2, updatePage: updatePage$1, updateInfo } = walletDetailSlice.actions;
const changTable$1 = (page, pageSize, hash) => async (dispatch2) => {
  dispatch2(updatePage$1({ page, pageSize }));
  dispatch2(asyncGetPageList$1(hash));
};
const asyncGetPageList$1 = (id2 = "") => (dispatch2, getState) => {
  const { main: main2, walletDetail: walletDetail2 } = getState();
  const { pageInfo } = walletDetail2;
  const { pageStart, pageSize } = pageInfo;
  const nfrIds = id2 ? id2 : main2.routeParam.type;
  return request$1.post({ url: "/transactions/queryByPage", query: { address: nfrIds, pageStart, pageSize } }).then((res) => {
    return dispatch2(updateList$1(res == null ? void 0 : res.data));
  }).catch((e3) => {
    console.log(e3);
  });
};
const asyncGetNfrDetail$1 = (id2 = "") => async (dispatch2, getState) => {
  const { main: main2 } = getState();
  const walletId = id2 ? id2 : main2.routeParam.type;
  const info = await request$1.post({ url: "/dashboard/search", query: { address: walletId } });
  dispatch2(updateInfo((info == null ? void 0 : info.data) || {}));
};
var walletDetail = walletDetailSlice.reducer;
const nfrDetailSlice = createSlice({
  name: "nfrDetail",
  initialState: {
    list: [],
    pageInfo: {
      pageStart: 1,
      pageSize: 10,
      totalElements: 10,
      totalPages: 1
    },
    detail: {}
  },
  reducers: {
    updateDetail(state2, { payload }) {
      state2.detail = payload || {};
    },
    updateList(state2, { payload }) {
      const { responseList = [], pageStart, pageSize, totalElements, totalPages } = payload;
      state2.list = responseList.map((item) => ({ key: item.createTime, ...item }));
      state2.pageInfo = { pageStart, pageSize, totalElements, totalPages };
    },
    updatePage(state2, { payload }) {
      const { pageInfo } = payload;
      state2.pageInfo = { ...pageInfo, ...payload };
    },
    getInitState(state2) {
      Object.assign(state2, {
        list: [],
        pageInfo: {
          pageStart: 1,
          pageSize: 10,
          totalElements: 10,
          totalPages: 1
        },
        detail: {}
      });
    }
  }
});
const { updateList, updatePage, getInitState: getInitState$1, updateDetail: updateDetail$1 } = nfrDetailSlice.actions;
const changTable = (page, pageSize, hash) => async (dispatch2) => {
  dispatch2(updatePage({ page, pageSize }));
  dispatch2(asyncGetPageList(hash));
};
const asyncGetPageList = (id2 = "") => (dispatch2, getState) => {
  const { main: main2, nfrDetail: nfrDetail2 } = getState();
  const { pageInfo } = nfrDetail2;
  const nfrIds = id2 ? id2 : main2.routeParam.type;
  return request$1.post({ url: "/transactions/queryByPage", query: { nfrIds, ...pageInfo } }).then((res) => {
    return dispatch2(updateList(res == null ? void 0 : res.data));
  }).catch((e3) => {
    console.log(e3);
  });
};
const asyncGetNfrDetail = (id2 = "") => (dispatch2, getState) => {
  const { main: main2, nfrDetail: nfrDetail2 } = getState();
  const nfrIds = id2 ? id2 : main2.routeParam.type;
  return request$1.post({ url: "/nfr/queryInfo", query: { tokenId: nfrIds } }).then((res) => {
    return dispatch2(updateDetail$1(res == null ? void 0 : res.data));
  }).catch((e3) => {
    console.log(e3);
  });
};
var nfrDetail = nfrDetailSlice.reducer;
const transactionSlice = createSlice({
  name: "transaction",
  initialState: {
    detail: {}
  },
  reducers: {
    updateDetail(state2, { payload }) {
      state2.detail = payload;
    },
    getInitState(state2) {
      Object.assign(state2, {
        detail: {}
      });
    }
  }
});
const { updateDetail, getInitState } = transactionSlice.actions;
const asyncGetDetail = (id2 = "") => (dispatch2, getState) => {
  const { main: main2, transaction: transaction2 } = getState();
  const txnHash = id2 ? id2 : main2.routeParam.type;
  return request$1.post({ url: "/transactions/queryInfo", query: { txnHash } }).then((res) => {
    return dispatch2(updateDetail(res == null ? void 0 : res.data));
  }).catch((e3) => {
    console.log(e3);
  });
};
var transaction = transactionSlice.reducer;
var store$1 = {
  home,
  main,
  recentInfo,
  blockHeight,
  nfrDetail,
  contractDetail,
  walletDetail,
  transaction
};
const getClientStore = () => {
  const preloadedState = window.PRE_LOADED_STATE || {};
  return configureStore({
    reducer: store$1,
    preloadedState
  });
};
var extendStatics$2 = function(d2, b10) {
  extendStatics$2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b11) {
    d3.__proto__ = b11;
  } || function(d3, b11) {
    for (var p2 in b11)
      if (Object.prototype.hasOwnProperty.call(b11, p2))
        d3[p2] = b11[p2];
  };
  return extendStatics$2(d2, b10);
};
function __extends$3(d2, b10) {
  if (typeof b10 !== "function" && b10 !== null)
    throw new TypeError("Class extends value " + String(b10) + " is not a constructor or null");
  extendStatics$2(d2, b10);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b10 === null ? Object.create(b10) : (__.prototype = b10.prototype, new __());
}
var __assign$4 = function() {
  __assign$4 = Object.assign || function __assign2(t2) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign$4.apply(this, arguments);
};
function __rest$3(s2, e3) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e3.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
}
function __awaiter(thisArg, _arguments, P2, generator) {
  function adopt(value2) {
    return value2 instanceof P2 ? value2 : new P2(function(resolve) {
      resolve(value2);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value2) {
      try {
        step(generator.next(value2));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value2) {
      try {
        step(generator["throw"](value2));
      } catch (e3) {
        reject(e3);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t2[0] & 1)
      throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f2, y2, t2, g2;
  return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v2) {
      return step([n2, v2]);
    };
  }
  function step(op) {
    if (f2)
      throw new TypeError("Generator is already executing.");
    while (_2)
      try {
        if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
          return t2;
        if (y2 = 0, t2)
          op = [op[0] & 2, t2.value];
        switch (op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            _2.label++;
            return { value: op[1], done: false };
          case 5:
            _2.label++;
            y2 = op[1];
            op = [0];
            continue;
          case 7:
            op = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _2.label = op[1];
              break;
            }
            if (op[0] === 6 && _2.label < t2[1]) {
              _2.label = t2[1];
              t2 = op;
              break;
            }
            if (t2 && _2.label < t2[2]) {
              _2.label = t2[2];
              _2.ops.push(op);
              break;
            }
            if (t2[2])
              _2.ops.pop();
            _2.trys.pop();
            continue;
        }
        op = body.call(thisArg, _2);
      } catch (e3) {
        op = [6, e3];
        y2 = 0;
      } finally {
        f2 = t2 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __values(o2) {
  var s2 = typeof Symbol === "function" && Symbol.iterator, m2 = s2 && o2[s2], i2 = 0;
  if (m2)
    return m2.call(o2);
  if (o2 && typeof o2.length === "number")
    return {
      next: function() {
        if (o2 && i2 >= o2.length)
          o2 = void 0;
        return { value: o2 && o2[i2++], done: !o2 };
      }
    };
  throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o2, n2) {
  var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m2)
    return o2;
  var i2 = m2.call(o2), r2, ar = [], e3;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done)
      ar.push(r2.value);
  } catch (error) {
    e3 = { error };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i2["return"]))
        m2.call(i2);
    } finally {
      if (e3)
        throw e3.error;
    }
  }
  return ar;
}
function __spreadArrays() {
  for (var s2 = 0, i2 = 0, il = arguments.length; i2 < il; i2++)
    s2 += arguments[i2].length;
  for (var r2 = Array(s2), k2 = 0, i2 = 0; i2 < il; i2++)
    for (var a2 = arguments[i2], j2 = 0, jl = a2.length; j2 < jl; j2++, k2++)
      r2[k2] = a2[j2];
  return r2;
}
function __spreadArray$1(to, from, pack2) {
  if (pack2 || arguments.length === 2)
    for (var i2 = 0, l2 = from.length, ar; i2 < l2; i2++) {
      if (ar || !(i2 in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i2);
        ar[i2] = from[i2];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
}
var isArrayLike = function(value2) {
  return value2 !== null && typeof value2 !== "function" && isFinite(value2.length);
};
var contains = function(arr, value2) {
  if (!isArrayLike(arr)) {
    return false;
  }
  return arr.indexOf(value2) > -1;
};
var filter = function(arr, func) {
  if (!isArrayLike(arr)) {
    return arr;
  }
  var result = [];
  for (var index2 = 0; index2 < arr.length; index2++) {
    var value2 = arr[index2];
    if (func(value2, index2)) {
      result.push(value2);
    }
  }
  return result;
};
var difference = function(arr, values2) {
  if (values2 === void 0) {
    values2 = [];
  }
  return filter(arr, function(value2) {
    return !contains(values2, value2);
  });
};
var toString$3 = {}.toString;
var isType$2 = function(value2, type4) {
  return toString$3.call(value2) === "[object " + type4 + "]";
};
var isFunction = function(value2) {
  return isType$2(value2, "Function");
};
var isNil = function(value2) {
  return value2 === null || value2 === void 0;
};
var isArray$1 = function(value2) {
  return Array.isArray ? Array.isArray(value2) : isType$2(value2, "Array");
};
var isObject = function(value2) {
  var type4 = typeof value2;
  return value2 !== null && type4 === "object" || type4 === "function";
};
function each$1(elements, func) {
  if (!elements) {
    return;
  }
  var rst;
  if (isArray$1(elements)) {
    for (var i2 = 0, len = elements.length; i2 < len; i2++) {
      rst = func(elements[i2], i2);
      if (rst === false) {
        break;
      }
    }
  } else if (isObject(elements)) {
    for (var k2 in elements) {
      if (elements.hasOwnProperty(k2)) {
        rst = func(elements[k2], k2);
        if (rst === false) {
          break;
        }
      }
    }
  }
}
var keys = Object.keys ? function(obj) {
  return Object.keys(obj);
} : function(obj) {
  var result = [];
  each$1(obj, function(value2, key2) {
    if (!(isFunction(obj) && key2 === "prototype")) {
      result.push(key2);
    }
  });
  return result;
};
function isMatch(obj, attrs) {
  var _keys = keys(attrs);
  var length2 = _keys.length;
  if (isNil(obj))
    return !length2;
  for (var i2 = 0; i2 < length2; i2 += 1) {
    var key2 = _keys[i2];
    if (attrs[key2] !== obj[key2] || !(key2 in obj)) {
      return false;
    }
  }
  return true;
}
var isObjectLike$1 = function(value2) {
  return typeof value2 === "object" && value2 !== null;
};
var isPlainObject$1 = function(value2) {
  if (!isObjectLike$1(value2) || !isType$2(value2, "Object")) {
    return false;
  }
  if (Object.getPrototypeOf(value2) === null) {
    return true;
  }
  var proto = value2;
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }
  return Object.getPrototypeOf(value2) === proto;
};
function find$1(arr, predicate) {
  if (!isArray$1(arr))
    return null;
  var _predicate;
  if (isFunction(predicate)) {
    _predicate = predicate;
  }
  if (isPlainObject$1(predicate)) {
    _predicate = function(a2) {
      return isMatch(a2, predicate);
    };
  }
  if (_predicate) {
    for (var i2 = 0; i2 < arr.length; i2 += 1) {
      if (_predicate(arr[i2])) {
        return arr[i2];
      }
    }
  }
  return null;
}
function findIndex(arr, predicate, fromIndex) {
  if (fromIndex === void 0) {
    fromIndex = 0;
  }
  for (var i2 = fromIndex; i2 < arr.length; i2++) {
    if (predicate(arr[i2], i2)) {
      return i2;
    }
  }
  return -1;
}
var firstValue = function(data2, name) {
  var rst = null;
  for (var i2 = 0; i2 < data2.length; i2++) {
    var obj = data2[i2];
    var value2 = obj[name];
    if (!isNil(value2)) {
      if (isArray$1(value2)) {
        rst = value2[0];
      } else {
        rst = value2;
      }
      break;
    }
  }
  return rst;
};
var flatten = function(arr) {
  if (!isArray$1(arr)) {
    return [];
  }
  var rst = [];
  for (var i2 = 0; i2 < arr.length; i2++) {
    rst = rst.concat(arr[i2]);
  }
  return rst;
};
var max$2 = function(arr) {
  if (!isArray$1(arr)) {
    return void 0;
  }
  return arr.reduce(function(prev, curr) {
    return Math.max(prev, curr);
  }, arr[0]);
};
var min$2 = function(arr) {
  if (!isArray$1(arr)) {
    return void 0;
  }
  return arr.reduce(function(prev, curr) {
    return Math.min(prev, curr);
  }, arr[0]);
};
var getRange = function(values2) {
  var filterValues = values2.filter(function(v2) {
    return !isNaN(v2);
  });
  if (!filterValues.length) {
    return {
      min: 0,
      max: 0
    };
  }
  if (isArray$1(values2[0])) {
    var tmp = [];
    for (var i2 = 0; i2 < values2.length; i2++) {
      tmp = tmp.concat(values2[i2]);
    }
    filterValues = tmp;
  }
  var max2 = max$2(filterValues);
  var min2 = min$2(filterValues);
  return {
    min: min2,
    max: max2
  };
};
var splice = Array.prototype.splice;
var pullAt = function pullAt2(arr, indexes) {
  if (!isArrayLike(arr)) {
    return [];
  }
  var length2 = arr ? indexes.length : 0;
  var last2 = length2 - 1;
  while (length2--) {
    var previous = void 0;
    var index2 = indexes[length2];
    if (length2 === last2 || index2 !== previous) {
      previous = index2;
      splice.call(arr, index2, 1);
    }
  }
  return arr;
};
var reduce = function(arr, fn2, init) {
  if (!isArray$1(arr) && !isPlainObject$1(arr)) {
    return arr;
  }
  var result = init;
  each$1(arr, function(data2, i2) {
    result = fn2(result, data2, i2);
  });
  return result;
};
var remove = function(arr, predicate) {
  var result = [];
  if (!isArrayLike(arr)) {
    return result;
  }
  var i2 = -1;
  var indexes = [];
  var length2 = arr.length;
  while (++i2 < length2) {
    var value2 = arr[i2];
    if (predicate(value2, i2, arr)) {
      result.push(value2);
      indexes.push(i2);
    }
  }
  pullAt(arr, indexes);
  return result;
};
var isString = function(str) {
  return isType$2(str, "String");
};
function sortBy(arr, key2) {
  var comparer;
  if (isFunction(key2)) {
    comparer = function(a2, b10) {
      return key2(a2) - key2(b10);
    };
  } else {
    var keys_12 = [];
    if (isString(key2)) {
      keys_12.push(key2);
    } else if (isArray$1(key2)) {
      keys_12 = key2;
    }
    comparer = function(a2, b10) {
      for (var i2 = 0; i2 < keys_12.length; i2 += 1) {
        var prop = keys_12[i2];
        if (a2[prop] > b10[prop]) {
          return 1;
        }
        if (a2[prop] < b10[prop]) {
          return -1;
        }
      }
      return 0;
    };
  }
  arr.sort(comparer);
  return arr;
}
function uniq$2(arr, cache2) {
  if (cache2 === void 0) {
    cache2 = /* @__PURE__ */ new Map();
  }
  var r2 = [];
  if (Array.isArray(arr)) {
    for (var i2 = 0, len = arr.length; i2 < len; i2++) {
      var item = arr[i2];
      if (!cache2.has(item)) {
        r2.push(item);
        cache2.set(item, true);
      }
    }
  }
  return r2;
}
var valuesOfKey = function(data2, name) {
  var rst = [];
  var tmpMap = {};
  for (var i2 = 0; i2 < data2.length; i2++) {
    var obj = data2[i2];
    var value2 = obj[name];
    if (!isNil(value2)) {
      if (!isArray$1(value2)) {
        value2 = [value2];
      }
      for (var j2 = 0; j2 < value2.length; j2++) {
        var val = value2[j2];
        if (!tmpMap[val]) {
          rst.push(val);
          tmpMap[val] = true;
        }
      }
    }
  }
  return rst;
};
function head(o2) {
  if (isArrayLike(o2)) {
    return o2[0];
  }
  return void 0;
}
function last(o2) {
  if (isArrayLike(o2)) {
    var arr = o2;
    return arr[arr.length - 1];
  }
  return void 0;
}
var every = function(arr, func) {
  for (var i2 = 0; i2 < arr.length; i2++) {
    if (!func(arr[i2], i2))
      return false;
  }
  return true;
};
var some = function(arr, func) {
  for (var i2 = 0; i2 < arr.length; i2++) {
    if (func(arr[i2], i2))
      return true;
  }
  return false;
};
var hasOwnProperty$2 = Object.prototype.hasOwnProperty;
function groupBy(data2, condition) {
  if (!condition || !isArray$1(data2)) {
    return {};
  }
  var result = {};
  var predicate = isFunction(condition) ? condition : function(item2) {
    return item2[condition];
  };
  var key2;
  for (var i2 = 0; i2 < data2.length; i2++) {
    var item = data2[i2];
    key2 = predicate(item);
    if (hasOwnProperty$2.call(result, key2)) {
      result[key2].push(item);
    } else {
      result[key2] = [item];
    }
  }
  return result;
}
function groupToMap(data2, condition) {
  if (!condition) {
    return {
      0: data2
    };
  }
  if (!isFunction(condition)) {
    var paramscondition_1 = isArray$1(condition) ? condition : condition.replace(/\s+/g, "").split("*");
    condition = function(row) {
      var unique = "_";
      for (var i2 = 0, l2 = paramscondition_1.length; i2 < l2; i2++) {
        unique += row[paramscondition_1[i2]] && row[paramscondition_1[i2]].toString();
      }
      return unique;
    };
  }
  return groupBy(data2, condition);
}
var group$1 = function(data2, condition) {
  if (!condition) {
    return [data2];
  }
  var groups = groupToMap(data2, condition);
  var array4 = [];
  for (var i2 in groups) {
    array4.push(groups[i2]);
  }
  return array4;
};
var clamp = function(a2, min2, max2) {
  if (a2 < min2) {
    return min2;
  } else if (a2 > max2) {
    return max2;
  }
  return a2;
};
var fixedBase = function(v2, base) {
  var str = base.toString();
  var index2 = str.indexOf(".");
  if (index2 === -1) {
    return Math.round(v2);
  }
  var length2 = str.substr(index2 + 1).length;
  if (length2 > 20) {
    length2 = 20;
  }
  return parseFloat(v2.toFixed(length2));
};
var isNumber$1 = function(value2) {
  return isType$2(value2, "Number");
};
var PRECISION = 1e-5;
function isNumberEqual$1(a2, b10, precision) {
  if (precision === void 0) {
    precision = PRECISION;
  }
  return Math.abs(a2 - b10) < precision;
}
var maxBy = function(arr, fn2) {
  if (!isArray$1(arr)) {
    return void 0;
  }
  var maxItem;
  var max2 = -Infinity;
  for (var i2 = 0; i2 < arr.length; i2++) {
    var item = arr[i2];
    var v2 = isFunction(fn2) ? fn2(item) : item[fn2];
    if (v2 > max2) {
      maxItem = item;
      max2 = v2;
    }
  }
  return maxItem;
};
var minBy = function(arr, fn2) {
  if (!isArray$1(arr)) {
    return void 0;
  }
  var minItem;
  var min2 = Infinity;
  for (var i2 = 0; i2 < arr.length; i2++) {
    var item = arr[i2];
    var v2 = isFunction(fn2) ? fn2(item) : item[fn2];
    if (v2 < min2) {
      minItem = item;
      min2 = v2;
    }
  }
  return minItem;
};
var mod$1 = function(n2, m2) {
  return (n2 % m2 + m2) % m2;
};
var RADIAN = Math.PI / 180;
var toRadian = function(degree) {
  return RADIAN * degree;
};
var has = function(obj, key2) {
  return obj.hasOwnProperty(key2);
};
var values = Object.values ? function(obj) {
  return Object.values(obj);
} : function(obj) {
  var result = [];
  each$1(obj, function(value2, key2) {
    if (!(isFunction(obj) && key2 === "prototype")) {
      result.push(value2);
    }
  });
  return result;
};
var toString$2 = function(value2) {
  if (isNil(value2))
    return "";
  return value2.toString();
};
var lowerCase = function(str) {
  return toString$2(str).toLowerCase();
};
function substitute(str, o2) {
  if (!str || !o2) {
    return str;
  }
  return str.replace(/\\?\{([^{}]+)\}/g, function(match2, name) {
    if (match2.charAt(0) === "\\") {
      return match2.slice(1);
    }
    return o2[name] === void 0 ? "" : o2[name];
  });
}
var upperFirst = function(value2) {
  var str = toString$2(value2);
  return str.charAt(0).toUpperCase() + str.substring(1);
};
var toString$1 = {}.toString;
var getType = function(value2) {
  return toString$1.call(value2).replace(/^\[object /, "").replace(/]$/, "");
};
var isBoolean = function(value2) {
  return isType$2(value2, "Boolean");
};
var isDate = function(value2) {
  return isType$2(value2, "Date");
};
var isNull = function(value2) {
  return value2 === null;
};
var objectProto = Object.prototype;
var isPrototype = function(value2) {
  var Ctor = value2 && value2.constructor;
  var proto = typeof Ctor === "function" && Ctor.prototype || objectProto;
  return value2 === proto;
};
var isUndefined = function(value2) {
  return value2 === void 0;
};
var isElement = function(o2) {
  return o2 instanceof Element || o2 instanceof HTMLDocument;
};
function requestAnimationFrame$1(fn2) {
  var method4 = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame || function(f2) {
    return setTimeout(f2, 16);
  };
  return method4(fn2);
}
function cancelAnimationFrame$1(handler) {
  var method4 = window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || window.msCancelAnimationFrame || clearTimeout;
  method4(handler);
}
function _mix(dist, obj) {
  for (var key2 in obj) {
    if (obj.hasOwnProperty(key2) && key2 !== "constructor" && obj[key2] !== void 0) {
      dist[key2] = obj[key2];
    }
  }
}
function mix(dist, src1, src2, src3) {
  if (src1)
    _mix(dist, src1);
  if (src2)
    _mix(dist, src2);
  if (src3)
    _mix(dist, src3);
  return dist;
}
var clone$1 = function(obj) {
  if (typeof obj !== "object" || obj === null) {
    return obj;
  }
  var rst;
  if (isArray$1(obj)) {
    rst = [];
    for (var i2 = 0, l2 = obj.length; i2 < l2; i2++) {
      if (typeof obj[i2] === "object" && obj[i2] != null) {
        rst[i2] = clone$1(obj[i2]);
      } else {
        rst[i2] = obj[i2];
      }
    }
  } else {
    rst = {};
    for (var k2 in obj) {
      if (typeof obj[k2] === "object" && obj[k2] != null) {
        rst[k2] = clone$1(obj[k2]);
      } else {
        rst[k2] = obj[k2];
      }
    }
  }
  return rst;
};
function debounce$1(func, wait, immediate) {
  var timeout2;
  return function() {
    var context2 = this, args = arguments;
    var later = function() {
      timeout2 = null;
      if (!immediate) {
        func.apply(context2, args);
      }
    };
    var callNow = immediate && !timeout2;
    clearTimeout(timeout2);
    timeout2 = setTimeout(later, wait);
    if (callNow) {
      func.apply(context2, args);
    }
  };
}
var memoize = function(f2, resolver) {
  if (!isFunction(f2)) {
    throw new TypeError("Expected a function");
  }
  var memoized = function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var key2 = resolver ? resolver.apply(this, args) : args[0];
    var cache2 = memoized.cache;
    if (cache2.has(key2)) {
      return cache2.get(key2);
    }
    var result = f2.apply(this, args);
    cache2.set(key2, result);
    return result;
  };
  memoized.cache = /* @__PURE__ */ new Map();
  return memoized;
};
var MAX_MIX_LEVEL$1 = 5;
function _deepMix(dist, src2, level, maxLevel) {
  level = level || 0;
  maxLevel = maxLevel || MAX_MIX_LEVEL$1;
  for (var key2 in src2) {
    if (src2.hasOwnProperty(key2)) {
      var value2 = src2[key2];
      if (value2 !== null && isPlainObject$1(value2)) {
        if (!isPlainObject$1(dist[key2])) {
          dist[key2] = {};
        }
        if (level < maxLevel) {
          _deepMix(dist[key2], value2, level + 1, maxLevel);
        } else {
          dist[key2] = src2[key2];
        }
      } else if (isArray$1(value2)) {
        dist[key2] = [];
        dist[key2] = dist[key2].concat(value2);
      } else if (value2 !== void 0) {
        dist[key2] = value2;
      }
    }
  }
}
var deepMix = function(rst) {
  var args = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    args[_i - 1] = arguments[_i];
  }
  for (var i2 = 0; i2 < args.length; i2 += 1) {
    _deepMix(rst, args[i2]);
  }
  return rst;
};
var indexOf = function(arr, obj) {
  if (!isArrayLike(arr)) {
    return -1;
  }
  var m2 = Array.prototype.indexOf;
  if (m2) {
    return m2.call(arr, obj);
  }
  var index2 = -1;
  for (var i2 = 0; i2 < arr.length; i2++) {
    if (arr[i2] === obj) {
      index2 = i2;
      break;
    }
  }
  return index2;
};
var hasOwnProperty$1 = Object.prototype.hasOwnProperty;
function isEmpty(value2) {
  if (isNil(value2)) {
    return true;
  }
  if (isArrayLike(value2)) {
    return !value2.length;
  }
  var type4 = getType(value2);
  if (type4 === "Map" || type4 === "Set") {
    return !value2.size;
  }
  if (isPrototype(value2)) {
    return !Object.keys(value2).length;
  }
  for (var key2 in value2) {
    if (hasOwnProperty$1.call(value2, key2)) {
      return false;
    }
  }
  return true;
}
var isEqual$1 = function(value2, other2) {
  if (value2 === other2) {
    return true;
  }
  if (!value2 || !other2) {
    return false;
  }
  if (isString(value2) || isString(other2)) {
    return false;
  }
  if (isArrayLike(value2) || isArrayLike(other2)) {
    if (value2.length !== other2.length) {
      return false;
    }
    var rst = true;
    for (var i2 = 0; i2 < value2.length; i2++) {
      rst = isEqual$1(value2[i2], other2[i2]);
      if (!rst) {
        break;
      }
    }
    return rst;
  }
  if (isObjectLike$1(value2) || isObjectLike$1(other2)) {
    var valueKeys = Object.keys(value2);
    var otherKeys = Object.keys(other2);
    if (valueKeys.length !== otherKeys.length) {
      return false;
    }
    var rst = true;
    for (var i2 = 0; i2 < valueKeys.length; i2++) {
      rst = isEqual$1(value2[valueKeys[i2]], other2[valueKeys[i2]]);
      if (!rst) {
        break;
      }
    }
    return rst;
  }
  return false;
};
var map$2 = function(arr, func) {
  if (!isArrayLike(arr)) {
    return arr;
  }
  var result = [];
  for (var index2 = 0; index2 < arr.length; index2++) {
    var value2 = arr[index2];
    result.push(func(value2, index2));
  }
  return result;
};
var identity = function(v2) {
  return v2;
};
var mapValues = function(object4, func) {
  if (func === void 0) {
    func = identity;
  }
  var r2 = {};
  if (isObject(object4) && !isNil(object4)) {
    Object.keys(object4).forEach(function(key2) {
      r2[key2] = func(object4[key2], key2);
    });
  }
  return r2;
};
var get = function(obj, key2, defaultValue) {
  var p2 = 0;
  var keyArr = isString(key2) ? key2.split(".") : key2;
  while (obj && p2 < keyArr.length) {
    obj = obj[keyArr[p2++]];
  }
  return obj === void 0 || p2 < keyArr.length ? defaultValue : obj;
};
var set = function(obj, path2, value2) {
  var o2 = obj;
  var keyArr = isString(path2) ? path2.split(".") : path2;
  keyArr.forEach(function(key2, idx) {
    if (idx < keyArr.length - 1) {
      if (!isObject(o2[key2])) {
        o2[key2] = isNumber$1(keyArr[idx + 1]) ? [] : {};
      }
      o2 = o2[key2];
    } else {
      o2[key2] = value2;
    }
  });
  return obj;
};
var hasOwnProperty = Object.prototype.hasOwnProperty;
var pick$1 = function(object4, keys2) {
  if (object4 === null || !isPlainObject$1(object4)) {
    return {};
  }
  var result = {};
  each$1(keys2, function(key2) {
    if (hasOwnProperty.call(object4, key2)) {
      result[key2] = object4[key2];
    }
  });
  return result;
};
var omit$1 = function(obj, keys2) {
  return reduce(obj, function(r2, curr, key2) {
    if (!keys2.includes(key2)) {
      r2[key2] = curr;
    }
    return r2;
  }, {});
};
var throttle = function(func, wait, options) {
  var timeout2, context2, args, result;
  var previous = 0;
  if (!options)
    options = {};
  var later = function() {
    previous = options.leading === false ? 0 : Date.now();
    timeout2 = null;
    result = func.apply(context2, args);
    if (!timeout2)
      context2 = args = null;
  };
  var throttled = function() {
    var now2 = Date.now();
    if (!previous && options.leading === false)
      previous = now2;
    var remaining = wait - (now2 - previous);
    context2 = this;
    args = arguments;
    if (remaining <= 0 || remaining > wait) {
      if (timeout2) {
        clearTimeout(timeout2);
        timeout2 = null;
      }
      previous = now2;
      result = func.apply(context2, args);
      if (!timeout2)
        context2 = args = null;
    } else if (!timeout2 && options.trailing !== false) {
      timeout2 = setTimeout(later, remaining);
    }
    return result;
  };
  throttled.cancel = function() {
    clearTimeout(timeout2);
    previous = 0;
    timeout2 = context2 = args = null;
  };
  return throttled;
};
var toArray = function(value2) {
  return isArrayLike(value2) ? Array.prototype.slice.call(value2) : [];
};
var map$1 = {};
var uniqueId = function(prefix) {
  prefix = prefix || "g";
  if (!map$1[prefix]) {
    map$1[prefix] = 1;
  } else {
    map$1[prefix] += 1;
  }
  return prefix + map$1[prefix];
};
var noop = function() {
};
function size(o2) {
  if (isNil(o2)) {
    return 0;
  }
  if (isArrayLike(o2)) {
    return o2.length;
  }
  return Object.keys(o2).length;
}
var ctx$2;
var measureTextWidth$1 = memoize(function(text2, font) {
  if (font === void 0) {
    font = {};
  }
  var fontSize = font.fontSize, fontFamily = font.fontFamily, fontWeight = font.fontWeight, fontStyle = font.fontStyle, fontVariant = font.fontVariant;
  if (!ctx$2) {
    ctx$2 = document.createElement("canvas").getContext("2d");
  }
  ctx$2.font = [fontStyle, fontVariant, fontWeight, fontSize + "px", fontFamily].join(" ");
  return ctx$2.measureText(isString(text2) ? text2 : "").width;
}, function(text2, font) {
  if (font === void 0) {
    font = {};
  }
  return __spreadArrays([text2], values(font)).join("");
});
var getEllipsisText$1 = function(text2, maxWidth, font, str) {
  if (str === void 0) {
    str = "...";
  }
  var STEP = 16;
  var PLACEHOLDER_WIDTH = measureTextWidth$1(str, font);
  var leftText = !isString(text2) ? toString$2(text2) : text2;
  var leftWidth = maxWidth;
  var r2 = [];
  var currentText;
  var currentWidth;
  if (measureTextWidth$1(text2, font) <= maxWidth) {
    return text2;
  }
  while (true) {
    currentText = leftText.substr(0, STEP);
    currentWidth = measureTextWidth$1(currentText, font);
    if (currentWidth + PLACEHOLDER_WIDTH > leftWidth) {
      if (currentWidth > leftWidth) {
        break;
      }
    }
    r2.push(currentText);
    leftWidth -= currentWidth;
    leftText = leftText.substr(STEP);
    if (!leftText) {
      return r2.join("");
    }
  }
  while (true) {
    currentText = leftText.substr(0, 1);
    currentWidth = measureTextWidth$1(currentText, font);
    if (currentWidth + PLACEHOLDER_WIDTH > leftWidth) {
      break;
    }
    r2.push(currentText);
    leftWidth -= currentWidth;
    leftText = leftText.substr(1);
    if (!leftText) {
      return r2.join("");
    }
  }
  return "" + r2.join("") + str;
};
var default_1 = function() {
  function default_12() {
    this.map = {};
  }
  default_12.prototype.has = function(key2) {
    return this.map[key2] !== void 0;
  };
  default_12.prototype.get = function(key2, def) {
    var v2 = this.map[key2];
    return v2 === void 0 ? def : v2;
  };
  default_12.prototype.set = function(key2, value2) {
    this.map[key2] = value2;
  };
  default_12.prototype.clear = function() {
    this.map = {};
  };
  default_12.prototype.delete = function(key2) {
    delete this.map[key2];
  };
  default_12.prototype.size = function() {
    return Object.keys(this.map).length;
  };
  return default_12;
}();
var LAYER;
(function(LAYER2) {
  LAYER2["FORE"] = "fore";
  LAYER2["MID"] = "mid";
  LAYER2["BG"] = "bg";
})(LAYER || (LAYER = {}));
var DIRECTION;
(function(DIRECTION2) {
  DIRECTION2["TOP"] = "top";
  DIRECTION2["TOP_LEFT"] = "top-left";
  DIRECTION2["TOP_RIGHT"] = "top-right";
  DIRECTION2["RIGHT"] = "right";
  DIRECTION2["RIGHT_TOP"] = "right-top";
  DIRECTION2["RIGHT_BOTTOM"] = "right-bottom";
  DIRECTION2["LEFT"] = "left";
  DIRECTION2["LEFT_TOP"] = "left-top";
  DIRECTION2["LEFT_BOTTOM"] = "left-bottom";
  DIRECTION2["BOTTOM"] = "bottom";
  DIRECTION2["BOTTOM_LEFT"] = "bottom-left";
  DIRECTION2["BOTTOM_RIGHT"] = "bottom-right";
  DIRECTION2["RADIUS"] = "radius";
  DIRECTION2["CIRCLE"] = "circle";
  DIRECTION2["NONE"] = "none";
})(DIRECTION || (DIRECTION = {}));
var COMPONENT_TYPE;
(function(COMPONENT_TYPE2) {
  COMPONENT_TYPE2["AXIS"] = "axis";
  COMPONENT_TYPE2["GRID"] = "grid";
  COMPONENT_TYPE2["LEGEND"] = "legend";
  COMPONENT_TYPE2["TOOLTIP"] = "tooltip";
  COMPONENT_TYPE2["ANNOTATION"] = "annotation";
  COMPONENT_TYPE2["SLIDER"] = "slider";
  COMPONENT_TYPE2["SCROLLBAR"] = "scrollbar";
  COMPONENT_TYPE2["OTHER"] = "other";
})(COMPONENT_TYPE || (COMPONENT_TYPE = {}));
var GROUP_Z_INDEX = {
  FORE: 3,
  MID: 2,
  BG: 1
};
var VIEW_LIFE_CIRCLE;
(function(VIEW_LIFE_CIRCLE2) {
  VIEW_LIFE_CIRCLE2["BEFORE_RENDER"] = "beforerender";
  VIEW_LIFE_CIRCLE2["AFTER_RENDER"] = "afterrender";
  VIEW_LIFE_CIRCLE2["BEFORE_PAINT"] = "beforepaint";
  VIEW_LIFE_CIRCLE2["AFTER_PAINT"] = "afterpaint";
  VIEW_LIFE_CIRCLE2["BEFORE_CHANGE_DATA"] = "beforechangedata";
  VIEW_LIFE_CIRCLE2["AFTER_CHANGE_DATA"] = "afterchangedata";
  VIEW_LIFE_CIRCLE2["BEFORE_CLEAR"] = "beforeclear";
  VIEW_LIFE_CIRCLE2["AFTER_CLEAR"] = "afterclear";
  VIEW_LIFE_CIRCLE2["BEFORE_DESTROY"] = "beforedestroy";
  VIEW_LIFE_CIRCLE2["BEFORE_CHANGE_SIZE"] = "beforechangesize";
  VIEW_LIFE_CIRCLE2["AFTER_CHANGE_SIZE"] = "afterchangesize";
})(VIEW_LIFE_CIRCLE || (VIEW_LIFE_CIRCLE = {}));
var GEOMETRY_LIFE_CIRCLE;
(function(GEOMETRY_LIFE_CIRCLE2) {
  GEOMETRY_LIFE_CIRCLE2["BEFORE_DRAW_ANIMATE"] = "beforeanimate";
  GEOMETRY_LIFE_CIRCLE2["AFTER_DRAW_ANIMATE"] = "afteranimate";
  GEOMETRY_LIFE_CIRCLE2["BEFORE_RENDER_LABEL"] = "beforerenderlabel";
  GEOMETRY_LIFE_CIRCLE2["AFTER_RENDER_LABEL"] = "afterrenderlabel";
})(GEOMETRY_LIFE_CIRCLE || (GEOMETRY_LIFE_CIRCLE = {}));
var PLOT_EVENTS;
(function(PLOT_EVENTS2) {
  PLOT_EVENTS2["MOUSE_ENTER"] = "plot:mouseenter";
  PLOT_EVENTS2["MOUSE_DOWN"] = "plot:mousedown";
  PLOT_EVENTS2["MOUSE_MOVE"] = "plot:mousemove";
  PLOT_EVENTS2["MOUSE_UP"] = "plot:mouseup";
  PLOT_EVENTS2["MOUSE_LEAVE"] = "plot:mouseleave";
  PLOT_EVENTS2["TOUCH_START"] = "plot:touchstart";
  PLOT_EVENTS2["TOUCH_MOVE"] = "plot:touchmove";
  PLOT_EVENTS2["TOUCH_END"] = "plot:touchend";
  PLOT_EVENTS2["TOUCH_CANCEL"] = "plot:touchcancel";
  PLOT_EVENTS2["CLICK"] = "plot:click";
  PLOT_EVENTS2["DBLCLICK"] = "plot:dblclick";
  PLOT_EVENTS2["CONTEXTMENU"] = "plot:contextmenu";
  PLOT_EVENTS2["LEAVE"] = "plot:leave";
  PLOT_EVENTS2["ENTER"] = "plot:enter";
})(PLOT_EVENTS || (PLOT_EVENTS = {}));
var ELEMENT_STATE;
(function(ELEMENT_STATE2) {
  ELEMENT_STATE2["ACTIVE"] = "active";
  ELEMENT_STATE2["INACTIVE"] = "inactive";
  ELEMENT_STATE2["SELECTED"] = "selected";
  ELEMENT_STATE2["DEFAULT"] = "default";
})(ELEMENT_STATE || (ELEMENT_STATE = {}));
var GROUP_ATTRS = ["color", "shape", "size"];
var FIELD_ORIGIN = "_origin";
var MIN_CHART_WIDTH = 1;
var MIN_CHART_HEIGHT = 1;
var COMPONENT_MAX_VIEW_PERCENTAGE = 0.25;
var ENGINES = {};
function getEngine(name) {
  var G2 = ENGINES[name];
  if (!G2) {
    throw new Error("G engine '".concat(name, "' is not exist, please register it at first."));
  }
  return G2;
}
function registerEngine(name, engine) {
  ENGINES[name] = engine;
}
function addEventListener(target, eventType, callback) {
  if (target) {
    if (typeof target.addEventListener === "function") {
      target.addEventListener(eventType, callback, false);
      return {
        remove: function() {
          target.removeEventListener(eventType, callback, false);
        }
      };
    }
    if (typeof target.attachEvent === "function") {
      target.attachEvent("on" + eventType, callback);
      return {
        remove: function() {
          target.detachEvent("on" + eventType, callback);
        }
      };
    }
  }
}
var TABLE;
var TABLE_TR;
var FRAGMENT_REG;
var CONTAINERS;
function initConstants() {
  TABLE = document.createElement("table");
  TABLE_TR = document.createElement("tr");
  FRAGMENT_REG = /^\s*<(\w+|!)[^>]*>/;
  CONTAINERS = {
    tr: document.createElement("tbody"),
    tbody: TABLE,
    thead: TABLE,
    tfoot: TABLE,
    td: TABLE_TR,
    th: TABLE_TR,
    "*": document.createElement("div")
  };
}
function createDom$1(str) {
  if (!TABLE) {
    initConstants();
  }
  var name = FRAGMENT_REG.test(str) && RegExp.$1;
  if (!name || !(name in CONTAINERS)) {
    name = "*";
  }
  var container = CONTAINERS[name];
  str = typeof str === "string" ? str.replace(/(^\s*)|(\s*$)/g, "") : str;
  container.innerHTML = "" + str;
  var dom = container.childNodes[0];
  if (dom && container.contains(dom)) {
    container.removeChild(dom);
  }
  return dom;
}
function getStyle$1(dom, name, defaultValue) {
  var v2;
  try {
    v2 = window.getComputedStyle ? window.getComputedStyle(dom, null)[name] : dom.style[name];
  } catch (e3) {
  } finally {
    v2 = v2 === void 0 ? defaultValue : v2;
  }
  return v2;
}
function getHeight$1(el, defaultValue) {
  var height = getStyle$1(el, "height", defaultValue);
  if (height === "auto") {
    height = el.offsetHeight;
  }
  return parseFloat(height);
}
function getOuterHeight(el, defaultValue) {
  var height = getHeight$1(el, defaultValue);
  var bTop = parseFloat(getStyle$1(el, "borderTopWidth")) || 0;
  var pTop = parseFloat(getStyle$1(el, "paddingTop")) || 0;
  var pBottom = parseFloat(getStyle$1(el, "paddingBottom")) || 0;
  var bBottom = parseFloat(getStyle$1(el, "borderBottomWidth")) || 0;
  var mTop = parseFloat(getStyle$1(el, "marginTop")) || 0;
  var mBottom = parseFloat(getStyle$1(el, "marginBottom")) || 0;
  return height + bTop + bBottom + pTop + pBottom + mTop + mBottom;
}
function getHeight(el, defaultValue) {
  var width = getStyle$1(el, "width", defaultValue);
  if (width === "auto") {
    width = el.offsetWidth;
  }
  return parseFloat(width);
}
function getOuterWidth(el, defaultValue) {
  var width = getHeight(el, defaultValue);
  var bLeft = parseFloat(getStyle$1(el, "borderLeftWidth")) || 0;
  var pLeft = parseFloat(getStyle$1(el, "paddingLeft")) || 0;
  var pRight = parseFloat(getStyle$1(el, "paddingRight")) || 0;
  var bRight = parseFloat(getStyle$1(el, "borderRightWidth")) || 0;
  var mRight = parseFloat(getStyle$1(el, "marginRight")) || 0;
  var mLeft = parseFloat(getStyle$1(el, "marginLeft")) || 0;
  return width + bLeft + bRight + pLeft + pRight + mLeft + mRight;
}
function modifyCSS(dom, css2) {
  if (dom) {
    for (var key2 in css2) {
      if (css2.hasOwnProperty(key2)) {
        dom.style[key2] = css2[key2];
      }
    }
  }
  return dom;
}
function getElementSize(ele) {
  var style2 = getComputedStyle(ele);
  return {
    width: (ele.clientWidth || parseInt(style2.width, 10)) - parseInt(style2.paddingLeft, 10) - parseInt(style2.paddingRight, 10),
    height: (ele.clientHeight || parseInt(style2.height, 10)) - parseInt(style2.paddingTop, 10) - parseInt(style2.paddingBottom, 10)
  };
}
function isNumber(v2) {
  return typeof v2 === "number" && !isNaN(v2);
}
function getChartSize(ele, autoFit, width, height) {
  var w2 = width;
  var h2 = height;
  if (autoFit) {
    var size2 = getElementSize(ele);
    w2 = size2.width ? size2.width : w2;
    h2 = size2.height ? size2.height : h2;
  }
  return {
    width: Math.max(isNumber(w2) ? w2 : MIN_CHART_WIDTH, MIN_CHART_WIDTH),
    height: Math.max(isNumber(h2) ? h2 : MIN_CHART_HEIGHT, MIN_CHART_HEIGHT)
  };
}
function removeDom(dom) {
  var parent = dom.parentNode;
  if (parent) {
    parent.removeChild(dom);
  }
}
var WILDCARD$1 = "*";
var EventEmitter = function() {
  function EventEmitter2() {
    this._events = {};
  }
  EventEmitter2.prototype.on = function(evt, callback, once) {
    if (!this._events[evt]) {
      this._events[evt] = [];
    }
    this._events[evt].push({
      callback,
      once: !!once
    });
    return this;
  };
  EventEmitter2.prototype.once = function(evt, callback) {
    return this.on(evt, callback, true);
  };
  EventEmitter2.prototype.emit = function(evt) {
    var _this = this;
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      args[_i - 1] = arguments[_i];
    }
    var events = this._events[evt] || [];
    var wildcardEvents = this._events[WILDCARD$1] || [];
    var doEmit = function(es) {
      var length2 = es.length;
      for (var i2 = 0; i2 < length2; i2++) {
        if (!es[i2]) {
          continue;
        }
        var _a2 = es[i2], callback = _a2.callback, once = _a2.once;
        if (once) {
          es.splice(i2, 1);
          if (es.length === 0) {
            delete _this._events[evt];
          }
          length2--;
          i2--;
        }
        callback.apply(_this, args);
      }
    };
    doEmit(events);
    doEmit(wildcardEvents);
  };
  EventEmitter2.prototype.off = function(evt, callback) {
    if (!evt) {
      this._events = {};
    } else {
      if (!callback) {
        delete this._events[evt];
      } else {
        var events = this._events[evt] || [];
        var length_1 = events.length;
        for (var i2 = 0; i2 < length_1; i2++) {
          if (events[i2].callback === callback) {
            events.splice(i2, 1);
            length_1--;
            i2--;
          }
        }
        if (events.length === 0) {
          delete this._events[evt];
        }
      }
    }
    return this;
  };
  EventEmitter2.prototype.getEvents = function() {
    return this._events;
  };
  return EventEmitter2;
}();
var Base$1 = function(_super) {
  __extends$3(Base2, _super);
  function Base2(cfg) {
    var _this = _super.call(this) || this;
    _this.destroyed = false;
    var _a2 = cfg.visible, visible = _a2 === void 0 ? true : _a2;
    _this.visible = visible;
    return _this;
  }
  Base2.prototype.show = function() {
    var visible = this.visible;
    if (!visible) {
      this.changeVisible(true);
    }
  };
  Base2.prototype.hide = function() {
    var visible = this.visible;
    if (visible) {
      this.changeVisible(false);
    }
  };
  Base2.prototype.destroy = function() {
    this.off();
    this.destroyed = true;
  };
  Base2.prototype.changeVisible = function(visible) {
    if (this.visible === visible) {
      return;
    }
    this.visible = visible;
  };
  return Base2;
}(EventEmitter);
var SPACES$1 = "	\n\v\f\r \xA0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029";
var PATH_COMMAND$1 = new RegExp("([a-z])[" + SPACES$1 + ",]*((-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?[" + SPACES$1 + "]*,?[" + SPACES$1 + "]*)+)", "ig");
var PATH_VALUES$1 = new RegExp("(-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?)[" + SPACES$1 + "]*,?[" + SPACES$1 + "]*", "ig");
var parsePathString$1 = function(pathString) {
  if (!pathString) {
    return null;
  }
  if (isArray$1(pathString)) {
    return pathString;
  }
  var paramCounts = {
    a: 7,
    c: 6,
    o: 2,
    h: 1,
    l: 2,
    m: 2,
    r: 4,
    q: 4,
    s: 4,
    t: 2,
    v: 1,
    u: 3,
    z: 0
  };
  var data2 = [];
  String(pathString).replace(PATH_COMMAND$1, function(a2, b10, c2) {
    var params = [];
    var name = b10.toLowerCase();
    c2.replace(PATH_VALUES$1, function(a3, b11) {
      b11 && params.push(+b11);
    });
    if (name === "m" && params.length > 2) {
      data2.push([b10].concat(params.splice(0, 2)));
      name = "l";
      b10 = b10 === "m" ? "l" : "L";
    }
    if (name === "o" && params.length === 1) {
      data2.push([b10, params[0]]);
    }
    if (name === "r") {
      data2.push([b10].concat(params));
    } else {
      while (params.length >= paramCounts[name]) {
        data2.push([b10].concat(params.splice(0, paramCounts[name])));
        if (!paramCounts[name]) {
          break;
        }
      }
    }
    return pathString;
  });
  return data2;
};
var catmullRomToBezier = function(crp, z2) {
  var d2 = [];
  for (var i2 = 0, iLen = crp.length; iLen - 2 * !z2 > i2; i2 += 2) {
    var p2 = [
      {
        x: +crp[i2 - 2],
        y: +crp[i2 - 1]
      },
      {
        x: +crp[i2],
        y: +crp[i2 + 1]
      },
      {
        x: +crp[i2 + 2],
        y: +crp[i2 + 3]
      },
      {
        x: +crp[i2 + 4],
        y: +crp[i2 + 5]
      }
    ];
    if (z2) {
      if (!i2) {
        p2[0] = {
          x: +crp[iLen - 2],
          y: +crp[iLen - 1]
        };
      } else if (iLen - 4 === i2) {
        p2[3] = {
          x: +crp[0],
          y: +crp[1]
        };
      } else if (iLen - 2 === i2) {
        p2[2] = {
          x: +crp[0],
          y: +crp[1]
        };
        p2[3] = {
          x: +crp[2],
          y: +crp[3]
        };
      }
    } else {
      if (iLen - 4 === i2) {
        p2[3] = p2[2];
      } else if (!i2) {
        p2[0] = {
          x: +crp[i2],
          y: +crp[i2 + 1]
        };
      }
    }
    d2.push([
      "C",
      (-p2[0].x + 6 * p2[1].x + p2[2].x) / 6,
      (-p2[0].y + 6 * p2[1].y + p2[2].y) / 6,
      (p2[1].x + 6 * p2[2].x - p2[3].x) / 6,
      (p2[1].y + 6 * p2[2].y - p2[3].y) / 6,
      p2[2].x,
      p2[2].y
    ]);
  }
  return d2;
};
var ellipsePath = function(x2, y2, rx, ry, a2) {
  var res = [];
  if (a2 === null && ry === null) {
    ry = rx;
  }
  x2 = +x2;
  y2 = +y2;
  rx = +rx;
  ry = +ry;
  if (a2 !== null) {
    var rad = Math.PI / 180;
    var x1 = x2 + rx * Math.cos(-ry * rad);
    var x22 = x2 + rx * Math.cos(-a2 * rad);
    var y1 = y2 + rx * Math.sin(-ry * rad);
    var y22 = y2 + rx * Math.sin(-a2 * rad);
    res = [
      ["M", x1, y1],
      ["A", rx, rx, 0, +(a2 - ry > 180), 0, x22, y22]
    ];
  } else {
    res = [["M", x2, y2], ["m", 0, -ry], ["a", rx, ry, 0, 1, 1, 0, 2 * ry], ["a", rx, ry, 0, 1, 1, 0, -2 * ry], ["z"]];
  }
  return res;
};
var pathToAbsolute$1 = function(pathArray) {
  pathArray = parsePathString$1(pathArray);
  if (!pathArray || !pathArray.length) {
    return [["M", 0, 0]];
  }
  var res = [];
  var x2 = 0;
  var y2 = 0;
  var mx = 0;
  var my = 0;
  var start = 0;
  var pa0;
  var dots;
  if (pathArray[0][0] === "M") {
    x2 = +pathArray[0][1];
    y2 = +pathArray[0][2];
    mx = x2;
    my = y2;
    start++;
    res[0] = ["M", x2, y2];
  }
  var crz = pathArray.length === 3 && pathArray[0][0] === "M" && pathArray[1][0].toUpperCase() === "R" && pathArray[2][0].toUpperCase() === "Z";
  for (var r2 = void 0, pa2 = void 0, i2 = start, ii2 = pathArray.length; i2 < ii2; i2++) {
    res.push(r2 = []);
    pa2 = pathArray[i2];
    pa0 = pa2[0];
    if (pa0 !== pa0.toUpperCase()) {
      r2[0] = pa0.toUpperCase();
      switch (r2[0]) {
        case "A":
          r2[1] = pa2[1];
          r2[2] = pa2[2];
          r2[3] = pa2[3];
          r2[4] = pa2[4];
          r2[5] = pa2[5];
          r2[6] = +pa2[6] + x2;
          r2[7] = +pa2[7] + y2;
          break;
        case "V":
          r2[1] = +pa2[1] + y2;
          break;
        case "H":
          r2[1] = +pa2[1] + x2;
          break;
        case "R":
          dots = [x2, y2].concat(pa2.slice(1));
          for (var j2 = 2, jj2 = dots.length; j2 < jj2; j2++) {
            dots[j2] = +dots[j2] + x2;
            dots[++j2] = +dots[j2] + y2;
          }
          res.pop();
          res = res.concat(catmullRomToBezier(dots, crz));
          break;
        case "O":
          res.pop();
          dots = ellipsePath(x2, y2, pa2[1], pa2[2]);
          dots.push(dots[0]);
          res = res.concat(dots);
          break;
        case "U":
          res.pop();
          res = res.concat(ellipsePath(x2, y2, pa2[1], pa2[2], pa2[3]));
          r2 = ["U"].concat(res[res.length - 1].slice(-2));
          break;
        case "M":
          mx = +pa2[1] + x2;
          my = +pa2[2] + y2;
          break;
        default:
          for (var j2 = 1, jj2 = pa2.length; j2 < jj2; j2++) {
            r2[j2] = +pa2[j2] + (j2 % 2 ? x2 : y2);
          }
      }
    } else if (pa0 === "R") {
      dots = [x2, y2].concat(pa2.slice(1));
      res.pop();
      res = res.concat(catmullRomToBezier(dots, crz));
      r2 = ["R"].concat(pa2.slice(-2));
    } else if (pa0 === "O") {
      res.pop();
      dots = ellipsePath(x2, y2, pa2[1], pa2[2]);
      dots.push(dots[0]);
      res = res.concat(dots);
    } else if (pa0 === "U") {
      res.pop();
      res = res.concat(ellipsePath(x2, y2, pa2[1], pa2[2], pa2[3]));
      r2 = ["U"].concat(res[res.length - 1].slice(-2));
    } else {
      for (var k2 = 0, kk2 = pa2.length; k2 < kk2; k2++) {
        r2[k2] = pa2[k2];
      }
    }
    pa0 = pa0.toUpperCase();
    if (pa0 !== "O") {
      switch (r2[0]) {
        case "Z":
          x2 = +mx;
          y2 = +my;
          break;
        case "H":
          x2 = r2[1];
          break;
        case "V":
          y2 = r2[1];
          break;
        case "M":
          mx = r2[r2.length - 2];
          my = r2[r2.length - 1];
          break;
        default:
          x2 = r2[r2.length - 2];
          y2 = r2[r2.length - 1];
      }
    }
  }
  return res;
};
var l2c = function(x1, y1, x2, y2) {
  return [x1, y1, x2, y2, x2, y2];
};
var q2c = function(x1, y1, ax, ay, x2, y2) {
  var _13 = 1 / 3;
  var _23 = 2 / 3;
  return [_13 * x1 + _23 * ax, _13 * y1 + _23 * ay, _13 * x2 + _23 * ax, _13 * y2 + _23 * ay, x2, y2];
};
var a2c = function(x1, y1, rx, ry, angle2, large_arc_flag, sweep_flag, x2, y2, recursive) {
  if (rx === ry) {
    rx += 1;
  }
  var _120 = Math.PI * 120 / 180;
  var rad = Math.PI / 180 * (+angle2 || 0);
  var res = [];
  var xy;
  var f1;
  var f2;
  var cx;
  var cy;
  var rotate2 = function(x4, y4, rad2) {
    var X2 = x4 * Math.cos(rad2) - y4 * Math.sin(rad2);
    var Y2 = x4 * Math.sin(rad2) + y4 * Math.cos(rad2);
    return {
      x: X2,
      y: Y2
    };
  };
  if (!recursive) {
    xy = rotate2(x1, y1, -rad);
    x1 = xy.x;
    y1 = xy.y;
    xy = rotate2(x2, y2, -rad);
    x2 = xy.x;
    y2 = xy.y;
    if (x1 === x2 && y1 === y2) {
      x2 += 1;
      y2 += 1;
    }
    var x3 = (x1 - x2) / 2;
    var y3 = (y1 - y2) / 2;
    var h2 = x3 * x3 / (rx * rx) + y3 * y3 / (ry * ry);
    if (h2 > 1) {
      h2 = Math.sqrt(h2);
      rx = h2 * rx;
      ry = h2 * ry;
    }
    var rx2 = rx * rx;
    var ry2 = ry * ry;
    var k2 = (large_arc_flag === sweep_flag ? -1 : 1) * Math.sqrt(Math.abs((rx2 * ry2 - rx2 * y3 * y3 - ry2 * x3 * x3) / (rx2 * y3 * y3 + ry2 * x3 * x3)));
    cx = k2 * rx * y3 / ry + (x1 + x2) / 2;
    cy = k2 * -ry * x3 / rx + (y1 + y2) / 2;
    f1 = Math.asin(((y1 - cy) / ry).toFixed(9));
    f2 = Math.asin(((y2 - cy) / ry).toFixed(9));
    f1 = x1 < cx ? Math.PI - f1 : f1;
    f2 = x2 < cx ? Math.PI - f2 : f2;
    f1 < 0 && (f1 = Math.PI * 2 + f1);
    f2 < 0 && (f2 = Math.PI * 2 + f2);
    if (sweep_flag && f1 > f2) {
      f1 = f1 - Math.PI * 2;
    }
    if (!sweep_flag && f2 > f1) {
      f2 = f2 - Math.PI * 2;
    }
  } else {
    f1 = recursive[0];
    f2 = recursive[1];
    cx = recursive[2];
    cy = recursive[3];
  }
  var df2 = f2 - f1;
  if (Math.abs(df2) > _120) {
    var f2old = f2;
    var x2old = x2;
    var y2old = y2;
    f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);
    x2 = cx + rx * Math.cos(f2);
    y2 = cy + ry * Math.sin(f2);
    res = a2c(x2, y2, rx, ry, angle2, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);
  }
  df2 = f2 - f1;
  var c1 = Math.cos(f1);
  var s1 = Math.sin(f1);
  var c2 = Math.cos(f2);
  var s2 = Math.sin(f2);
  var t2 = Math.tan(df2 / 4);
  var hx = 4 / 3 * rx * t2;
  var hy = 4 / 3 * ry * t2;
  var m1 = [x1, y1];
  var m2 = [x1 + hx * s1, y1 - hy * c1];
  var m3 = [x2 + hx * s2, y2 - hy * c2];
  var m4 = [x2, y2];
  m2[0] = 2 * m1[0] - m2[0];
  m2[1] = 2 * m1[1] - m2[1];
  if (recursive) {
    return [m2, m3, m4].concat(res);
  }
  res = [m2, m3, m4].concat(res).join().split(",");
  var newres = [];
  for (var i2 = 0, ii2 = res.length; i2 < ii2; i2++) {
    newres[i2] = i2 % 2 ? rotate2(res[i2 - 1], res[i2], rad).y : rotate2(res[i2], res[i2 + 1], rad).x;
  }
  return newres;
};
var pathToCurve = function(path2, path22) {
  var p2 = pathToAbsolute$1(path2);
  var p22 = path22 && pathToAbsolute$1(path22);
  var attrs = {
    x: 0,
    y: 0,
    bx: 0,
    by: 0,
    X: 0,
    Y: 0,
    qx: null,
    qy: null
  };
  var attrs2 = {
    x: 0,
    y: 0,
    bx: 0,
    by: 0,
    X: 0,
    Y: 0,
    qx: null,
    qy: null
  };
  var pcoms1 = [];
  var pcoms2 = [];
  var pfirst = "";
  var pcom = "";
  var ii2;
  var processPath = function(path3, d2, pcom2) {
    var nx;
    var ny;
    if (!path3) {
      return ["C", d2.x, d2.y, d2.x, d2.y, d2.x, d2.y];
    }
    !(path3[0] in {
      T: 1,
      Q: 1
    }) && (d2.qx = d2.qy = null);
    switch (path3[0]) {
      case "M":
        d2.X = path3[1];
        d2.Y = path3[2];
        break;
      case "A":
        path3 = ["C"].concat(a2c.apply(0, [d2.x, d2.y].concat(path3.slice(1))));
        break;
      case "S":
        if (pcom2 === "C" || pcom2 === "S") {
          nx = d2.x * 2 - d2.bx;
          ny = d2.y * 2 - d2.by;
        } else {
          nx = d2.x;
          ny = d2.y;
        }
        path3 = ["C", nx, ny].concat(path3.slice(1));
        break;
      case "T":
        if (pcom2 === "Q" || pcom2 === "T") {
          d2.qx = d2.x * 2 - d2.qx;
          d2.qy = d2.y * 2 - d2.qy;
        } else {
          d2.qx = d2.x;
          d2.qy = d2.y;
        }
        path3 = ["C"].concat(q2c(d2.x, d2.y, d2.qx, d2.qy, path3[1], path3[2]));
        break;
      case "Q":
        d2.qx = path3[1];
        d2.qy = path3[2];
        path3 = ["C"].concat(q2c(d2.x, d2.y, path3[1], path3[2], path3[3], path3[4]));
        break;
      case "L":
        path3 = ["C"].concat(l2c(d2.x, d2.y, path3[1], path3[2]));
        break;
      case "H":
        path3 = ["C"].concat(l2c(d2.x, d2.y, path3[1], d2.y));
        break;
      case "V":
        path3 = ["C"].concat(l2c(d2.x, d2.y, d2.x, path3[1]));
        break;
      case "Z":
        path3 = ["C"].concat(l2c(d2.x, d2.y, d2.X, d2.Y));
        break;
    }
    return path3;
  };
  var fixArc = function(pp, i3) {
    if (pp[i3].length > 7) {
      pp[i3].shift();
      var pi2 = pp[i3];
      while (pi2.length) {
        pcoms1[i3] = "A";
        p22 && (pcoms2[i3] = "A");
        pp.splice(i3++, 0, ["C"].concat(pi2.splice(0, 6)));
      }
      pp.splice(i3, 1);
      ii2 = Math.max(p2.length, p22 && p22.length || 0);
    }
  };
  var fixM = function(path1, path23, a1, a2, i3) {
    if (path1 && path23 && path1[i3][0] === "M" && path23[i3][0] !== "M") {
      path23.splice(i3, 0, ["M", a2.x, a2.y]);
      a1.bx = 0;
      a1.by = 0;
      a1.x = path1[i3][1];
      a1.y = path1[i3][2];
      ii2 = Math.max(p2.length, p22 && p22.length || 0);
    }
  };
  ii2 = Math.max(p2.length, p22 && p22.length || 0);
  for (var i2 = 0; i2 < ii2; i2++) {
    p2[i2] && (pfirst = p2[i2][0]);
    if (pfirst !== "C") {
      pcoms1[i2] = pfirst;
      i2 && (pcom = pcoms1[i2 - 1]);
    }
    p2[i2] = processPath(p2[i2], attrs, pcom);
    if (pcoms1[i2] !== "A" && pfirst === "C")
      pcoms1[i2] = "C";
    fixArc(p2, i2);
    if (p22) {
      p22[i2] && (pfirst = p22[i2][0]);
      if (pfirst !== "C") {
        pcoms2[i2] = pfirst;
        i2 && (pcom = pcoms2[i2 - 1]);
      }
      p22[i2] = processPath(p22[i2], attrs2, pcom);
      if (pcoms2[i2] !== "A" && pfirst === "C") {
        pcoms2[i2] = "C";
      }
      fixArc(p22, i2);
    }
    fixM(p2, p22, attrs, attrs2, i2);
    fixM(p22, p2, attrs2, attrs, i2);
    var seg = p2[i2];
    var seg2 = p22 && p22[i2];
    var seglen = seg.length;
    var seg2len = p22 && seg2.length;
    attrs.x = seg[seglen - 2];
    attrs.y = seg[seglen - 1];
    attrs.bx = parseFloat(seg[seglen - 4]) || attrs.x;
    attrs.by = parseFloat(seg[seglen - 3]) || attrs.y;
    attrs2.bx = p22 && (parseFloat(seg2[seg2len - 4]) || attrs2.x);
    attrs2.by = p22 && (parseFloat(seg2[seg2len - 3]) || attrs2.y);
    attrs2.x = p22 && seg2[seg2len - 2];
    attrs2.y = p22 && seg2[seg2len - 1];
  }
  return p22 ? [p2, p22] : p2;
};
var p2s = /,?([a-z]),?/gi;
var parsePathArray = function(path2) {
  return path2.join(",").replace(p2s, "$1");
};
var base3 = function(t2, p1, p2, p3, p4) {
  var t1 = -3 * p1 + 9 * p2 - 9 * p3 + 3 * p4;
  var t22 = t2 * t1 + 6 * p1 - 12 * p2 + 6 * p3;
  return t2 * t22 - 3 * p1 + 3 * p2;
};
var bezlen = function(x1, y1, x2, y2, x3, y3, x4, y4, z2) {
  if (z2 === null) {
    z2 = 1;
  }
  z2 = z2 > 1 ? 1 : z2 < 0 ? 0 : z2;
  var z22 = z2 / 2;
  var n2 = 12;
  var Tvalues = [
    -0.1252,
    0.1252,
    -0.3678,
    0.3678,
    -0.5873,
    0.5873,
    -0.7699,
    0.7699,
    -0.9041,
    0.9041,
    -0.9816,
    0.9816
  ];
  var Cvalues = [0.2491, 0.2491, 0.2335, 0.2335, 0.2032, 0.2032, 0.1601, 0.1601, 0.1069, 0.1069, 0.0472, 0.0472];
  var sum = 0;
  for (var i2 = 0; i2 < n2; i2++) {
    var ct = z22 * Tvalues[i2] + z22;
    var xbase = base3(ct, x1, x2, x3, x4);
    var ybase = base3(ct, y1, y2, y3, y4);
    var comb = xbase * xbase + ybase * ybase;
    sum += Cvalues[i2] * Math.sqrt(comb);
  }
  return z22 * sum;
};
var curveDim = function(x0, y0, x1, y1, x2, y2, x3, y3) {
  var tvalues = [];
  var bounds = [[], []];
  var a2;
  var b10;
  var c2;
  var t2;
  for (var i2 = 0; i2 < 2; ++i2) {
    if (i2 === 0) {
      b10 = 6 * x0 - 12 * x1 + 6 * x2;
      a2 = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;
      c2 = 3 * x1 - 3 * x0;
    } else {
      b10 = 6 * y0 - 12 * y1 + 6 * y2;
      a2 = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;
      c2 = 3 * y1 - 3 * y0;
    }
    if (Math.abs(a2) < 1e-12) {
      if (Math.abs(b10) < 1e-12) {
        continue;
      }
      t2 = -c2 / b10;
      if (t2 > 0 && t2 < 1) {
        tvalues.push(t2);
      }
      continue;
    }
    var b2ac = b10 * b10 - 4 * c2 * a2;
    var sqrtb2ac = Math.sqrt(b2ac);
    if (b2ac < 0) {
      continue;
    }
    var t1 = (-b10 + sqrtb2ac) / (2 * a2);
    if (t1 > 0 && t1 < 1) {
      tvalues.push(t1);
    }
    var t22 = (-b10 - sqrtb2ac) / (2 * a2);
    if (t22 > 0 && t22 < 1) {
      tvalues.push(t22);
    }
  }
  var j2 = tvalues.length;
  var jlen = j2;
  var mt;
  while (j2--) {
    t2 = tvalues[j2];
    mt = 1 - t2;
    bounds[0][j2] = mt * mt * mt * x0 + 3 * mt * mt * t2 * x1 + 3 * mt * t2 * t2 * x2 + t2 * t2 * t2 * x3;
    bounds[1][j2] = mt * mt * mt * y0 + 3 * mt * mt * t2 * y1 + 3 * mt * t2 * t2 * y2 + t2 * t2 * t2 * y3;
  }
  bounds[0][jlen] = x0;
  bounds[1][jlen] = y0;
  bounds[0][jlen + 1] = x3;
  bounds[1][jlen + 1] = y3;
  bounds[0].length = bounds[1].length = jlen + 2;
  return {
    min: {
      x: Math.min.apply(0, bounds[0]),
      y: Math.min.apply(0, bounds[1])
    },
    max: {
      x: Math.max.apply(0, bounds[0]),
      y: Math.max.apply(0, bounds[1])
    }
  };
};
var intersect$1 = function(x1, y1, x2, y2, x3, y3, x4, y4) {
  if (Math.max(x1, x2) < Math.min(x3, x4) || Math.min(x1, x2) > Math.max(x3, x4) || Math.max(y1, y2) < Math.min(y3, y4) || Math.min(y1, y2) > Math.max(y3, y4)) {
    return;
  }
  var nx = (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4);
  var ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4);
  var denominator = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
  if (!denominator) {
    return;
  }
  var px = nx / denominator;
  var py = ny / denominator;
  var px2 = +px.toFixed(2);
  var py2 = +py.toFixed(2);
  if (px2 < +Math.min(x1, x2).toFixed(2) || px2 > +Math.max(x1, x2).toFixed(2) || px2 < +Math.min(x3, x4).toFixed(2) || px2 > +Math.max(x3, x4).toFixed(2) || py2 < +Math.min(y1, y2).toFixed(2) || py2 > +Math.max(y1, y2).toFixed(2) || py2 < +Math.min(y3, y4).toFixed(2) || py2 > +Math.max(y3, y4).toFixed(2)) {
    return;
  }
  return {
    x: px,
    y: py
  };
};
var isPointInsideBBox = function(bbox, x2, y2) {
  return x2 >= bbox.x && x2 <= bbox.x + bbox.width && y2 >= bbox.y && y2 <= bbox.y + bbox.height;
};
var rectPath = function(x2, y2, w2, h2, r2) {
  if (r2) {
    return [
      ["M", +x2 + +r2, y2],
      ["l", w2 - r2 * 2, 0],
      ["a", r2, r2, 0, 0, 1, r2, r2],
      ["l", 0, h2 - r2 * 2],
      ["a", r2, r2, 0, 0, 1, -r2, r2],
      ["l", r2 * 2 - w2, 0],
      ["a", r2, r2, 0, 0, 1, -r2, -r2],
      ["l", 0, r2 * 2 - h2],
      ["a", r2, r2, 0, 0, 1, r2, -r2],
      ["z"]
    ];
  }
  var res = [["M", x2, y2], ["l", w2, 0], ["l", 0, h2], ["l", -w2, 0], ["z"]];
  res.parsePathArray = parsePathArray;
  return res;
};
var box = function(x2, y2, width, height) {
  if (x2 === null) {
    x2 = y2 = width = height = 0;
  }
  if (y2 === null) {
    y2 = x2.y;
    width = x2.width;
    height = x2.height;
    x2 = x2.x;
  }
  return {
    x: x2,
    y: y2,
    width,
    w: width,
    height,
    h: height,
    x2: x2 + width,
    y2: y2 + height,
    cx: x2 + width / 2,
    cy: y2 + height / 2,
    r1: Math.min(width, height) / 2,
    r2: Math.max(width, height) / 2,
    r0: Math.sqrt(width * width + height * height) / 2,
    path: rectPath(x2, y2, width, height),
    vb: [x2, y2, width, height].join(" ")
  };
};
var isBBoxIntersect = function(bbox1, bbox2) {
  bbox1 = box(bbox1);
  bbox2 = box(bbox2);
  return isPointInsideBBox(bbox2, bbox1.x, bbox1.y) || isPointInsideBBox(bbox2, bbox1.x2, bbox1.y) || isPointInsideBBox(bbox2, bbox1.x, bbox1.y2) || isPointInsideBBox(bbox2, bbox1.x2, bbox1.y2) || isPointInsideBBox(bbox1, bbox2.x, bbox2.y) || isPointInsideBBox(bbox1, bbox2.x2, bbox2.y) || isPointInsideBBox(bbox1, bbox2.x, bbox2.y2) || isPointInsideBBox(bbox1, bbox2.x2, bbox2.y2) || (bbox1.x < bbox2.x2 && bbox1.x > bbox2.x || bbox2.x < bbox1.x2 && bbox2.x > bbox1.x) && (bbox1.y < bbox2.y2 && bbox1.y > bbox2.y || bbox2.y < bbox1.y2 && bbox2.y > bbox1.y);
};
var bezierBBox = function(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y) {
  if (!isArray$1(p1x)) {
    p1x = [p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y];
  }
  var bbox = curveDim.apply(null, p1x);
  return box(bbox.min.x, bbox.min.y, bbox.max.x - bbox.min.x, bbox.max.y - bbox.min.y);
};
var findDotsAtSegment = function(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t2) {
  var t1 = 1 - t2;
  var t13 = Math.pow(t1, 3);
  var t12 = Math.pow(t1, 2);
  var t22 = t2 * t2;
  var t3 = t22 * t2;
  var x2 = t13 * p1x + t12 * 3 * t2 * c1x + t1 * 3 * t2 * t2 * c2x + t3 * p2x;
  var y2 = t13 * p1y + t12 * 3 * t2 * c1y + t1 * 3 * t2 * t2 * c2y + t3 * p2y;
  var mx = p1x + 2 * t2 * (c1x - p1x) + t22 * (c2x - 2 * c1x + p1x);
  var my = p1y + 2 * t2 * (c1y - p1y) + t22 * (c2y - 2 * c1y + p1y);
  var nx = c1x + 2 * t2 * (c2x - c1x) + t22 * (p2x - 2 * c2x + c1x);
  var ny = c1y + 2 * t2 * (c2y - c1y) + t22 * (p2y - 2 * c2y + c1y);
  var ax = t1 * p1x + t2 * c1x;
  var ay = t1 * p1y + t2 * c1y;
  var cx = t1 * c2x + t2 * p2x;
  var cy = t1 * c2y + t2 * p2y;
  var alpha = 90 - Math.atan2(mx - nx, my - ny) * 180 / Math.PI;
  return {
    x: x2,
    y: y2,
    m: {
      x: mx,
      y: my
    },
    n: {
      x: nx,
      y: ny
    },
    start: {
      x: ax,
      y: ay
    },
    end: {
      x: cx,
      y: cy
    },
    alpha
  };
};
var interHelper = function(bez1, bez2, justCount) {
  var bbox1 = bezierBBox(bez1);
  var bbox2 = bezierBBox(bez2);
  if (!isBBoxIntersect(bbox1, bbox2)) {
    return justCount ? 0 : [];
  }
  var l1 = bezlen.apply(0, bez1);
  var l2 = bezlen.apply(0, bez2);
  var n1 = ~~(l1 / 8);
  var n2 = ~~(l2 / 8);
  var dots1 = [];
  var dots2 = [];
  var xy = {};
  var res = justCount ? 0 : [];
  for (var i2 = 0; i2 < n1 + 1; i2++) {
    var d2 = findDotsAtSegment.apply(0, bez1.concat(i2 / n1));
    dots1.push({
      x: d2.x,
      y: d2.y,
      t: i2 / n1
    });
  }
  for (var i2 = 0; i2 < n2 + 1; i2++) {
    var d2 = findDotsAtSegment.apply(0, bez2.concat(i2 / n2));
    dots2.push({
      x: d2.x,
      y: d2.y,
      t: i2 / n2
    });
  }
  for (var i2 = 0; i2 < n1; i2++) {
    for (var j2 = 0; j2 < n2; j2++) {
      var di2 = dots1[i2];
      var di1 = dots1[i2 + 1];
      var dj2 = dots2[j2];
      var dj1 = dots2[j2 + 1];
      var ci2 = Math.abs(di1.x - di2.x) < 1e-3 ? "y" : "x";
      var cj2 = Math.abs(dj1.x - dj2.x) < 1e-3 ? "y" : "x";
      var is2 = intersect$1(di2.x, di2.y, di1.x, di1.y, dj2.x, dj2.y, dj1.x, dj1.y);
      if (is2) {
        if (xy[is2.x.toFixed(4)] === is2.y.toFixed(4)) {
          continue;
        }
        xy[is2.x.toFixed(4)] = is2.y.toFixed(4);
        var t1 = di2.t + Math.abs((is2[ci2] - di2[ci2]) / (di1[ci2] - di2[ci2])) * (di1.t - di2.t);
        var t2 = dj2.t + Math.abs((is2[cj2] - dj2[cj2]) / (dj1[cj2] - dj2[cj2])) * (dj1.t - dj2.t);
        if (t1 >= 0 && t1 <= 1 && t2 >= 0 && t2 <= 1) {
          if (justCount) {
            res += 1;
          } else {
            res.push({
              x: is2.x,
              y: is2.y,
              t1,
              t2
            });
          }
        }
      }
    }
  }
  return res;
};
var interPathHelper = function(path1, path2, justCount) {
  path1 = pathToCurve(path1);
  path2 = pathToCurve(path2);
  var x1;
  var y1;
  var x2;
  var y2;
  var x1m;
  var y1m;
  var x2m;
  var y2m;
  var bez1;
  var bez2;
  var res = justCount ? 0 : [];
  for (var i2 = 0, ii2 = path1.length; i2 < ii2; i2++) {
    var pi2 = path1[i2];
    if (pi2[0] === "M") {
      x1 = x1m = pi2[1];
      y1 = y1m = pi2[2];
    } else {
      if (pi2[0] === "C") {
        bez1 = [x1, y1].concat(pi2.slice(1));
        x1 = bez1[6];
        y1 = bez1[7];
      } else {
        bez1 = [x1, y1, x1, y1, x1m, y1m, x1m, y1m];
        x1 = x1m;
        y1 = y1m;
      }
      for (var j2 = 0, jj2 = path2.length; j2 < jj2; j2++) {
        var pj2 = path2[j2];
        if (pj2[0] === "M") {
          x2 = x2m = pj2[1];
          y2 = y2m = pj2[2];
        } else {
          if (pj2[0] === "C") {
            bez2 = [x2, y2].concat(pj2.slice(1));
            x2 = bez2[6];
            y2 = bez2[7];
          } else {
            bez2 = [x2, y2, x2, y2, x2m, y2m, x2m, y2m];
            x2 = x2m;
            y2 = y2m;
          }
          var intr = interHelper(bez1, bez2, justCount);
          if (justCount) {
            res += intr;
          } else {
            for (var k2 = 0, kk2 = intr.length; k2 < kk2; k2++) {
              intr[k2].segment1 = i2;
              intr[k2].segment2 = j2;
              intr[k2].bez1 = bez1;
              intr[k2].bez2 = bez2;
            }
            res = res.concat(intr);
          }
        }
      }
    }
  }
  return res;
};
var intersection = function(path1, path2) {
  return interPathHelper(path1, path2);
};
function decasteljau(points2, t2) {
  var left2 = [];
  var right2 = [];
  function recurse(points3, t3) {
    if (points3.length === 1) {
      left2.push(points3[0]);
      right2.push(points3[0]);
    } else {
      var middlePoints = [];
      for (var i2 = 0; i2 < points3.length - 1; i2++) {
        if (i2 === 0) {
          left2.push(points3[0]);
        }
        if (i2 === points3.length - 2) {
          right2.push(points3[i2 + 1]);
        }
        middlePoints[i2] = [
          (1 - t3) * points3[i2][0] + t3 * points3[i2 + 1][0],
          (1 - t3) * points3[i2][1] + t3 * points3[i2 + 1][1]
        ];
      }
      recurse(middlePoints, t3);
    }
  }
  if (points2.length) {
    recurse(points2, t2);
  }
  return { left: left2, right: right2.reverse() };
}
function splitCurve(start, end, count2) {
  var points2 = [[start[1], start[2]]];
  count2 = count2 || 2;
  var segments = [];
  if (end[0] === "A") {
    points2.push(end[6]);
    points2.push(end[7]);
  } else if (end[0] === "C") {
    points2.push([end[1], end[2]]);
    points2.push([end[3], end[4]]);
    points2.push([end[5], end[6]]);
  } else if (end[0] === "S" || end[0] === "Q") {
    points2.push([end[1], end[2]]);
    points2.push([end[3], end[4]]);
  } else {
    points2.push([end[1], end[2]]);
  }
  var leftSegments = points2;
  var t2 = 1 / count2;
  for (var i2 = 0; i2 < count2 - 1; i2++) {
    var rt = t2 / (1 - t2 * i2);
    var split = decasteljau(leftSegments, rt);
    segments.push(split.left);
    leftSegments = split.right;
  }
  segments.push(leftSegments);
  var result = segments.map(function(segment) {
    var cmd = [];
    if (segment.length === 4) {
      cmd.push("C");
      cmd = cmd.concat(segment[2]);
    }
    if (segment.length >= 3) {
      if (segment.length === 3) {
        cmd.push("Q");
      }
      cmd = cmd.concat(segment[1]);
    }
    if (segment.length === 2) {
      cmd.push("L");
    }
    cmd = cmd.concat(segment[segment.length - 1]);
    return cmd;
  });
  return result;
}
var splitSegment = function(start, end, count2) {
  if (count2 === 1) {
    return [[].concat(start)];
  }
  var segments = [];
  if (end[0] === "L" || end[0] === "C" || end[0] === "Q") {
    segments = segments.concat(splitCurve(start, end, count2));
  } else {
    var temp = [].concat(start);
    if (temp[0] === "M") {
      temp[0] = "L";
    }
    for (var i2 = 0; i2 <= count2 - 1; i2++) {
      segments.push(temp);
    }
  }
  return segments;
};
var fillPath = function(source, target) {
  if (source.length === 1) {
    return source;
  }
  var sourceLen = source.length - 1;
  var targetLen = target.length - 1;
  var ratio = sourceLen / targetLen;
  var segmentsToFill = [];
  if (source.length === 1 && source[0][0] === "M") {
    for (var i2 = 0; i2 < targetLen - sourceLen; i2++) {
      source.push(source[0]);
    }
    return source;
  }
  for (var i2 = 0; i2 < targetLen; i2++) {
    var index2 = Math.floor(ratio * i2);
    segmentsToFill[index2] = (segmentsToFill[index2] || 0) + 1;
  }
  var filled = segmentsToFill.reduce(function(filled2, count2, i3) {
    if (i3 === sourceLen) {
      return filled2.concat(source[sourceLen]);
    }
    return filled2.concat(splitSegment(source[i3], source[i3 + 1], count2));
  }, []);
  filled.unshift(source[0]);
  if (target[targetLen] === "Z" || target[targetLen] === "z") {
    filled.push("Z");
  }
  return filled;
};
var isEqual = function(obj1, obj2) {
  if (obj1.length !== obj2.length) {
    return false;
  }
  var result = true;
  each$1(obj1, function(item, i2) {
    if (item !== obj2[i2]) {
      result = false;
      return false;
    }
  });
  return result;
};
function getMinDiff(del, add2, modify) {
  var type4 = null;
  var min2 = modify;
  if (add2 < min2) {
    min2 = add2;
    type4 = "add";
  }
  if (del < min2) {
    min2 = del;
    type4 = "del";
  }
  return {
    type: type4,
    min: min2
  };
}
var levenshteinDistance = function(source, target) {
  var sourceLen = source.length;
  var targetLen = target.length;
  var sourceSegment;
  var targetSegment;
  var temp = 0;
  if (sourceLen === 0 || targetLen === 0) {
    return null;
  }
  var dist = [];
  for (var i2 = 0; i2 <= sourceLen; i2++) {
    dist[i2] = [];
    dist[i2][0] = { min: i2 };
  }
  for (var j2 = 0; j2 <= targetLen; j2++) {
    dist[0][j2] = { min: j2 };
  }
  for (var i2 = 1; i2 <= sourceLen; i2++) {
    sourceSegment = source[i2 - 1];
    for (var j2 = 1; j2 <= targetLen; j2++) {
      targetSegment = target[j2 - 1];
      if (isEqual(sourceSegment, targetSegment)) {
        temp = 0;
      } else {
        temp = 1;
      }
      var del = dist[i2 - 1][j2].min + 1;
      var add2 = dist[i2][j2 - 1].min + 1;
      var modify = dist[i2 - 1][j2 - 1].min + temp;
      dist[i2][j2] = getMinDiff(del, add2, modify);
    }
  }
  return dist;
};
var fillPathByDiff = function(source, target) {
  var diffMatrix = levenshteinDistance(source, target);
  var sourceLen = source.length;
  var targetLen = target.length;
  var changes = [];
  var index2 = 1;
  var minPos = 1;
  if (diffMatrix[sourceLen][targetLen].min !== sourceLen) {
    for (var i2 = 1; i2 <= sourceLen; i2++) {
      var min2 = diffMatrix[i2][i2].min;
      minPos = i2;
      for (var j2 = index2; j2 <= targetLen; j2++) {
        if (diffMatrix[i2][j2].min < min2) {
          min2 = diffMatrix[i2][j2].min;
          minPos = j2;
        }
      }
      index2 = minPos;
      if (diffMatrix[i2][index2].type) {
        changes.push({ index: i2 - 1, type: diffMatrix[i2][index2].type });
      }
    }
    for (var i2 = changes.length - 1; i2 >= 0; i2--) {
      index2 = changes[i2].index;
      if (changes[i2].type === "add") {
        source.splice(index2, 0, [].concat(source[index2]));
      } else {
        source.splice(index2, 1);
      }
    }
  }
  sourceLen = source.length;
  var diff2 = targetLen - sourceLen;
  if (sourceLen < targetLen) {
    for (var i2 = 0; i2 < diff2; i2++) {
      if (source[sourceLen - 1][0] === "z" || source[sourceLen - 1][0] === "Z") {
        source.splice(sourceLen - 2, 0, source[sourceLen - 2]);
      } else {
        source.push(source[sourceLen - 1]);
      }
      sourceLen += 1;
    }
  }
  return source;
};
function _splitPoints(points2, former, count2) {
  var result = [].concat(points2);
  var index2;
  var t2 = 1 / (count2 + 1);
  var formerEnd = _getSegmentPoints(former)[0];
  for (var i2 = 1; i2 <= count2; i2++) {
    t2 *= i2;
    index2 = Math.floor(points2.length * t2);
    if (index2 === 0) {
      result.unshift([formerEnd[0] * t2 + points2[index2][0] * (1 - t2), formerEnd[1] * t2 + points2[index2][1] * (1 - t2)]);
    } else {
      result.splice(index2, 0, [
        formerEnd[0] * t2 + points2[index2][0] * (1 - t2),
        formerEnd[1] * t2 + points2[index2][1] * (1 - t2)
      ]);
    }
  }
  return result;
}
function _getSegmentPoints(segment) {
  var points2 = [];
  switch (segment[0]) {
    case "M":
      points2.push([segment[1], segment[2]]);
      break;
    case "L":
      points2.push([segment[1], segment[2]]);
      break;
    case "A":
      points2.push([segment[6], segment[7]]);
      break;
    case "Q":
      points2.push([segment[3], segment[4]]);
      points2.push([segment[1], segment[2]]);
      break;
    case "T":
      points2.push([segment[1], segment[2]]);
      break;
    case "C":
      points2.push([segment[5], segment[6]]);
      points2.push([segment[1], segment[2]]);
      points2.push([segment[3], segment[4]]);
      break;
    case "S":
      points2.push([segment[3], segment[4]]);
      points2.push([segment[1], segment[2]]);
      break;
    case "H":
      points2.push([segment[1], segment[1]]);
      break;
    case "V":
      points2.push([segment[1], segment[1]]);
      break;
  }
  return points2;
}
var formatPath = function(fromPath, toPath) {
  if (fromPath.length <= 1) {
    return fromPath;
  }
  var points2;
  for (var i2 = 0; i2 < toPath.length; i2++) {
    if (fromPath[i2][0] !== toPath[i2][0]) {
      points2 = _getSegmentPoints(fromPath[i2]);
      switch (toPath[i2][0]) {
        case "M":
          fromPath[i2] = ["M"].concat(points2[0]);
          break;
        case "L":
          fromPath[i2] = ["L"].concat(points2[0]);
          break;
        case "A":
          fromPath[i2] = [].concat(toPath[i2]);
          fromPath[i2][6] = points2[0][0];
          fromPath[i2][7] = points2[0][1];
          break;
        case "Q":
          if (points2.length < 2) {
            if (i2 > 0) {
              points2 = _splitPoints(points2, fromPath[i2 - 1], 1);
            } else {
              fromPath[i2] = toPath[i2];
              break;
            }
          }
          fromPath[i2] = ["Q"].concat(points2.reduce(function(arr, i3) {
            return arr.concat(i3);
          }, []));
          break;
        case "T":
          fromPath[i2] = ["T"].concat(points2[0]);
          break;
        case "C":
          if (points2.length < 3) {
            if (i2 > 0) {
              points2 = _splitPoints(points2, fromPath[i2 - 1], 2);
            } else {
              fromPath[i2] = toPath[i2];
              break;
            }
          }
          fromPath[i2] = ["C"].concat(points2.reduce(function(arr, i3) {
            return arr.concat(i3);
          }, []));
          break;
        case "S":
          if (points2.length < 2) {
            if (i2 > 0) {
              points2 = _splitPoints(points2, fromPath[i2 - 1], 1);
            } else {
              fromPath[i2] = toPath[i2];
              break;
            }
          }
          fromPath[i2] = ["S"].concat(points2.reduce(function(arr, i3) {
            return arr.concat(i3);
          }, []));
          break;
        default:
          fromPath[i2] = toPath[i2];
      }
    }
  }
  return fromPath;
};
var PathUtil$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  catmullRomToBezier,
  fillPath,
  fillPathByDiff,
  formatPath,
  intersection,
  parsePathArray,
  parsePathString: parsePathString$1,
  pathToAbsolute: pathToAbsolute$1,
  pathToCurve,
  rectPath
}, Symbol.toStringTag, { value: "Module" }));
var GraphEvent = function() {
  function GraphEvent2(type4, event) {
    this.bubbles = true;
    this.target = null;
    this.currentTarget = null;
    this.delegateTarget = null;
    this.delegateObject = null;
    this.defaultPrevented = false;
    this.propagationStopped = false;
    this.shape = null;
    this.fromShape = null;
    this.toShape = null;
    this.propagationPath = [];
    this.type = type4;
    this.name = type4;
    this.originalEvent = event;
    this.timeStamp = event.timeStamp;
  }
  GraphEvent2.prototype.preventDefault = function() {
    this.defaultPrevented = true;
    if (this.originalEvent.preventDefault) {
      this.originalEvent.preventDefault();
    }
  };
  GraphEvent2.prototype.stopPropagation = function() {
    this.propagationStopped = true;
  };
  GraphEvent2.prototype.toString = function() {
    var type4 = this.type;
    return "[Event (type=" + type4 + ")]";
  };
  GraphEvent2.prototype.save = function() {
  };
  GraphEvent2.prototype.restore = function() {
  };
  return GraphEvent2;
}();
function removeFromArray(arr, obj) {
  var index2 = arr.indexOf(obj);
  if (index2 !== -1) {
    arr.splice(index2, 1);
  }
}
var isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined";
function isParent(container, shape) {
  if (container.isCanvas()) {
    return true;
  }
  var parent = shape.getParent();
  var isParent2 = false;
  while (parent) {
    if (parent === container) {
      isParent2 = true;
      break;
    }
    parent = parent.getParent();
  }
  return isParent2;
}
function isAllowCapture(element) {
  return element.cfg.visible && element.cfg.capture;
}
var Base = function(_super) {
  __extends$3(Base2, _super);
  function Base2(cfg) {
    var _this = _super.call(this) || this;
    _this.destroyed = false;
    var defaultCfg = _this.getDefaultCfg();
    _this.cfg = mix(defaultCfg, cfg);
    return _this;
  }
  Base2.prototype.getDefaultCfg = function() {
    return {};
  };
  Base2.prototype.get = function(name) {
    return this.cfg[name];
  };
  Base2.prototype.set = function(name, value2) {
    this.cfg[name] = value2;
  };
  Base2.prototype.destroy = function() {
    this.cfg = {
      destroyed: true
    };
    this.off();
    this.destroyed = true;
  };
  return Base2;
}(EventEmitter);
var __spreadArray = globalThis && globalThis.__spreadArray || function(to, from, pack2) {
  if (pack2 || arguments.length === 2)
    for (var i2 = 0, l2 = from.length, ar; i2 < l2; i2++) {
      if (ar || !(i2 in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i2);
        ar[i2] = from[i2];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var BrowserInfo = function() {
  function BrowserInfo2(name, version2, os) {
    this.name = name;
    this.version = version2;
    this.os = os;
    this.type = "browser";
  }
  return BrowserInfo2;
}();
var NodeInfo = function() {
  function NodeInfo2(version2) {
    this.version = version2;
    this.type = "node";
    this.name = "node";
    this.os = process.platform;
  }
  return NodeInfo2;
}();
var SearchBotDeviceInfo = function() {
  function SearchBotDeviceInfo2(name, version2, os, bot) {
    this.name = name;
    this.version = version2;
    this.os = os;
    this.bot = bot;
    this.type = "bot-device";
  }
  return SearchBotDeviceInfo2;
}();
var BotInfo = function() {
  function BotInfo2() {
    this.type = "bot";
    this.bot = true;
    this.name = "bot";
    this.version = null;
    this.os = null;
  }
  return BotInfo2;
}();
var ReactNativeInfo = function() {
  function ReactNativeInfo2() {
    this.type = "react-native";
    this.name = "react-native";
    this.version = null;
    this.os = null;
  }
  return ReactNativeInfo2;
}();
var SEARCHBOX_UA_REGEX = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/;
var SEARCHBOT_OS_REGEX = /(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/;
var REQUIRED_VERSION_PARTS = 3;
var userAgentRules = [
  ["aol", /AOLShield\/([0-9\._]+)/],
  ["edge", /Edge\/([0-9\._]+)/],
  ["edge-ios", /EdgiOS\/([0-9\._]+)/],
  ["yandexbrowser", /YaBrowser\/([0-9\._]+)/],
  ["kakaotalk", /KAKAOTALK\s([0-9\.]+)/],
  ["samsung", /SamsungBrowser\/([0-9\.]+)/],
  ["silk", /\bSilk\/([0-9._-]+)\b/],
  ["miui", /MiuiBrowser\/([0-9\.]+)$/],
  ["beaker", /BeakerBrowser\/([0-9\.]+)/],
  ["edge-chromium", /EdgA?\/([0-9\.]+)/],
  [
    "chromium-webview",
    /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/
  ],
  ["chrome", /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
  ["phantomjs", /PhantomJS\/([0-9\.]+)(:?\s|$)/],
  ["crios", /CriOS\/([0-9\.]+)(:?\s|$)/],
  ["firefox", /Firefox\/([0-9\.]+)(?:\s|$)/],
  ["fxios", /FxiOS\/([0-9\.]+)/],
  ["opera-mini", /Opera Mini.*Version\/([0-9\.]+)/],
  ["opera", /Opera\/([0-9\.]+)(?:\s|$)/],
  ["opera", /OPR\/([0-9\.]+)(:?\s|$)/],
  ["pie", /^Microsoft Pocket Internet Explorer\/(\d+\.\d+)$/],
  ["pie", /^Mozilla\/\d\.\d+\s\(compatible;\s(?:MSP?IE|MSInternet Explorer) (\d+\.\d+);.*Windows CE.*\)$/],
  ["netfront", /^Mozilla\/\d\.\d+.*NetFront\/(\d.\d)/],
  ["ie", /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],
  ["ie", /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],
  ["ie", /MSIE\s(7\.0)/],
  ["bb10", /BB10;\sTouch.*Version\/([0-9\.]+)/],
  ["android", /Android\s([0-9\.]+)/],
  ["ios", /Version\/([0-9\._]+).*Mobile.*Safari.*/],
  ["safari", /Version\/([0-9\._]+).*Safari/],
  ["facebook", /FB[AS]V\/([0-9\.]+)/],
  ["instagram", /Instagram\s([0-9\.]+)/],
  ["ios-webview", /AppleWebKit\/([0-9\.]+).*Mobile/],
  ["ios-webview", /AppleWebKit\/([0-9\.]+).*Gecko\)$/],
  ["curl", /^curl\/([0-9\.]+)$/],
  ["searchbot", SEARCHBOX_UA_REGEX]
];
var operatingSystemRules = [
  ["iOS", /iP(hone|od|ad)/],
  ["Android OS", /Android/],
  ["BlackBerry OS", /BlackBerry|BB10/],
  ["Windows Mobile", /IEMobile/],
  ["Amazon OS", /Kindle/],
  ["Windows 3.11", /Win16/],
  ["Windows 95", /(Windows 95)|(Win95)|(Windows_95)/],
  ["Windows 98", /(Windows 98)|(Win98)/],
  ["Windows 2000", /(Windows NT 5.0)|(Windows 2000)/],
  ["Windows XP", /(Windows NT 5.1)|(Windows XP)/],
  ["Windows Server 2003", /(Windows NT 5.2)/],
  ["Windows Vista", /(Windows NT 6.0)/],
  ["Windows 7", /(Windows NT 6.1)/],
  ["Windows 8", /(Windows NT 6.2)/],
  ["Windows 8.1", /(Windows NT 6.3)/],
  ["Windows 10", /(Windows NT 10.0)/],
  ["Windows ME", /Windows ME/],
  ["Windows CE", /Windows CE|WinCE|Microsoft Pocket Internet Explorer/],
  ["Open BSD", /OpenBSD/],
  ["Sun OS", /SunOS/],
  ["Chrome OS", /CrOS/],
  ["Linux", /(Linux)|(X11)/],
  ["Mac OS", /(Mac_PowerPC)|(Macintosh)/],
  ["QNX", /QNX/],
  ["BeOS", /BeOS/],
  ["OS/2", /OS\/2/]
];
function detect(userAgent) {
  if (!!userAgent) {
    return parseUserAgent(userAgent);
  }
  if (typeof document === "undefined" && typeof navigator !== "undefined" && navigator.product === "ReactNative") {
    return new ReactNativeInfo();
  }
  if (typeof navigator !== "undefined") {
    return parseUserAgent(navigator.userAgent);
  }
  return getNodeVersion();
}
function matchUserAgent(ua2) {
  return ua2 !== "" && userAgentRules.reduce(function(matched, _a2) {
    var browser2 = _a2[0], regex = _a2[1];
    if (matched) {
      return matched;
    }
    var uaMatch = regex.exec(ua2);
    return !!uaMatch && [browser2, uaMatch];
  }, false);
}
function parseUserAgent(ua2) {
  var matchedRule = matchUserAgent(ua2);
  if (!matchedRule) {
    return null;
  }
  var name = matchedRule[0], match2 = matchedRule[1];
  if (name === "searchbot") {
    return new BotInfo();
  }
  var versionParts = match2[1] && match2[1].split(".").join("_").split("_").slice(0, 3);
  if (versionParts) {
    if (versionParts.length < REQUIRED_VERSION_PARTS) {
      versionParts = __spreadArray(__spreadArray([], versionParts, true), createVersionParts(REQUIRED_VERSION_PARTS - versionParts.length), true);
    }
  } else {
    versionParts = [];
  }
  var version2 = versionParts.join(".");
  var os = detectOS(ua2);
  var searchBotMatch = SEARCHBOT_OS_REGEX.exec(ua2);
  if (searchBotMatch && searchBotMatch[1]) {
    return new SearchBotDeviceInfo(name, version2, os, searchBotMatch[1]);
  }
  return new BrowserInfo(name, version2, os);
}
function detectOS(ua2) {
  for (var ii2 = 0, count2 = operatingSystemRules.length; ii2 < count2; ii2++) {
    var _a2 = operatingSystemRules[ii2], os = _a2[0], regex = _a2[1];
    var match2 = regex.exec(ua2);
    if (match2) {
      return os;
    }
  }
  return null;
}
function getNodeVersion() {
  var isNode = typeof process !== "undefined" && process.version;
  return isNode ? new NodeInfo(process.version.slice(1)) : null;
}
function createVersionParts(count2) {
  var output2 = [];
  for (var ii2 = 0; ii2 < count2; ii2++) {
    output2.push("0");
  }
  return output2;
}
var ARRAY_TYPE = typeof Float32Array !== "undefined" ? Float32Array : Array;
if (!Math.hypot)
  Math.hypot = function() {
    var y2 = 0, i2 = arguments.length;
    while (i2--) {
      y2 += arguments[i2] * arguments[i2];
    }
    return Math.sqrt(y2);
  };
function invert$1(out, a2) {
  var a00 = a2[0], a01 = a2[1], a02 = a2[2];
  var a10 = a2[3], a11 = a2[4], a12 = a2[5];
  var a20 = a2[6], a21 = a2[7], a22 = a2[8];
  var b01 = a22 * a11 - a12 * a21;
  var b11 = -a22 * a10 + a12 * a20;
  var b21 = a21 * a10 - a11 * a20;
  var det = a00 * b01 + a01 * b11 + a02 * b21;
  if (!det) {
    return null;
  }
  det = 1 / det;
  out[0] = b01 * det;
  out[1] = (-a22 * a01 + a02 * a21) * det;
  out[2] = (a12 * a01 - a02 * a11) * det;
  out[3] = b11 * det;
  out[4] = (a22 * a00 - a02 * a20) * det;
  out[5] = (-a12 * a00 + a02 * a10) * det;
  out[6] = b21 * det;
  out[7] = (-a21 * a00 + a01 * a20) * det;
  out[8] = (a11 * a00 - a01 * a10) * det;
  return out;
}
function multiply(out, a2, b10) {
  var a00 = a2[0], a01 = a2[1], a02 = a2[2];
  var a10 = a2[3], a11 = a2[4], a12 = a2[5];
  var a20 = a2[6], a21 = a2[7], a22 = a2[8];
  var b00 = b10[0], b01 = b10[1], b02 = b10[2];
  var b102 = b10[3], b11 = b10[4], b12 = b10[5];
  var b20 = b10[6], b21 = b10[7], b22 = b10[8];
  out[0] = b00 * a00 + b01 * a10 + b02 * a20;
  out[1] = b00 * a01 + b01 * a11 + b02 * a21;
  out[2] = b00 * a02 + b01 * a12 + b02 * a22;
  out[3] = b102 * a00 + b11 * a10 + b12 * a20;
  out[4] = b102 * a01 + b11 * a11 + b12 * a21;
  out[5] = b102 * a02 + b11 * a12 + b12 * a22;
  out[6] = b20 * a00 + b21 * a10 + b22 * a20;
  out[7] = b20 * a01 + b21 * a11 + b22 * a21;
  out[8] = b20 * a02 + b21 * a12 + b22 * a22;
  return out;
}
function fromTranslation(out, v2) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = v2[0];
  out[7] = v2[1];
  out[8] = 1;
  return out;
}
function fromRotation(out, rad) {
  var s2 = Math.sin(rad), c2 = Math.cos(rad);
  out[0] = c2;
  out[1] = s2;
  out[2] = 0;
  out[3] = -s2;
  out[4] = c2;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
function fromScaling(out, v2) {
  out[0] = v2[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = v2[1];
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
function create$1() {
  var out = new ARRAY_TYPE(3);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }
  return out;
}
function transformMat3$1(out, a2, m2) {
  var x2 = a2[0], y2 = a2[1], z2 = a2[2];
  out[0] = x2 * m2[0] + y2 * m2[3] + z2 * m2[6];
  out[1] = x2 * m2[1] + y2 * m2[4] + z2 * m2[7];
  out[2] = x2 * m2[2] + y2 * m2[5] + z2 * m2[8];
  return out;
}
(function() {
  var vec = create$1();
  return function(a2, stride, offset3, count2, fn2, arg) {
    var i2, l2;
    if (!stride) {
      stride = 3;
    }
    if (!offset3) {
      offset3 = 0;
    }
    if (count2) {
      l2 = Math.min(count2 * stride + offset3, a2.length);
    } else {
      l2 = a2.length;
    }
    for (i2 = offset3; i2 < l2; i2 += stride) {
      vec[0] = a2[i2];
      vec[1] = a2[i2 + 1];
      vec[2] = a2[i2 + 2];
      fn2(vec, vec, arg);
      a2[i2] = vec[0];
      a2[i2 + 1] = vec[1];
      a2[i2 + 2] = vec[2];
    }
    return a2;
  };
})();
function create() {
  var out = new ARRAY_TYPE(2);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
  }
  return out;
}
function add(out, a2, b10) {
  out[0] = a2[0] + b10[0];
  out[1] = a2[1] + b10[1];
  return out;
}
function subtract(out, a2, b10) {
  out[0] = a2[0] - b10[0];
  out[1] = a2[1] - b10[1];
  return out;
}
function min$1(out, a2, b10) {
  out[0] = Math.min(a2[0], b10[0]);
  out[1] = Math.min(a2[1], b10[1]);
  return out;
}
function max$1(out, a2, b10) {
  out[0] = Math.max(a2[0], b10[0]);
  out[1] = Math.max(a2[1], b10[1]);
  return out;
}
function scale$3(out, a2, b10) {
  out[0] = a2[0] * b10;
  out[1] = a2[1] * b10;
  return out;
}
function distance$6(a2, b10) {
  var x2 = b10[0] - a2[0], y2 = b10[1] - a2[1];
  return Math.hypot(x2, y2);
}
function length(a2) {
  var x2 = a2[0], y2 = a2[1];
  return Math.hypot(x2, y2);
}
function normalize(out, a2) {
  var x2 = a2[0], y2 = a2[1];
  var len = x2 * x2 + y2 * y2;
  if (len > 0) {
    len = 1 / Math.sqrt(len);
  }
  out[0] = a2[0] * len;
  out[1] = a2[1] * len;
  return out;
}
function dot$2(a2, b10) {
  return a2[0] * b10[0] + a2[1] * b10[1];
}
function transformMat3(out, a2, m2) {
  var x2 = a2[0], y2 = a2[1];
  out[0] = m2[0] * x2 + m2[3] * y2 + m2[6];
  out[1] = m2[1] * x2 + m2[4] * y2 + m2[7];
  return out;
}
function angle$1(a2, b10) {
  var x1 = a2[0], y1 = a2[1], x2 = b10[0], y2 = b10[1], mag = Math.sqrt(x1 * x1 + y1 * y1) * Math.sqrt(x2 * x2 + y2 * y2), cosine = mag && (x1 * x2 + y1 * y2) / mag;
  return Math.acos(Math.min(Math.max(cosine, -1), 1));
}
function exactEquals(a2, b10) {
  return a2[0] === b10[0] && a2[1] === b10[1];
}
var sub = subtract;
(function() {
  var vec = create();
  return function(a2, stride, offset3, count2, fn2, arg) {
    var i2, l2;
    if (!stride) {
      stride = 2;
    }
    if (!offset3) {
      offset3 = 0;
    }
    if (count2) {
      l2 = Math.min(count2 * stride + offset3, a2.length);
    } else {
      l2 = a2.length;
    }
    for (i2 = offset3; i2 < l2; i2 += stride) {
      vec[0] = a2[i2];
      vec[1] = a2[i2 + 1];
      fn2(vec, vec, arg);
      a2[i2] = vec[0];
      a2[i2 + 1] = vec[1];
    }
    return a2;
  };
})();
function leftTranslate(out, a2, v2) {
  var transMat = [0, 0, 0, 0, 0, 0, 0, 0, 0];
  fromTranslation(transMat, v2);
  return multiply(out, transMat, a2);
}
function leftRotate(out, a2, rad) {
  var rotateMat = [0, 0, 0, 0, 0, 0, 0, 0, 0];
  fromRotation(rotateMat, rad);
  return multiply(out, rotateMat, a2);
}
function leftScale(out, a2, v2) {
  var scaleMat = [0, 0, 0, 0, 0, 0, 0, 0, 0];
  fromScaling(scaleMat, v2);
  return multiply(out, scaleMat, a2);
}
function leftMultiply(out, a2, a1) {
  return multiply(out, a1, a2);
}
function transform$6(m2, actions) {
  var matrix = m2 ? [].concat(m2) : [1, 0, 0, 0, 1, 0, 0, 0, 1];
  for (var i2 = 0, len = actions.length; i2 < len; i2++) {
    var action = actions[i2];
    switch (action[0]) {
      case "t":
        leftTranslate(matrix, matrix, [action[1], action[2]]);
        break;
      case "s":
        leftScale(matrix, matrix, [action[1], action[2]]);
        break;
      case "r":
        leftRotate(matrix, matrix, action[1]);
        break;
      case "m":
        leftMultiply(matrix, matrix, action[1]);
        break;
    }
  }
  return matrix;
}
function direction(v1, v2) {
  return v1[0] * v2[1] - v2[0] * v1[1];
}
function angleTo(v1, v2, direct) {
  var ang = angle$1(v1, v2);
  var angleLargeThanPI = direction(v1, v2) >= 0;
  if (direct) {
    if (angleLargeThanPI) {
      return Math.PI * 2 - ang;
    }
    return ang;
  }
  if (angleLargeThanPI) {
    return ang;
  }
  return Math.PI * 2 - ang;
}
function multiplyMatrix(a2, b10) {
  var out = [];
  var a00 = a2[0];
  var a01 = a2[1];
  var a02 = a2[2];
  var a10 = a2[3];
  var a11 = a2[4];
  var a12 = a2[5];
  var a20 = a2[6];
  var a21 = a2[7];
  var a22 = a2[8];
  var b00 = b10[0];
  var b01 = b10[1];
  var b02 = b10[2];
  var b102 = b10[3];
  var b11 = b10[4];
  var b12 = b10[5];
  var b20 = b10[6];
  var b21 = b10[7];
  var b22 = b10[8];
  out[0] = b00 * a00 + b01 * a10 + b02 * a20;
  out[1] = b00 * a01 + b01 * a11 + b02 * a21;
  out[2] = b00 * a02 + b01 * a12 + b02 * a22;
  out[3] = b102 * a00 + b11 * a10 + b12 * a20;
  out[4] = b102 * a01 + b11 * a11 + b12 * a21;
  out[5] = b102 * a02 + b11 * a12 + b12 * a22;
  out[6] = b20 * a00 + b21 * a10 + b22 * a20;
  out[7] = b20 * a01 + b21 * a11 + b22 * a21;
  out[8] = b20 * a02 + b21 * a12 + b22 * a22;
  return out;
}
function multiplyVec2$1(m2, v2) {
  var out = [];
  var x2 = v2[0];
  var y2 = v2[1];
  out[0] = m2[0] * x2 + m2[3] * y2 + m2[6];
  out[1] = m2[1] * x2 + m2[4] * y2 + m2[7];
  return out;
}
function invert(a2) {
  var out = [];
  var a00 = a2[0];
  var a01 = a2[1];
  var a02 = a2[2];
  var a10 = a2[3];
  var a11 = a2[4];
  var a12 = a2[5];
  var a20 = a2[6];
  var a21 = a2[7];
  var a22 = a2[8];
  var b01 = a22 * a11 - a12 * a21;
  var b11 = -a22 * a10 + a12 * a20;
  var b21 = a21 * a10 - a11 * a20;
  var det = a00 * b01 + a01 * b11 + a02 * b21;
  if (!det) {
    return null;
  }
  det = 1 / det;
  out[0] = b01 * det;
  out[1] = (-a22 * a01 + a02 * a21) * det;
  out[2] = (a12 * a01 - a02 * a11) * det;
  out[3] = b11 * det;
  out[4] = (a22 * a00 - a02 * a20) * det;
  out[5] = (-a12 * a00 + a02 * a10) * det;
  out[6] = b21 * det;
  out[7] = (-a21 * a00 + a01 * a20) * det;
  out[8] = (a11 * a00 - a01 * a10) * det;
  return out;
}
var transform$5 = transform$6;
var MATRIX = "matrix";
var CLONE_CFGS = ["zIndex", "capture", "visible", "type"];
var RESERVED_PORPS = ["repeat"];
var DELEGATION_SPLIT = ":";
var WILDCARD = "*";
function _cloneArrayAttr(arr) {
  var result = [];
  for (var i2 = 0; i2 < arr.length; i2++) {
    if (isArray$1(arr[i2])) {
      result.push([].concat(arr[i2]));
    } else {
      result.push(arr[i2]);
    }
  }
  return result;
}
function getFormatFromAttrs(toAttrs, shape) {
  var fromAttrs = {};
  var attrs = shape.attrs;
  for (var k2 in toAttrs) {
    fromAttrs[k2] = attrs[k2];
  }
  return fromAttrs;
}
function getFormatToAttrs(props, shape) {
  var toAttrs = {};
  var attrs = shape.attr();
  each$1(props, function(v2, k2) {
    if (RESERVED_PORPS.indexOf(k2) === -1 && !isEqual$1(attrs[k2], v2)) {
      toAttrs[k2] = v2;
    }
  });
  return toAttrs;
}
function checkExistedAttrs(animations, animation2) {
  if (animation2.onFrame) {
    return animations;
  }
  var startTime = animation2.startTime, delay = animation2.delay, duration = animation2.duration;
  var hasOwnProperty2 = Object.prototype.hasOwnProperty;
  each$1(animations, function(item) {
    if (startTime + delay < item.startTime + item.delay + item.duration && duration > item.delay) {
      each$1(animation2.toAttrs, function(v2, k2) {
        if (hasOwnProperty2.call(item.toAttrs, k2)) {
          delete item.toAttrs[k2];
          delete item.fromAttrs[k2];
        }
      });
    }
  });
  return animations;
}
var Element$2 = function(_super) {
  __extends$3(Element2, _super);
  function Element2(cfg) {
    var _this = _super.call(this, cfg) || this;
    _this.attrs = {};
    var attrs = _this.getDefaultAttrs();
    mix(attrs, cfg.attrs);
    _this.attrs = attrs;
    _this.initAttrs(attrs);
    _this.initAnimate();
    return _this;
  }
  Element2.prototype.getDefaultCfg = function() {
    return {
      visible: true,
      capture: true,
      zIndex: 0
    };
  };
  Element2.prototype.getDefaultAttrs = function() {
    return {
      matrix: this.getDefaultMatrix(),
      opacity: 1
    };
  };
  Element2.prototype.onCanvasChange = function(changeType) {
  };
  Element2.prototype.initAttrs = function(attrs) {
  };
  Element2.prototype.initAnimate = function() {
    this.set("animable", true);
    this.set("animating", false);
  };
  Element2.prototype.isGroup = function() {
    return false;
  };
  Element2.prototype.getParent = function() {
    return this.get("parent");
  };
  Element2.prototype.getCanvas = function() {
    return this.get("canvas");
  };
  Element2.prototype.attr = function() {
    var _a2;
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var name = args[0], value2 = args[1];
    if (!name)
      return this.attrs;
    if (isObject(name)) {
      for (var k2 in name) {
        this.setAttr(k2, name[k2]);
      }
      this.afterAttrsChange(name);
      return this;
    }
    if (args.length === 2) {
      this.setAttr(name, value2);
      this.afterAttrsChange((_a2 = {}, _a2[name] = value2, _a2));
      return this;
    }
    return this.attrs[name];
  };
  Element2.prototype.isClipped = function(refX, refY) {
    var clip = this.getClip();
    return clip && !clip.isHit(refX, refY);
  };
  Element2.prototype.setAttr = function(name, value2) {
    var originValue = this.attrs[name];
    if (originValue !== value2) {
      this.attrs[name] = value2;
      this.onAttrChange(name, value2, originValue);
    }
  };
  Element2.prototype.onAttrChange = function(name, value2, originValue) {
    if (name === "matrix") {
      this.set("totalMatrix", null);
    }
  };
  Element2.prototype.afterAttrsChange = function(targetAttrs) {
    if (this.cfg.isClipShape) {
      var applyTo = this.cfg.applyTo;
      if (applyTo) {
        applyTo.onCanvasChange("clip");
      }
    } else {
      this.onCanvasChange("attr");
    }
  };
  Element2.prototype.show = function() {
    this.set("visible", true);
    this.onCanvasChange("show");
    return this;
  };
  Element2.prototype.hide = function() {
    this.set("visible", false);
    this.onCanvasChange("hide");
    return this;
  };
  Element2.prototype.setZIndex = function(zIndex) {
    this.set("zIndex", zIndex);
    var parent = this.getParent();
    if (parent) {
      parent.sort();
    }
    return this;
  };
  Element2.prototype.toFront = function() {
    var parent = this.getParent();
    if (!parent) {
      return;
    }
    var children = parent.getChildren();
    this.get("el");
    var index2 = children.indexOf(this);
    children.splice(index2, 1);
    children.push(this);
    this.onCanvasChange("zIndex");
  };
  Element2.prototype.toBack = function() {
    var parent = this.getParent();
    if (!parent) {
      return;
    }
    var children = parent.getChildren();
    this.get("el");
    var index2 = children.indexOf(this);
    children.splice(index2, 1);
    children.unshift(this);
    this.onCanvasChange("zIndex");
  };
  Element2.prototype.remove = function(destroy3) {
    if (destroy3 === void 0) {
      destroy3 = true;
    }
    var parent = this.getParent();
    if (parent) {
      removeFromArray(parent.getChildren(), this);
      if (!parent.get("clearing")) {
        this.onCanvasChange("remove");
      }
    } else {
      this.onCanvasChange("remove");
    }
    if (destroy3) {
      this.destroy();
    }
  };
  Element2.prototype.resetMatrix = function() {
    this.attr(MATRIX, this.getDefaultMatrix());
    this.onCanvasChange("matrix");
  };
  Element2.prototype.getMatrix = function() {
    return this.attr(MATRIX);
  };
  Element2.prototype.setMatrix = function(m2) {
    this.attr(MATRIX, m2);
    this.onCanvasChange("matrix");
  };
  Element2.prototype.getTotalMatrix = function() {
    var totalMatrix = this.cfg.totalMatrix;
    if (!totalMatrix) {
      var currentMatrix = this.attr("matrix");
      var parentMatrix = this.cfg.parentMatrix;
      if (parentMatrix && currentMatrix) {
        totalMatrix = multiplyMatrix(parentMatrix, currentMatrix);
      } else {
        totalMatrix = currentMatrix || parentMatrix;
      }
      this.set("totalMatrix", totalMatrix);
    }
    return totalMatrix;
  };
  Element2.prototype.applyMatrix = function(matrix) {
    var currentMatrix = this.attr("matrix");
    var totalMatrix = null;
    if (matrix && currentMatrix) {
      totalMatrix = multiplyMatrix(matrix, currentMatrix);
    } else {
      totalMatrix = currentMatrix || matrix;
    }
    this.set("totalMatrix", totalMatrix);
    this.set("parentMatrix", matrix);
  };
  Element2.prototype.getDefaultMatrix = function() {
    return null;
  };
  Element2.prototype.applyToMatrix = function(v2) {
    var matrix = this.attr("matrix");
    if (matrix) {
      return multiplyVec2$1(matrix, v2);
    }
    return v2;
  };
  Element2.prototype.invertFromMatrix = function(v2) {
    var matrix = this.attr("matrix");
    if (matrix) {
      var invertMatrix = invert(matrix);
      if (invertMatrix) {
        return multiplyVec2$1(invertMatrix, v2);
      }
    }
    return v2;
  };
  Element2.prototype.setClip = function(clipCfg) {
    var canvas = this.getCanvas();
    var clipShape = null;
    if (clipCfg) {
      var ShapeBase2 = this.getShapeBase();
      var shapeType = upperFirst(clipCfg.type);
      var Cons = ShapeBase2[shapeType];
      if (Cons) {
        clipShape = new Cons({
          type: clipCfg.type,
          isClipShape: true,
          applyTo: this,
          attrs: clipCfg.attrs,
          canvas
        });
      }
    }
    this.set("clipShape", clipShape);
    this.onCanvasChange("clip");
    return clipShape;
  };
  Element2.prototype.getClip = function() {
    var clipShape = this.cfg.clipShape;
    if (!clipShape) {
      return null;
    }
    return clipShape;
  };
  Element2.prototype.clone = function() {
    var _this = this;
    var originAttrs = this.attrs;
    var attrs = {};
    each$1(originAttrs, function(i2, k2) {
      if (isArray$1(originAttrs[k2])) {
        attrs[k2] = _cloneArrayAttr(originAttrs[k2]);
      } else {
        attrs[k2] = originAttrs[k2];
      }
    });
    var cons = this.constructor;
    var clone3 = new cons({ attrs });
    each$1(CLONE_CFGS, function(cfgName) {
      clone3.set(cfgName, _this.get(cfgName));
    });
    return clone3;
  };
  Element2.prototype.destroy = function() {
    var destroyed = this.destroyed;
    if (destroyed) {
      return;
    }
    this.attrs = {};
    _super.prototype.destroy.call(this);
  };
  Element2.prototype.isAnimatePaused = function() {
    return this.get("_pause").isPaused;
  };
  Element2.prototype.animate = function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    if (!this.get("timeline") && !this.get("canvas")) {
      return;
    }
    this.set("animating", true);
    var timeline = this.get("timeline");
    if (!timeline) {
      timeline = this.get("canvas").get("timeline");
      this.set("timeline", timeline);
    }
    var animations = this.get("animations") || [];
    if (!timeline.timer) {
      timeline.initTimer();
    }
    var toAttrs = args[0], duration = args[1], _a2 = args[2], easing = _a2 === void 0 ? "easeLinear" : _a2, _b = args[3], callback = _b === void 0 ? noop : _b, _c = args[4], delay = _c === void 0 ? 0 : _c;
    var onFrame;
    var repeat;
    var pauseCallback;
    var resumeCallback;
    var animateCfg;
    if (isFunction(toAttrs)) {
      onFrame = toAttrs;
      toAttrs = {};
    } else if (isObject(toAttrs) && toAttrs.onFrame) {
      onFrame = toAttrs.onFrame;
      repeat = toAttrs.repeat;
    }
    if (isObject(duration)) {
      animateCfg = duration;
      duration = animateCfg.duration;
      easing = animateCfg.easing || "easeLinear";
      delay = animateCfg.delay || 0;
      repeat = animateCfg.repeat || repeat || false;
      callback = animateCfg.callback || noop;
      pauseCallback = animateCfg.pauseCallback || noop;
      resumeCallback = animateCfg.resumeCallback || noop;
    } else {
      if (isNumber$1(callback)) {
        delay = callback;
        callback = null;
      }
      if (isFunction(easing)) {
        callback = easing;
        easing = "easeLinear";
      } else {
        easing = easing || "easeLinear";
      }
    }
    var formatToAttrs = getFormatToAttrs(toAttrs, this);
    var animation2 = {
      fromAttrs: getFormatFromAttrs(formatToAttrs, this),
      toAttrs: formatToAttrs,
      duration,
      easing,
      repeat,
      callback,
      pauseCallback,
      resumeCallback,
      delay,
      startTime: timeline.getTime(),
      id: uniqueId(),
      onFrame,
      pathFormatted: false
    };
    if (animations.length > 0) {
      animations = checkExistedAttrs(animations, animation2);
    } else {
      timeline.addAnimator(this);
    }
    animations.push(animation2);
    this.set("animations", animations);
    this.set("_pause", { isPaused: false });
  };
  Element2.prototype.stopAnimate = function(toEnd) {
    var _this = this;
    if (toEnd === void 0) {
      toEnd = true;
    }
    var animations = this.get("animations");
    each$1(animations, function(animation2) {
      if (toEnd) {
        if (animation2.onFrame) {
          _this.attr(animation2.onFrame(1));
        } else {
          _this.attr(animation2.toAttrs);
        }
      }
      if (animation2.callback) {
        animation2.callback();
      }
    });
    this.set("animating", false);
    this.set("animations", []);
  };
  Element2.prototype.pauseAnimate = function() {
    var timeline = this.get("timeline");
    var animations = this.get("animations");
    var pauseTime = timeline.getTime();
    each$1(animations, function(animation2) {
      animation2._paused = true;
      animation2._pauseTime = pauseTime;
      if (animation2.pauseCallback) {
        animation2.pauseCallback();
      }
    });
    this.set("_pause", {
      isPaused: true,
      pauseTime
    });
    return this;
  };
  Element2.prototype.resumeAnimate = function() {
    var timeline = this.get("timeline");
    var current = timeline.getTime();
    var animations = this.get("animations");
    var pauseTime = this.get("_pause").pauseTime;
    each$1(animations, function(animation2) {
      animation2.startTime = animation2.startTime + (current - pauseTime);
      animation2._paused = false;
      animation2._pauseTime = null;
      if (animation2.resumeCallback) {
        animation2.resumeCallback();
      }
    });
    this.set("_pause", {
      isPaused: false
    });
    this.set("animations", animations);
    return this;
  };
  Element2.prototype.emitDelegation = function(type4, eventObj) {
    var _this = this;
    var paths = eventObj.propagationPath;
    this.getEvents();
    var relativeShape;
    if (type4 === "mouseenter") {
      relativeShape = eventObj.fromShape;
    } else if (type4 === "mouseleave") {
      relativeShape = eventObj.toShape;
    }
    var _loop_1 = function(i3) {
      var element = paths[i3];
      var name_1 = element.get("name");
      if (name_1) {
        if ((element.isGroup() || element.isCanvas && element.isCanvas()) && relativeShape && isParent(element, relativeShape)) {
          return "break";
        }
        if (isArray$1(name_1)) {
          each$1(name_1, function(subName) {
            _this.emitDelegateEvent(element, subName, eventObj);
          });
        } else {
          this_1.emitDelegateEvent(element, name_1, eventObj);
        }
      }
    };
    var this_1 = this;
    for (var i2 = 0; i2 < paths.length; i2++) {
      var state_1 = _loop_1(i2);
      if (state_1 === "break")
        break;
    }
  };
  Element2.prototype.emitDelegateEvent = function(element, name, eventObj) {
    var events = this.getEvents();
    var eventName = name + DELEGATION_SPLIT + eventObj.type;
    if (events[eventName] || events[WILDCARD]) {
      eventObj.name = eventName;
      eventObj.currentTarget = element;
      eventObj.delegateTarget = this;
      eventObj.delegateObject = element.get("delegateObject");
      this.emit(eventName, eventObj);
    }
  };
  Element2.prototype.translate = function(translateX, translateY) {
    if (translateX === void 0) {
      translateX = 0;
    }
    if (translateY === void 0) {
      translateY = 0;
    }
    var matrix = this.getMatrix();
    var newMatrix = transform$5(matrix, [["t", translateX, translateY]]);
    this.setMatrix(newMatrix);
    return this;
  };
  Element2.prototype.move = function(targetX, targetY) {
    var x2 = this.attr("x") || 0;
    var y2 = this.attr("y") || 0;
    this.translate(targetX - x2, targetY - y2);
    return this;
  };
  Element2.prototype.moveTo = function(targetX, targetY) {
    return this.move(targetX, targetY);
  };
  Element2.prototype.scale = function(ratioX, ratioY) {
    var matrix = this.getMatrix();
    var newMatrix = transform$5(matrix, [["s", ratioX, ratioY || ratioX]]);
    this.setMatrix(newMatrix);
    return this;
  };
  Element2.prototype.rotate = function(radian) {
    var matrix = this.getMatrix();
    var newMatrix = transform$5(matrix, [["r", radian]]);
    this.setMatrix(newMatrix);
    return this;
  };
  Element2.prototype.rotateAtStart = function(rotate2) {
    var _a2 = this.attr(), x2 = _a2.x, y2 = _a2.y;
    var matrix = this.getMatrix();
    var newMatrix = transform$5(matrix, [
      ["t", -x2, -y2],
      ["r", rotate2],
      ["t", x2, y2]
    ]);
    this.setMatrix(newMatrix);
    return this;
  };
  Element2.prototype.rotateAtPoint = function(x2, y2, rotate2) {
    var matrix = this.getMatrix();
    var newMatrix = transform$5(matrix, [
      ["t", -x2, -y2],
      ["r", rotate2],
      ["t", x2, y2]
    ]);
    this.setMatrix(newMatrix);
    return this;
  };
  return Element2;
}(Base);
var SHAPE_MAP = {};
var INDEX = "_INDEX";
function setCanvas(element, canvas) {
  element.set("canvas", canvas);
  if (element.isGroup()) {
    var children = element.get("children");
    if (children.length) {
      children.forEach(function(child) {
        setCanvas(child, canvas);
      });
    }
  }
}
function setTimeline(element, timeline) {
  element.set("timeline", timeline);
  if (element.isGroup()) {
    var children = element.get("children");
    if (children.length) {
      children.forEach(function(child) {
        setTimeline(child, timeline);
      });
    }
  }
}
function removeChild(container, element, destroy3) {
  if (destroy3 === void 0) {
    destroy3 = true;
  }
  if (destroy3) {
    element.destroy();
  } else {
    element.set("parent", null);
    element.set("canvas", null);
  }
  removeFromArray(container.getChildren(), element);
}
function getComparer(compare2) {
  return function(left2, right2) {
    var result = compare2(left2, right2);
    return result === 0 ? left2[INDEX] - right2[INDEX] : result;
  };
}
var Container = function(_super) {
  __extends$3(Container2, _super);
  function Container2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Container2.prototype.isCanvas = function() {
    return false;
  };
  Container2.prototype.getBBox = function() {
    var minX = Infinity;
    var maxX = -Infinity;
    var minY = Infinity;
    var maxY2 = -Infinity;
    var xArr = [];
    var yArr = [];
    var children = this.getChildren().filter(function(child) {
      return child.get("visible") && (!child.isGroup() || child.isGroup() && child.getChildren().length > 0);
    });
    if (children.length > 0) {
      each$1(children, function(child) {
        var box3 = child.getBBox();
        xArr.push(box3.minX, box3.maxX);
        yArr.push(box3.minY, box3.maxY);
      });
      minX = min$2(xArr);
      maxX = max$2(xArr);
      minY = min$2(yArr);
      maxY2 = max$2(yArr);
    } else {
      minX = 0;
      maxX = 0;
      minY = 0;
      maxY2 = 0;
    }
    var box2 = {
      x: minX,
      y: minY,
      minX,
      minY,
      maxX,
      maxY: maxY2,
      width: maxX - minX,
      height: maxY2 - minY
    };
    return box2;
  };
  Container2.prototype.getCanvasBBox = function() {
    var minX = Infinity;
    var maxX = -Infinity;
    var minY = Infinity;
    var maxY2 = -Infinity;
    var xArr = [];
    var yArr = [];
    var children = this.getChildren().filter(function(child) {
      return child.get("visible") && (!child.isGroup() || child.isGroup() && child.getChildren().length > 0);
    });
    if (children.length > 0) {
      each$1(children, function(child) {
        var box3 = child.getCanvasBBox();
        xArr.push(box3.minX, box3.maxX);
        yArr.push(box3.minY, box3.maxY);
      });
      minX = min$2(xArr);
      maxX = max$2(xArr);
      minY = min$2(yArr);
      maxY2 = max$2(yArr);
    } else {
      minX = 0;
      maxX = 0;
      minY = 0;
      maxY2 = 0;
    }
    var box2 = {
      x: minX,
      y: minY,
      minX,
      minY,
      maxX,
      maxY: maxY2,
      width: maxX - minX,
      height: maxY2 - minY
    };
    return box2;
  };
  Container2.prototype.getDefaultCfg = function() {
    var cfg = _super.prototype.getDefaultCfg.call(this);
    cfg["children"] = [];
    return cfg;
  };
  Container2.prototype.onAttrChange = function(name, value2, originValue) {
    _super.prototype.onAttrChange.call(this, name, value2, originValue);
    if (name === "matrix") {
      var totalMatrix = this.getTotalMatrix();
      this._applyChildrenMarix(totalMatrix);
    }
  };
  Container2.prototype.applyMatrix = function(matrix) {
    var preTotalMatrix = this.getTotalMatrix();
    _super.prototype.applyMatrix.call(this, matrix);
    var totalMatrix = this.getTotalMatrix();
    if (totalMatrix === preTotalMatrix) {
      return;
    }
    this._applyChildrenMarix(totalMatrix);
  };
  Container2.prototype._applyChildrenMarix = function(totalMatrix) {
    var children = this.getChildren();
    each$1(children, function(child) {
      child.applyMatrix(totalMatrix);
    });
  };
  Container2.prototype.addShape = function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var type4 = args[0];
    var cfg = args[1];
    if (isObject(type4)) {
      cfg = type4;
    } else {
      cfg["type"] = type4;
    }
    var shapeType = SHAPE_MAP[cfg.type];
    if (!shapeType) {
      shapeType = upperFirst(cfg.type);
      SHAPE_MAP[cfg.type] = shapeType;
    }
    var ShapeBase2 = this.getShapeBase();
    var shape = new ShapeBase2[shapeType](cfg);
    this.add(shape);
    return shape;
  };
  Container2.prototype.addGroup = function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var groupClass = args[0], cfg = args[1];
    var group2;
    if (isFunction(groupClass)) {
      if (cfg) {
        group2 = new groupClass(cfg);
      } else {
        group2 = new groupClass({
          parent: this
        });
      }
    } else {
      var tmpCfg = groupClass || {};
      var TmpGroupClass = this.getGroupBase();
      group2 = new TmpGroupClass(tmpCfg);
    }
    this.add(group2);
    return group2;
  };
  Container2.prototype.getCanvas = function() {
    var canvas;
    if (this.isCanvas()) {
      canvas = this;
    } else {
      canvas = this.get("canvas");
    }
    return canvas;
  };
  Container2.prototype.getShape = function(x2, y2, ev) {
    if (!isAllowCapture(this)) {
      return null;
    }
    var children = this.getChildren();
    var shape;
    if (!this.isCanvas()) {
      var v2 = [x2, y2, 1];
      v2 = this.invertFromMatrix(v2);
      if (!this.isClipped(v2[0], v2[1])) {
        shape = this._findShape(children, v2[0], v2[1], ev);
      }
    } else {
      shape = this._findShape(children, x2, y2, ev);
    }
    return shape;
  };
  Container2.prototype._findShape = function(children, x2, y2, ev) {
    var shape = null;
    for (var i2 = children.length - 1; i2 >= 0; i2--) {
      var child = children[i2];
      if (isAllowCapture(child)) {
        if (child.isGroup()) {
          shape = child.getShape(x2, y2, ev);
        } else if (child.isHit(x2, y2)) {
          shape = child;
        }
      }
      if (shape) {
        break;
      }
    }
    return shape;
  };
  Container2.prototype.add = function(element) {
    var canvas = this.getCanvas();
    var children = this.getChildren();
    var timeline = this.get("timeline");
    var preParent = element.getParent();
    if (preParent) {
      removeChild(preParent, element, false);
    }
    element.set("parent", this);
    if (canvas) {
      setCanvas(element, canvas);
    }
    if (timeline) {
      setTimeline(element, timeline);
    }
    children.push(element);
    element.onCanvasChange("add");
    this._applyElementMatrix(element);
  };
  Container2.prototype._applyElementMatrix = function(element) {
    var totalMatrix = this.getTotalMatrix();
    if (totalMatrix) {
      element.applyMatrix(totalMatrix);
    }
  };
  Container2.prototype.getChildren = function() {
    return this.get("children");
  };
  Container2.prototype.sort = function() {
    var children = this.getChildren();
    each$1(children, function(child, index2) {
      child[INDEX] = index2;
      return child;
    });
    children.sort(getComparer(function(obj1, obj2) {
      return obj1.get("zIndex") - obj2.get("zIndex");
    }));
    this.onCanvasChange("sort");
  };
  Container2.prototype.clear = function() {
    this.set("clearing", true);
    if (this.destroyed) {
      return;
    }
    var children = this.getChildren();
    for (var i2 = children.length - 1; i2 >= 0; i2--) {
      children[i2].destroy();
    }
    this.set("children", []);
    this.onCanvasChange("clear");
    this.set("clearing", false);
  };
  Container2.prototype.destroy = function() {
    if (this.get("destroyed")) {
      return;
    }
    this.clear();
    _super.prototype.destroy.call(this);
  };
  Container2.prototype.getFirst = function() {
    return this.getChildByIndex(0);
  };
  Container2.prototype.getLast = function() {
    var children = this.getChildren();
    return this.getChildByIndex(children.length - 1);
  };
  Container2.prototype.getChildByIndex = function(index2) {
    var children = this.getChildren();
    return children[index2];
  };
  Container2.prototype.getCount = function() {
    var children = this.getChildren();
    return children.length;
  };
  Container2.prototype.contain = function(element) {
    var children = this.getChildren();
    return children.indexOf(element) > -1;
  };
  Container2.prototype.removeChild = function(element, destroy3) {
    if (destroy3 === void 0) {
      destroy3 = true;
    }
    if (this.contain(element)) {
      element.remove(destroy3);
    }
  };
  Container2.prototype.findAll = function(fn2) {
    var rst = [];
    var children = this.getChildren();
    each$1(children, function(element) {
      if (fn2(element)) {
        rst.push(element);
      }
      if (element.isGroup()) {
        rst = rst.concat(element.findAll(fn2));
      }
    });
    return rst;
  };
  Container2.prototype.find = function(fn2) {
    var rst = null;
    var children = this.getChildren();
    each$1(children, function(element) {
      if (fn2(element)) {
        rst = element;
      } else if (element.isGroup()) {
        rst = element.find(fn2);
      }
      if (rst) {
        return false;
      }
    });
    return rst;
  };
  Container2.prototype.findById = function(id2) {
    return this.find(function(element) {
      return element.get("id") === id2;
    });
  };
  Container2.prototype.findByClassName = function(className) {
    return this.find(function(element) {
      return element.get("className") === className;
    });
  };
  Container2.prototype.findAllByName = function(name) {
    return this.findAll(function(element) {
      return element.get("name") === name;
    });
  };
  return Container2;
}(Element$2);
var frame = 0, timeout = 0, interval$1 = 0, pokeDelay = 1e3, taskHead, taskTail, clockLast = 0, clockNow = 0, clockSkew = 0, clock = typeof performance === "object" && performance.now ? performance : Date, setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f2) {
  setTimeout(f2, 17);
};
function now() {
  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
}
function clearNow() {
  clockNow = 0;
}
function Timer() {
  this._call = this._time = this._next = null;
}
Timer.prototype = timer.prototype = {
  constructor: Timer,
  restart: function(callback, delay, time) {
    if (typeof callback !== "function")
      throw new TypeError("callback is not a function");
    time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);
    if (!this._next && taskTail !== this) {
      if (taskTail)
        taskTail._next = this;
      else
        taskHead = this;
      taskTail = this;
    }
    this._call = callback;
    this._time = time;
    sleep();
  },
  stop: function() {
    if (this._call) {
      this._call = null;
      this._time = Infinity;
      sleep();
    }
  }
};
function timer(callback, delay, time) {
  var t2 = new Timer();
  t2.restart(callback, delay, time);
  return t2;
}
function timerFlush() {
  now();
  ++frame;
  var t2 = taskHead, e3;
  while (t2) {
    if ((e3 = clockNow - t2._time) >= 0)
      t2._call.call(null, e3);
    t2 = t2._next;
  }
  --frame;
}
function wake() {
  clockNow = (clockLast = clock.now()) + clockSkew;
  frame = timeout = 0;
  try {
    timerFlush();
  } finally {
    frame = 0;
    nap();
    clockNow = 0;
  }
}
function poke() {
  var now2 = clock.now(), delay = now2 - clockLast;
  if (delay > pokeDelay)
    clockSkew -= delay, clockLast = now2;
}
function nap() {
  var t0, t1 = taskHead, t2, time = Infinity;
  while (t1) {
    if (t1._call) {
      if (time > t1._time)
        time = t1._time;
      t0 = t1, t1 = t1._next;
    } else {
      t2 = t1._next, t1._next = null;
      t1 = t0 ? t0._next = t2 : taskHead = t2;
    }
  }
  taskTail = t0;
  sleep(time);
}
function sleep(time) {
  if (frame)
    return;
  if (timeout)
    timeout = clearTimeout(timeout);
  var delay = time - clockNow;
  if (delay > 24) {
    if (time < Infinity)
      timeout = setTimeout(wake, time - clock.now() - clockSkew);
    if (interval$1)
      interval$1 = clearInterval(interval$1);
  } else {
    if (!interval$1)
      clockLast = clock.now(), interval$1 = setInterval(poke, pokeDelay);
    frame = 1, setFrame(wake);
  }
}
function define(constructor, factory, prototype2) {
  constructor.prototype = factory.prototype = prototype2;
  prototype2.constructor = constructor;
}
function extend(parent, definition) {
  var prototype2 = Object.create(parent.prototype);
  for (var key2 in definition)
    prototype2[key2] = definition[key2];
  return prototype2;
}
function Color$1() {
}
var darker = 0.7;
var brighter = 1 / darker;
var reI = "\\s*([+-]?\\d+)\\s*", reN = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*", reP = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*", reHex = /^#([0-9a-f]{3,8})$/, reRgbInteger = new RegExp("^rgb\\(" + [reI, reI, reI] + "\\)$"), reRgbPercent = new RegExp("^rgb\\(" + [reP, reP, reP] + "\\)$"), reRgbaInteger = new RegExp("^rgba\\(" + [reI, reI, reI, reN] + "\\)$"), reRgbaPercent = new RegExp("^rgba\\(" + [reP, reP, reP, reN] + "\\)$"), reHslPercent = new RegExp("^hsl\\(" + [reN, reP, reP] + "\\)$"), reHslaPercent = new RegExp("^hsla\\(" + [reN, reP, reP, reN] + "\\)$");
var named = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
define(Color$1, color$1, {
  copy: function(channels) {
    return Object.assign(new this.constructor(), this, channels);
  },
  displayable: function() {
    return this.rgb().displayable();
  },
  hex: color_formatHex,
  formatHex: color_formatHex,
  formatHsl: color_formatHsl,
  formatRgb: color_formatRgb,
  toString: color_formatRgb
});
function color_formatHex() {
  return this.rgb().formatHex();
}
function color_formatHsl() {
  return hslConvert(this).formatHsl();
}
function color_formatRgb() {
  return this.rgb().formatRgb();
}
function color$1(format2) {
  var m2, l2;
  format2 = (format2 + "").trim().toLowerCase();
  return (m2 = reHex.exec(format2)) ? (l2 = m2[1].length, m2 = parseInt(m2[1], 16), l2 === 6 ? rgbn(m2) : l2 === 3 ? new Rgb(m2 >> 8 & 15 | m2 >> 4 & 240, m2 >> 4 & 15 | m2 & 240, (m2 & 15) << 4 | m2 & 15, 1) : l2 === 8 ? rgba(m2 >> 24 & 255, m2 >> 16 & 255, m2 >> 8 & 255, (m2 & 255) / 255) : l2 === 4 ? rgba(m2 >> 12 & 15 | m2 >> 8 & 240, m2 >> 8 & 15 | m2 >> 4 & 240, m2 >> 4 & 15 | m2 & 240, ((m2 & 15) << 4 | m2 & 15) / 255) : null) : (m2 = reRgbInteger.exec(format2)) ? new Rgb(m2[1], m2[2], m2[3], 1) : (m2 = reRgbPercent.exec(format2)) ? new Rgb(m2[1] * 255 / 100, m2[2] * 255 / 100, m2[3] * 255 / 100, 1) : (m2 = reRgbaInteger.exec(format2)) ? rgba(m2[1], m2[2], m2[3], m2[4]) : (m2 = reRgbaPercent.exec(format2)) ? rgba(m2[1] * 255 / 100, m2[2] * 255 / 100, m2[3] * 255 / 100, m2[4]) : (m2 = reHslPercent.exec(format2)) ? hsla(m2[1], m2[2] / 100, m2[3] / 100, 1) : (m2 = reHslaPercent.exec(format2)) ? hsla(m2[1], m2[2] / 100, m2[3] / 100, m2[4]) : named.hasOwnProperty(format2) ? rgbn(named[format2]) : format2 === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
}
function rgbn(n2) {
  return new Rgb(n2 >> 16 & 255, n2 >> 8 & 255, n2 & 255, 1);
}
function rgba(r2, g2, b10, a2) {
  if (a2 <= 0)
    r2 = g2 = b10 = NaN;
  return new Rgb(r2, g2, b10, a2);
}
function rgbConvert(o2) {
  if (!(o2 instanceof Color$1))
    o2 = color$1(o2);
  if (!o2)
    return new Rgb();
  o2 = o2.rgb();
  return new Rgb(o2.r, o2.g, o2.b, o2.opacity);
}
function rgb$1(r2, g2, b10, opacity) {
  return arguments.length === 1 ? rgbConvert(r2) : new Rgb(r2, g2, b10, opacity == null ? 1 : opacity);
}
function Rgb(r2, g2, b10, opacity) {
  this.r = +r2;
  this.g = +g2;
  this.b = +b10;
  this.opacity = +opacity;
}
define(Rgb, rgb$1, extend(Color$1, {
  brighter: function(k2) {
    k2 = k2 == null ? brighter : Math.pow(brighter, k2);
    return new Rgb(this.r * k2, this.g * k2, this.b * k2, this.opacity);
  },
  darker: function(k2) {
    k2 = k2 == null ? darker : Math.pow(darker, k2);
    return new Rgb(this.r * k2, this.g * k2, this.b * k2, this.opacity);
  },
  rgb: function() {
    return this;
  },
  displayable: function() {
    return -0.5 <= this.r && this.r < 255.5 && (-0.5 <= this.g && this.g < 255.5) && (-0.5 <= this.b && this.b < 255.5) && (0 <= this.opacity && this.opacity <= 1);
  },
  hex: rgb_formatHex,
  formatHex: rgb_formatHex,
  formatRgb: rgb_formatRgb,
  toString: rgb_formatRgb
}));
function rgb_formatHex() {
  return "#" + hex(this.r) + hex(this.g) + hex(this.b);
}
function rgb_formatRgb() {
  var a2 = this.opacity;
  a2 = isNaN(a2) ? 1 : Math.max(0, Math.min(1, a2));
  return (a2 === 1 ? "rgb(" : "rgba(") + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.b) || 0)) + (a2 === 1 ? ")" : ", " + a2 + ")");
}
function hex(value2) {
  value2 = Math.max(0, Math.min(255, Math.round(value2) || 0));
  return (value2 < 16 ? "0" : "") + value2.toString(16);
}
function hsla(h2, s2, l2, a2) {
  if (a2 <= 0)
    h2 = s2 = l2 = NaN;
  else if (l2 <= 0 || l2 >= 1)
    h2 = s2 = NaN;
  else if (s2 <= 0)
    h2 = NaN;
  return new Hsl(h2, s2, l2, a2);
}
function hslConvert(o2) {
  if (o2 instanceof Hsl)
    return new Hsl(o2.h, o2.s, o2.l, o2.opacity);
  if (!(o2 instanceof Color$1))
    o2 = color$1(o2);
  if (!o2)
    return new Hsl();
  if (o2 instanceof Hsl)
    return o2;
  o2 = o2.rgb();
  var r2 = o2.r / 255, g2 = o2.g / 255, b10 = o2.b / 255, min2 = Math.min(r2, g2, b10), max2 = Math.max(r2, g2, b10), h2 = NaN, s2 = max2 - min2, l2 = (max2 + min2) / 2;
  if (s2) {
    if (r2 === max2)
      h2 = (g2 - b10) / s2 + (g2 < b10) * 6;
    else if (g2 === max2)
      h2 = (b10 - r2) / s2 + 2;
    else
      h2 = (r2 - g2) / s2 + 4;
    s2 /= l2 < 0.5 ? max2 + min2 : 2 - max2 - min2;
    h2 *= 60;
  } else {
    s2 = l2 > 0 && l2 < 1 ? 0 : h2;
  }
  return new Hsl(h2, s2, l2, o2.opacity);
}
function hsl(h2, s2, l2, opacity) {
  return arguments.length === 1 ? hslConvert(h2) : new Hsl(h2, s2, l2, opacity == null ? 1 : opacity);
}
function Hsl(h2, s2, l2, opacity) {
  this.h = +h2;
  this.s = +s2;
  this.l = +l2;
  this.opacity = +opacity;
}
define(Hsl, hsl, extend(Color$1, {
  brighter: function(k2) {
    k2 = k2 == null ? brighter : Math.pow(brighter, k2);
    return new Hsl(this.h, this.s, this.l * k2, this.opacity);
  },
  darker: function(k2) {
    k2 = k2 == null ? darker : Math.pow(darker, k2);
    return new Hsl(this.h, this.s, this.l * k2, this.opacity);
  },
  rgb: function() {
    var h2 = this.h % 360 + (this.h < 0) * 360, s2 = isNaN(h2) || isNaN(this.s) ? 0 : this.s, l2 = this.l, m2 = l2 + (l2 < 0.5 ? l2 : 1 - l2) * s2, m1 = 2 * l2 - m2;
    return new Rgb(
      hsl2rgb(h2 >= 240 ? h2 - 240 : h2 + 120, m1, m2),
      hsl2rgb(h2, m1, m2),
      hsl2rgb(h2 < 120 ? h2 + 240 : h2 - 120, m1, m2),
      this.opacity
    );
  },
  displayable: function() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);
  },
  formatHsl: function() {
    var a2 = this.opacity;
    a2 = isNaN(a2) ? 1 : Math.max(0, Math.min(1, a2));
    return (a2 === 1 ? "hsl(" : "hsla(") + (this.h || 0) + ", " + (this.s || 0) * 100 + "%, " + (this.l || 0) * 100 + "%" + (a2 === 1 ? ")" : ", " + a2 + ")");
  }
}));
function hsl2rgb(h2, m1, m2) {
  return (h2 < 60 ? m1 + (m2 - m1) * h2 / 60 : h2 < 180 ? m2 : h2 < 240 ? m1 + (m2 - m1) * (240 - h2) / 60 : m1) * 255;
}
function constant$3(x2) {
  return function() {
    return x2;
  };
}
function linear$3(a2, d2) {
  return function(t2) {
    return a2 + t2 * d2;
  };
}
function exponential$1(a2, b10, y2) {
  return a2 = Math.pow(a2, y2), b10 = Math.pow(b10, y2) - a2, y2 = 1 / y2, function(t2) {
    return Math.pow(a2 + t2 * b10, y2);
  };
}
function gamma(y2) {
  return (y2 = +y2) === 1 ? nogamma : function(a2, b10) {
    return b10 - a2 ? exponential$1(a2, b10, y2) : constant$3(isNaN(a2) ? b10 : a2);
  };
}
function nogamma(a2, b10) {
  var d2 = b10 - a2;
  return d2 ? linear$3(a2, d2) : constant$3(isNaN(a2) ? b10 : a2);
}
var rgb = function rgbGamma(y2) {
  var color2 = gamma(y2);
  function rgb2(start, end) {
    var r2 = color2((start = rgb$1(start)).r, (end = rgb$1(end)).r), g2 = color2(start.g, end.g), b10 = color2(start.b, end.b), opacity = nogamma(start.opacity, end.opacity);
    return function(t2) {
      start.r = r2(t2);
      start.g = g2(t2);
      start.b = b10(t2);
      start.opacity = opacity(t2);
      return start + "";
    };
  }
  rgb2.gamma = rgbGamma;
  return rgb2;
}(1);
function numberArray(a2, b10) {
  if (!b10)
    b10 = [];
  var n2 = a2 ? Math.min(b10.length, a2.length) : 0, c2 = b10.slice(), i2;
  return function(t2) {
    for (i2 = 0; i2 < n2; ++i2)
      c2[i2] = a2[i2] * (1 - t2) + b10[i2] * t2;
    return c2;
  };
}
function isNumberArray(x2) {
  return ArrayBuffer.isView(x2) && !(x2 instanceof DataView);
}
function interpolateArray(a2, b10) {
  return (isNumberArray(b10) ? numberArray : genericArray)(a2, b10);
}
function genericArray(a2, b10) {
  var nb2 = b10 ? b10.length : 0, na2 = a2 ? Math.min(nb2, a2.length) : 0, x2 = new Array(na2), c2 = new Array(nb2), i2;
  for (i2 = 0; i2 < na2; ++i2)
    x2[i2] = interpolate(a2[i2], b10[i2]);
  for (; i2 < nb2; ++i2)
    c2[i2] = b10[i2];
  return function(t2) {
    for (i2 = 0; i2 < na2; ++i2)
      c2[i2] = x2[i2](t2);
    return c2;
  };
}
function date(a2, b10) {
  var d2 = new Date();
  return a2 = +a2, b10 = +b10, function(t2) {
    return d2.setTime(a2 * (1 - t2) + b10 * t2), d2;
  };
}
function number(a2, b10) {
  return a2 = +a2, b10 = +b10, function(t2) {
    return a2 * (1 - t2) + b10 * t2;
  };
}
function object$1(a2, b10) {
  var i2 = {}, c2 = {}, k2;
  if (a2 === null || typeof a2 !== "object")
    a2 = {};
  if (b10 === null || typeof b10 !== "object")
    b10 = {};
  for (k2 in b10) {
    if (k2 in a2) {
      i2[k2] = interpolate(a2[k2], b10[k2]);
    } else {
      c2[k2] = b10[k2];
    }
  }
  return function(t2) {
    for (k2 in i2)
      c2[k2] = i2[k2](t2);
    return c2;
  };
}
var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, reB = new RegExp(reA.source, "g");
function zero(b10) {
  return function() {
    return b10;
  };
}
function one(b10) {
  return function(t2) {
    return b10(t2) + "";
  };
}
function string(a2, b10) {
  var bi2 = reA.lastIndex = reB.lastIndex = 0, am, bm, bs, i2 = -1, s2 = [], q2 = [];
  a2 = a2 + "", b10 = b10 + "";
  while ((am = reA.exec(a2)) && (bm = reB.exec(b10))) {
    if ((bs = bm.index) > bi2) {
      bs = b10.slice(bi2, bs);
      if (s2[i2])
        s2[i2] += bs;
      else
        s2[++i2] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) {
      if (s2[i2])
        s2[i2] += bm;
      else
        s2[++i2] = bm;
    } else {
      s2[++i2] = null;
      q2.push({ i: i2, x: number(am, bm) });
    }
    bi2 = reB.lastIndex;
  }
  if (bi2 < b10.length) {
    bs = b10.slice(bi2);
    if (s2[i2])
      s2[i2] += bs;
    else
      s2[++i2] = bs;
  }
  return s2.length < 2 ? q2[0] ? one(q2[0].x) : zero(b10) : (b10 = q2.length, function(t2) {
    for (var i3 = 0, o2; i3 < b10; ++i3)
      s2[(o2 = q2[i3]).i] = o2.x(t2);
    return s2.join("");
  });
}
function interpolate(a2, b10) {
  var t2 = typeof b10, c2;
  return b10 == null || t2 === "boolean" ? constant$3(b10) : (t2 === "number" ? number : t2 === "string" ? (c2 = color$1(b10)) ? (b10 = c2, rgb) : string : b10 instanceof color$1 ? rgb : b10 instanceof Date ? date : isNumberArray(b10) ? numberArray : Array.isArray(b10) ? genericArray : typeof b10.valueOf !== "function" && typeof b10.toString !== "function" || isNaN(b10) ? object$1 : number)(a2, b10);
}
function linear$2(t2) {
  return +t2;
}
function quadIn(t2) {
  return t2 * t2;
}
function quadOut(t2) {
  return t2 * (2 - t2);
}
function quadInOut(t2) {
  return ((t2 *= 2) <= 1 ? t2 * t2 : --t2 * (2 - t2) + 1) / 2;
}
function cubicIn(t2) {
  return t2 * t2 * t2;
}
function cubicOut(t2) {
  return --t2 * t2 * t2 + 1;
}
function cubicInOut(t2) {
  return ((t2 *= 2) <= 1 ? t2 * t2 * t2 : (t2 -= 2) * t2 * t2 + 2) / 2;
}
var exponent = 3;
var polyIn = function custom(e3) {
  e3 = +e3;
  function polyIn2(t2) {
    return Math.pow(t2, e3);
  }
  polyIn2.exponent = custom;
  return polyIn2;
}(exponent);
var polyOut = function custom2(e3) {
  e3 = +e3;
  function polyOut2(t2) {
    return 1 - Math.pow(1 - t2, e3);
  }
  polyOut2.exponent = custom2;
  return polyOut2;
}(exponent);
var polyInOut = function custom3(e3) {
  e3 = +e3;
  function polyInOut2(t2) {
    return ((t2 *= 2) <= 1 ? Math.pow(t2, e3) : 2 - Math.pow(2 - t2, e3)) / 2;
  }
  polyInOut2.exponent = custom3;
  return polyInOut2;
}(exponent);
var pi = Math.PI, halfPi = pi / 2;
function sinIn(t2) {
  return +t2 === 1 ? 1 : 1 - Math.cos(t2 * halfPi);
}
function sinOut(t2) {
  return Math.sin(t2 * halfPi);
}
function sinInOut(t2) {
  return (1 - Math.cos(pi * t2)) / 2;
}
function tpmt(x2) {
  return (Math.pow(2, -10 * x2) - 9765625e-10) * 1.0009775171065494;
}
function expIn(t2) {
  return tpmt(1 - +t2);
}
function expOut(t2) {
  return 1 - tpmt(t2);
}
function expInOut(t2) {
  return ((t2 *= 2) <= 1 ? tpmt(1 - t2) : 2 - tpmt(t2 - 1)) / 2;
}
function circleIn(t2) {
  return 1 - Math.sqrt(1 - t2 * t2);
}
function circleOut(t2) {
  return Math.sqrt(1 - --t2 * t2);
}
function circleInOut(t2) {
  return ((t2 *= 2) <= 1 ? 1 - Math.sqrt(1 - t2 * t2) : Math.sqrt(1 - (t2 -= 2) * t2) + 1) / 2;
}
var b1 = 4 / 11, b2 = 6 / 11, b3 = 8 / 11, b4 = 3 / 4, b5 = 9 / 11, b6 = 10 / 11, b7 = 15 / 16, b8 = 21 / 22, b9 = 63 / 64, b0 = 1 / b1 / b1;
function bounceIn(t2) {
  return 1 - bounceOut(1 - t2);
}
function bounceOut(t2) {
  return (t2 = +t2) < b1 ? b0 * t2 * t2 : t2 < b3 ? b0 * (t2 -= b2) * t2 + b4 : t2 < b6 ? b0 * (t2 -= b5) * t2 + b7 : b0 * (t2 -= b8) * t2 + b9;
}
function bounceInOut(t2) {
  return ((t2 *= 2) <= 1 ? 1 - bounceOut(1 - t2) : bounceOut(t2 - 1) + 1) / 2;
}
var overshoot = 1.70158;
var backIn = function custom4(s2) {
  s2 = +s2;
  function backIn2(t2) {
    return (t2 = +t2) * t2 * (s2 * (t2 - 1) + t2);
  }
  backIn2.overshoot = custom4;
  return backIn2;
}(overshoot);
var backOut = function custom5(s2) {
  s2 = +s2;
  function backOut2(t2) {
    return --t2 * t2 * ((t2 + 1) * s2 + t2) + 1;
  }
  backOut2.overshoot = custom5;
  return backOut2;
}(overshoot);
var backInOut = function custom6(s2) {
  s2 = +s2;
  function backInOut2(t2) {
    return ((t2 *= 2) < 1 ? t2 * t2 * ((s2 + 1) * t2 - s2) : (t2 -= 2) * t2 * ((s2 + 1) * t2 + s2) + 2) / 2;
  }
  backInOut2.overshoot = custom6;
  return backInOut2;
}(overshoot);
var tau = 2 * Math.PI, amplitude = 1, period = 0.3;
var elasticIn = function custom7(a2, p2) {
  var s2 = Math.asin(1 / (a2 = Math.max(1, a2))) * (p2 /= tau);
  function elasticIn2(t2) {
    return a2 * tpmt(- --t2) * Math.sin((s2 - t2) / p2);
  }
  elasticIn2.amplitude = function(a3) {
    return custom7(a3, p2 * tau);
  };
  elasticIn2.period = function(p3) {
    return custom7(a2, p3);
  };
  return elasticIn2;
}(amplitude, period);
var elasticOut = function custom8(a2, p2) {
  var s2 = Math.asin(1 / (a2 = Math.max(1, a2))) * (p2 /= tau);
  function elasticOut2(t2) {
    return 1 - a2 * tpmt(t2 = +t2) * Math.sin((t2 + s2) / p2);
  }
  elasticOut2.amplitude = function(a3) {
    return custom8(a3, p2 * tau);
  };
  elasticOut2.period = function(p3) {
    return custom8(a2, p3);
  };
  return elasticOut2;
}(amplitude, period);
var elasticInOut = function custom9(a2, p2) {
  var s2 = Math.asin(1 / (a2 = Math.max(1, a2))) * (p2 /= tau);
  function elasticInOut2(t2) {
    return ((t2 = t2 * 2 - 1) < 0 ? a2 * tpmt(-t2) * Math.sin((s2 - t2) / p2) : 2 - a2 * tpmt(t2) * Math.sin((s2 + t2) / p2)) / 2;
  }
  elasticInOut2.amplitude = function(a3) {
    return custom9(a3, p2 * tau);
  };
  elasticInOut2.period = function(p3) {
    return custom9(a2, p3);
  };
  return elasticInOut2;
}(amplitude, period);
var d3Ease = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  easeLinear: linear$2,
  easeQuad: quadInOut,
  easeQuadIn: quadIn,
  easeQuadOut: quadOut,
  easeQuadInOut: quadInOut,
  easeCubic: cubicInOut,
  easeCubicIn: cubicIn,
  easeCubicOut: cubicOut,
  easeCubicInOut: cubicInOut,
  easePoly: polyInOut,
  easePolyIn: polyIn,
  easePolyOut: polyOut,
  easePolyInOut: polyInOut,
  easeSin: sinInOut,
  easeSinIn: sinIn,
  easeSinOut: sinOut,
  easeSinInOut: sinInOut,
  easeExp: expInOut,
  easeExpIn: expIn,
  easeExpOut: expOut,
  easeExpInOut: expInOut,
  easeCircle: circleInOut,
  easeCircleIn: circleIn,
  easeCircleOut: circleOut,
  easeCircleInOut: circleInOut,
  easeBounce: bounceOut,
  easeBounceIn: bounceIn,
  easeBounceOut: bounceOut,
  easeBounceInOut: bounceInOut,
  easeBack: backInOut,
  easeBackIn: backIn,
  easeBackOut: backOut,
  easeBackInOut: backInOut,
  easeElastic: elasticOut,
  easeElasticIn: elasticIn,
  easeElasticOut: elasticOut,
  easeElasticInOut: elasticInOut
}, Symbol.toStringTag, { value: "Module" }));
var EASING_MAP = {};
function getEasing(type4) {
  return EASING_MAP[type4.toLowerCase()] || d3Ease[type4];
}
function registerEasing(type4, easeFn) {
  EASING_MAP[type4.toLowerCase()] = easeFn;
}
var isColorProp = function(prop) {
  return ["fill", "stroke", "fillStyle", "strokeStyle"].includes(prop);
};
var isGradientColor$1 = function(val) {
  return /^[r,R,L,l]{1}[\s]*\(/.test(val);
};
var IDENTITY_MATRIX = [1, 0, 0, 0, 1, 0, 0, 0, 1];
function _update(shape, animation2, ratio) {
  var cProps = {};
  var fromAttrs = animation2.fromAttrs, toAttrs = animation2.toAttrs;
  if (shape.destroyed) {
    return;
  }
  var interf;
  for (var k2 in toAttrs) {
    if (!isEqual$1(fromAttrs[k2], toAttrs[k2])) {
      if (k2 === "path") {
        var toPath = toAttrs[k2];
        var fromPath = fromAttrs[k2];
        if (toPath.length > fromPath.length) {
          toPath = parsePathString$1(toAttrs[k2]);
          fromPath = parsePathString$1(fromAttrs[k2]);
          fromPath = fillPathByDiff(fromPath, toPath);
          fromPath = formatPath(fromPath, toPath);
          animation2.fromAttrs.path = fromPath;
          animation2.toAttrs.path = toPath;
        } else if (!animation2.pathFormatted) {
          toPath = parsePathString$1(toAttrs[k2]);
          fromPath = parsePathString$1(fromAttrs[k2]);
          fromPath = formatPath(fromPath, toPath);
          animation2.fromAttrs.path = fromPath;
          animation2.toAttrs.path = toPath;
          animation2.pathFormatted = true;
        }
        cProps[k2] = [];
        for (var i2 = 0; i2 < toPath.length; i2++) {
          var toPathPoint = toPath[i2];
          var fromPathPoint = fromPath[i2];
          var cPathPoint = [];
          for (var j2 = 0; j2 < toPathPoint.length; j2++) {
            if (isNumber$1(toPathPoint[j2]) && fromPathPoint && isNumber$1(fromPathPoint[j2])) {
              interf = interpolate(fromPathPoint[j2], toPathPoint[j2]);
              cPathPoint.push(interf(ratio));
            } else {
              cPathPoint.push(toPathPoint[j2]);
            }
          }
          cProps[k2].push(cPathPoint);
        }
      } else if (k2 === "matrix") {
        var matrixFn = interpolateArray(fromAttrs[k2] || IDENTITY_MATRIX, toAttrs[k2] || IDENTITY_MATRIX);
        var currentMatrix = matrixFn(ratio);
        cProps[k2] = currentMatrix;
      } else if (isColorProp(k2) && isGradientColor$1(toAttrs[k2])) {
        cProps[k2] = toAttrs[k2];
      } else if (!isFunction(toAttrs[k2])) {
        interf = interpolate(fromAttrs[k2], toAttrs[k2]);
        cProps[k2] = interf(ratio);
      }
    }
  }
  shape.attr(cProps);
}
function update(shape, animation2, elapsed) {
  var startTime = animation2.startTime, delay = animation2.delay;
  if (elapsed < startTime + delay || animation2._paused) {
    return false;
  }
  var ratio;
  var duration = animation2.duration;
  var easing = animation2.easing;
  var easeFn = getEasing(easing);
  elapsed = elapsed - startTime - animation2.delay;
  if (animation2.repeat) {
    ratio = elapsed % duration / duration;
    ratio = easeFn(ratio);
  } else {
    ratio = elapsed / duration;
    if (ratio < 1) {
      ratio = easeFn(ratio);
    } else {
      if (animation2.onFrame) {
        shape.attr(animation2.onFrame(1));
      } else {
        shape.attr(animation2.toAttrs);
      }
      return true;
    }
  }
  if (animation2.onFrame) {
    var attrs = animation2.onFrame(ratio);
    shape.attr(attrs);
  } else {
    _update(shape, animation2, ratio);
  }
  return false;
}
var Timeline = function() {
  function Timeline2(canvas) {
    this.animators = [];
    this.current = 0;
    this.timer = null;
    this.canvas = canvas;
  }
  Timeline2.prototype.initTimer = function() {
    var _this = this;
    var isFinished = false;
    var shape;
    var animations;
    var animation2;
    this.timer = timer(function(elapsed) {
      _this.current = elapsed;
      if (_this.animators.length > 0) {
        for (var i2 = _this.animators.length - 1; i2 >= 0; i2--) {
          shape = _this.animators[i2];
          if (shape.destroyed) {
            _this.removeAnimator(i2);
            continue;
          }
          if (!shape.isAnimatePaused()) {
            animations = shape.get("animations");
            for (var j2 = animations.length - 1; j2 >= 0; j2--) {
              animation2 = animations[j2];
              isFinished = update(shape, animation2, elapsed);
              if (isFinished) {
                animations.splice(j2, 1);
                isFinished = false;
                if (animation2.callback) {
                  animation2.callback();
                }
              }
            }
          }
          if (animations.length === 0) {
            _this.removeAnimator(i2);
          }
        }
        var autoDraw = _this.canvas.get("autoDraw");
        if (!autoDraw) {
          _this.canvas.draw();
        }
      }
    });
  };
  Timeline2.prototype.addAnimator = function(shape) {
    this.animators.push(shape);
  };
  Timeline2.prototype.removeAnimator = function(index2) {
    this.animators.splice(index2, 1);
  };
  Timeline2.prototype.isAnimating = function() {
    return !!this.animators.length;
  };
  Timeline2.prototype.stop = function() {
    if (this.timer) {
      this.timer.stop();
    }
  };
  Timeline2.prototype.stopAllAnimations = function(toEnd) {
    if (toEnd === void 0) {
      toEnd = true;
    }
    this.animators.forEach(function(animator) {
      animator.stopAnimate(toEnd);
    });
    this.animators = [];
    this.canvas.draw();
  };
  Timeline2.prototype.getTime = function() {
    return this.current;
  };
  return Timeline2;
}();
var CLICK_OFFSET = 40;
var LEFT_BTN_CODE = 0;
var EVENTS$2 = [
  "mousedown",
  "mouseup",
  "dblclick",
  "mouseout",
  "mouseover",
  "mousemove",
  "mouseleave",
  "mouseenter",
  "touchstart",
  "touchmove",
  "touchend",
  "dragenter",
  "dragover",
  "dragleave",
  "drop",
  "contextmenu",
  "mousewheel"
];
function emitTargetEvent(target, type4, eventObj) {
  eventObj.name = type4;
  eventObj.target = target;
  eventObj.currentTarget = target;
  eventObj.delegateTarget = target;
  target.emit(type4, eventObj);
}
function bubbleEvent(container, type4, eventObj) {
  if (eventObj.bubbles) {
    var relativeShape = void 0;
    var isOverEvent = false;
    if (type4 === "mouseenter") {
      relativeShape = eventObj.fromShape;
      isOverEvent = true;
    } else if (type4 === "mouseleave") {
      isOverEvent = true;
      relativeShape = eventObj.toShape;
    }
    if (container.isCanvas() && isOverEvent) {
      return;
    }
    if (relativeShape && isParent(container, relativeShape)) {
      eventObj.bubbles = false;
      return;
    }
    eventObj.name = type4;
    eventObj.currentTarget = container;
    eventObj.delegateTarget = container;
    container.emit(type4, eventObj);
  }
}
var EventController = function() {
  function EventController2(cfg) {
    var _this = this;
    this.draggingShape = null;
    this.dragging = false;
    this.currentShape = null;
    this.mousedownShape = null;
    this.mousedownPoint = null;
    this._eventCallback = function(ev) {
      var type4 = ev.type;
      _this._triggerEvent(type4, ev);
    };
    this._onDocumentMove = function(ev) {
      var canvas = _this.canvas;
      var el = canvas.get("el");
      if (el !== ev.target) {
        if (_this.dragging || _this.currentShape) {
          var pointInfo = _this._getPointInfo(ev);
          if (_this.dragging) {
            _this._emitEvent("drag", ev, pointInfo, _this.draggingShape);
          }
        }
      }
    };
    this._onDocumentMouseUp = function(ev) {
      var canvas = _this.canvas;
      var el = canvas.get("el");
      if (el !== ev.target) {
        if (_this.dragging) {
          var pointInfo = _this._getPointInfo(ev);
          if (_this.draggingShape) {
            _this._emitEvent("drop", ev, pointInfo, null);
          }
          _this._emitEvent("dragend", ev, pointInfo, _this.draggingShape);
          _this._afterDrag(_this.draggingShape, pointInfo, ev);
        }
      }
    };
    this.canvas = cfg.canvas;
  }
  EventController2.prototype.init = function() {
    this._bindEvents();
  };
  EventController2.prototype._bindEvents = function() {
    var _this = this;
    var el = this.canvas.get("el");
    each$1(EVENTS$2, function(eventName) {
      el.addEventListener(eventName, _this._eventCallback);
    });
    if (document) {
      document.addEventListener("mousemove", this._onDocumentMove);
      document.addEventListener("mouseup", this._onDocumentMouseUp);
    }
  };
  EventController2.prototype._clearEvents = function() {
    var _this = this;
    var el = this.canvas.get("el");
    each$1(EVENTS$2, function(eventName) {
      el.removeEventListener(eventName, _this._eventCallback);
    });
    if (document) {
      document.removeEventListener("mousemove", this._onDocumentMove);
      document.removeEventListener("mouseup", this._onDocumentMouseUp);
    }
  };
  EventController2.prototype._getEventObj = function(type4, event, point2, target, fromShape, toShape) {
    var eventObj = new GraphEvent(type4, event);
    eventObj.fromShape = fromShape;
    eventObj.toShape = toShape;
    eventObj.x = point2.x;
    eventObj.y = point2.y;
    eventObj.clientX = point2.clientX;
    eventObj.clientY = point2.clientY;
    eventObj.propagationPath.push(target);
    return eventObj;
  };
  EventController2.prototype._getShape = function(point2, ev) {
    return this.canvas.getShape(point2.x, point2.y, ev);
  };
  EventController2.prototype._getPointInfo = function(ev) {
    var canvas = this.canvas;
    var clientPoint = canvas.getClientByEvent(ev);
    var point2 = canvas.getPointByEvent(ev);
    return {
      x: point2.x,
      y: point2.y,
      clientX: clientPoint.x,
      clientY: clientPoint.y
    };
  };
  EventController2.prototype._triggerEvent = function(type4, ev) {
    var pointInfo = this._getPointInfo(ev);
    var shape = this._getShape(pointInfo, ev);
    var method4 = this["_on" + type4];
    var leaveCanvas = false;
    if (method4) {
      method4.call(this, pointInfo, shape, ev);
    } else {
      var preShape = this.currentShape;
      if (type4 === "mouseenter" || type4 === "dragenter" || type4 === "mouseover") {
        this._emitEvent(type4, ev, pointInfo, null, null, shape);
        if (shape) {
          this._emitEvent(type4, ev, pointInfo, shape, null, shape);
        }
        if (type4 === "mouseenter" && this.draggingShape) {
          this._emitEvent("dragenter", ev, pointInfo, null);
        }
      } else if (type4 === "mouseleave" || type4 === "dragleave" || type4 === "mouseout") {
        leaveCanvas = true;
        if (preShape) {
          this._emitEvent(type4, ev, pointInfo, preShape, preShape, null);
        }
        this._emitEvent(type4, ev, pointInfo, null, preShape, null);
        if (type4 === "mouseleave" && this.draggingShape) {
          this._emitEvent("dragleave", ev, pointInfo, null);
        }
      } else {
        this._emitEvent(type4, ev, pointInfo, shape, null, null);
      }
    }
    if (!leaveCanvas) {
      this.currentShape = shape;
    }
    if (shape && !shape.get("destroyed")) {
      var canvas = this.canvas;
      var el = canvas.get("el");
      el.style.cursor = shape.attr("cursor") || canvas.get("cursor");
    }
  };
  EventController2.prototype._onmousedown = function(pointInfo, shape, event) {
    if (event.button === LEFT_BTN_CODE) {
      this.mousedownShape = shape;
      this.mousedownPoint = pointInfo;
      this.mousedownTimeStamp = event.timeStamp;
    }
    this._emitEvent("mousedown", event, pointInfo, shape, null, null);
  };
  EventController2.prototype._emitMouseoverEvents = function(event, pointInfo, fromShape, toShape) {
    var el = this.canvas.get("el");
    if (fromShape !== toShape) {
      if (fromShape) {
        this._emitEvent("mouseout", event, pointInfo, fromShape, fromShape, toShape);
        this._emitEvent("mouseleave", event, pointInfo, fromShape, fromShape, toShape);
        if (!toShape || toShape.get("destroyed")) {
          el.style.cursor = this.canvas.get("cursor");
        }
      }
      if (toShape) {
        this._emitEvent("mouseover", event, pointInfo, toShape, fromShape, toShape);
        this._emitEvent("mouseenter", event, pointInfo, toShape, fromShape, toShape);
      }
    }
  };
  EventController2.prototype._emitDragoverEvents = function(event, pointInfo, fromShape, toShape, isCanvasEmit) {
    if (toShape) {
      if (toShape !== fromShape) {
        if (fromShape) {
          this._emitEvent("dragleave", event, pointInfo, fromShape, fromShape, toShape);
        }
        this._emitEvent("dragenter", event, pointInfo, toShape, fromShape, toShape);
      }
      if (!isCanvasEmit) {
        this._emitEvent("dragover", event, pointInfo, toShape);
      }
    } else if (fromShape) {
      this._emitEvent("dragleave", event, pointInfo, fromShape, fromShape, toShape);
    }
    if (isCanvasEmit) {
      this._emitEvent("dragover", event, pointInfo, toShape);
    }
  };
  EventController2.prototype._afterDrag = function(draggingShape, pointInfo, event) {
    if (draggingShape) {
      draggingShape.set("capture", true);
      this.draggingShape = null;
    }
    this.dragging = false;
    var shape = this._getShape(pointInfo, event);
    if (shape !== draggingShape) {
      this._emitMouseoverEvents(event, pointInfo, draggingShape, shape);
    }
    this.currentShape = shape;
  };
  EventController2.prototype._onmouseup = function(pointInfo, shape, event) {
    if (event.button === LEFT_BTN_CODE) {
      var draggingShape = this.draggingShape;
      if (this.dragging) {
        if (draggingShape) {
          this._emitEvent("drop", event, pointInfo, shape);
        }
        this._emitEvent("dragend", event, pointInfo, draggingShape);
        this._afterDrag(draggingShape, pointInfo, event);
      } else {
        this._emitEvent("mouseup", event, pointInfo, shape);
        if (shape === this.mousedownShape) {
          this._emitEvent("click", event, pointInfo, shape);
        }
        this.mousedownShape = null;
        this.mousedownPoint = null;
      }
    }
  };
  EventController2.prototype._ondragover = function(pointInfo, shape, event) {
    event.preventDefault();
    var preShape = this.currentShape;
    this._emitDragoverEvents(event, pointInfo, preShape, shape, true);
  };
  EventController2.prototype._onmousemove = function(pointInfo, shape, event) {
    var canvas = this.canvas;
    var preShape = this.currentShape;
    var draggingShape = this.draggingShape;
    if (this.dragging) {
      if (draggingShape) {
        this._emitDragoverEvents(event, pointInfo, preShape, shape, false);
      }
      this._emitEvent("drag", event, pointInfo, draggingShape);
    } else {
      var mousedownPoint = this.mousedownPoint;
      if (mousedownPoint) {
        var mousedownShape = this.mousedownShape;
        var now2 = event.timeStamp;
        var timeWindow = now2 - this.mousedownTimeStamp;
        var dx = mousedownPoint.clientX - pointInfo.clientX;
        var dy = mousedownPoint.clientY - pointInfo.clientY;
        var dist = dx * dx + dy * dy;
        if (timeWindow > 120 || dist > CLICK_OFFSET) {
          if (mousedownShape && mousedownShape.get("draggable")) {
            draggingShape = this.mousedownShape;
            draggingShape.set("capture", false);
            this.draggingShape = draggingShape;
            this.dragging = true;
            this._emitEvent("dragstart", event, pointInfo, draggingShape);
            this.mousedownShape = null;
            this.mousedownPoint = null;
          } else if (!mousedownShape && canvas.get("draggable")) {
            this.dragging = true;
            this._emitEvent("dragstart", event, pointInfo, null);
            this.mousedownShape = null;
            this.mousedownPoint = null;
          } else {
            this._emitMouseoverEvents(event, pointInfo, preShape, shape);
            this._emitEvent("mousemove", event, pointInfo, shape);
          }
        } else {
          this._emitMouseoverEvents(event, pointInfo, preShape, shape);
          this._emitEvent("mousemove", event, pointInfo, shape);
        }
      } else {
        this._emitMouseoverEvents(event, pointInfo, preShape, shape);
        this._emitEvent("mousemove", event, pointInfo, shape);
      }
    }
  };
  EventController2.prototype._emitEvent = function(type4, event, pointInfo, shape, fromShape, toShape) {
    var eventObj = this._getEventObj(type4, event, pointInfo, shape, fromShape, toShape);
    if (shape) {
      eventObj.shape = shape;
      emitTargetEvent(shape, type4, eventObj);
      var parent_1 = shape.getParent();
      while (parent_1) {
        parent_1.emitDelegation(type4, eventObj);
        if (!eventObj.propagationStopped) {
          bubbleEvent(parent_1, type4, eventObj);
        }
        eventObj.propagationPath.push(parent_1);
        parent_1 = parent_1.getParent();
      }
    } else {
      var canvas = this.canvas;
      emitTargetEvent(canvas, type4, eventObj);
    }
  };
  EventController2.prototype.destroy = function() {
    this._clearEvents();
    this.canvas = null;
    this.currentShape = null;
    this.draggingShape = null;
    this.mousedownPoint = null;
    this.mousedownShape = null;
    this.mousedownTimeStamp = null;
  };
  return EventController2;
}();
var PX_SUFFIX = "px";
var browser = detect();
var isFirefox = browser && browser.name === "firefox";
var Canvas$2 = function(_super) {
  __extends$3(Canvas2, _super);
  function Canvas2(cfg) {
    var _this = _super.call(this, cfg) || this;
    _this.initContainer();
    _this.initDom();
    _this.initEvents();
    _this.initTimeline();
    return _this;
  }
  Canvas2.prototype.getDefaultCfg = function() {
    var cfg = _super.prototype.getDefaultCfg.call(this);
    cfg["cursor"] = "default";
    cfg["supportCSSTransform"] = false;
    return cfg;
  };
  Canvas2.prototype.initContainer = function() {
    var container = this.get("container");
    if (isString(container)) {
      container = document.getElementById(container);
      this.set("container", container);
    }
  };
  Canvas2.prototype.initDom = function() {
    var el = this.createDom();
    this.set("el", el);
    var container = this.get("container");
    container.appendChild(el);
    this.setDOMSize(this.get("width"), this.get("height"));
  };
  Canvas2.prototype.initEvents = function() {
    var eventController = new EventController({
      canvas: this
    });
    eventController.init();
    this.set("eventController", eventController);
  };
  Canvas2.prototype.initTimeline = function() {
    var timeline = new Timeline(this);
    this.set("timeline", timeline);
  };
  Canvas2.prototype.setDOMSize = function(width, height) {
    var el = this.get("el");
    if (isBrowser) {
      el.style.width = width + PX_SUFFIX;
      el.style.height = height + PX_SUFFIX;
    }
  };
  Canvas2.prototype.changeSize = function(width, height) {
    this.setDOMSize(width, height);
    this.set("width", width);
    this.set("height", height);
    this.onCanvasChange("changeSize");
  };
  Canvas2.prototype.getRenderer = function() {
    return this.get("renderer");
  };
  Canvas2.prototype.getCursor = function() {
    return this.get("cursor");
  };
  Canvas2.prototype.setCursor = function(cursor) {
    this.set("cursor", cursor);
    var el = this.get("el");
    if (isBrowser && el) {
      el.style.cursor = cursor;
    }
  };
  Canvas2.prototype.getPointByEvent = function(ev) {
    var supportCSSTransform = this.get("supportCSSTransform");
    if (supportCSSTransform) {
      if (isFirefox && !isNil(ev.layerX) && ev.layerX !== ev.offsetX) {
        return {
          x: ev.layerX,
          y: ev.layerY
        };
      }
      if (!isNil(ev.offsetX)) {
        return {
          x: ev.offsetX,
          y: ev.offsetY
        };
      }
    }
    var _a2 = this.getClientByEvent(ev), clientX = _a2.x, clientY = _a2.y;
    return this.getPointByClient(clientX, clientY);
  };
  Canvas2.prototype.getClientByEvent = function(ev) {
    var clientInfo = ev;
    if (ev.touches) {
      if (ev.type === "touchend") {
        clientInfo = ev.changedTouches[0];
      } else {
        clientInfo = ev.touches[0];
      }
    }
    return {
      x: clientInfo.clientX,
      y: clientInfo.clientY
    };
  };
  Canvas2.prototype.getPointByClient = function(clientX, clientY) {
    var el = this.get("el");
    var bbox = el.getBoundingClientRect();
    return {
      x: clientX - bbox.left,
      y: clientY - bbox.top
    };
  };
  Canvas2.prototype.getClientByPoint = function(x2, y2) {
    var el = this.get("el");
    var bbox = el.getBoundingClientRect();
    return {
      x: x2 + bbox.left,
      y: y2 + bbox.top
    };
  };
  Canvas2.prototype.draw = function() {
  };
  Canvas2.prototype.removeDom = function() {
    var el = this.get("el");
    el.parentNode.removeChild(el);
  };
  Canvas2.prototype.clearEvents = function() {
    var eventController = this.get("eventController");
    eventController.destroy();
  };
  Canvas2.prototype.isCanvas = function() {
    return true;
  };
  Canvas2.prototype.getParent = function() {
    return null;
  };
  Canvas2.prototype.destroy = function() {
    var timeline = this.get("timeline");
    if (this.get("destroyed")) {
      return;
    }
    this.clear();
    if (timeline) {
      timeline.stop();
    }
    this.clearEvents();
    this.removeDom();
    _super.prototype.destroy.call(this);
  };
  return Canvas2;
}(Container);
var AbstractGroup = function(_super) {
  __extends$3(AbstractGroup2, _super);
  function AbstractGroup2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  AbstractGroup2.prototype.isGroup = function() {
    return true;
  };
  AbstractGroup2.prototype.isEntityGroup = function() {
    return false;
  };
  AbstractGroup2.prototype.clone = function() {
    var clone3 = _super.prototype.clone.call(this);
    var children = this.getChildren();
    for (var i2 = 0; i2 < children.length; i2++) {
      var child = children[i2];
      clone3.add(child.clone());
    }
    return clone3;
  };
  return AbstractGroup2;
}(Container);
var AbstractShape = function(_super) {
  __extends$3(AbstractShape2, _super);
  function AbstractShape2(cfg) {
    return _super.call(this, cfg) || this;
  }
  AbstractShape2.prototype._isInBBox = function(refX, refY) {
    var bbox = this.getBBox();
    return bbox.minX <= refX && bbox.maxX >= refX && bbox.minY <= refY && bbox.maxY >= refY;
  };
  AbstractShape2.prototype.afterAttrsChange = function(targetAttrs) {
    _super.prototype.afterAttrsChange.call(this, targetAttrs);
    this.clearCacheBBox();
  };
  AbstractShape2.prototype.getBBox = function() {
    var bbox = this.cfg.bbox;
    if (!bbox) {
      bbox = this.calculateBBox();
      this.set("bbox", bbox);
    }
    return bbox;
  };
  AbstractShape2.prototype.getCanvasBBox = function() {
    var canvasBBox = this.cfg.canvasBBox;
    if (!canvasBBox) {
      canvasBBox = this.calculateCanvasBBox();
      this.set("canvasBBox", canvasBBox);
    }
    return canvasBBox;
  };
  AbstractShape2.prototype.applyMatrix = function(matrix) {
    _super.prototype.applyMatrix.call(this, matrix);
    this.set("canvasBBox", null);
  };
  AbstractShape2.prototype.calculateCanvasBBox = function() {
    var bbox = this.getBBox();
    var totalMatrix = this.getTotalMatrix();
    var minX = bbox.minX, minY = bbox.minY, maxX = bbox.maxX, maxY2 = bbox.maxY;
    if (totalMatrix) {
      var topLeft = multiplyVec2$1(totalMatrix, [bbox.minX, bbox.minY]);
      var topRight = multiplyVec2$1(totalMatrix, [bbox.maxX, bbox.minY]);
      var bottomLeft = multiplyVec2$1(totalMatrix, [bbox.minX, bbox.maxY]);
      var bottomRight = multiplyVec2$1(totalMatrix, [bbox.maxX, bbox.maxY]);
      minX = Math.min(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]);
      maxX = Math.max(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]);
      minY = Math.min(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1]);
      maxY2 = Math.max(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1]);
    }
    var attrs = this.attrs;
    if (attrs.shadowColor) {
      var _a2 = attrs.shadowBlur, shadowBlur = _a2 === void 0 ? 0 : _a2, _b = attrs.shadowOffsetX, shadowOffsetX = _b === void 0 ? 0 : _b, _c = attrs.shadowOffsetY, shadowOffsetY = _c === void 0 ? 0 : _c;
      var shadowLeft = minX - shadowBlur + shadowOffsetX;
      var shadowRight = maxX + shadowBlur + shadowOffsetX;
      var shadowTop = minY - shadowBlur + shadowOffsetY;
      var shadowBottom = maxY2 + shadowBlur + shadowOffsetY;
      minX = Math.min(minX, shadowLeft);
      maxX = Math.max(maxX, shadowRight);
      minY = Math.min(minY, shadowTop);
      maxY2 = Math.max(maxY2, shadowBottom);
    }
    return {
      x: minX,
      y: minY,
      minX,
      minY,
      maxX,
      maxY: maxY2,
      width: maxX - minX,
      height: maxY2 - minY
    };
  };
  AbstractShape2.prototype.clearCacheBBox = function() {
    this.set("bbox", null);
    this.set("canvasBBox", null);
  };
  AbstractShape2.prototype.isClipShape = function() {
    return this.get("isClipShape");
  };
  AbstractShape2.prototype.isInShape = function(refX, refY) {
    return false;
  };
  AbstractShape2.prototype.isOnlyHitBox = function() {
    return false;
  };
  AbstractShape2.prototype.isHit = function(x2, y2) {
    var startArrowShape = this.get("startArrowShape");
    var endArrowShape = this.get("endArrowShape");
    var vec = [x2, y2, 1];
    vec = this.invertFromMatrix(vec);
    var refX = vec[0], refY = vec[1];
    var inBBox = this._isInBBox(refX, refY);
    if (this.isOnlyHitBox()) {
      return inBBox;
    }
    if (inBBox && !this.isClipped(refX, refY)) {
      if (this.isInShape(refX, refY)) {
        return true;
      }
      if (startArrowShape && startArrowShape.isHit(refX, refY)) {
        return true;
      }
      if (endArrowShape && endArrowShape.isHit(refX, refY)) {
        return true;
      }
    }
    return false;
  };
  return AbstractShape2;
}(Element$2);
var cache$1 = /* @__PURE__ */ new Map();
function register(type4, method4) {
  cache$1.set(type4, method4);
}
function getMethod(type4) {
  return cache$1.get(type4);
}
function rect$1(shape) {
  var attrs = shape.attr();
  var x2 = attrs.x, y2 = attrs.y, width = attrs.width, height = attrs.height;
  return {
    x: x2,
    y: y2,
    width,
    height
  };
}
function circle$1(shape) {
  var _a2 = shape.attr(), x2 = _a2.x, y2 = _a2.y, r2 = _a2.r;
  return {
    x: x2 - r2,
    y: y2 - r2,
    width: r2 * 2,
    height: r2 * 2
  };
}
function minNum(array4) {
  return Math.min.apply(null, array4);
}
function maxNum(array4) {
  return Math.max.apply(null, array4);
}
function distance$5(x1, y1, x2, y2) {
  var dx = x1 - x2;
  var dy = y1 - y2;
  return Math.sqrt(dx * dx + dy * dy);
}
function isNumberEqual(v1, v2) {
  return Math.abs(v1 - v2) < 1e-3;
}
function getBBoxByArray(xArr, yArr) {
  var minX = minNum(xArr);
  var minY = minNum(yArr);
  var maxX = maxNum(xArr);
  var maxY2 = maxNum(yArr);
  return {
    x: minX,
    y: minY,
    width: maxX - minX,
    height: maxY2 - minY
  };
}
function piMod(angle2) {
  return (angle2 + Math.PI * 2) % (Math.PI * 2);
}
var LineUtil = {
  box: function(x1, y1, x2, y2) {
    return getBBoxByArray([x1, x2], [y1, y2]);
  },
  length: function(x1, y1, x2, y2) {
    return distance$5(x1, y1, x2, y2);
  },
  pointAt: function(x1, y1, x2, y2, t2) {
    return {
      x: (1 - t2) * x1 + t2 * x2,
      y: (1 - t2) * y1 + t2 * y2
    };
  },
  pointDistance: function(x1, y1, x2, y2, x3, y3) {
    var cross = (x2 - x1) * (x3 - x1) + (y2 - y1) * (y3 - y1);
    if (cross < 0) {
      return distance$5(x1, y1, x3, y3);
    }
    var lengthSquare = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);
    if (cross > lengthSquare) {
      return distance$5(x2, y2, x3, y3);
    }
    return this.pointToLine(x1, y1, x2, y2, x3, y3);
  },
  pointToLine: function(x1, y1, x2, y2, x3, y3) {
    var d2 = [x2 - x1, y2 - y1];
    if (exactEquals(d2, [0, 0])) {
      return Math.sqrt((x3 - x1) * (x3 - x1) + (y3 - y1) * (y3 - y1));
    }
    var u2 = [-d2[1], d2[0]];
    normalize(u2, u2);
    var a2 = [x3 - x1, y3 - y1];
    return Math.abs(dot$2(a2, u2));
  },
  tangentAngle: function(x1, y1, x2, y2) {
    return Math.atan2(y2 - y1, x2 - x1);
  }
};
var EPSILON = 1e-4;
function nearestPoint(xArr, yArr, x2, y2, tCallback, length2) {
  var t2;
  var d2 = Infinity;
  var v0 = [x2, y2];
  var segNum = 20;
  if (length2 && length2 > 200) {
    segNum = length2 / 10;
  }
  var increaseRate = 1 / segNum;
  var interval2 = increaseRate / 10;
  for (var i2 = 0; i2 <= segNum; i2++) {
    var _t = i2 * increaseRate;
    var v1 = [tCallback.apply(null, xArr.concat([_t])), tCallback.apply(null, yArr.concat([_t]))];
    var d1 = distance$5(v0[0], v0[1], v1[0], v1[1]);
    if (d1 < d2) {
      t2 = _t;
      d2 = d1;
    }
  }
  if (t2 === 0) {
    return {
      x: xArr[0],
      y: yArr[0]
    };
  }
  if (t2 === 1) {
    var count2 = xArr.length;
    return {
      x: xArr[count2 - 1],
      y: yArr[count2 - 1]
    };
  }
  d2 = Infinity;
  for (var i2 = 0; i2 < 32; i2++) {
    if (interval2 < EPSILON) {
      break;
    }
    var prev = t2 - interval2;
    var next = t2 + interval2;
    var v1 = [tCallback.apply(null, xArr.concat([prev])), tCallback.apply(null, yArr.concat([prev]))];
    var d1 = distance$5(v0[0], v0[1], v1[0], v1[1]);
    if (prev >= 0 && d1 < d2) {
      t2 = prev;
      d2 = d1;
    } else {
      var v2 = [tCallback.apply(null, xArr.concat([next])), tCallback.apply(null, yArr.concat([next]))];
      var d22 = distance$5(v0[0], v0[1], v2[0], v2[1]);
      if (next <= 1 && d22 < d2) {
        t2 = next;
        d2 = d22;
      } else {
        interval2 *= 0.5;
      }
    }
  }
  return {
    x: tCallback.apply(null, xArr.concat([t2])),
    y: tCallback.apply(null, yArr.concat([t2]))
  };
}
function snapLength(xArr, yArr) {
  var totalLength = 0;
  var count2 = xArr.length;
  for (var i2 = 0; i2 < count2; i2++) {
    var x2 = xArr[i2];
    var y2 = yArr[i2];
    var nextX = xArr[(i2 + 1) % count2];
    var nextY = yArr[(i2 + 1) % count2];
    totalLength += distance$5(x2, y2, nextX, nextY);
  }
  return totalLength / 2;
}
function quadraticAt(p0, p1, p2, t2) {
  var onet = 1 - t2;
  return onet * onet * p0 + 2 * t2 * onet * p1 + t2 * t2 * p2;
}
function extrema$1(p0, p1, p2) {
  var a2 = p0 + p2 - 2 * p1;
  if (isNumberEqual(a2, 0)) {
    return [0.5];
  }
  var rst = (p0 - p1) / a2;
  if (rst <= 1 && rst >= 0) {
    return [rst];
  }
  return [];
}
function derivativeAt$1(p0, p1, p2, t2) {
  return 2 * (1 - t2) * (p1 - p0) + 2 * t2 * (p2 - p1);
}
function divideQuadratic(x1, y1, x2, y2, x3, y3, t2) {
  var xt = quadraticAt(x1, x2, x3, t2);
  var yt = quadraticAt(y1, y2, y3, t2);
  var controlPoint1 = LineUtil.pointAt(x1, y1, x2, y2, t2);
  var controlPoint2 = LineUtil.pointAt(x2, y2, x3, y3, t2);
  return [
    [x1, y1, controlPoint1.x, controlPoint1.y, xt, yt],
    [xt, yt, controlPoint2.x, controlPoint2.y, x3, y3]
  ];
}
function quadraticLength(x1, y1, x2, y2, x3, y3, iterationCount) {
  if (iterationCount === 0) {
    return (distance$5(x1, y1, x2, y2) + distance$5(x2, y2, x3, y3) + distance$5(x1, y1, x3, y3)) / 2;
  }
  var quadratics = divideQuadratic(x1, y1, x2, y2, x3, y3, 0.5);
  var left2 = quadratics[0];
  var right2 = quadratics[1];
  left2.push(iterationCount - 1);
  right2.push(iterationCount - 1);
  return quadraticLength.apply(null, left2) + quadraticLength.apply(null, right2);
}
var QuadUtil = {
  box: function(x1, y1, x2, y2, x3, y3) {
    var xExtrema2 = extrema$1(x1, x2, x3)[0];
    var yExtrema2 = extrema$1(y1, y2, y3)[0];
    var xArr = [x1, x3];
    var yArr = [y1, y3];
    if (xExtrema2 !== void 0) {
      xArr.push(quadraticAt(x1, x2, x3, xExtrema2));
    }
    if (yExtrema2 !== void 0) {
      yArr.push(quadraticAt(y1, y2, y3, yExtrema2));
    }
    return getBBoxByArray(xArr, yArr);
  },
  length: function(x1, y1, x2, y2, x3, y3) {
    return quadraticLength(x1, y1, x2, y2, x3, y3, 3);
  },
  nearestPoint: function(x1, y1, x2, y2, x3, y3, x0, y0) {
    return nearestPoint([x1, x2, x3], [y1, y2, y3], x0, y0, quadraticAt);
  },
  pointDistance: function(x1, y1, x2, y2, x3, y3, x0, y0) {
    var point2 = this.nearestPoint(x1, y1, x2, y2, x3, y3, x0, y0);
    return distance$5(point2.x, point2.y, x0, y0);
  },
  interpolationAt: quadraticAt,
  pointAt: function(x1, y1, x2, y2, x3, y3, t2) {
    return {
      x: quadraticAt(x1, x2, x3, t2),
      y: quadraticAt(y1, y2, y3, t2)
    };
  },
  divide: function(x1, y1, x2, y2, x3, y3, t2) {
    return divideQuadratic(x1, y1, x2, y2, x3, y3, t2);
  },
  tangentAngle: function(x1, y1, x2, y2, x3, y3, t2) {
    var dx = derivativeAt$1(x1, x2, x3, t2);
    var dy = derivativeAt$1(y1, y2, y3, t2);
    var angle2 = Math.atan2(dy, dx);
    return piMod(angle2);
  }
};
function cubicAt(p0, p1, p2, p3, t2) {
  var onet = 1 - t2;
  return onet * onet * onet * p0 + 3 * p1 * t2 * onet * onet + 3 * p2 * t2 * t2 * onet + p3 * t2 * t2 * t2;
}
function derivativeAt(p0, p1, p2, p3, t2) {
  var onet = 1 - t2;
  return 3 * (onet * onet * (p1 - p0) + 2 * onet * t2 * (p2 - p1) + t2 * t2 * (p3 - p2));
}
function extrema(p0, p1, p2, p3) {
  var a2 = -3 * p0 + 9 * p1 - 9 * p2 + 3 * p3;
  var b10 = 6 * p0 - 12 * p1 + 6 * p2;
  var c2 = 3 * p1 - 3 * p0;
  var extremas = [];
  var t1;
  var t2;
  var discSqrt;
  if (isNumberEqual(a2, 0)) {
    if (!isNumberEqual(b10, 0)) {
      t1 = -c2 / b10;
      if (t1 >= 0 && t1 <= 1) {
        extremas.push(t1);
      }
    }
  } else {
    var disc = b10 * b10 - 4 * a2 * c2;
    if (isNumberEqual(disc, 0)) {
      extremas.push(-b10 / (2 * a2));
    } else if (disc > 0) {
      discSqrt = Math.sqrt(disc);
      t1 = (-b10 + discSqrt) / (2 * a2);
      t2 = (-b10 - discSqrt) / (2 * a2);
      if (t1 >= 0 && t1 <= 1) {
        extremas.push(t1);
      }
      if (t2 >= 0 && t2 <= 1) {
        extremas.push(t2);
      }
    }
  }
  return extremas;
}
function divideCubic(x1, y1, x2, y2, x3, y3, x4, y4, t2) {
  var xt = cubicAt(x1, x2, x3, x4, t2);
  var yt = cubicAt(y1, y2, y3, y4, t2);
  var c1 = LineUtil.pointAt(x1, y1, x2, y2, t2);
  var c2 = LineUtil.pointAt(x2, y2, x3, y3, t2);
  var c3 = LineUtil.pointAt(x3, y3, x4, y4, t2);
  var c12 = LineUtil.pointAt(c1.x, c1.y, c2.x, c2.y, t2);
  var c23 = LineUtil.pointAt(c2.x, c2.y, c3.x, c3.y, t2);
  return [
    [x1, y1, c1.x, c1.y, c12.x, c12.y, xt, yt],
    [xt, yt, c23.x, c23.y, c3.x, c3.y, x4, y4]
  ];
}
function cubicLength(x1, y1, x2, y2, x3, y3, x4, y4, iterationCount) {
  if (iterationCount === 0) {
    return snapLength([x1, x2, x3, x4], [y1, y2, y3, y4]);
  }
  var cubics = divideCubic(x1, y1, x2, y2, x3, y3, x4, y4, 0.5);
  var left2 = cubics[0];
  var right2 = cubics[1];
  left2.push(iterationCount - 1);
  right2.push(iterationCount - 1);
  return cubicLength.apply(null, left2) + cubicLength.apply(null, right2);
}
var CubicUtil = {
  extrema,
  box: function(x1, y1, x2, y2, x3, y3, x4, y4) {
    var xArr = [x1, x4];
    var yArr = [y1, y4];
    var xExtrema2 = extrema(x1, x2, x3, x4);
    var yExtrema2 = extrema(y1, y2, y3, y4);
    for (var i2 = 0; i2 < xExtrema2.length; i2++) {
      xArr.push(cubicAt(x1, x2, x3, x4, xExtrema2[i2]));
    }
    for (var i2 = 0; i2 < yExtrema2.length; i2++) {
      yArr.push(cubicAt(y1, y2, y3, y4, yExtrema2[i2]));
    }
    return getBBoxByArray(xArr, yArr);
  },
  length: function(x1, y1, x2, y2, x3, y3, x4, y4) {
    return cubicLength(x1, y1, x2, y2, x3, y3, x4, y4, 3);
  },
  nearestPoint: function(x1, y1, x2, y2, x3, y3, x4, y4, x0, y0, length2) {
    return nearestPoint([x1, x2, x3, x4], [y1, y2, y3, y4], x0, y0, cubicAt, length2);
  },
  pointDistance: function(x1, y1, x2, y2, x3, y3, x4, y4, x0, y0, length2) {
    var point2 = this.nearestPoint(x1, y1, x2, y2, x3, y3, x4, y4, x0, y0, length2);
    return distance$5(point2.x, point2.y, x0, y0);
  },
  interpolationAt: cubicAt,
  pointAt: function(x1, y1, x2, y2, x3, y3, x4, y4, t2) {
    return {
      x: cubicAt(x1, x2, x3, x4, t2),
      y: cubicAt(y1, y2, y3, y4, t2)
    };
  },
  divide: function(x1, y1, x2, y2, x3, y3, x4, y4, t2) {
    return divideCubic(x1, y1, x2, y2, x3, y3, x4, y4, t2);
  },
  tangentAngle: function(x1, y1, x2, y2, x3, y3, x4, y4, t2) {
    var dx = derivativeAt(x1, x2, x3, x4, t2);
    var dy = derivativeAt(y1, y2, y3, y4, t2);
    return piMod(Math.atan2(dy, dx));
  }
};
function copysign(v1, v2) {
  var absv = Math.abs(v1);
  return v2 > 0 ? absv : absv * -1;
}
var ellipse$1 = {
  box: function(x2, y2, rx, ry) {
    return {
      x: x2 - rx,
      y: y2 - ry,
      width: rx * 2,
      height: ry * 2
    };
  },
  length: function(x2, y2, rx, ry) {
    return Math.PI * (3 * (rx + ry) - Math.sqrt((3 * rx + ry) * (rx + 3 * ry)));
  },
  nearestPoint: function(x2, y2, rx, ry, x0, y0) {
    var a2 = rx;
    var b10 = ry;
    if (a2 === 0 || b10 === 0) {
      return {
        x: x2,
        y: y2
      };
    }
    var relativeX = x0 - x2;
    var relativeY = y0 - y2;
    var px = Math.abs(relativeX);
    var py = Math.abs(relativeY);
    var squareA = a2 * a2;
    var squareB = b10 * b10;
    var t2 = Math.PI / 4;
    var nearestX;
    var nearestY;
    for (var i2 = 0; i2 < 4; i2++) {
      nearestX = a2 * Math.cos(t2);
      nearestY = b10 * Math.sin(t2);
      var ex = (squareA - squareB) * Math.pow(Math.cos(t2), 3) / a2;
      var ey = (squareB - squareA) * Math.pow(Math.sin(t2), 3) / b10;
      var rx1 = nearestX - ex;
      var ry1 = nearestY - ey;
      var qx = px - ex;
      var qy = py - ey;
      var r2 = Math.hypot(ry1, rx1);
      var q2 = Math.hypot(qy, qx);
      var delta_c = r2 * Math.asin((rx1 * qy - ry1 * qx) / (r2 * q2));
      var delta_t = delta_c / Math.sqrt(squareA + squareB - nearestX * nearestX - nearestY * nearestY);
      t2 += delta_t;
      t2 = Math.min(Math.PI / 2, Math.max(0, t2));
    }
    return {
      x: x2 + copysign(nearestX, relativeX),
      y: y2 + copysign(nearestY, relativeY)
    };
  },
  pointDistance: function(x2, y2, rx, ry, x0, y0) {
    var nearestPoint2 = this.nearestPoint(x2, y2, rx, ry, x0, y0);
    return distance$5(nearestPoint2.x, nearestPoint2.y, x0, y0);
  },
  pointAt: function(x2, y2, rx, ry, t2) {
    var angle2 = 2 * Math.PI * t2;
    return {
      x: x2 + rx * Math.cos(angle2),
      y: y2 + ry * Math.sin(angle2)
    };
  },
  tangentAngle: function(x2, y2, rx, ry, t2) {
    var angle2 = 2 * Math.PI * t2;
    var tangentAngle = Math.atan2(ry * Math.cos(angle2), -rx * Math.sin(angle2));
    return piMod(tangentAngle);
  }
};
function derivativeXAt(cx, cy, rx, ry, xRotation, startAngle, endAngle, angle2) {
  return -1 * rx * Math.cos(xRotation) * Math.sin(angle2) - ry * Math.sin(xRotation) * Math.cos(angle2);
}
function derivativeYAt(cx, cy, rx, ry, xRotation, startAngle, endAngle, angle2) {
  return -1 * rx * Math.sin(xRotation) * Math.sin(angle2) + ry * Math.cos(xRotation) * Math.cos(angle2);
}
function xExtrema(rx, ry, xRotation) {
  return Math.atan(-ry / rx * Math.tan(xRotation));
}
function yExtrema(rx, ry, xRotation) {
  return Math.atan(ry / (rx * Math.tan(xRotation)));
}
function xAt(cx, cy, rx, ry, xRotation, angle2) {
  return rx * Math.cos(xRotation) * Math.cos(angle2) - ry * Math.sin(xRotation) * Math.sin(angle2) + cx;
}
function yAt(cx, cy, rx, ry, xRotation, angle2) {
  return rx * Math.sin(xRotation) * Math.cos(angle2) + ry * Math.cos(xRotation) * Math.sin(angle2) + cy;
}
function getAngle$2(rx, ry, x0, y0) {
  var angle2 = Math.atan2(y0 * rx, x0 * ry);
  return (angle2 + Math.PI * 2) % (Math.PI * 2);
}
function getPoint(rx, ry, angle2) {
  return {
    x: rx * Math.cos(angle2),
    y: ry * Math.sin(angle2)
  };
}
function rotate$1(x2, y2, angle2) {
  var cos2 = Math.cos(angle2);
  var sin2 = Math.sin(angle2);
  return [x2 * cos2 - y2 * sin2, x2 * sin2 + y2 * cos2];
}
var EllipseArcUtil = {
  box: function(cx, cy, rx, ry, xRotation, startAngle, endAngle) {
    var xDim = xExtrema(rx, ry, xRotation);
    var minX = Infinity;
    var maxX = -Infinity;
    var xs = [startAngle, endAngle];
    for (var i2 = -Math.PI * 2; i2 <= Math.PI * 2; i2 += Math.PI) {
      var xAngle = xDim + i2;
      if (startAngle < endAngle) {
        if (startAngle < xAngle && xAngle < endAngle) {
          xs.push(xAngle);
        }
      } else {
        if (endAngle < xAngle && xAngle < startAngle) {
          xs.push(xAngle);
        }
      }
    }
    for (var i2 = 0; i2 < xs.length; i2++) {
      var x2 = xAt(cx, cy, rx, ry, xRotation, xs[i2]);
      if (x2 < minX) {
        minX = x2;
      }
      if (x2 > maxX) {
        maxX = x2;
      }
    }
    var yDim = yExtrema(rx, ry, xRotation);
    var minY = Infinity;
    var maxY2 = -Infinity;
    var ys = [startAngle, endAngle];
    for (var i2 = -Math.PI * 2; i2 <= Math.PI * 2; i2 += Math.PI) {
      var yAngle = yDim + i2;
      if (startAngle < endAngle) {
        if (startAngle < yAngle && yAngle < endAngle) {
          ys.push(yAngle);
        }
      } else {
        if (endAngle < yAngle && yAngle < startAngle) {
          ys.push(yAngle);
        }
      }
    }
    for (var i2 = 0; i2 < ys.length; i2++) {
      var y2 = yAt(cx, cy, rx, ry, xRotation, ys[i2]);
      if (y2 < minY) {
        minY = y2;
      }
      if (y2 > maxY2) {
        maxY2 = y2;
      }
    }
    return {
      x: minX,
      y: minY,
      width: maxX - minX,
      height: maxY2 - minY
    };
  },
  length: function(cx, cy, rx, ry, xRotation, startAngle, endAngle) {
  },
  nearestPoint: function(cx, cy, rx, ry, xRotation, startAngle, endAngle, x0, y0) {
    var relativeVector = rotate$1(x0 - cx, y0 - cy, -xRotation);
    var x1 = relativeVector[0], y1 = relativeVector[1];
    var relativePoint = ellipse$1.nearestPoint(0, 0, rx, ry, x1, y1);
    var angle2 = getAngle$2(rx, ry, relativePoint.x, relativePoint.y);
    if (angle2 < startAngle) {
      relativePoint = getPoint(rx, ry, startAngle);
    } else if (angle2 > endAngle) {
      relativePoint = getPoint(rx, ry, endAngle);
    }
    var vector = rotate$1(relativePoint.x, relativePoint.y, xRotation);
    return {
      x: vector[0] + cx,
      y: vector[1] + cy
    };
  },
  pointDistance: function(cx, cy, rx, ry, xRotation, startAngle, endAngle, x0, y0) {
    var nearestPoint2 = this.nearestPoint(cx, cy, rx, ry, x0, y0);
    return distance$5(nearestPoint2.x, nearestPoint2.y, x0, y0);
  },
  pointAt: function(cx, cy, rx, ry, xRotation, startAngle, endAngle, t2) {
    var angle2 = (endAngle - startAngle) * t2 + startAngle;
    return {
      x: xAt(cx, cy, rx, ry, xRotation, angle2),
      y: yAt(cx, cy, rx, ry, xRotation, angle2)
    };
  },
  tangentAngle: function(cx, cy, rx, ry, xRotation, startAngle, endAngle, t2) {
    var angle2 = (endAngle - startAngle) * t2 + startAngle;
    var dx = derivativeXAt(cx, cy, rx, ry, xRotation, startAngle, endAngle, angle2);
    var dy = derivativeYAt(cx, cy, rx, ry, xRotation, startAngle, endAngle, angle2);
    return piMod(Math.atan2(dy, dx));
  }
};
function analyzePoints(points2) {
  var totalLength = 0;
  var segments = [];
  for (var i2 = 0; i2 < points2.length - 1; i2++) {
    var from = points2[i2];
    var to = points2[i2 + 1];
    var length_1 = distance$5(from[0], from[1], to[0], to[1]);
    var seg = {
      from,
      to,
      length: length_1
    };
    segments.push(seg);
    totalLength += length_1;
  }
  return { segments, totalLength };
}
function lengthOfSegment(points2) {
  if (points2.length < 2) {
    return 0;
  }
  var totalLength = 0;
  for (var i2 = 0; i2 < points2.length - 1; i2++) {
    var from = points2[i2];
    var to = points2[i2 + 1];
    totalLength += distance$5(from[0], from[1], to[0], to[1]);
  }
  return totalLength;
}
function pointAtSegments(points2, t2) {
  if (t2 > 1 || t2 < 0 || points2.length < 2) {
    return null;
  }
  var _a2 = analyzePoints(points2), segments = _a2.segments, totalLength = _a2.totalLength;
  if (totalLength === 0) {
    return {
      x: points2[0][0],
      y: points2[0][1]
    };
  }
  var startRatio = 0;
  var point2 = null;
  for (var i2 = 0; i2 < segments.length; i2++) {
    var seg = segments[i2];
    var from = seg.from, to = seg.to;
    var currentRatio = seg.length / totalLength;
    if (t2 >= startRatio && t2 <= startRatio + currentRatio) {
      var localRatio = (t2 - startRatio) / currentRatio;
      point2 = LineUtil.pointAt(from[0], from[1], to[0], to[1], localRatio);
      break;
    }
    startRatio += currentRatio;
  }
  return point2;
}
function angleAtSegments(points2, t2) {
  if (t2 > 1 || t2 < 0 || points2.length < 2) {
    return 0;
  }
  var _a2 = analyzePoints(points2), segments = _a2.segments, totalLength = _a2.totalLength;
  var startRatio = 0;
  var angle2 = 0;
  for (var i2 = 0; i2 < segments.length; i2++) {
    var seg = segments[i2];
    var from = seg.from, to = seg.to;
    var currentRatio = seg.length / totalLength;
    if (t2 >= startRatio && t2 <= startRatio + currentRatio) {
      angle2 = Math.atan2(to[1] - from[1], to[0] - from[0]);
      break;
    }
    startRatio += currentRatio;
  }
  return angle2;
}
function distanceAtSegment(points2, x2, y2) {
  var minDistance = Infinity;
  for (var i2 = 0; i2 < points2.length - 1; i2++) {
    var point2 = points2[i2];
    var nextPoint = points2[i2 + 1];
    var distance_1 = LineUtil.pointDistance(point2[0], point2[1], nextPoint[0], nextPoint[1], x2, y2);
    if (distance_1 < minDistance) {
      minDistance = distance_1;
    }
  }
  return minDistance;
}
var PolylineUtil = {
  box: function(points2) {
    var xArr = [];
    var yArr = [];
    for (var i2 = 0; i2 < points2.length; i2++) {
      var point2 = points2[i2];
      xArr.push(point2[0]);
      yArr.push(point2[1]);
    }
    return getBBoxByArray(xArr, yArr);
  },
  length: function(points2) {
    return lengthOfSegment(points2);
  },
  pointAt: function(points2, t2) {
    return pointAtSegments(points2, t2);
  },
  pointDistance: function(points2, x2, y2) {
    return distanceAtSegment(points2, x2, y2);
  },
  tangentAngle: function(points2, t2) {
    return angleAtSegments(points2, t2);
  }
};
function mergeBBox(bbox1, bbox2) {
  if (!bbox1 || !bbox2) {
    return bbox1 || bbox2;
  }
  return {
    minX: Math.min(bbox1.minX, bbox2.minX),
    minY: Math.min(bbox1.minY, bbox2.minY),
    maxX: Math.max(bbox1.maxX, bbox2.maxX),
    maxY: Math.max(bbox1.maxY, bbox2.maxY)
  };
}
function mergeArrowBBox(shape, bbox) {
  var startArrowShape = shape.get("startArrowShape");
  var endArrowShape = shape.get("endArrowShape");
  var startArrowBBox = null;
  var endArrowBBox = null;
  if (startArrowShape) {
    startArrowBBox = startArrowShape.getCanvasBBox();
    bbox = mergeBBox(bbox, startArrowBBox);
  }
  if (endArrowShape) {
    endArrowBBox = endArrowShape.getCanvasBBox();
    bbox = mergeBBox(bbox, endArrowBBox);
  }
  return bbox;
}
function polyline(shape) {
  var attrs = shape.attr();
  var points2 = attrs.points;
  var xArr = [];
  var yArr = [];
  for (var i2 = 0; i2 < points2.length; i2++) {
    var point2 = points2[i2];
    xArr.push(point2[0]);
    yArr.push(point2[1]);
  }
  var _a2 = getBBoxByArray(xArr, yArr), x2 = _a2.x, y2 = _a2.y, width = _a2.width, height = _a2.height;
  var bbox = {
    minX: x2,
    minY: y2,
    maxX: x2 + width,
    maxY: y2 + height
  };
  bbox = mergeArrowBBox(shape, bbox);
  return {
    x: bbox.minX,
    y: bbox.minY,
    width: bbox.maxX - bbox.minX,
    height: bbox.maxY - bbox.minY
  };
}
function polygon$1(shape) {
  var attrs = shape.attr();
  var points2 = attrs.points;
  var xArr = [];
  var yArr = [];
  for (var i2 = 0; i2 < points2.length; i2++) {
    var point2 = points2[i2];
    xArr.push(point2[0]);
    yArr.push(point2[1]);
  }
  return getBBoxByArray(xArr, yArr);
}
var offScreenCtx = null;
function getOffScreenContext() {
  if (!offScreenCtx) {
    var canvas = document.createElement("canvas");
    canvas.width = 1;
    canvas.height = 1;
    offScreenCtx = canvas.getContext("2d");
  }
  return offScreenCtx;
}
function getTextHeight(text2, fontSize, lineHeight) {
  var lineCount = 1;
  if (isString(text2)) {
    lineCount = text2.split("\n").length;
  }
  if (lineCount > 1) {
    var spaceingY = getLineSpaceing(fontSize, lineHeight);
    return fontSize * lineCount + spaceingY * (lineCount - 1);
  }
  return fontSize;
}
function getLineSpaceing(fontSize, lineHeight) {
  return lineHeight ? lineHeight - fontSize : fontSize * 0.14;
}
function getTextWidth(text2, font) {
  var context2 = getOffScreenContext();
  var width = 0;
  if (isNil(text2) || text2 === "") {
    return width;
  }
  context2.save();
  context2.font = font;
  if (isString(text2) && text2.includes("\n")) {
    var textArr = text2.split("\n");
    each$1(textArr, function(subText) {
      var measureWidth = context2.measureText(subText).width;
      if (width < measureWidth) {
        width = measureWidth;
      }
    });
  } else {
    width = context2.measureText(text2).width;
  }
  context2.restore();
  return width;
}
function assembleFont(attrs) {
  var fontSize = attrs.fontSize, fontFamily = attrs.fontFamily, fontWeight = attrs.fontWeight, fontStyle = attrs.fontStyle, fontVariant = attrs.fontVariant;
  return [fontStyle, fontVariant, fontWeight, fontSize + "px", fontFamily].join(" ").trim();
}
function text(shape) {
  var attrs = shape.attr();
  var x2 = attrs.x, y2 = attrs.y, text2 = attrs.text, fontSize = attrs.fontSize, lineHeight = attrs.lineHeight;
  var font = attrs.font;
  if (!font) {
    font = assembleFont(attrs);
  }
  var width = getTextWidth(text2, font);
  var bbox;
  if (!width) {
    bbox = {
      x: x2,
      y: y2,
      width: 0,
      height: 0
    };
  } else {
    var textAlign = attrs.textAlign, textBaseline = attrs.textBaseline;
    var height = getTextHeight(text2, fontSize, lineHeight);
    var point2 = {
      x: x2,
      y: y2 - height
    };
    if (textAlign) {
      if (textAlign === "end" || textAlign === "right") {
        point2.x -= width;
      } else if (textAlign === "center") {
        point2.x -= width / 2;
      }
    }
    if (textBaseline) {
      if (textBaseline === "top") {
        point2.y += height;
      } else if (textBaseline === "middle") {
        point2.y += height / 2;
      }
    }
    bbox = {
      x: point2.x,
      y: point2.y,
      width,
      height
    };
  }
  return bbox;
}
var regexTags = /[MLHVQTCSAZ]([^MLHVQTCSAZ]*)/ig;
var regexDot = /[^\s\,]+/ig;
function parsePath(p2) {
  var path2 = p2 || [];
  if (isArray$1(path2)) {
    return path2;
  }
  if (isString(path2)) {
    path2 = path2.match(regexTags);
    each$1(path2, function(item, index2) {
      item = item.match(regexDot);
      if (item[0].length > 1) {
        var tag = item[0].charAt(0);
        item.splice(1, 0, item[0].substr(1));
        item[0] = tag;
      }
      each$1(item, function(sub2, i2) {
        if (!isNaN(sub2)) {
          item[i2] = +sub2;
        }
      });
      path2[index2] = item;
    });
    return path2;
  }
}
function smoothBezier$2(points2, smooth, isLoop, constraint) {
  var cps = [];
  var hasConstraint = !!constraint;
  var prevPoint;
  var nextPoint;
  var min2;
  var max2;
  var nextCp0;
  var cp1;
  var cp0;
  if (hasConstraint) {
    min2 = constraint[0], max2 = constraint[1];
    for (var i2 = 0, l2 = points2.length; i2 < l2; i2 += 1) {
      var point2 = points2[i2];
      min2 = min$1([0, 0], min2, point2);
      max2 = max$1([0, 0], max2, point2);
    }
  }
  for (var i2 = 0, len = points2.length; i2 < len; i2 += 1) {
    var point2 = points2[i2];
    if (i2 === 0 && !isLoop) {
      cp0 = point2;
    } else if (i2 === len - 1 && !isLoop) {
      cp1 = point2;
      cps.push(cp0);
      cps.push(cp1);
    } else {
      var prevIdx = [i2 ? i2 - 1 : len - 1, i2 - 1][isLoop ? 0 : 1];
      prevPoint = points2[prevIdx];
      nextPoint = points2[isLoop ? (i2 + 1) % len : i2 + 1];
      var v2 = [0, 0];
      v2 = sub(v2, nextPoint, prevPoint);
      v2 = scale$3(v2, v2, smooth);
      var d0 = distance$6(point2, prevPoint);
      var d1 = distance$6(point2, nextPoint);
      var sum = d0 + d1;
      if (sum !== 0) {
        d0 /= sum;
        d1 /= sum;
      }
      var v1 = scale$3([0, 0], v2, -d0);
      var v22 = scale$3([0, 0], v2, d1);
      cp1 = add([0, 0], point2, v1);
      nextCp0 = add([0, 0], point2, v22);
      nextCp0 = min$1([0, 0], nextCp0, max$1([0, 0], nextPoint, point2));
      nextCp0 = max$1([0, 0], nextCp0, min$1([0, 0], nextPoint, point2));
      v1 = sub([0, 0], nextCp0, point2);
      v1 = scale$3([0, 0], v1, -d0 / d1);
      cp1 = add([0, 0], point2, v1);
      cp1 = min$1([0, 0], cp1, max$1([0, 0], prevPoint, point2));
      cp1 = max$1([0, 0], cp1, min$1([0, 0], prevPoint, point2));
      v22 = sub([0, 0], point2, cp1);
      v22 = scale$3([0, 0], v22, d1 / d0);
      nextCp0 = add([0, 0], point2, v22);
      if (hasConstraint) {
        cp1 = max$1([0, 0], cp1, min2);
        cp1 = min$1([0, 0], cp1, max2);
        nextCp0 = max$1([0, 0], nextCp0, min2);
        nextCp0 = min$1([0, 0], nextCp0, max2);
      }
      cps.push(cp0);
      cps.push(cp1);
      cp0 = nextCp0;
    }
  }
  if (isLoop) {
    cps.push(cps.shift());
  }
  return cps;
}
function catmullRom2Bezier(crp, z2, constraint) {
  if (z2 === void 0) {
    z2 = false;
  }
  if (constraint === void 0) {
    constraint = [
      [0, 0],
      [1, 1]
    ];
  }
  var isLoop = !!z2;
  var pointList = [];
  for (var i2 = 0, l2 = crp.length; i2 < l2; i2 += 2) {
    pointList.push([crp[i2], crp[i2 + 1]]);
  }
  var controlPointList = smoothBezier$2(pointList, 0.4, isLoop, constraint);
  var len = pointList.length;
  var d1 = [];
  var cp1;
  var cp2;
  var p2;
  for (var i2 = 0; i2 < len - 1; i2 += 1) {
    cp1 = controlPointList[i2 * 2];
    cp2 = controlPointList[i2 * 2 + 1];
    p2 = pointList[i2 + 1];
    d1.push(["C", cp1[0], cp1[1], cp2[0], cp2[1], p2[0], p2[1]]);
  }
  if (isLoop) {
    cp1 = controlPointList[len];
    cp2 = controlPointList[len + 1];
    p2 = pointList[0];
    d1.push(["C", cp1[0], cp1[1], cp2[0], cp2[1], p2[0], p2[1]]);
  }
  return d1;
}
var SPACES = "	\n\v\f\r \xA0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029";
var PATH_COMMAND = new RegExp("([a-z])[" + SPACES + ",]*((-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?[" + SPACES + "]*,?[" + SPACES + "]*)+)", "ig");
var PATH_VALUES = new RegExp("(-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?)[" + SPACES + "]*,?[" + SPACES + "]*", "ig");
function parsePathString(pathString) {
  if (!pathString) {
    return null;
  }
  if (isArray$1(pathString)) {
    return pathString;
  }
  var paramCounts = {
    a: 7,
    c: 6,
    o: 2,
    h: 1,
    l: 2,
    m: 2,
    r: 4,
    q: 4,
    s: 4,
    t: 2,
    v: 1,
    u: 3,
    z: 0
  };
  var data2 = [];
  String(pathString).replace(PATH_COMMAND, function(a2, b10, c2) {
    var params = [];
    var name = b10.toLowerCase();
    c2.replace(PATH_VALUES, function(a3, b11) {
      b11 && params.push(+b11);
    });
    if (name === "m" && params.length > 2) {
      data2.push([b10].concat(params.splice(0, 2)));
      name = "l";
      b10 = b10 === "m" ? "l" : "L";
    }
    if (name === "o" && params.length === 1) {
      data2.push([b10, params[0]]);
    }
    if (name === "r") {
      data2.push([b10].concat(params));
    } else {
      while (params.length >= paramCounts[name]) {
        data2.push([b10].concat(params.splice(0, paramCounts[name])));
        if (!paramCounts[name]) {
          break;
        }
      }
    }
    return "";
  });
  return data2;
}
var REGEX_MD = /[a-z]/;
function toSymmetry$1(p2, c2) {
  return [
    c2[0] + (c2[0] - p2[0]),
    c2[1] + (c2[1] - p2[1])
  ];
}
function pathToAbsolute(pathString) {
  var pathArray = parsePathString(pathString);
  if (!pathArray || !pathArray.length) {
    return [
      ["M", 0, 0]
    ];
  }
  var needProcess = false;
  for (var i2 = 0; i2 < pathArray.length; i2++) {
    var cmd = pathArray[i2][0];
    if (REGEX_MD.test(cmd) || ["V", "H", "T", "S"].indexOf(cmd) >= 0) {
      needProcess = true;
      break;
    }
  }
  if (!needProcess) {
    return pathArray;
  }
  var res = [];
  var x2 = 0;
  var y2 = 0;
  var mx = 0;
  var my = 0;
  var start = 0;
  var first = pathArray[0];
  if (first[0] === "M" || first[0] === "m") {
    x2 = +first[1];
    y2 = +first[2];
    mx = x2;
    my = y2;
    start++;
    res[0] = ["M", x2, y2];
  }
  for (var i2 = start, ii2 = pathArray.length; i2 < ii2; i2++) {
    var pa2 = pathArray[i2];
    var preParams = res[i2 - 1];
    var r2 = [];
    var cmd = pa2[0];
    var upCmd = cmd.toUpperCase();
    if (cmd !== upCmd) {
      r2[0] = upCmd;
      switch (upCmd) {
        case "A":
          r2[1] = pa2[1];
          r2[2] = pa2[2];
          r2[3] = pa2[3];
          r2[4] = pa2[4];
          r2[5] = pa2[5];
          r2[6] = +pa2[6] + x2;
          r2[7] = +pa2[7] + y2;
          break;
        case "V":
          r2[1] = +pa2[1] + y2;
          break;
        case "H":
          r2[1] = +pa2[1] + x2;
          break;
        case "M":
          mx = +pa2[1] + x2;
          my = +pa2[2] + y2;
          r2[1] = mx;
          r2[2] = my;
          break;
        default:
          for (var j2 = 1, jj2 = pa2.length; j2 < jj2; j2++) {
            r2[j2] = +pa2[j2] + (j2 % 2 ? x2 : y2);
          }
      }
    } else {
      r2 = pathArray[i2];
    }
    switch (upCmd) {
      case "Z":
        x2 = +mx;
        y2 = +my;
        break;
      case "H":
        x2 = r2[1];
        r2 = ["L", x2, y2];
        break;
      case "V":
        y2 = r2[1];
        r2 = ["L", x2, y2];
        break;
      case "T":
        x2 = r2[1];
        y2 = r2[2];
        var symetricT = toSymmetry$1([preParams[1], preParams[2]], [preParams[3], preParams[4]]);
        r2 = ["Q", symetricT[0], symetricT[1], x2, y2];
        break;
      case "S":
        x2 = r2[r2.length - 2];
        y2 = r2[r2.length - 1];
        var length_1 = preParams.length;
        var symetricS = toSymmetry$1([preParams[length_1 - 4], preParams[length_1 - 3]], [preParams[length_1 - 2], preParams[length_1 - 1]]);
        r2 = ["C", symetricS[0], symetricS[1], r2[1], r2[2], x2, y2];
        break;
      case "M":
        mx = r2[r2.length - 2];
        my = r2[r2.length - 1];
        break;
      default:
        x2 = r2[r2.length - 2];
        y2 = r2[r2.length - 1];
    }
    res.push(r2);
  }
  return res;
}
function vMag$1(v2) {
  return Math.sqrt(v2[0] * v2[0] + v2[1] * v2[1]);
}
function vRatio$1(u2, v2) {
  return vMag$1(u2) * vMag$1(v2) ? (u2[0] * v2[0] + u2[1] * v2[1]) / (vMag$1(u2) * vMag$1(v2)) : 1;
}
function vAngle$1(u2, v2) {
  return (u2[0] * v2[1] < u2[1] * v2[0] ? -1 : 1) * Math.acos(vRatio$1(u2, v2));
}
function isSamePoint$1(point1, point2) {
  return point1[0] === point2[0] && point1[1] === point2[1];
}
function getArcParams$1(startPoint, params) {
  var rx = params[1];
  var ry = params[2];
  var xRotation = mod$1(toRadian(params[3]), Math.PI * 2);
  var arcFlag = params[4];
  var sweepFlag = params[5];
  var x1 = startPoint[0];
  var y1 = startPoint[1];
  var x2 = params[6];
  var y2 = params[7];
  var xp = Math.cos(xRotation) * (x1 - x2) / 2 + Math.sin(xRotation) * (y1 - y2) / 2;
  var yp = -1 * Math.sin(xRotation) * (x1 - x2) / 2 + Math.cos(xRotation) * (y1 - y2) / 2;
  var lambda = xp * xp / (rx * rx) + yp * yp / (ry * ry);
  if (lambda > 1) {
    rx *= Math.sqrt(lambda);
    ry *= Math.sqrt(lambda);
  }
  var diff2 = rx * rx * (yp * yp) + ry * ry * (xp * xp);
  var f2 = diff2 ? Math.sqrt((rx * rx * (ry * ry) - diff2) / diff2) : 1;
  if (arcFlag === sweepFlag) {
    f2 *= -1;
  }
  if (isNaN(f2)) {
    f2 = 0;
  }
  var cxp = ry ? f2 * rx * yp / ry : 0;
  var cyp = rx ? f2 * -ry * xp / rx : 0;
  var cx = (x1 + x2) / 2 + Math.cos(xRotation) * cxp - Math.sin(xRotation) * cyp;
  var cy = (y1 + y2) / 2 + Math.sin(xRotation) * cxp + Math.cos(xRotation) * cyp;
  var u2 = [(xp - cxp) / rx, (yp - cyp) / ry];
  var v2 = [(-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry];
  var theta = vAngle$1([1, 0], u2);
  var dTheta = vAngle$1(u2, v2);
  if (vRatio$1(u2, v2) <= -1) {
    dTheta = Math.PI;
  }
  if (vRatio$1(u2, v2) >= 1) {
    dTheta = 0;
  }
  if (sweepFlag === 0 && dTheta > 0) {
    dTheta = dTheta - 2 * Math.PI;
  }
  if (sweepFlag === 1 && dTheta < 0) {
    dTheta = dTheta + 2 * Math.PI;
  }
  return {
    cx,
    cy,
    rx: isSamePoint$1(startPoint, [x2, y2]) ? 0 : rx,
    ry: isSamePoint$1(startPoint, [x2, y2]) ? 0 : ry,
    startAngle: theta,
    endAngle: theta + dTheta,
    xRotation,
    arcFlag,
    sweepFlag
  };
}
function toSymmetry(point2, center2) {
  return [center2[0] + (center2[0] - point2[0]), center2[1] + (center2[1] - point2[1])];
}
function getSegments(path2) {
  path2 = parsePath(path2);
  var segments = [];
  var currentPoint = null;
  var nextParams = null;
  var startMovePoint = null;
  var lastStartMovePointIndex = 0;
  var count2 = path2.length;
  for (var i2 = 0; i2 < count2; i2++) {
    var params = path2[i2];
    nextParams = path2[i2 + 1];
    var command = params[0];
    var segment = {
      command,
      prePoint: currentPoint,
      params,
      startTangent: null,
      endTangent: null
    };
    switch (command) {
      case "M":
        startMovePoint = [params[1], params[2]];
        lastStartMovePointIndex = i2;
        break;
      case "A":
        var arcParams = getArcParams$1(currentPoint, params);
        segment["arcParams"] = arcParams;
        break;
    }
    if (command === "Z") {
      currentPoint = startMovePoint;
      nextParams = path2[lastStartMovePointIndex + 1];
    } else {
      var len = params.length;
      currentPoint = [params[len - 2], params[len - 1]];
    }
    if (nextParams && nextParams[0] === "Z") {
      nextParams = path2[lastStartMovePointIndex];
      if (segments[lastStartMovePointIndex]) {
        segments[lastStartMovePointIndex].prePoint = currentPoint;
      }
    }
    segment["currentPoint"] = currentPoint;
    if (segments[lastStartMovePointIndex] && isSamePoint$1(currentPoint, segments[lastStartMovePointIndex].currentPoint)) {
      segments[lastStartMovePointIndex].prePoint = segment.prePoint;
    }
    var nextPoint = nextParams ? [nextParams[nextParams.length - 2], nextParams[nextParams.length - 1]] : null;
    segment["nextPoint"] = nextPoint;
    var prePoint = segment.prePoint;
    if (["L", "H", "V"].includes(command)) {
      segment.startTangent = [prePoint[0] - currentPoint[0], prePoint[1] - currentPoint[1]];
      segment.endTangent = [currentPoint[0] - prePoint[0], currentPoint[1] - prePoint[1]];
    } else if (command === "Q") {
      var cp = [params[1], params[2]];
      segment.startTangent = [prePoint[0] - cp[0], prePoint[1] - cp[1]];
      segment.endTangent = [currentPoint[0] - cp[0], currentPoint[1] - cp[1]];
    } else if (command === "T") {
      var preSegment = segments[i2 - 1];
      var cp = toSymmetry(preSegment.currentPoint, prePoint);
      if (preSegment.command === "Q") {
        segment.command = "Q";
        segment.startTangent = [prePoint[0] - cp[0], prePoint[1] - cp[1]];
        segment.endTangent = [currentPoint[0] - cp[0], currentPoint[1] - cp[1]];
      } else {
        segment.command = "TL";
        segment.startTangent = [prePoint[0] - currentPoint[0], prePoint[1] - currentPoint[1]];
        segment.endTangent = [currentPoint[0] - prePoint[0], currentPoint[1] - prePoint[1]];
      }
    } else if (command === "C") {
      var cp1 = [params[1], params[2]];
      var cp2 = [params[3], params[4]];
      segment.startTangent = [prePoint[0] - cp1[0], prePoint[1] - cp1[1]];
      segment.endTangent = [currentPoint[0] - cp2[0], currentPoint[1] - cp2[1]];
      if (segment.startTangent[0] === 0 && segment.startTangent[1] === 0) {
        segment.startTangent = [cp1[0] - cp2[0], cp1[1] - cp2[1]];
      }
      if (segment.endTangent[0] === 0 && segment.endTangent[1] === 0) {
        segment.endTangent = [cp2[0] - cp1[0], cp2[1] - cp1[1]];
      }
    } else if (command === "S") {
      var preSegment = segments[i2 - 1];
      var cp1 = toSymmetry(preSegment.currentPoint, prePoint);
      var cp2 = [params[1], params[2]];
      if (preSegment.command === "C") {
        segment.command = "C";
        segment.startTangent = [prePoint[0] - cp1[0], prePoint[1] - cp1[1]];
        segment.endTangent = [currentPoint[0] - cp2[0], currentPoint[1] - cp2[1]];
      } else {
        segment.command = "SQ";
        segment.startTangent = [prePoint[0] - cp2[0], prePoint[1] - cp2[1]];
        segment.endTangent = [currentPoint[0] - cp2[0], currentPoint[1] - cp2[1]];
      }
    } else if (command === "A") {
      var d2 = 1e-3;
      var _a2 = segment["arcParams"] || {}, _b = _a2.cx, cx = _b === void 0 ? 0 : _b, _c = _a2.cy, cy = _c === void 0 ? 0 : _c, _d = _a2.rx, rx = _d === void 0 ? 0 : _d, _e = _a2.ry, ry = _e === void 0 ? 0 : _e, _f = _a2.sweepFlag, sweepFlag = _f === void 0 ? 0 : _f, _g = _a2.startAngle, startAngle = _g === void 0 ? 0 : _g, _h = _a2.endAngle, endAngle = _h === void 0 ? 0 : _h;
      if (sweepFlag === 0) {
        d2 *= -1;
      }
      var dx1 = rx * Math.cos(startAngle - d2) + cx;
      var dy1 = ry * Math.sin(startAngle - d2) + cy;
      segment.startTangent = [dx1 - startMovePoint[0], dy1 - startMovePoint[1]];
      var dx2 = rx * Math.cos(startAngle + endAngle + d2) + cx;
      var dy2 = ry * Math.sin(startAngle + endAngle - d2) + cy;
      segment.endTangent = [prePoint[0] - dx2, prePoint[1] - dy2];
    }
    segments.push(segment);
  }
  return segments;
}
var isBetween$2 = function(value2, min2, max2) {
  return value2 >= min2 && value2 <= max2;
};
function getLineIntersect(p0, p1, p2, p3) {
  var tolerance2 = 1e-3;
  var E2 = {
    x: p2.x - p0.x,
    y: p2.y - p0.y
  };
  var D0 = {
    x: p1.x - p0.x,
    y: p1.y - p0.y
  };
  var D1 = {
    x: p3.x - p2.x,
    y: p3.y - p2.y
  };
  var kross = D0.x * D1.y - D0.y * D1.x;
  var sqrKross = kross * kross;
  var sqrLen0 = D0.x * D0.x + D0.y * D0.y;
  var sqrLen1 = D1.x * D1.x + D1.y * D1.y;
  var point2 = null;
  if (sqrKross > tolerance2 * sqrLen0 * sqrLen1) {
    var s2 = (E2.x * D1.y - E2.y * D1.x) / kross;
    var t2 = (E2.x * D0.y - E2.y * D0.x) / kross;
    if (isBetween$2(s2, 0, 1) && isBetween$2(t2, 0, 1)) {
      point2 = {
        x: p0.x + s2 * D0.x,
        y: p0.y + s2 * D0.y
      };
    }
  }
  return point2;
}
var tolerance$1 = 1e-6;
function dcmp$1(x2) {
  if (Math.abs(x2) < tolerance$1) {
    return 0;
  }
  return x2 < 0 ? -1 : 1;
}
function onSegment$1(p1, p2, q2) {
  if ((q2[0] - p1[0]) * (p2[1] - p1[1]) === (p2[0] - p1[0]) * (q2[1] - p1[1]) && Math.min(p1[0], p2[0]) <= q2[0] && q2[0] <= Math.max(p1[0], p2[0]) && Math.min(p1[1], p2[1]) <= q2[1] && q2[1] <= Math.max(p1[1], p2[1])) {
    return true;
  }
  return false;
}
function isInPolygon$1(points2, x2, y2) {
  var isHit = false;
  var n2 = points2.length;
  if (n2 <= 2) {
    return false;
  }
  for (var i2 = 0; i2 < n2; i2++) {
    var p1 = points2[i2];
    var p2 = points2[(i2 + 1) % n2];
    if (onSegment$1(p1, p2, [x2, y2])) {
      return true;
    }
    if (dcmp$1(p1[1] - y2) > 0 !== dcmp$1(p2[1] - y2) > 0 && dcmp$1(x2 - (y2 - p1[1]) * (p1[0] - p2[0]) / (p1[1] - p2[1]) - p1[0]) < 0) {
      isHit = !isHit;
    }
  }
  return isHit;
}
function parseToLines(points2) {
  var lines = [];
  var count2 = points2.length;
  for (var i2 = 0; i2 < count2 - 1; i2++) {
    var point2 = points2[i2];
    var next = points2[i2 + 1];
    lines.push({
      from: {
        x: point2[0],
        y: point2[1]
      },
      to: {
        x: next[0],
        y: next[1]
      }
    });
  }
  if (lines.length > 1) {
    var first = points2[0];
    var last2 = points2[count2 - 1];
    lines.push({
      from: {
        x: last2[0],
        y: last2[1]
      },
      to: {
        x: first[0],
        y: first[1]
      }
    });
  }
  return lines;
}
function lineIntersectPolygon(lines, line2) {
  var isIntersect = false;
  each$1(lines, function(l2) {
    if (getLineIntersect(l2.from, l2.to, line2.from, line2.to)) {
      isIntersect = true;
      return false;
    }
  });
  return isIntersect;
}
function getBBox(points2) {
  var xArr = points2.map(function(p2) {
    return p2[0];
  });
  var yArr = points2.map(function(p2) {
    return p2[1];
  });
  return {
    minX: Math.min.apply(null, xArr),
    maxX: Math.max.apply(null, xArr),
    minY: Math.min.apply(null, yArr),
    maxY: Math.max.apply(null, yArr)
  };
}
function intersectBBox$1(box1, box2) {
  return !(box2.minX > box1.maxX || box2.maxX < box1.minX || box2.minY > box1.maxY || box2.maxY < box1.minY);
}
function isPolygonsIntersect(points1, points2) {
  if (points1.length < 2 || points2.length < 2) {
    return false;
  }
  var bbox1 = getBBox(points1);
  var bbox2 = getBBox(points2);
  if (!intersectBBox$1(bbox1, bbox2)) {
    return false;
  }
  var isIn = false;
  each$1(points2, function(point2) {
    if (isInPolygon$1(points1, point2[0], point2[1])) {
      isIn = true;
      return false;
    }
  });
  if (isIn) {
    return true;
  }
  each$1(points1, function(point2) {
    if (isInPolygon$1(points2, point2[0], point2[1])) {
      isIn = true;
      return false;
    }
  });
  if (isIn) {
    return true;
  }
  var lines1 = parseToLines(points1);
  var lines2 = parseToLines(points2);
  var isIntersect = false;
  each$1(lines2, function(line2) {
    if (lineIntersectPolygon(lines1, line2)) {
      isIntersect = true;
      return false;
    }
  });
  return isIntersect;
}
function getPathBox(segments, lineWidth) {
  var xArr = [];
  var yArr = [];
  var segmentsWithAngle = [];
  for (var i2 = 0; i2 < segments.length; i2++) {
    var segment = segments[i2];
    var currentPoint = segment.currentPoint, params = segment.params, prePoint = segment.prePoint;
    var box2 = void 0;
    switch (segment.command) {
      case "Q":
        box2 = QuadUtil.box(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4]);
        break;
      case "C":
        box2 = CubicUtil.box(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4], params[5], params[6]);
        break;
      case "A":
        var arcParams = segment.arcParams;
        box2 = EllipseArcUtil.box(arcParams.cx, arcParams.cy, arcParams.rx, arcParams.ry, arcParams.xRotation, arcParams.startAngle, arcParams.endAngle);
        break;
      default:
        xArr.push(currentPoint[0]);
        yArr.push(currentPoint[1]);
        break;
    }
    if (box2) {
      segment.box = box2;
      xArr.push(box2.x, box2.x + box2.width);
      yArr.push(box2.y, box2.y + box2.height);
    }
    if (lineWidth && (segment.command === "L" || segment.command === "M") && segment.prePoint && segment.nextPoint) {
      segmentsWithAngle.push(segment);
    }
  }
  xArr = xArr.filter(function(item) {
    return !Number.isNaN(item) && item !== Infinity && item !== -Infinity;
  });
  yArr = yArr.filter(function(item) {
    return !Number.isNaN(item) && item !== Infinity && item !== -Infinity;
  });
  var minX = min$2(xArr);
  var minY = min$2(yArr);
  var maxX = max$2(xArr);
  var maxY2 = max$2(yArr);
  if (segmentsWithAngle.length === 0) {
    return {
      x: minX,
      y: minY,
      width: maxX - minX,
      height: maxY2 - minY
    };
  }
  for (var i2 = 0; i2 < segmentsWithAngle.length; i2++) {
    var segment = segmentsWithAngle[i2];
    var currentPoint = segment.currentPoint;
    var extra = void 0;
    if (currentPoint[0] === minX) {
      extra = getExtraFromSegmentWithAngle(segment, lineWidth);
      minX = minX - extra.xExtra;
    } else if (currentPoint[0] === maxX) {
      extra = getExtraFromSegmentWithAngle(segment, lineWidth);
      maxX = maxX + extra.xExtra;
    }
    if (currentPoint[1] === minY) {
      extra = getExtraFromSegmentWithAngle(segment, lineWidth);
      minY = minY - extra.yExtra;
    } else if (currentPoint[1] === maxY2) {
      extra = getExtraFromSegmentWithAngle(segment, lineWidth);
      maxY2 = maxY2 + extra.yExtra;
    }
  }
  return {
    x: minX,
    y: minY,
    width: maxX - minX,
    height: maxY2 - minY
  };
}
function getExtraFromSegmentWithAngle(segment, lineWidth) {
  var prePoint = segment.prePoint, currentPoint = segment.currentPoint, nextPoint = segment.nextPoint;
  var currentAndPre = Math.pow(currentPoint[0] - prePoint[0], 2) + Math.pow(currentPoint[1] - prePoint[1], 2);
  var currentAndNext = Math.pow(currentPoint[0] - nextPoint[0], 2) + Math.pow(currentPoint[1] - nextPoint[1], 2);
  var preAndNext = Math.pow(prePoint[0] - nextPoint[0], 2) + Math.pow(prePoint[1] - nextPoint[1], 2);
  var currentAngle = Math.acos((currentAndPre + currentAndNext - preAndNext) / (2 * Math.sqrt(currentAndPre) * Math.sqrt(currentAndNext)));
  if (!currentAngle || Math.sin(currentAngle) === 0 || isNumberEqual$1(currentAngle, 0)) {
    return {
      xExtra: 0,
      yExtra: 0
    };
  }
  var xAngle = Math.abs(Math.atan2(nextPoint[1] - currentPoint[1], nextPoint[0] - currentPoint[0]));
  var yAngle = Math.abs(Math.atan2(nextPoint[0] - currentPoint[0], nextPoint[1] - currentPoint[1]));
  xAngle = xAngle > Math.PI / 2 ? Math.PI - xAngle : xAngle;
  yAngle = yAngle > Math.PI / 2 ? Math.PI - yAngle : yAngle;
  var extra = {
    xExtra: Math.cos(currentAngle / 2 - xAngle) * (lineWidth / 2 * (1 / Math.sin(currentAngle / 2))) - lineWidth / 2 || 0,
    yExtra: Math.cos(yAngle - currentAngle / 2) * (lineWidth / 2 * (1 / Math.sin(currentAngle / 2))) - lineWidth / 2 || 0
  };
  return extra;
}
function path(shape) {
  var attrs = shape.attr();
  var path2 = attrs.path, stroke = attrs.stroke;
  var lineWidth = stroke ? attrs.lineWidth : 0;
  var segments = shape.get("segments") || getSegments(path2);
  var _a2 = getPathBox(segments, lineWidth), x2 = _a2.x, y2 = _a2.y, width = _a2.width, height = _a2.height;
  var bbox = {
    minX: x2,
    minY: y2,
    maxX: x2 + width,
    maxY: y2 + height
  };
  bbox = mergeArrowBBox(shape, bbox);
  return {
    x: bbox.minX,
    y: bbox.minY,
    width: bbox.maxX - bbox.minX,
    height: bbox.maxY - bbox.minY
  };
}
function line$1(shape) {
  var attrs = shape.attr();
  var x1 = attrs.x1, y1 = attrs.y1, x2 = attrs.x2, y2 = attrs.y2;
  var minX = Math.min(x1, x2);
  var maxX = Math.max(x1, x2);
  var minY = Math.min(y1, y2);
  var maxY2 = Math.max(y1, y2);
  var bbox = {
    minX,
    maxX,
    minY,
    maxY: maxY2
  };
  bbox = mergeArrowBBox(shape, bbox);
  return {
    x: bbox.minX,
    y: bbox.minY,
    width: bbox.maxX - bbox.minX,
    height: bbox.maxY - bbox.minY
  };
}
function ellipse(shape) {
  var attrs = shape.attr();
  var x2 = attrs.x, y2 = attrs.y, rx = attrs.rx, ry = attrs.ry;
  return {
    x: x2 - rx,
    y: y2 - ry,
    width: rx * 2,
    height: ry * 2
  };
}
register("rect", rect$1);
register("image", rect$1);
register("circle", circle$1);
register("marker", circle$1);
register("polyline", polyline);
register("polygon", polygon$1);
register("text", text);
register("path", path);
register("line", line$1);
register("ellipse", ellipse);
var DEFAULT_Y = 0;
var MARGIN_RATIO = 1 / 2;
var DODGE_RATIO = 1 / 2;
var GAP = 0.05;
var Adjust = function() {
  function Adjust2(cfg) {
    var xField = cfg.xField, yField = cfg.yField, _a2 = cfg.adjustNames, adjustNames = _a2 === void 0 ? ["x", "y"] : _a2, dimValuesMap = cfg.dimValuesMap;
    this.adjustNames = adjustNames;
    this.xField = xField;
    this.yField = yField;
    this.dimValuesMap = dimValuesMap;
  }
  Adjust2.prototype.isAdjust = function(dim) {
    return this.adjustNames.indexOf(dim) >= 0;
  };
  Adjust2.prototype.getAdjustRange = function(dim, dimValue, values2) {
    var yField = this.yField;
    var index2 = values2.indexOf(dimValue);
    var length2 = values2.length;
    var pre;
    var next;
    if (!yField && this.isAdjust("y")) {
      pre = 0;
      next = 1;
    } else if (length2 > 1) {
      pre = values2[index2 === 0 ? 0 : index2 - 1];
      next = values2[index2 === length2 - 1 ? length2 - 1 : index2 + 1];
      if (index2 !== 0) {
        pre += (dimValue - pre) / 2;
      } else {
        pre -= (next - dimValue) / 2;
      }
      if (index2 !== length2 - 1) {
        next -= (next - dimValue) / 2;
      } else {
        next += (dimValue - values2[length2 - 2]) / 2;
      }
    } else {
      pre = dimValue === 0 ? 0 : dimValue - 0.5;
      next = dimValue === 0 ? 1 : dimValue + 0.5;
    }
    return {
      pre,
      next
    };
  };
  Adjust2.prototype.adjustData = function(groupedDataArray, mergedData) {
    var _this = this;
    var dimValuesMap = this.getDimValues(mergedData);
    each$1(groupedDataArray, function(dataArray, index2) {
      each$1(dimValuesMap, function(values2, dim) {
        _this.adjustDim(dim, values2, dataArray, index2);
      });
    });
  };
  Adjust2.prototype.groupData = function(data2, dim) {
    each$1(data2, function(record) {
      if (record[dim] === void 0) {
        record[dim] = DEFAULT_Y;
      }
    });
    return groupBy(data2, dim);
  };
  Adjust2.prototype.adjustDim = function(dim, values2, data2, index2) {
  };
  Adjust2.prototype.getDimValues = function(mergedData) {
    var _a2 = this, xField = _a2.xField, yField = _a2.yField;
    var dimValuesMap = mix({}, this.dimValuesMap);
    var dims = [];
    if (xField && this.isAdjust("x")) {
      dims.push(xField);
    }
    if (yField && this.isAdjust("y")) {
      dims.push(yField);
    }
    dims.forEach(function(dim2) {
      if (dimValuesMap && dimValuesMap[dim2]) {
        return;
      }
      dimValuesMap[dim2] = valuesOfKey(mergedData, dim2).sort(function(v1, v2) {
        return v1 - v2;
      });
    });
    if (!yField && this.isAdjust("y")) {
      var dim = "y";
      dimValuesMap[dim] = [DEFAULT_Y, 1];
    }
    return dimValuesMap;
  };
  return Adjust2;
}();
var ADJUST_MAP = {};
var getAdjust = function(type4) {
  return ADJUST_MAP[type4.toLowerCase()];
};
var registerAdjust = function(type4, ctor) {
  if (getAdjust(type4)) {
    throw new Error("Adjust type '" + type4 + "' existed.");
  }
  ADJUST_MAP[type4.toLowerCase()] = ctor;
};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$1 = function(d2, b10) {
  extendStatics$1 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b11) {
    d3.__proto__ = b11;
  } || function(d3, b11) {
    for (var p2 in b11)
      if (b11.hasOwnProperty(p2))
        d3[p2] = b11[p2];
  };
  return extendStatics$1(d2, b10);
};
function __extends$2(d2, b10) {
  extendStatics$1(d2, b10);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b10 === null ? Object.create(b10) : (__.prototype = b10.prototype, new __());
}
var __assign$3 = function() {
  __assign$3 = Object.assign || function __assign2(t2) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign$3.apply(this, arguments);
};
var Dodge = function(_super) {
  __extends$2(Dodge2, _super);
  function Dodge2(cfg) {
    var _this = _super.call(this, cfg) || this;
    _this.cacheMap = {};
    _this.adjustDataArray = [];
    _this.mergeData = [];
    var _a2 = cfg.marginRatio, marginRatio = _a2 === void 0 ? MARGIN_RATIO : _a2, _b = cfg.dodgeRatio, dodgeRatio = _b === void 0 ? DODGE_RATIO : _b, dodgeBy = cfg.dodgeBy, intervalPadding = cfg.intervalPadding, dodgePadding = cfg.dodgePadding, xDimensionLength = cfg.xDimensionLength, groupNum = cfg.groupNum, defaultSize = cfg.defaultSize, maxColumnWidth = cfg.maxColumnWidth, minColumnWidth = cfg.minColumnWidth, columnWidthRatio = cfg.columnWidthRatio, customOffset = cfg.customOffset;
    _this.marginRatio = marginRatio;
    _this.dodgeRatio = dodgeRatio;
    _this.dodgeBy = dodgeBy;
    _this.intervalPadding = intervalPadding;
    _this.dodgePadding = dodgePadding;
    _this.xDimensionLegenth = xDimensionLength;
    _this.groupNum = groupNum;
    _this.defaultSize = defaultSize;
    _this.maxColumnWidth = maxColumnWidth;
    _this.minColumnWidth = minColumnWidth;
    _this.columnWidthRatio = columnWidthRatio;
    _this.customOffset = customOffset;
    return _this;
  }
  Dodge2.prototype.process = function(groupDataArray) {
    var groupedDataArray = clone$1(groupDataArray);
    var mergeData = flatten(groupedDataArray);
    var dodgeBy = this.dodgeBy;
    var adjustDataArray = dodgeBy ? group$1(mergeData, dodgeBy) : groupedDataArray;
    this.cacheMap = {};
    this.adjustDataArray = adjustDataArray;
    this.mergeData = mergeData;
    this.adjustData(adjustDataArray, mergeData);
    this.adjustDataArray = [];
    this.mergeData = [];
    return groupedDataArray;
  };
  Dodge2.prototype.adjustDim = function(dim, values2, data2, frameIndex) {
    var _this = this;
    var customOffset = this.customOffset;
    var map2 = this.getDistribution(dim);
    var groupData = this.groupData(data2, dim);
    each$1(groupData, function(group2, key2) {
      var range3;
      if (values2.length === 1) {
        range3 = {
          pre: values2[0] - 1,
          next: values2[0] + 1
        };
      } else {
        range3 = _this.getAdjustRange(dim, parseFloat(key2), values2);
      }
      each$1(group2, function(d2) {
        var value2 = d2[dim];
        var valueArr = map2[value2];
        var valIndex = valueArr.indexOf(frameIndex);
        if (!isNil(customOffset)) {
          var pre = range3.pre, next = range3.next;
          d2[dim] = isFunction(customOffset) ? customOffset(d2, range3) : (pre + next) / 2 + customOffset;
        } else {
          d2[dim] = _this.getDodgeOffset(range3, valIndex, valueArr.length);
        }
      });
    });
    return [];
  };
  Dodge2.prototype.getDodgeOffset = function(range3, idx, len) {
    var _a2 = this, dodgeRatio = _a2.dodgeRatio, marginRatio = _a2.marginRatio, intervalPadding = _a2.intervalPadding, dodgePadding = _a2.dodgePadding;
    var pre = range3.pre, next = range3.next;
    var tickLength = next - pre;
    var position;
    if (!isNil(intervalPadding) && isNil(dodgePadding) && intervalPadding >= 0) {
      var offset3 = this.getIntervalOnlyOffset(len, idx);
      position = pre + offset3;
    } else if (!isNil(dodgePadding) && isNil(intervalPadding) && dodgePadding >= 0) {
      var offset3 = this.getDodgeOnlyOffset(len, idx);
      position = pre + offset3;
    } else if (!isNil(intervalPadding) && !isNil(dodgePadding) && intervalPadding >= 0 && dodgePadding >= 0) {
      var offset3 = this.getIntervalAndDodgeOffset(len, idx);
      position = pre + offset3;
    } else {
      var width = tickLength * dodgeRatio / len;
      var margin = marginRatio * width;
      var offset3 = 1 / 2 * (tickLength - len * width - (len - 1) * margin) + ((idx + 1) * width + idx * margin) - 1 / 2 * width - 1 / 2 * tickLength;
      position = (pre + next) / 2 + offset3;
    }
    return position;
  };
  Dodge2.prototype.getIntervalOnlyOffset = function(len, idx) {
    var _a2 = this, defaultSize = _a2.defaultSize, intervalPadding = _a2.intervalPadding, xDimensionLegenth = _a2.xDimensionLegenth, groupNum = _a2.groupNum, dodgeRatio = _a2.dodgeRatio, maxColumnWidth = _a2.maxColumnWidth, minColumnWidth = _a2.minColumnWidth, columnWidthRatio = _a2.columnWidthRatio;
    var normalizedIntervalPadding = intervalPadding / xDimensionLegenth;
    var normalizedDodgePadding = (1 - (groupNum - 1) * normalizedIntervalPadding) / groupNum * dodgeRatio / (len - 1);
    var geomWidth = ((1 - normalizedIntervalPadding * (groupNum - 1)) / groupNum - normalizedDodgePadding * (len - 1)) / len;
    geomWidth = !isNil(columnWidthRatio) ? 1 / groupNum / len * columnWidthRatio : geomWidth;
    if (!isNil(maxColumnWidth)) {
      var normalizedMaxWidht = maxColumnWidth / xDimensionLegenth;
      geomWidth = Math.min(geomWidth, normalizedMaxWidht);
    }
    if (!isNil(minColumnWidth)) {
      var normalizedMinWidht = minColumnWidth / xDimensionLegenth;
      geomWidth = Math.max(geomWidth, normalizedMinWidht);
    }
    geomWidth = defaultSize ? defaultSize / xDimensionLegenth : geomWidth;
    normalizedDodgePadding = ((1 - (groupNum - 1) * normalizedIntervalPadding) / groupNum - len * geomWidth) / (len - 1);
    var offset3 = ((1 / 2 + idx) * geomWidth + idx * normalizedDodgePadding + 1 / 2 * normalizedIntervalPadding) * groupNum - normalizedIntervalPadding / 2;
    return offset3;
  };
  Dodge2.prototype.getDodgeOnlyOffset = function(len, idx) {
    var _a2 = this, defaultSize = _a2.defaultSize, dodgePadding = _a2.dodgePadding, xDimensionLegenth = _a2.xDimensionLegenth, groupNum = _a2.groupNum, marginRatio = _a2.marginRatio, maxColumnWidth = _a2.maxColumnWidth, minColumnWidth = _a2.minColumnWidth, columnWidthRatio = _a2.columnWidthRatio;
    var normalizedDodgePadding = dodgePadding / xDimensionLegenth;
    var normalizedIntervalPadding = 1 * marginRatio / (groupNum - 1);
    var geomWidth = ((1 - normalizedIntervalPadding * (groupNum - 1)) / groupNum - normalizedDodgePadding * (len - 1)) / len;
    geomWidth = columnWidthRatio ? 1 / groupNum / len * columnWidthRatio : geomWidth;
    if (!isNil(maxColumnWidth)) {
      var normalizedMaxWidht = maxColumnWidth / xDimensionLegenth;
      geomWidth = Math.min(geomWidth, normalizedMaxWidht);
    }
    if (!isNil(minColumnWidth)) {
      var normalizedMinWidht = minColumnWidth / xDimensionLegenth;
      geomWidth = Math.max(geomWidth, normalizedMinWidht);
    }
    geomWidth = defaultSize ? defaultSize / xDimensionLegenth : geomWidth;
    normalizedIntervalPadding = (1 - (geomWidth * len + normalizedDodgePadding * (len - 1)) * groupNum) / (groupNum - 1);
    var offset3 = ((1 / 2 + idx) * geomWidth + idx * normalizedDodgePadding + 1 / 2 * normalizedIntervalPadding) * groupNum - normalizedIntervalPadding / 2;
    return offset3;
  };
  Dodge2.prototype.getIntervalAndDodgeOffset = function(len, idx) {
    var _a2 = this, intervalPadding = _a2.intervalPadding, dodgePadding = _a2.dodgePadding, xDimensionLegenth = _a2.xDimensionLegenth, groupNum = _a2.groupNum;
    var normalizedIntervalPadding = intervalPadding / xDimensionLegenth;
    var normalizedDodgePadding = dodgePadding / xDimensionLegenth;
    var geomWidth = ((1 - normalizedIntervalPadding * (groupNum - 1)) / groupNum - normalizedDodgePadding * (len - 1)) / len;
    var offset3 = ((1 / 2 + idx) * geomWidth + idx * normalizedDodgePadding + 1 / 2 * normalizedIntervalPadding) * groupNum - normalizedIntervalPadding / 2;
    return offset3;
  };
  Dodge2.prototype.getDistribution = function(dim) {
    var groupedDataArray = this.adjustDataArray;
    var cacheMap = this.cacheMap;
    var map2 = cacheMap[dim];
    if (!map2) {
      map2 = {};
      each$1(groupedDataArray, function(data2, index2) {
        var values2 = valuesOfKey(data2, dim);
        if (!values2.length) {
          values2.push(0);
        }
        each$1(values2, function(val) {
          if (!map2[val]) {
            map2[val] = [];
          }
          map2[val].push(index2);
        });
      });
      cacheMap[dim] = map2;
    }
    return map2;
  };
  return Dodge2;
}(Adjust);
function randomNumber(min2, max2) {
  return (max2 - min2) * Math.random() + min2;
}
var Jitter = function(_super) {
  __extends$2(Jitter2, _super);
  function Jitter2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Jitter2.prototype.process = function(groupDataArray) {
    var groupedDataArray = clone$1(groupDataArray);
    var mergeData = flatten(groupedDataArray);
    this.adjustData(groupedDataArray, mergeData);
    return groupedDataArray;
  };
  Jitter2.prototype.adjustDim = function(dim, values2, dataArray) {
    var _this = this;
    var groupDataArray = this.groupData(dataArray, dim);
    return each$1(groupDataArray, function(data2, dimValue) {
      return _this.adjustGroup(data2, dim, parseFloat(dimValue), values2);
    });
  };
  Jitter2.prototype.getAdjustOffset = function(range3) {
    var pre = range3.pre, next = range3.next;
    var margin = (next - pre) * GAP;
    return randomNumber(pre + margin, next - margin);
  };
  Jitter2.prototype.adjustGroup = function(group2, dim, dimValue, values2) {
    var _this = this;
    var range3 = this.getAdjustRange(dim, dimValue, values2);
    each$1(group2, function(data2) {
      data2[dim] = _this.getAdjustOffset(range3);
    });
    return group2;
  };
  return Jitter2;
}(Adjust);
var Cache = default_1;
var Stack = function(_super) {
  __extends$2(Stack2, _super);
  function Stack2(cfg) {
    var _this = _super.call(this, cfg) || this;
    var _a2 = cfg.adjustNames, adjustNames = _a2 === void 0 ? ["y"] : _a2, _b = cfg.height, height = _b === void 0 ? NaN : _b, _c = cfg.size, size2 = _c === void 0 ? 10 : _c, _d = cfg.reverseOrder, reverseOrder = _d === void 0 ? false : _d;
    _this.adjustNames = adjustNames;
    _this.height = height;
    _this.size = size2;
    _this.reverseOrder = reverseOrder;
    return _this;
  }
  Stack2.prototype.process = function(groupDataArray) {
    var _a2 = this, yField = _a2.yField, reverseOrder = _a2.reverseOrder;
    var d2 = yField ? this.processStack(groupDataArray) : this.processOneDimStack(groupDataArray);
    return reverseOrder ? this.reverse(d2) : d2;
  };
  Stack2.prototype.reverse = function(groupedDataArray) {
    return groupedDataArray.slice(0).reverse();
  };
  Stack2.prototype.processStack = function(groupDataArray) {
    var _a2 = this, xField = _a2.xField, yField = _a2.yField, reverseOrder = _a2.reverseOrder;
    var groupedDataArray = reverseOrder ? this.reverse(groupDataArray) : groupDataArray;
    var positive = new Cache();
    var negative = new Cache();
    return groupedDataArray.map(function(dataArray) {
      return dataArray.map(function(data2) {
        var _a3;
        var x2 = get(data2, xField, 0);
        var y2 = get(data2, [yField]);
        var xKey = x2.toString();
        y2 = isArray$1(y2) ? y2[1] : y2;
        if (!isNil(y2)) {
          var cache2 = y2 >= 0 ? positive : negative;
          if (!cache2.has(xKey)) {
            cache2.set(xKey, 0);
          }
          var xValue = cache2.get(xKey);
          var newXValue = y2 + xValue;
          cache2.set(xKey, newXValue);
          return __assign$3(__assign$3({}, data2), (_a3 = {}, _a3[yField] = [xValue, newXValue], _a3));
        }
        return data2;
      });
    });
  };
  Stack2.prototype.processOneDimStack = function(groupDataArray) {
    var _this = this;
    var _a2 = this, xField = _a2.xField, height = _a2.height, reverseOrder = _a2.reverseOrder;
    var yField = "y";
    var groupedDataArray = reverseOrder ? this.reverse(groupDataArray) : groupDataArray;
    var cache2 = new Cache();
    return groupedDataArray.map(function(dataArray) {
      return dataArray.map(function(data2) {
        var _a3;
        var size2 = _this.size;
        var xValue = data2[xField];
        var stackHeight = size2 * 2 / height;
        if (!cache2.has(xValue)) {
          cache2.set(xValue, stackHeight / 2);
        }
        var stackValue = cache2.get(xValue);
        cache2.set(xValue, stackValue + stackHeight);
        return __assign$3(__assign$3({}, data2), (_a3 = {}, _a3[yField] = stackValue, _a3));
      });
    });
  };
  return Stack2;
}(Adjust);
var Symmetric = function(_super) {
  __extends$2(Symmetric2, _super);
  function Symmetric2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Symmetric2.prototype.process = function(groupDataArray) {
    var mergeData = flatten(groupDataArray);
    var _a2 = this, xField = _a2.xField, yField = _a2.yField;
    var cache2 = this.getXValuesMaxMap(mergeData);
    var max2 = Math.max.apply(Math, Object.keys(cache2).map(function(key2) {
      return cache2[key2];
    }));
    return map$2(groupDataArray, function(dataArray) {
      return map$2(dataArray, function(data2) {
        var _a3, _b;
        var yValue = data2[yField];
        var xValue = data2[xField];
        if (isArray$1(yValue)) {
          var off_1 = (max2 - cache2[xValue]) / 2;
          return __assign$3(__assign$3({}, data2), (_a3 = {}, _a3[yField] = map$2(yValue, function(y2) {
            return off_1 + y2;
          }), _a3));
        }
        var offset3 = (max2 - yValue) / 2;
        return __assign$3(__assign$3({}, data2), (_b = {}, _b[yField] = [offset3, yValue + offset3], _b));
      });
    });
  };
  Symmetric2.prototype.getXValuesMaxMap = function(mergeData) {
    var _this = this;
    var _a2 = this, xField = _a2.xField, yField = _a2.yField;
    var groupDataArray = groupBy(mergeData, function(data2) {
      return data2[xField];
    });
    return mapValues(groupDataArray, function(dataArray) {
      return _this.getDimMaxValue(dataArray, yField);
    });
  };
  Symmetric2.prototype.getDimMaxValue = function(mergeData, dim) {
    var dimValues = map$2(mergeData, function(data2) {
      return get(data2, dim, []);
    });
    var flattenValues = flatten(dimValues);
    return Math.max.apply(Math, flattenValues);
  };
  return Symmetric2;
}(Adjust);
registerAdjust("Dodge", Dodge);
registerAdjust("Jitter", Jitter);
registerAdjust("Stack", Stack);
registerAdjust("Symmetric", Symmetric);
var toScaleString = function(scale2, value2) {
  if (isString(value2)) {
    return value2;
  }
  return scale2.invert(scale2.scale(value2));
};
var Attribute = function() {
  function Attribute2(cfg) {
    this.names = [];
    this.scales = [];
    this.linear = false;
    this.values = [];
    this.callback = function() {
      return [];
    };
    this._parseCfg(cfg);
  }
  Attribute2.prototype.mapping = function() {
    var _this = this;
    var params = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      params[_i] = arguments[_i];
    }
    var values2 = params.map(function(param, idx) {
      return _this._toOriginParam(param, _this.scales[idx]);
    });
    return this.callback.apply(this, values2);
  };
  Attribute2.prototype.getLinearValue = function(percent2) {
    var steps = this.values.length - 1;
    var step = Math.floor(steps * percent2);
    var leftPercent = steps * percent2 - step;
    var start = this.values[step];
    var end = step === steps ? start : this.values[step + 1];
    return start + (end - start) * leftPercent;
  };
  Attribute2.prototype.getNames = function() {
    var scales = this.scales;
    var names2 = this.names;
    var length2 = Math.min(scales.length, names2.length);
    var rst = [];
    for (var i2 = 0; i2 < length2; i2 += 1) {
      rst.push(names2[i2]);
    }
    return rst;
  };
  Attribute2.prototype.getFields = function() {
    return this.scales.map(function(scale2) {
      return scale2.field;
    });
  };
  Attribute2.prototype.getScale = function(name) {
    return this.scales[this.names.indexOf(name)];
  };
  Attribute2.prototype.defaultCallback = function() {
    var _this = this;
    var params = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      params[_i] = arguments[_i];
    }
    if (params.length === 0) {
      return this.values;
    }
    return params.map(function(param, idx) {
      var scale2 = _this.scales[idx];
      return scale2.type === "identity" ? scale2.values[0] : _this._getAttributeValue(scale2, param);
    });
  };
  Attribute2.prototype._parseCfg = function(cfg) {
    var _this = this;
    var _a2 = cfg.type, type4 = _a2 === void 0 ? "base" : _a2, _b = cfg.names, names2 = _b === void 0 ? [] : _b, _c = cfg.scales, scales = _c === void 0 ? [] : _c, _d = cfg.values, values2 = _d === void 0 ? [] : _d, callback = cfg.callback;
    this.type = type4;
    this.scales = scales;
    this.values = values2;
    this.names = names2;
    this.callback = function() {
      var params = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        params[_i] = arguments[_i];
      }
      if (callback) {
        var ret = callback.apply(void 0, params);
        if (!isNil(ret)) {
          return [ret];
        }
      }
      return _this.defaultCallback.apply(_this, params);
    };
  };
  Attribute2.prototype._getAttributeValue = function(scale2, value2) {
    if (scale2.isCategory && !this.linear) {
      var idx = scale2.translate(value2);
      return this.values[idx % this.values.length];
    }
    var percent2 = scale2.scale(value2);
    return this.getLinearValue(percent2);
  };
  Attribute2.prototype._toOriginParam = function(param, scale2) {
    return !scale2.isLinear ? isArray$1(param) ? param.map(function(p2) {
      return toScaleString(scale2, p2);
    }) : toScaleString(scale2, param) : param;
  };
  return Attribute2;
}();
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics = function(d2, b10) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b11) {
    d3.__proto__ = b11;
  } || function(d3, b11) {
    for (var p2 in b11)
      if (b11.hasOwnProperty(p2))
        d3[p2] = b11[p2];
  };
  return extendStatics(d2, b10);
};
function __extends$1(d2, b10) {
  extendStatics(d2, b10);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b10 === null ? Object.create(b10) : (__.prototype = b10.prototype, new __());
}
var RGB_REG = /rgba?\(([\s.,0-9]+)\)/;
var regexLG$2 = /^l\s*\(\s*([\d.]+)\s*\)\s*(.*)/i;
var regexRG$2 = /^r\s*\(\s*([\d.]+)\s*,\s*([\d.]+)\s*,\s*([\d.]+)\s*\)\s*(.*)/i;
var regexColorStop$2 = /[\d.]+:(#[^\s]+|[^\)]+\))/gi;
var isGradientColor = function(val) {
  return /^[r,R,L,l]{1}[\s]*\(/.test(val);
};
var createTmp = function() {
  var i2 = document.createElement("i");
  i2.title = "Web Colour Picker";
  i2.style.display = "none";
  document.body.appendChild(i2);
  return i2;
};
var getValue = function(start, end, percent2, index2) {
  return start[index2] + (end[index2] - start[index2]) * percent2;
};
function arr2rgb(arr) {
  return "#" + toHex(arr[0]) + toHex(arr[1]) + toHex(arr[2]);
}
var rgb2arr = function(str) {
  return [
    parseInt(str.substr(1, 2), 16),
    parseInt(str.substr(3, 2), 16),
    parseInt(str.substr(5, 2), 16)
  ];
};
var toHex = function(value2) {
  var x16Value = Math.round(value2).toString(16);
  return x16Value.length === 1 ? "0" + x16Value : x16Value;
};
var calColor = function(points2, percent2) {
  var fixedPercent = isNaN(Number(percent2)) || percent2 < 0 ? 0 : percent2 > 1 ? 1 : Number(percent2);
  var steps = points2.length - 1;
  var step = Math.floor(steps * fixedPercent);
  var left2 = steps * fixedPercent - step;
  var start = points2[step];
  var end = step === steps ? start : points2[step + 1];
  return arr2rgb([
    getValue(start, end, left2, 0),
    getValue(start, end, left2, 1),
    getValue(start, end, left2, 2)
  ]);
};
var iEl;
var toRGB = function(color2) {
  if (color2[0] === "#" && color2.length === 7) {
    return color2;
  }
  if (!iEl) {
    iEl = createTmp();
  }
  iEl.style.color = color2;
  var rst = document.defaultView.getComputedStyle(iEl, "").getPropertyValue("color");
  var matches = RGB_REG.exec(rst);
  var cArray = matches[1].split(/\s*,\s*/).map(function(s2) {
    return Number(s2);
  });
  rst = arr2rgb(cArray);
  return rst;
};
var gradient = function(colors) {
  var colorArray = isString(colors) ? colors.split("-") : colors;
  var points2 = map$2(colorArray, function(color2) {
    return rgb2arr(color2.indexOf("#") === -1 ? toRGB(color2) : color2);
  });
  return function(percent2) {
    return calColor(points2, percent2);
  };
};
var toCSSGradient = function(gradientColor) {
  if (isGradientColor(gradientColor)) {
    var cssColor_1;
    var steps = void 0;
    if (gradientColor[0] === "l") {
      var arr = regexLG$2.exec(gradientColor);
      var angle2 = +arr[1] + 90;
      steps = arr[2];
      cssColor_1 = "linear-gradient(" + angle2 + "deg, ";
    } else if (gradientColor[0] === "r") {
      cssColor_1 = "radial-gradient(";
      var arr = regexRG$2.exec(gradientColor);
      steps = arr[4];
    }
    var colorStops_1 = steps.match(regexColorStop$2);
    each$1(colorStops_1, function(item, index2) {
      var itemArr = item.split(":");
      cssColor_1 += itemArr[1] + " " + itemArr[0] * 100 + "%";
      if (index2 !== colorStops_1.length - 1) {
        cssColor_1 += ", ";
      }
    });
    cssColor_1 += ")";
    return cssColor_1;
  }
  return gradientColor;
};
var colorUtil = {
  rgb2arr,
  gradient,
  toRGB: memoize(toRGB),
  toCSSGradient
};
var Color = function(_super) {
  __extends$1(Color2, _super);
  function Color2(cfg) {
    var _this = _super.call(this, cfg) || this;
    _this.type = "color";
    _this.names = ["color"];
    if (isString(_this.values)) {
      _this.linear = true;
    }
    _this.gradient = colorUtil.gradient(_this.values);
    return _this;
  }
  Color2.prototype.getLinearValue = function(percent2) {
    return this.gradient(percent2);
  };
  return Color2;
}(Attribute);
var Opacity = function(_super) {
  __extends$1(Opacity2, _super);
  function Opacity2(cfg) {
    var _this = _super.call(this, cfg) || this;
    _this.type = "opacity";
    _this.names = ["opacity"];
    return _this;
  }
  return Opacity2;
}(Attribute);
var Position = function(_super) {
  __extends$1(Position2, _super);
  function Position2(cfg) {
    var _this = _super.call(this, cfg) || this;
    _this.names = ["x", "y"];
    _this.type = "position";
    return _this;
  }
  Position2.prototype.mapping = function(x2, y2) {
    var _a2 = this.scales, scaleX = _a2[0], scaleY = _a2[1];
    if (isNil(x2) || isNil(y2)) {
      return [];
    }
    return [
      isArray$1(x2) ? x2.map(function(xi2) {
        return scaleX.scale(xi2);
      }) : scaleX.scale(x2),
      isArray$1(y2) ? y2.map(function(yi2) {
        return scaleY.scale(yi2);
      }) : scaleY.scale(y2)
    ];
  };
  return Position2;
}(Attribute);
var Shape$2 = function(_super) {
  __extends$1(Shape2, _super);
  function Shape2(cfg) {
    var _this = _super.call(this, cfg) || this;
    _this.type = "shape";
    _this.names = ["shape"];
    return _this;
  }
  Shape2.prototype.getLinearValue = function(percent2) {
    var idx = Math.round((this.values.length - 1) * percent2);
    return this.values[idx];
  };
  return Shape2;
}(Attribute);
var Size = function(_super) {
  __extends$1(Size2, _super);
  function Size2(cfg) {
    var _this = _super.call(this, cfg) || this;
    _this.type = "size";
    _this.names = ["size"];
    return _this;
  }
  return Size2;
}(Attribute);
var methodCache = {};
function getTickMethod(key2) {
  return methodCache[key2];
}
function registerTickMethod(key2, method4) {
  methodCache[key2] = method4;
}
var Scale = function() {
  function Scale2(cfg) {
    this.type = "base";
    this.isCategory = false;
    this.isLinear = false;
    this.isContinuous = false;
    this.isIdentity = false;
    this.values = [];
    this.range = [0, 1];
    this.ticks = [];
    this.__cfg__ = cfg;
    this.initCfg();
    this.init();
  }
  Scale2.prototype.translate = function(v2) {
    return v2;
  };
  Scale2.prototype.change = function(cfg) {
    mix(this.__cfg__, cfg);
    this.init();
  };
  Scale2.prototype.clone = function() {
    return this.constructor(this.__cfg__);
  };
  Scale2.prototype.getTicks = function() {
    var _this = this;
    return map$2(this.ticks, function(tick, idx) {
      if (isObject(tick)) {
        return tick;
      }
      return {
        text: _this.getText(tick, idx),
        tickValue: tick,
        value: _this.scale(tick)
      };
    });
  };
  Scale2.prototype.getText = function(value2, key2) {
    var formatter = this.formatter;
    var res = formatter ? formatter(value2, key2) : value2;
    if (isNil(res) || !isFunction(res.toString)) {
      return "";
    }
    return res.toString();
  };
  Scale2.prototype.getConfig = function(key2) {
    return this.__cfg__[key2];
  };
  Scale2.prototype.init = function() {
    mix(this, this.__cfg__);
    this.setDomain();
    if (isEmpty(this.getConfig("ticks"))) {
      this.ticks = this.calculateTicks();
    }
  };
  Scale2.prototype.initCfg = function() {
  };
  Scale2.prototype.setDomain = function() {
  };
  Scale2.prototype.calculateTicks = function() {
    var tickMethod = this.tickMethod;
    var ticks = [];
    if (isString(tickMethod)) {
      var method4 = getTickMethod(tickMethod);
      if (!method4) {
        throw new Error("There is no method to to calculate ticks!");
      }
      ticks = method4(this);
    } else if (isFunction(tickMethod)) {
      ticks = tickMethod(this);
    }
    return ticks;
  };
  Scale2.prototype.rangeMin = function() {
    return this.range[0];
  };
  Scale2.prototype.rangeMax = function() {
    return this.range[1];
  };
  Scale2.prototype.calcPercent = function(value2, min2, max2) {
    if (isNumber$1(value2)) {
      return (value2 - min2) / (max2 - min2);
    }
    return NaN;
  };
  Scale2.prototype.calcValue = function(percent2, min2, max2) {
    return min2 + percent2 * (max2 - min2);
  };
  return Scale2;
}();
var Category$1 = function(_super) {
  __extends$3(Category2, _super);
  function Category2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "cat";
    _this.isCategory = true;
    return _this;
  }
  Category2.prototype.buildIndexMap = function() {
    if (!this.translateIndexMap) {
      this.translateIndexMap = /* @__PURE__ */ new Map();
      for (var i2 = 0; i2 < this.values.length; i2++) {
        this.translateIndexMap.set(this.values[i2], i2);
      }
    }
  };
  Category2.prototype.translate = function(value2) {
    this.buildIndexMap();
    var idx = this.translateIndexMap.get(value2);
    if (idx === void 0) {
      idx = isNumber$1(value2) ? value2 : NaN;
    }
    return idx;
  };
  Category2.prototype.scale = function(value2) {
    var order = this.translate(value2);
    var percent2 = this.calcPercent(order, this.min, this.max);
    return this.calcValue(percent2, this.rangeMin(), this.rangeMax());
  };
  Category2.prototype.invert = function(scaledValue) {
    var domainRange = this.max - this.min;
    var percent2 = this.calcPercent(scaledValue, this.rangeMin(), this.rangeMax());
    var idx = Math.round(domainRange * percent2) + this.min;
    if (idx < this.min || idx > this.max) {
      return NaN;
    }
    return this.values[idx];
  };
  Category2.prototype.getText = function(value2) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      args[_i - 1] = arguments[_i];
    }
    var v2 = value2;
    if (isNumber$1(value2) && !this.values.includes(value2)) {
      v2 = this.values[v2];
    }
    return _super.prototype.getText.apply(this, __spreadArrays([v2], args));
  };
  Category2.prototype.initCfg = function() {
    this.tickMethod = "cat";
  };
  Category2.prototype.setDomain = function() {
    if (isNil(this.getConfig("min"))) {
      this.min = 0;
    }
    if (isNil(this.getConfig("max"))) {
      var size2 = this.values.length;
      this.max = size2 > 1 ? size2 - 1 : size2;
    }
    if (this.translateIndexMap) {
      this.translateIndexMap = void 0;
    }
  };
  return Category2;
}(Scale);
var token = /d{1,4}|M{1,4}|YY(?:YY)?|S{1,3}|Do|ZZ|Z|([HhMsDm])\1?|[aA]|"[^"]*"|'[^']*'/g;
var twoDigitsOptional = "\\d\\d?";
var twoDigits = "\\d\\d";
var threeDigits = "\\d{3}";
var fourDigits = "\\d{4}";
var word = "[^\\s]+";
var literal = /\[([^]*?)\]/gm;
function shorten(arr, sLen) {
  var newArr = [];
  for (var i2 = 0, len = arr.length; i2 < len; i2++) {
    newArr.push(arr[i2].substr(0, sLen));
  }
  return newArr;
}
var monthUpdate = function(arrName) {
  return function(v2, i18n) {
    var lowerCaseArr = i18n[arrName].map(function(v3) {
      return v3.toLowerCase();
    });
    var index2 = lowerCaseArr.indexOf(v2.toLowerCase());
    if (index2 > -1) {
      return index2;
    }
    return null;
  };
};
function assign(origObj) {
  var args = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    args[_i - 1] = arguments[_i];
  }
  for (var _a2 = 0, args_1 = args; _a2 < args_1.length; _a2++) {
    var obj = args_1[_a2];
    for (var key2 in obj) {
      origObj[key2] = obj[key2];
    }
  }
  return origObj;
}
var dayNames = [
  "Sunday",
  "Monday",
  "Tuesday",
  "Wednesday",
  "Thursday",
  "Friday",
  "Saturday"
];
var monthNames = [
  "January",
  "February",
  "March",
  "April",
  "May",
  "June",
  "July",
  "August",
  "September",
  "October",
  "November",
  "December"
];
var monthNamesShort = shorten(monthNames, 3);
var dayNamesShort = shorten(dayNames, 3);
var defaultI18n = {
  dayNamesShort,
  dayNames,
  monthNamesShort,
  monthNames,
  amPm: ["am", "pm"],
  DoFn: function(dayOfMonth) {
    return dayOfMonth + ["th", "st", "nd", "rd"][dayOfMonth % 10 > 3 ? 0 : (dayOfMonth - dayOfMonth % 10 !== 10 ? 1 : 0) * dayOfMonth % 10];
  }
};
var globalI18n = assign({}, defaultI18n);
var setGlobalDateI18n = function(i18n) {
  return globalI18n = assign(globalI18n, i18n);
};
var regexEscape = function(str) {
  return str.replace(/[|\\{()[^$+*?.-]/g, "\\$&");
};
var pad = function(val, len) {
  if (len === void 0) {
    len = 2;
  }
  val = String(val);
  while (val.length < len) {
    val = "0" + val;
  }
  return val;
};
var formatFlags = {
  D: function(dateObj) {
    return String(dateObj.getDate());
  },
  DD: function(dateObj) {
    return pad(dateObj.getDate());
  },
  Do: function(dateObj, i18n) {
    return i18n.DoFn(dateObj.getDate());
  },
  d: function(dateObj) {
    return String(dateObj.getDay());
  },
  dd: function(dateObj) {
    return pad(dateObj.getDay());
  },
  ddd: function(dateObj, i18n) {
    return i18n.dayNamesShort[dateObj.getDay()];
  },
  dddd: function(dateObj, i18n) {
    return i18n.dayNames[dateObj.getDay()];
  },
  M: function(dateObj) {
    return String(dateObj.getMonth() + 1);
  },
  MM: function(dateObj) {
    return pad(dateObj.getMonth() + 1);
  },
  MMM: function(dateObj, i18n) {
    return i18n.monthNamesShort[dateObj.getMonth()];
  },
  MMMM: function(dateObj, i18n) {
    return i18n.monthNames[dateObj.getMonth()];
  },
  YY: function(dateObj) {
    return pad(String(dateObj.getFullYear()), 4).substr(2);
  },
  YYYY: function(dateObj) {
    return pad(dateObj.getFullYear(), 4);
  },
  h: function(dateObj) {
    return String(dateObj.getHours() % 12 || 12);
  },
  hh: function(dateObj) {
    return pad(dateObj.getHours() % 12 || 12);
  },
  H: function(dateObj) {
    return String(dateObj.getHours());
  },
  HH: function(dateObj) {
    return pad(dateObj.getHours());
  },
  m: function(dateObj) {
    return String(dateObj.getMinutes());
  },
  mm: function(dateObj) {
    return pad(dateObj.getMinutes());
  },
  s: function(dateObj) {
    return String(dateObj.getSeconds());
  },
  ss: function(dateObj) {
    return pad(dateObj.getSeconds());
  },
  S: function(dateObj) {
    return String(Math.round(dateObj.getMilliseconds() / 100));
  },
  SS: function(dateObj) {
    return pad(Math.round(dateObj.getMilliseconds() / 10), 2);
  },
  SSS: function(dateObj) {
    return pad(dateObj.getMilliseconds(), 3);
  },
  a: function(dateObj, i18n) {
    return dateObj.getHours() < 12 ? i18n.amPm[0] : i18n.amPm[1];
  },
  A: function(dateObj, i18n) {
    return dateObj.getHours() < 12 ? i18n.amPm[0].toUpperCase() : i18n.amPm[1].toUpperCase();
  },
  ZZ: function(dateObj) {
    var offset3 = dateObj.getTimezoneOffset();
    return (offset3 > 0 ? "-" : "+") + pad(Math.floor(Math.abs(offset3) / 60) * 100 + Math.abs(offset3) % 60, 4);
  },
  Z: function(dateObj) {
    var offset3 = dateObj.getTimezoneOffset();
    return (offset3 > 0 ? "-" : "+") + pad(Math.floor(Math.abs(offset3) / 60), 2) + ":" + pad(Math.abs(offset3) % 60, 2);
  }
};
var monthParse = function(v2) {
  return +v2 - 1;
};
var emptyDigits = [null, twoDigitsOptional];
var emptyWord = [null, word];
var amPm = [
  "isPm",
  word,
  function(v2, i18n) {
    var val = v2.toLowerCase();
    if (val === i18n.amPm[0]) {
      return 0;
    } else if (val === i18n.amPm[1]) {
      return 1;
    }
    return null;
  }
];
var timezoneOffset = [
  "timezoneOffset",
  "[^\\s]*?[\\+\\-]\\d\\d:?\\d\\d|[^\\s]*?Z?",
  function(v2) {
    var parts = (v2 + "").match(/([+-]|\d\d)/gi);
    if (parts) {
      var minutes = +parts[1] * 60 + parseInt(parts[2], 10);
      return parts[0] === "+" ? minutes : -minutes;
    }
    return 0;
  }
];
var parseFlags = {
  D: ["day", twoDigitsOptional],
  DD: ["day", twoDigits],
  Do: ["day", twoDigitsOptional + word, function(v2) {
    return parseInt(v2, 10);
  }],
  M: ["month", twoDigitsOptional, monthParse],
  MM: ["month", twoDigits, monthParse],
  YY: [
    "year",
    twoDigits,
    function(v2) {
      var now2 = new Date();
      var cent = +("" + now2.getFullYear()).substr(0, 2);
      return +("" + (+v2 > 68 ? cent - 1 : cent) + v2);
    }
  ],
  h: ["hour", twoDigitsOptional, void 0, "isPm"],
  hh: ["hour", twoDigits, void 0, "isPm"],
  H: ["hour", twoDigitsOptional],
  HH: ["hour", twoDigits],
  m: ["minute", twoDigitsOptional],
  mm: ["minute", twoDigits],
  s: ["second", twoDigitsOptional],
  ss: ["second", twoDigits],
  YYYY: ["year", fourDigits],
  S: ["millisecond", "\\d", function(v2) {
    return +v2 * 100;
  }],
  SS: ["millisecond", twoDigits, function(v2) {
    return +v2 * 10;
  }],
  SSS: ["millisecond", threeDigits],
  d: emptyDigits,
  dd: emptyDigits,
  ddd: emptyWord,
  dddd: emptyWord,
  MMM: ["month", word, monthUpdate("monthNamesShort")],
  MMMM: ["month", word, monthUpdate("monthNames")],
  a: amPm,
  A: amPm,
  ZZ: timezoneOffset,
  Z: timezoneOffset
};
var globalMasks = {
  default: "ddd MMM DD YYYY HH:mm:ss",
  shortDate: "M/D/YY",
  mediumDate: "MMM D, YYYY",
  longDate: "MMMM D, YYYY",
  fullDate: "dddd, MMMM D, YYYY",
  isoDate: "YYYY-MM-DD",
  isoDateTime: "YYYY-MM-DDTHH:mm:ssZ",
  shortTime: "HH:mm",
  mediumTime: "HH:mm:ss",
  longTime: "HH:mm:ss.SSS"
};
var setGlobalDateMasks = function(masks) {
  return assign(globalMasks, masks);
};
var format = function(dateObj, mask, i18n) {
  if (mask === void 0) {
    mask = globalMasks["default"];
  }
  if (i18n === void 0) {
    i18n = {};
  }
  if (typeof dateObj === "number") {
    dateObj = new Date(dateObj);
  }
  if (Object.prototype.toString.call(dateObj) !== "[object Date]" || isNaN(dateObj.getTime())) {
    throw new Error("Invalid Date pass to format");
  }
  mask = globalMasks[mask] || mask;
  var literals = [];
  mask = mask.replace(literal, function($0, $1) {
    literals.push($1);
    return "@@@";
  });
  var combinedI18nSettings = assign(assign({}, globalI18n), i18n);
  mask = mask.replace(token, function($0) {
    return formatFlags[$0](dateObj, combinedI18nSettings);
  });
  return mask.replace(/@@@/g, function() {
    return literals.shift();
  });
};
function parse(dateStr, format2, i18n) {
  if (i18n === void 0) {
    i18n = {};
  }
  if (typeof format2 !== "string") {
    throw new Error("Invalid format in fecha parse");
  }
  format2 = globalMasks[format2] || format2;
  if (dateStr.length > 1e3) {
    return null;
  }
  var today = new Date();
  var dateInfo = {
    year: today.getFullYear(),
    month: 0,
    day: 1,
    hour: 0,
    minute: 0,
    second: 0,
    millisecond: 0,
    isPm: null,
    timezoneOffset: null
  };
  var parseInfo = [];
  var literals = [];
  var newFormat = format2.replace(literal, function($0, $1) {
    literals.push(regexEscape($1));
    return "@@@";
  });
  var specifiedFields = {};
  var requiredFields = {};
  newFormat = regexEscape(newFormat).replace(token, function($0) {
    var info = parseFlags[$0];
    var field3 = info[0], regex = info[1], requiredField = info[3];
    if (specifiedFields[field3]) {
      throw new Error("Invalid format. " + field3 + " specified twice in format");
    }
    specifiedFields[field3] = true;
    if (requiredField) {
      requiredFields[requiredField] = true;
    }
    parseInfo.push(info);
    return "(" + regex + ")";
  });
  Object.keys(requiredFields).forEach(function(field3) {
    if (!specifiedFields[field3]) {
      throw new Error("Invalid format. " + field3 + " is required in specified format");
    }
  });
  newFormat = newFormat.replace(/@@@/g, function() {
    return literals.shift();
  });
  var matches = dateStr.match(new RegExp(newFormat, "i"));
  if (!matches) {
    return null;
  }
  var combinedI18nSettings = assign(assign({}, globalI18n), i18n);
  for (var i2 = 1; i2 < matches.length; i2++) {
    var _a2 = parseInfo[i2 - 1], field2 = _a2[0], parser = _a2[2];
    var value2 = parser ? parser(matches[i2], combinedI18nSettings) : +matches[i2];
    if (value2 == null) {
      return null;
    }
    dateInfo[field2] = value2;
  }
  if (dateInfo.isPm === 1 && dateInfo.hour != null && +dateInfo.hour !== 12) {
    dateInfo.hour = +dateInfo.hour + 12;
  } else if (dateInfo.isPm === 0 && +dateInfo.hour === 12) {
    dateInfo.hour = 0;
  }
  var dateTZ;
  if (dateInfo.timezoneOffset == null) {
    dateTZ = new Date(dateInfo.year, dateInfo.month, dateInfo.day, dateInfo.hour, dateInfo.minute, dateInfo.second, dateInfo.millisecond);
    var validateFields = [
      ["month", "getMonth"],
      ["day", "getDate"],
      ["hour", "getHours"],
      ["minute", "getMinutes"],
      ["second", "getSeconds"]
    ];
    for (var i2 = 0, len = validateFields.length; i2 < len; i2++) {
      if (specifiedFields[validateFields[i2][0]] && dateInfo[validateFields[i2][0]] !== dateTZ[validateFields[i2][1]]()) {
        return null;
      }
    }
  } else {
    dateTZ = new Date(Date.UTC(dateInfo.year, dateInfo.month, dateInfo.day, dateInfo.hour, dateInfo.minute - dateInfo.timezoneOffset, dateInfo.second, dateInfo.millisecond));
    if (dateInfo.month > 11 || dateInfo.month < 0 || dateInfo.day > 31 || dateInfo.day < 1 || dateInfo.hour > 23 || dateInfo.hour < 0 || dateInfo.minute > 59 || dateInfo.minute < 0 || dateInfo.second > 59 || dateInfo.second < 0) {
      return null;
    }
  }
  return dateTZ;
}
var fecha = {
  format,
  parse,
  defaultI18n,
  setGlobalDateI18n,
  setGlobalDateMasks
};
var fecha1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": fecha,
  assign,
  format,
  parse,
  defaultI18n,
  setGlobalDateI18n,
  setGlobalDateMasks
}, Symbol.toStringTag, { value: "Module" }));
function bisector(getter) {
  return function(a2, x2, _lo, _hi) {
    var lo = isNil(_lo) ? 0 : _lo;
    var hi2 = isNil(_hi) ? a2.length : _hi;
    while (lo < hi2) {
      var mid2 = lo + hi2 >>> 1;
      if (getter(a2[mid2]) > x2) {
        hi2 = mid2;
      } else {
        lo = mid2 + 1;
      }
    }
    return lo;
  };
}
var FORMAT_METHOD = "format";
function timeFormat(time, mask) {
  var method4 = fecha1[FORMAT_METHOD] || fecha[FORMAT_METHOD];
  return method4(time, mask);
}
function toTimeStamp(value2) {
  if (isString(value2)) {
    if (value2.indexOf("T") > 0) {
      value2 = new Date(value2).getTime();
    } else {
      value2 = new Date(value2.replace(/-/gi, "/")).getTime();
    }
  }
  if (isDate(value2)) {
    value2 = value2.getTime();
  }
  return value2;
}
var SECOND = 1e3;
var MINUTE = 60 * SECOND;
var HOUR = 60 * MINUTE;
var DAY = 24 * HOUR;
var MONTH = DAY * 31;
var YEAR = DAY * 365;
var intervals = [
  ["HH:mm:ss", SECOND],
  ["HH:mm:ss", SECOND * 10],
  ["HH:mm:ss", SECOND * 30],
  ["HH:mm", MINUTE],
  ["HH:mm", MINUTE * 10],
  ["HH:mm", MINUTE * 30],
  ["HH", HOUR],
  ["HH", HOUR * 6],
  ["HH", HOUR * 12],
  ["YYYY-MM-DD", DAY],
  ["YYYY-MM-DD", DAY * 4],
  ["YYYY-WW", DAY * 7],
  ["YYYY-MM", MONTH],
  ["YYYY-MM", MONTH * 4],
  ["YYYY-MM", MONTH * 6],
  ["YYYY", DAY * 380]
];
function getTickInterval(min2, max2, tickCount) {
  var target = (max2 - min2) / tickCount;
  var idx = bisector(function(o2) {
    return o2[1];
  })(intervals, target) - 1;
  var interval2 = intervals[idx];
  if (idx < 0) {
    interval2 = intervals[0];
  } else if (idx >= intervals.length) {
    interval2 = last(intervals);
  }
  return interval2;
}
var TimeCat = function(_super) {
  __extends$3(TimeCat2, _super);
  function TimeCat2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "timeCat";
    return _this;
  }
  TimeCat2.prototype.translate = function(value2) {
    value2 = toTimeStamp(value2);
    var index2 = this.values.indexOf(value2);
    if (index2 === -1) {
      if (isNumber$1(value2) && value2 < this.values.length) {
        index2 = value2;
      } else {
        index2 = NaN;
      }
    }
    return index2;
  };
  TimeCat2.prototype.getText = function(value2, tickIndex) {
    var index2 = this.translate(value2);
    if (index2 > -1) {
      var result = this.values[index2];
      var formatter = this.formatter;
      result = formatter ? formatter(result, tickIndex) : timeFormat(result, this.mask);
      return result;
    }
    return value2;
  };
  TimeCat2.prototype.initCfg = function() {
    this.tickMethod = "time-cat";
    this.mask = "YYYY-MM-DD";
    this.tickCount = 7;
  };
  TimeCat2.prototype.setDomain = function() {
    var values2 = this.values;
    each$1(values2, function(v2, i2) {
      values2[i2] = toTimeStamp(v2);
    });
    values2.sort(function(v1, v2) {
      return v1 - v2;
    });
    _super.prototype.setDomain.call(this);
  };
  return TimeCat2;
}(Category$1);
var Continuous = function(_super) {
  __extends$3(Continuous2, _super);
  function Continuous2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.isContinuous = true;
    return _this;
  }
  Continuous2.prototype.scale = function(value2) {
    if (isNil(value2)) {
      return NaN;
    }
    var rangeMin = this.rangeMin();
    var rangeMax = this.rangeMax();
    var max2 = this.max;
    var min2 = this.min;
    if (max2 === min2) {
      return rangeMin;
    }
    var percent2 = this.getScalePercent(value2);
    return rangeMin + percent2 * (rangeMax - rangeMin);
  };
  Continuous2.prototype.init = function() {
    _super.prototype.init.call(this);
    var ticks = this.ticks;
    var firstTick = head(ticks);
    var lastTick = last(ticks);
    if (firstTick < this.min) {
      this.min = firstTick;
    }
    if (lastTick > this.max) {
      this.max = lastTick;
    }
    if (!isNil(this.minLimit)) {
      this.min = firstTick;
    }
    if (!isNil(this.maxLimit)) {
      this.max = lastTick;
    }
  };
  Continuous2.prototype.setDomain = function() {
    var _a2 = getRange(this.values), min2 = _a2.min, max2 = _a2.max;
    if (isNil(this.min)) {
      this.min = min2;
    }
    if (isNil(this.max)) {
      this.max = max2;
    }
    if (this.min > this.max) {
      this.min = min2;
      this.max = max2;
    }
  };
  Continuous2.prototype.calculateTicks = function() {
    var _this = this;
    var ticks = _super.prototype.calculateTicks.call(this);
    if (!this.nice) {
      ticks = filter(ticks, function(tick) {
        return tick >= _this.min && tick <= _this.max;
      });
    }
    return ticks;
  };
  Continuous2.prototype.getScalePercent = function(value2) {
    var max2 = this.max;
    var min2 = this.min;
    return (value2 - min2) / (max2 - min2);
  };
  Continuous2.prototype.getInvertPercent = function(value2) {
    return (value2 - this.rangeMin()) / (this.rangeMax() - this.rangeMin());
  };
  return Continuous2;
}(Scale);
var Linear = function(_super) {
  __extends$3(Linear2, _super);
  function Linear2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "linear";
    _this.isLinear = true;
    return _this;
  }
  Linear2.prototype.invert = function(value2) {
    var percent2 = this.getInvertPercent(value2);
    return this.min + percent2 * (this.max - this.min);
  };
  Linear2.prototype.initCfg = function() {
    this.tickMethod = "wilkinson-extended";
    this.nice = false;
  };
  return Linear2;
}(Continuous);
function calBase(a2, b10) {
  var e3 = Math.E;
  var value2;
  if (b10 >= 0) {
    value2 = Math.pow(e3, Math.log(b10) / a2);
  } else {
    value2 = Math.pow(e3, Math.log(-b10) / a2) * -1;
  }
  return value2;
}
function log$1(a2, b10) {
  if (a2 === 1) {
    return 1;
  }
  return Math.log(b10) / Math.log(a2);
}
function getLogPositiveMin(values2, base, max2) {
  if (isNil(max2)) {
    max2 = Math.max.apply(null, values2);
  }
  var positiveMin = max2;
  each$1(values2, function(value2) {
    if (value2 > 0 && value2 < positiveMin) {
      positiveMin = value2;
    }
  });
  if (positiveMin === max2) {
    positiveMin = max2 / base;
  }
  if (positiveMin > 1) {
    positiveMin = 1;
  }
  return positiveMin;
}
var Log = function(_super) {
  __extends$3(Log2, _super);
  function Log2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "log";
    return _this;
  }
  Log2.prototype.invert = function(value2) {
    var base = this.base;
    var max2 = log$1(base, this.max);
    var rangeMin = this.rangeMin();
    var range3 = this.rangeMax() - rangeMin;
    var min2;
    var positiveMin = this.positiveMin;
    if (positiveMin) {
      if (value2 === 0) {
        return 0;
      }
      min2 = log$1(base, positiveMin / base);
      var appendPercent = 1 / (max2 - min2) * range3;
      if (value2 < appendPercent) {
        return value2 / appendPercent * positiveMin;
      }
    } else {
      min2 = log$1(base, this.min);
    }
    var percent2 = (value2 - rangeMin) / range3;
    var tmp = percent2 * (max2 - min2) + min2;
    return Math.pow(base, tmp);
  };
  Log2.prototype.initCfg = function() {
    this.tickMethod = "log";
    this.base = 10;
    this.tickCount = 6;
    this.nice = true;
  };
  Log2.prototype.setDomain = function() {
    _super.prototype.setDomain.call(this);
    var min2 = this.min;
    if (min2 < 0) {
      throw new Error("When you use log scale, the minimum value must be greater than zero!");
    }
    if (min2 === 0) {
      this.positiveMin = getLogPositiveMin(this.values, this.base, this.max);
    }
  };
  Log2.prototype.getScalePercent = function(value2) {
    var max2 = this.max;
    var min2 = this.min;
    if (max2 === min2) {
      return 0;
    }
    if (value2 <= 0) {
      return 0;
    }
    var base = this.base;
    var positiveMin = this.positiveMin;
    if (positiveMin) {
      min2 = positiveMin * 1 / base;
    }
    var percent2;
    if (value2 < positiveMin) {
      percent2 = value2 / positiveMin / (log$1(base, max2) - log$1(base, min2));
    } else {
      percent2 = (log$1(base, value2) - log$1(base, min2)) / (log$1(base, max2) - log$1(base, min2));
    }
    return percent2;
  };
  return Log2;
}(Continuous);
var Pow = function(_super) {
  __extends$3(Pow2, _super);
  function Pow2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "pow";
    return _this;
  }
  Pow2.prototype.invert = function(value2) {
    var percent2 = this.getInvertPercent(value2);
    var exponent2 = this.exponent;
    var max2 = calBase(exponent2, this.max);
    var min2 = calBase(exponent2, this.min);
    var tmp = percent2 * (max2 - min2) + min2;
    var factor = tmp >= 0 ? 1 : -1;
    return Math.pow(tmp, exponent2) * factor;
  };
  Pow2.prototype.initCfg = function() {
    this.tickMethod = "pow";
    this.exponent = 2;
    this.tickCount = 5;
    this.nice = true;
  };
  Pow2.prototype.getScalePercent = function(value2) {
    var max2 = this.max;
    var min2 = this.min;
    if (max2 === min2) {
      return 0;
    }
    var exponent2 = this.exponent;
    var percent2 = (calBase(exponent2, value2) - calBase(exponent2, min2)) / (calBase(exponent2, max2) - calBase(exponent2, min2));
    return percent2;
  };
  return Pow2;
}(Continuous);
var Time = function(_super) {
  __extends$3(Time2, _super);
  function Time2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "time";
    return _this;
  }
  Time2.prototype.getText = function(value2, index2) {
    var numberValue = this.translate(value2);
    var formatter = this.formatter;
    return formatter ? formatter(numberValue, index2) : timeFormat(numberValue, this.mask);
  };
  Time2.prototype.scale = function(value2) {
    var v2 = value2;
    if (isString(v2) || isDate(v2)) {
      v2 = this.translate(v2);
    }
    return _super.prototype.scale.call(this, v2);
  };
  Time2.prototype.translate = function(v2) {
    return toTimeStamp(v2);
  };
  Time2.prototype.initCfg = function() {
    this.tickMethod = "time-pretty";
    this.mask = "YYYY-MM-DD";
    this.tickCount = 7;
    this.nice = false;
  };
  Time2.prototype.setDomain = function() {
    var values2 = this.values;
    var minConfig = this.getConfig("min");
    var maxConfig = this.getConfig("max");
    if (!isNil(minConfig) || !isNumber$1(minConfig)) {
      this.min = this.translate(this.min);
    }
    if (!isNil(maxConfig) || !isNumber$1(maxConfig)) {
      this.max = this.translate(this.max);
    }
    if (values2 && values2.length) {
      var timeStamps_1 = [];
      var min_1 = Infinity;
      var secondMin_1 = min_1;
      var max_1 = 0;
      each$1(values2, function(v2) {
        var timeStamp = toTimeStamp(v2);
        if (isNaN(timeStamp)) {
          throw new TypeError("Invalid Time: " + v2 + " in time scale!");
        }
        if (min_1 > timeStamp) {
          secondMin_1 = min_1;
          min_1 = timeStamp;
        } else if (secondMin_1 > timeStamp) {
          secondMin_1 = timeStamp;
        }
        if (max_1 < timeStamp) {
          max_1 = timeStamp;
        }
        timeStamps_1.push(timeStamp);
      });
      if (values2.length > 1) {
        this.minTickInterval = secondMin_1 - min_1;
      }
      if (isNil(minConfig)) {
        this.min = min_1;
      }
      if (isNil(maxConfig)) {
        this.max = max_1;
      }
    }
  };
  return Time2;
}(Linear);
var Quantize = function(_super) {
  __extends$3(Quantize2, _super);
  function Quantize2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "quantize";
    return _this;
  }
  Quantize2.prototype.invert = function(value2) {
    var ticks = this.ticks;
    var length2 = ticks.length;
    var percent2 = this.getInvertPercent(value2);
    var minIndex = Math.floor(percent2 * (length2 - 1));
    if (minIndex >= length2 - 1) {
      return last(ticks);
    }
    if (minIndex < 0) {
      return head(ticks);
    }
    var minTick = ticks[minIndex];
    var nextTick = ticks[minIndex + 1];
    var minIndexPercent = minIndex / (length2 - 1);
    var maxIndexPercent = (minIndex + 1) / (length2 - 1);
    return minTick + (percent2 - minIndexPercent) / (maxIndexPercent - minIndexPercent) * (nextTick - minTick);
  };
  Quantize2.prototype.initCfg = function() {
    this.tickMethod = "r-pretty";
    this.tickCount = 5;
    this.nice = true;
  };
  Quantize2.prototype.calculateTicks = function() {
    var ticks = _super.prototype.calculateTicks.call(this);
    if (!this.nice) {
      if (last(ticks) !== this.max) {
        ticks.push(this.max);
      }
      if (head(ticks) !== this.min) {
        ticks.unshift(this.min);
      }
    }
    return ticks;
  };
  Quantize2.prototype.getScalePercent = function(value2) {
    var ticks = this.ticks;
    if (value2 < head(ticks)) {
      return 0;
    }
    if (value2 > last(ticks)) {
      return 1;
    }
    var minIndex = 0;
    each$1(ticks, function(tick, index2) {
      if (value2 >= tick) {
        minIndex = index2;
      } else {
        return false;
      }
    });
    return minIndex / (ticks.length - 1);
  };
  return Quantize2;
}(Continuous);
var Quantile = function(_super) {
  __extends$3(Quantile2, _super);
  function Quantile2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "quantile";
    return _this;
  }
  Quantile2.prototype.initCfg = function() {
    this.tickMethod = "quantile";
    this.tickCount = 5;
    this.nice = true;
  };
  return Quantile2;
}(Quantize);
var map = {};
function getClass(key2) {
  return map[key2];
}
function registerClass(key2, cls) {
  if (getClass(key2)) {
    throw new Error("type '" + key2 + "' existed.");
  }
  map[key2] = cls;
}
var Identity = function(_super) {
  __extends$3(Identity2, _super);
  function Identity2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "identity";
    _this.isIdentity = true;
    return _this;
  }
  Identity2.prototype.calculateTicks = function() {
    return this.values;
  };
  Identity2.prototype.scale = function(value2) {
    if (this.values[0] !== value2 && isNumber$1(value2)) {
      return value2;
    }
    return this.range[0];
  };
  Identity2.prototype.invert = function(value2) {
    var range3 = this.range;
    if (value2 < range3[0] || value2 > range3[1]) {
      return NaN;
    }
    return this.values[0];
  };
  return Identity2;
}(Scale);
function calculateCatTicks(cfg) {
  var values2 = cfg.values, tickInterval = cfg.tickInterval, tickCount = cfg.tickCount, showLast = cfg.showLast;
  if (isNumber$1(tickInterval)) {
    var ticks_1 = filter(values2, function(__, i3) {
      return i3 % tickInterval === 0;
    });
    var lastValue = last(values2);
    if (showLast && last(ticks_1) !== lastValue) {
      ticks_1.push(lastValue);
    }
    return ticks_1;
  }
  var len = values2.length;
  var min2 = cfg.min, max2 = cfg.max;
  if (isNil(min2)) {
    min2 = 0;
  }
  if (isNil(max2)) {
    max2 = values2.length - 1;
  }
  if (!isNumber$1(tickCount) || tickCount >= len)
    return values2.slice(min2, max2 + 1);
  if (tickCount <= 0 || max2 <= 0)
    return [];
  var interval2 = tickCount === 1 ? len : Math.floor(len / (tickCount - 1));
  var ticks = [];
  var idx = min2;
  for (var i2 = 0; i2 < tickCount; i2++) {
    if (idx >= max2)
      break;
    idx = Math.min(min2 + i2 * interval2, max2);
    if (i2 === tickCount - 1 && showLast)
      ticks.push(values2[max2]);
    else
      ticks.push(values2[idx]);
  }
  return ticks;
}
function d3Linear(cfg) {
  var min2 = cfg.min, max2 = cfg.max, nice = cfg.nice, tickCount = cfg.tickCount;
  var linear2 = new D3Linear();
  linear2.domain([min2, max2]);
  if (nice) {
    linear2.nice(tickCount);
  }
  return linear2.ticks(tickCount);
}
var DEFAULT_COUNT = 5;
var e10 = Math.sqrt(50);
var e5 = Math.sqrt(10);
var e2 = Math.sqrt(2);
var D3Linear = function() {
  function D3Linear2() {
    this._domain = [0, 1];
  }
  D3Linear2.prototype.domain = function(domain) {
    if (domain) {
      this._domain = Array.from(domain, Number);
      return this;
    }
    return this._domain.slice();
  };
  D3Linear2.prototype.nice = function(count2) {
    var _a2, _b;
    if (count2 === void 0) {
      count2 = DEFAULT_COUNT;
    }
    var d2 = this._domain.slice();
    var i0 = 0;
    var i1 = this._domain.length - 1;
    var start = this._domain[i0];
    var stop = this._domain[i1];
    var step;
    if (stop < start) {
      _a2 = [stop, start], start = _a2[0], stop = _a2[1];
      _b = [i1, i0], i0 = _b[0], i1 = _b[1];
    }
    step = tickIncrement(start, stop, count2);
    if (step > 0) {
      start = Math.floor(start / step) * step;
      stop = Math.ceil(stop / step) * step;
      step = tickIncrement(start, stop, count2);
    } else if (step < 0) {
      start = Math.ceil(start * step) / step;
      stop = Math.floor(stop * step) / step;
      step = tickIncrement(start, stop, count2);
    }
    if (step > 0) {
      d2[i0] = Math.floor(start / step) * step;
      d2[i1] = Math.ceil(stop / step) * step;
      this.domain(d2);
    } else if (step < 0) {
      d2[i0] = Math.ceil(start * step) / step;
      d2[i1] = Math.floor(stop * step) / step;
      this.domain(d2);
    }
    return this;
  };
  D3Linear2.prototype.ticks = function(count2) {
    if (count2 === void 0) {
      count2 = DEFAULT_COUNT;
    }
    return d3ArrayTicks(this._domain[0], this._domain[this._domain.length - 1], count2 || DEFAULT_COUNT);
  };
  return D3Linear2;
}();
function d3ArrayTicks(start, stop, count2) {
  var reverse;
  var i2 = -1;
  var n2;
  var ticks;
  var step;
  stop = +stop, start = +start, count2 = +count2;
  if (start === stop && count2 > 0) {
    return [start];
  }
  if (reverse = stop < start) {
    n2 = start, start = stop, stop = n2;
  }
  if ((step = tickIncrement(start, stop, count2)) === 0 || !isFinite(step)) {
    return [];
  }
  if (step > 0) {
    start = Math.ceil(start / step);
    stop = Math.floor(stop / step);
    ticks = new Array(n2 = Math.ceil(stop - start + 1));
    while (++i2 < n2) {
      ticks[i2] = (start + i2) * step;
    }
  } else {
    start = Math.floor(start * step);
    stop = Math.ceil(stop * step);
    ticks = new Array(n2 = Math.ceil(start - stop + 1));
    while (++i2 < n2) {
      ticks[i2] = (start - i2) / step;
    }
  }
  if (reverse) {
    ticks.reverse();
  }
  return ticks;
}
function tickIncrement(start, stop, count2) {
  var step = (stop - start) / Math.max(0, count2);
  var power2 = Math.floor(Math.log(step) / Math.LN10);
  var error = step / Math.pow(10, power2);
  return power2 >= 0 ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power2) : -Math.pow(10, -power2) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);
}
function snapMultiple(v2, base, snapType) {
  var div;
  if (snapType === "ceil") {
    div = Math.ceil(v2 / base);
  } else if (snapType === "floor") {
    div = Math.floor(v2 / base);
  } else {
    div = Math.round(v2 / base);
  }
  return div * base;
}
function intervalTicks(min2, max2, interval2) {
  var minTick = snapMultiple(min2, interval2, "floor");
  var maxTick = snapMultiple(max2, interval2, "ceil");
  minTick = fixedBase(minTick, interval2);
  maxTick = fixedBase(maxTick, interval2);
  var ticks = [];
  var availableInterval = Math.max((maxTick - minTick) / (Math.pow(2, 12) - 1), interval2);
  for (var i2 = minTick; i2 <= maxTick; i2 = i2 + availableInterval) {
    var tickValue = fixedBase(i2, availableInterval);
    ticks.push(tickValue);
  }
  return {
    min: minTick,
    max: maxTick,
    ticks
  };
}
function strictLimit(cfg, defaultMin, defaultMax) {
  var _a2;
  var minLimit = cfg.minLimit, maxLimit = cfg.maxLimit, min2 = cfg.min, max2 = cfg.max, _b = cfg.tickCount, tickCount = _b === void 0 ? 5 : _b;
  var tickMin = isNil(minLimit) ? isNil(defaultMin) ? min2 : defaultMin : minLimit;
  var tickMax = isNil(maxLimit) ? isNil(defaultMax) ? max2 : defaultMax : maxLimit;
  if (tickMin > tickMax) {
    _a2 = [tickMin, tickMax], tickMax = _a2[0], tickMin = _a2[1];
  }
  if (tickCount <= 2) {
    return [tickMin, tickMax];
  }
  var step = (tickMax - tickMin) / (tickCount - 1);
  var ticks = [];
  for (var i2 = 0; i2 < tickCount; i2++) {
    ticks.push(tickMin + step * i2);
  }
  return ticks;
}
function d3LinearTickMethod(cfg) {
  var min2 = cfg.min, max2 = cfg.max, tickInterval = cfg.tickInterval, minLimit = cfg.minLimit, maxLimit = cfg.maxLimit;
  var ticks = d3Linear(cfg);
  if (!isNil(minLimit) || !isNil(maxLimit)) {
    return strictLimit(cfg, head(ticks), last(ticks));
  }
  if (tickInterval) {
    return intervalTicks(min2, max2, tickInterval).ticks;
  }
  return ticks;
}
function prettyNumber(n2) {
  return Math.abs(n2) < 1e-15 ? n2 : parseFloat(n2.toFixed(15));
}
var DEFAULT_Q = [1, 5, 2, 2.5, 4, 3];
var eps = Number.EPSILON * 100;
function mod(n2, m2) {
  return (n2 % m2 + m2) % m2;
}
function round(n2) {
  return Math.round(n2 * 1e12) / 1e12;
}
function simplicity(q2, Q2, j2, lmin, lmax, lstep) {
  var n2 = size(Q2);
  var i2 = indexOf(Q2, q2);
  var v2 = 0;
  var m2 = mod(lmin, lstep);
  if ((m2 < eps || lstep - m2 < eps) && lmin <= 0 && lmax >= 0) {
    v2 = 1;
  }
  return 1 - i2 / (n2 - 1) - j2 + v2;
}
function simplicityMax(q2, Q2, j2) {
  var n2 = size(Q2);
  var i2 = indexOf(Q2, q2);
  var v2 = 1;
  return 1 - i2 / (n2 - 1) - j2 + v2;
}
function density(k2, m2, dMin, dMax, lMin, lMax) {
  var r2 = (k2 - 1) / (lMax - lMin);
  var rt = (m2 - 1) / (Math.max(lMax, dMax) - Math.min(dMin, lMin));
  return 2 - Math.max(r2 / rt, rt / r2);
}
function densityMax(k2, m2) {
  if (k2 >= m2) {
    return 2 - (k2 - 1) / (m2 - 1);
  }
  return 1;
}
function coverage(dMin, dMax, lMin, lMax) {
  var range3 = dMax - dMin;
  return 1 - 0.5 * (Math.pow(dMax - lMax, 2) + Math.pow(dMin - lMin, 2)) / Math.pow(0.1 * range3, 2);
}
function coverageMax(dMin, dMax, span) {
  var range3 = dMax - dMin;
  if (span > range3) {
    var half = (span - range3) / 2;
    return 1 - Math.pow(half, 2) / Math.pow(0.1 * range3, 2);
  }
  return 1;
}
function legibility() {
  return 1;
}
function extended(dMin, dMax, n2, onlyLoose, Q2, w2) {
  if (n2 === void 0) {
    n2 = 5;
  }
  if (onlyLoose === void 0) {
    onlyLoose = true;
  }
  if (Q2 === void 0) {
    Q2 = DEFAULT_Q;
  }
  if (w2 === void 0) {
    w2 = [0.25, 0.2, 0.5, 0.05];
  }
  var m2 = n2 < 0 ? 0 : Math.round(n2);
  if (Number.isNaN(dMin) || Number.isNaN(dMax) || typeof dMin !== "number" || typeof dMax !== "number" || !m2) {
    return {
      min: 0,
      max: 0,
      ticks: []
    };
  }
  if (dMax - dMin < 1e-15 || m2 === 1) {
    return {
      min: dMin,
      max: dMax,
      ticks: [dMin]
    };
  }
  if (dMax - dMin > 1e148) {
    var count2 = n2 || 5;
    var step_1 = (dMax - dMin) / count2;
    return {
      min: dMin,
      max: dMax,
      ticks: Array(count2).fill(null).map(function(_2, idx) {
        return prettyNumber(dMin + step_1 * idx);
      })
    };
  }
  var best = {
    score: -2,
    lmin: 0,
    lmax: 0,
    lstep: 0
  };
  var j2 = 1;
  while (j2 < Infinity) {
    for (var i2 = 0; i2 < Q2.length; i2 += 1) {
      var q2 = Q2[i2];
      var sm = simplicityMax(q2, Q2, j2);
      if (w2[0] * sm + w2[1] + w2[2] + w2[3] < best.score) {
        j2 = Infinity;
        break;
      }
      var k2 = 2;
      while (k2 < Infinity) {
        var dm = densityMax(k2, m2);
        if (w2[0] * sm + w2[1] + w2[2] * dm + w2[3] < best.score) {
          break;
        }
        var delta = (dMax - dMin) / (k2 + 1) / j2 / q2;
        var z2 = Math.ceil(Math.log10(delta));
        while (z2 < Infinity) {
          var step = j2 * q2 * Math.pow(10, z2);
          var cm = coverageMax(dMin, dMax, step * (k2 - 1));
          if (w2[0] * sm + w2[1] * cm + w2[2] * dm + w2[3] < best.score) {
            break;
          }
          var minStart = Math.floor(dMax / step) * j2 - (k2 - 1) * j2;
          var maxStart = Math.ceil(dMin / step) * j2;
          if (minStart <= maxStart) {
            var count2 = maxStart - minStart;
            for (var i_1 = 0; i_1 <= count2; i_1 += 1) {
              var start = minStart + i_1;
              var lMin = start * (step / j2);
              var lMax = lMin + step * (k2 - 1);
              var lStep = step;
              var s2 = simplicity(q2, Q2, j2, lMin, lMax, lStep);
              var c2 = coverage(dMin, dMax, lMin, lMax);
              var g2 = density(k2, m2, dMin, dMax, lMin, lMax);
              var l2 = legibility();
              var score2 = w2[0] * s2 + w2[1] * c2 + w2[2] * g2 + w2[3] * l2;
              if (score2 > best.score && (!onlyLoose || lMin <= dMin && lMax >= dMax)) {
                best.lmin = lMin;
                best.lmax = lMax;
                best.lstep = lStep;
                best.score = score2;
              }
            }
          }
          z2 += 1;
        }
        k2 += 1;
      }
    }
    j2 += 1;
  }
  var lmax = prettyNumber(best.lmax);
  var lmin = prettyNumber(best.lmin);
  var lstep = prettyNumber(best.lstep);
  var tickCount = Math.floor(round((lmax - lmin) / lstep)) + 1;
  var ticks = new Array(tickCount);
  ticks[0] = prettyNumber(lmin);
  for (var i2 = 1; i2 < tickCount; i2++) {
    ticks[i2] = prettyNumber(ticks[i2 - 1] + lstep);
  }
  return {
    min: Math.min(dMin, head(ticks)),
    max: Math.max(dMax, last(ticks)),
    ticks
  };
}
function linear$1(cfg) {
  var min2 = cfg.min, max2 = cfg.max, tickCount = cfg.tickCount, nice = cfg.nice, tickInterval = cfg.tickInterval, minLimit = cfg.minLimit, maxLimit = cfg.maxLimit;
  var ticks = extended(min2, max2, tickCount, nice).ticks;
  if (!isNil(minLimit) || !isNil(maxLimit)) {
    return strictLimit(cfg, head(ticks), last(ticks));
  }
  if (tickInterval) {
    return intervalTicks(min2, max2, tickInterval).ticks;
  }
  return ticks;
}
function calculateLogTicks(cfg) {
  var base = cfg.base, tickCount = cfg.tickCount, min2 = cfg.min, max2 = cfg.max, values2 = cfg.values;
  var minTick;
  var maxTick = log$1(base, max2);
  if (min2 > 0) {
    minTick = Math.floor(log$1(base, min2));
  } else {
    var positiveMin = getLogPositiveMin(values2, base, max2);
    minTick = Math.floor(log$1(base, positiveMin));
  }
  var count2 = maxTick - minTick;
  var avg2 = Math.ceil(count2 / tickCount);
  var ticks = [];
  for (var i2 = minTick; i2 < maxTick + avg2; i2 = i2 + avg2) {
    ticks.push(Math.pow(base, i2));
  }
  if (min2 <= 0) {
    ticks.unshift(0);
  }
  return ticks;
}
function pretty(min2, max2, m2) {
  if (m2 === void 0) {
    m2 = 5;
  }
  if (min2 === max2) {
    return {
      max: max2,
      min: min2,
      ticks: [min2]
    };
  }
  var n2 = m2 < 0 ? 0 : Math.round(m2);
  if (n2 === 0)
    return { max: max2, min: min2, ticks: [] };
  var h2 = 1.5;
  var h5 = 0.5 + 1.5 * h2;
  var d2 = max2 - min2;
  var c2 = d2 / n2;
  var base = Math.pow(10, Math.floor(Math.log10(c2)));
  var unit = base;
  if (2 * base - c2 < h2 * (c2 - unit)) {
    unit = 2 * base;
    if (5 * base - c2 < h5 * (c2 - unit)) {
      unit = 5 * base;
      if (10 * base - c2 < h2 * (c2 - unit)) {
        unit = 10 * base;
      }
    }
  }
  var nu = Math.ceil(max2 / unit);
  var ns = Math.floor(min2 / unit);
  var hi2 = Math.max(nu * unit, max2);
  var lo = Math.min(ns * unit, min2);
  var size2 = Math.floor((hi2 - lo) / unit) + 1;
  var ticks = new Array(size2);
  for (var i2 = 0; i2 < size2; i2++) {
    ticks[i2] = prettyNumber(lo + i2 * unit);
  }
  return {
    min: lo,
    max: hi2,
    ticks
  };
}
function calculatePowTicks(cfg) {
  var exponent2 = cfg.exponent, tickCount = cfg.tickCount;
  var max2 = Math.ceil(calBase(exponent2, cfg.max));
  var min2 = Math.floor(calBase(exponent2, cfg.min));
  var ticks = pretty(min2, max2, tickCount).ticks;
  return ticks.map(function(tick) {
    var factor = tick >= 0 ? 1 : -1;
    return Math.pow(tick, exponent2) * factor;
  });
}
function quantileSorted$1(x2, p2) {
  var idx = x2.length * p2;
  if (p2 === 1) {
    return x2[x2.length - 1];
  } else if (p2 === 0) {
    return x2[0];
  } else if (idx % 1 !== 0) {
    return x2[Math.ceil(idx) - 1];
  } else if (x2.length % 2 === 0) {
    return (x2[idx - 1] + x2[idx]) / 2;
  } else {
    return x2[idx];
  }
}
function calculateTicks(cfg) {
  var tickCount = cfg.tickCount, values2 = cfg.values;
  if (!values2 || !values2.length) {
    return [];
  }
  var sorted = values2.slice().sort(function(a2, b10) {
    return a2 - b10;
  });
  var ticks = [];
  for (var i2 = 0; i2 < tickCount; i2++) {
    var p2 = i2 / (tickCount - 1);
    ticks.push(quantileSorted$1(sorted, p2));
  }
  return ticks;
}
function linearPretty(cfg) {
  var min2 = cfg.min, max2 = cfg.max, tickCount = cfg.tickCount, tickInterval = cfg.tickInterval, minLimit = cfg.minLimit, maxLimit = cfg.maxLimit;
  var ticks = pretty(min2, max2, tickCount).ticks;
  if (!isNil(minLimit) || !isNil(maxLimit)) {
    return strictLimit(cfg, head(ticks), last(ticks));
  }
  if (tickInterval) {
    return intervalTicks(min2, max2, tickInterval).ticks;
  }
  return ticks;
}
function calculateTimeTicks(cfg) {
  var min2 = cfg.min, max2 = cfg.max, minTickInterval = cfg.minTickInterval;
  var tickInterval = cfg.tickInterval;
  var tickCount = cfg.tickCount;
  if (tickInterval) {
    tickCount = Math.ceil((max2 - min2) / tickInterval);
  } else {
    tickInterval = getTickInterval(min2, max2, tickCount)[1];
    var count2 = (max2 - min2) / tickInterval;
    var ratio = count2 / tickCount;
    if (ratio > 1) {
      tickInterval = tickInterval * Math.ceil(ratio);
    }
    if (minTickInterval && tickInterval < minTickInterval) {
      tickInterval = minTickInterval;
    }
  }
  tickInterval = Math.max(Math.floor((max2 - min2) / (Math.pow(2, 12) - 1)), tickInterval);
  var ticks = [];
  for (var i2 = min2; i2 < max2 + tickInterval; i2 += tickInterval) {
    ticks.push(i2);
  }
  return ticks;
}
function timeCat(cfg) {
  var ticks = calculateCatTicks(__assign$4({ showLast: true }, cfg));
  return ticks;
}
function getYear(date4) {
  return new Date(date4).getFullYear();
}
function createYear(year) {
  return new Date(year, 0, 1).getTime();
}
function getMonth(date4) {
  return new Date(date4).getMonth();
}
function diffMonth(min2, max2) {
  var minYear = getYear(min2);
  var maxYear = getYear(max2);
  var minMonth = getMonth(min2);
  var maxMonth = getMonth(max2);
  return (maxYear - minYear) * 12 + (maxMonth - minMonth) % 12;
}
function creatMonth(year, month) {
  return new Date(year, month, 1).getTime();
}
function diffDay(min2, max2) {
  return Math.ceil((max2 - min2) / DAY);
}
function diffHour(min2, max2) {
  return Math.ceil((max2 - min2) / HOUR);
}
function diffMinus(min2, max2) {
  return Math.ceil((max2 - min2) / (60 * 1e3));
}
function timePretty(cfg) {
  var min2 = cfg.min, max2 = cfg.max, minTickInterval = cfg.minTickInterval, tickCount = cfg.tickCount;
  var tickInterval = cfg.tickInterval;
  var ticks = [];
  if (!tickInterval) {
    tickInterval = (max2 - min2) / tickCount;
    if (minTickInterval && tickInterval < minTickInterval) {
      tickInterval = minTickInterval;
    }
  }
  tickInterval = Math.max(Math.floor((max2 - min2) / (Math.pow(2, 12) - 1)), tickInterval);
  var minYear = getYear(min2);
  if (tickInterval > YEAR) {
    var maxYear = getYear(max2);
    var yearInterval = Math.ceil(tickInterval / YEAR);
    for (var i2 = minYear; i2 <= maxYear + yearInterval; i2 = i2 + yearInterval) {
      ticks.push(createYear(i2));
    }
  } else if (tickInterval > MONTH) {
    var monthInterval = Math.ceil(tickInterval / MONTH);
    var mmMoth = getMonth(min2);
    var dMonths = diffMonth(min2, max2);
    for (var i2 = 0; i2 <= dMonths + monthInterval; i2 = i2 + monthInterval) {
      ticks.push(creatMonth(minYear, i2 + mmMoth));
    }
  } else if (tickInterval > DAY) {
    var date4 = new Date(min2);
    var year = date4.getFullYear();
    var month = date4.getMonth();
    var mday = date4.getDate();
    var day = Math.ceil(tickInterval / DAY);
    var ddays = diffDay(min2, max2);
    for (var i2 = 0; i2 < ddays + day; i2 = i2 + day) {
      ticks.push(new Date(year, month, mday + i2).getTime());
    }
  } else if (tickInterval > HOUR) {
    var date4 = new Date(min2);
    var year = date4.getFullYear();
    var month = date4.getMonth();
    var day = date4.getDate();
    var hour = date4.getHours();
    var hours = Math.ceil(tickInterval / HOUR);
    var dHours = diffHour(min2, max2);
    for (var i2 = 0; i2 <= dHours + hours; i2 = i2 + hours) {
      ticks.push(new Date(year, month, day, hour + i2).getTime());
    }
  } else if (tickInterval > MINUTE) {
    var dMinus = diffMinus(min2, max2);
    var minutes = Math.ceil(tickInterval / MINUTE);
    for (var i2 = 0; i2 <= dMinus + minutes; i2 = i2 + minutes) {
      ticks.push(min2 + i2 * MINUTE);
    }
  } else {
    var interval2 = tickInterval;
    if (interval2 < SECOND) {
      interval2 = SECOND;
    }
    var minSecond = Math.floor(min2 / SECOND) * SECOND;
    var dSeconds = Math.ceil((max2 - min2) / SECOND);
    var seconds = Math.ceil(interval2 / SECOND);
    for (var i2 = 0; i2 < dSeconds + seconds; i2 = i2 + seconds) {
      ticks.push(minSecond + i2 * SECOND);
    }
  }
  if (ticks.length >= 512) {
    console.warn("Notice: current ticks length(" + ticks.length + ') >= 512, may cause performance issues, even out of memory. Because of the configure "tickInterval"(in milliseconds, current is ' + tickInterval + ") is too small, increase the value to solve the problem!");
  }
  return ticks;
}
registerTickMethod("cat", calculateCatTicks);
registerTickMethod("time-cat", timeCat);
registerTickMethod("wilkinson-extended", linear$1);
registerTickMethod("r-pretty", linearPretty);
registerTickMethod("time", calculateTimeTicks);
registerTickMethod("time-pretty", timePretty);
registerTickMethod("log", calculateLogTicks);
registerTickMethod("pow", calculatePowTicks);
registerTickMethod("quantile", calculateTicks);
registerTickMethod("d3-linear", d3LinearTickMethod);
registerClass("cat", Category$1);
registerClass("category", Category$1);
registerClass("identity", Identity);
registerClass("linear", Linear);
registerClass("log", Log);
registerClass("pow", Pow);
registerClass("time", Time);
registerClass("timeCat", TimeCat);
registerClass("quantize", Quantize);
registerClass("quantile", Quantile);
var ATTRIBUTE_MAP = {};
var getAttribute = function(type4) {
  return ATTRIBUTE_MAP[type4.toLowerCase()];
};
var registerAttribute = function(type4, ctor) {
  if (getAttribute(type4)) {
    throw new Error("Attribute type '" + type4 + "' existed.");
  }
  ATTRIBUTE_MAP[type4.toLowerCase()] = ctor;
};
registerAttribute("Color", Color);
registerAttribute("Opacity", Opacity);
registerAttribute("Position", Position);
registerAttribute("Shape", Shape$2);
registerAttribute("Size", Size);
var Coordinate = function() {
  function Coordinate2(cfg) {
    this.type = "coordinate";
    this.isRect = false;
    this.isHelix = false;
    this.isPolar = false;
    this.isReflectX = false;
    this.isReflectY = false;
    var start = cfg.start, end = cfg.end, _a2 = cfg.matrix, matrix = _a2 === void 0 ? [1, 0, 0, 0, 1, 0, 0, 0, 1] : _a2, _b = cfg.isTransposed, isTransposed = _b === void 0 ? false : _b;
    this.start = start;
    this.end = end;
    this.matrix = matrix;
    this.originalMatrix = __spreadArray$1([], matrix);
    this.isTransposed = isTransposed;
  }
  Coordinate2.prototype.initial = function() {
    this.center = {
      x: (this.start.x + this.end.x) / 2,
      y: (this.start.y + this.end.y) / 2
    };
    this.width = Math.abs(this.end.x - this.start.x);
    this.height = Math.abs(this.end.y - this.start.y);
  };
  Coordinate2.prototype.update = function(cfg) {
    mix(this, cfg);
    this.initial();
  };
  Coordinate2.prototype.convertDim = function(percent2, dim) {
    var _a2;
    var _b = this[dim], start = _b.start, end = _b.end;
    if (this.isReflect(dim)) {
      _a2 = [end, start], start = _a2[0], end = _a2[1];
    }
    return start + percent2 * (end - start);
  };
  Coordinate2.prototype.invertDim = function(value2, dim) {
    var _a2;
    var _b = this[dim], start = _b.start, end = _b.end;
    if (this.isReflect(dim)) {
      _a2 = [end, start], start = _a2[0], end = _a2[1];
    }
    return (value2 - start) / (end - start);
  };
  Coordinate2.prototype.applyMatrix = function(x2, y2, tag) {
    if (tag === void 0) {
      tag = 0;
    }
    var matrix = this.matrix;
    var vector = [x2, y2, tag];
    transformMat3$1(vector, vector, matrix);
    return vector;
  };
  Coordinate2.prototype.invertMatrix = function(x2, y2, tag) {
    if (tag === void 0) {
      tag = 0;
    }
    var matrix = this.matrix;
    var inverted = invert$1([0, 0, 0, 0, 0, 0, 0, 0, 0], matrix);
    var vector = [x2, y2, tag];
    if (inverted) {
      transformMat3$1(vector, vector, inverted);
    }
    return vector;
  };
  Coordinate2.prototype.convert = function(point2) {
    var _a2 = this.convertPoint(point2), x2 = _a2.x, y2 = _a2.y;
    var vector = this.applyMatrix(x2, y2, 1);
    return {
      x: vector[0],
      y: vector[1]
    };
  };
  Coordinate2.prototype.invert = function(point2) {
    var vector = this.invertMatrix(point2.x, point2.y, 1);
    return this.invertPoint({
      x: vector[0],
      y: vector[1]
    });
  };
  Coordinate2.prototype.rotate = function(radian) {
    var matrix = this.matrix;
    var center2 = this.center;
    leftTranslate(matrix, matrix, [-center2.x, -center2.y]);
    leftRotate(matrix, matrix, radian);
    leftTranslate(matrix, matrix, [center2.x, center2.y]);
    return this;
  };
  Coordinate2.prototype.reflect = function(dim) {
    if (dim === "x") {
      this.isReflectX = !this.isReflectX;
    } else {
      this.isReflectY = !this.isReflectY;
    }
    return this;
  };
  Coordinate2.prototype.scale = function(s1, s2) {
    var matrix = this.matrix;
    var center2 = this.center;
    leftTranslate(matrix, matrix, [-center2.x, -center2.y]);
    leftScale(matrix, matrix, [s1, s2]);
    leftTranslate(matrix, matrix, [center2.x, center2.y]);
    return this;
  };
  Coordinate2.prototype.translate = function(x2, y2) {
    var matrix = this.matrix;
    leftTranslate(matrix, matrix, [x2, y2]);
    return this;
  };
  Coordinate2.prototype.transpose = function() {
    this.isTransposed = !this.isTransposed;
    return this;
  };
  Coordinate2.prototype.getCenter = function() {
    return this.center;
  };
  Coordinate2.prototype.getWidth = function() {
    return this.width;
  };
  Coordinate2.prototype.getHeight = function() {
    return this.height;
  };
  Coordinate2.prototype.getRadius = function() {
    return this.radius;
  };
  Coordinate2.prototype.isReflect = function(dim) {
    return dim === "x" ? this.isReflectX : this.isReflectY;
  };
  Coordinate2.prototype.resetMatrix = function(matrix) {
    this.matrix = matrix ? matrix : __spreadArray$1([], this.originalMatrix);
  };
  return Coordinate2;
}();
var Cartesian = function(_super) {
  __extends$3(Cartesian2, _super);
  function Cartesian2(cfg) {
    var _this = _super.call(this, cfg) || this;
    _this.isRect = true;
    _this.type = "cartesian";
    _this.initial();
    return _this;
  }
  Cartesian2.prototype.initial = function() {
    _super.prototype.initial.call(this);
    var start = this.start;
    var end = this.end;
    this.x = {
      start: start.x,
      end: end.x
    };
    this.y = {
      start: start.y,
      end: end.y
    };
  };
  Cartesian2.prototype.convertPoint = function(point2) {
    var _a2;
    var x2 = point2.x, y2 = point2.y;
    if (this.isTransposed) {
      _a2 = [y2, x2], x2 = _a2[0], y2 = _a2[1];
    }
    return {
      x: this.convertDim(x2, "x"),
      y: this.convertDim(y2, "y")
    };
  };
  Cartesian2.prototype.invertPoint = function(point2) {
    var _a2;
    var x2 = this.invertDim(point2.x, "x");
    var y2 = this.invertDim(point2.y, "y");
    if (this.isTransposed) {
      _a2 = [y2, x2], x2 = _a2[0], y2 = _a2[1];
    }
    return { x: x2, y: y2 };
  };
  return Cartesian2;
}(Coordinate);
var Helix = function(_super) {
  __extends$3(Helix2, _super);
  function Helix2(cfg) {
    var _this = _super.call(this, cfg) || this;
    _this.isHelix = true;
    _this.type = "helix";
    var _a2 = cfg.startAngle, startAngle = _a2 === void 0 ? 1.25 * Math.PI : _a2, _b = cfg.endAngle, endAngle = _b === void 0 ? 7.25 * Math.PI : _b, _c = cfg.innerRadius, innerRadius = _c === void 0 ? 0 : _c, radius = cfg.radius;
    _this.startAngle = startAngle;
    _this.endAngle = endAngle;
    _this.innerRadius = innerRadius;
    _this.radius = radius;
    _this.initial();
    return _this;
  }
  Helix2.prototype.initial = function() {
    _super.prototype.initial.call(this);
    var index2 = (this.endAngle - this.startAngle) / (2 * Math.PI) + 1;
    var maxRadius = Math.min(this.width, this.height) / 2;
    if (this.radius && this.radius >= 0 && this.radius <= 1) {
      maxRadius = maxRadius * this.radius;
    }
    this.d = Math.floor(maxRadius * (1 - this.innerRadius) / index2);
    this.a = this.d / (Math.PI * 2);
    this.x = {
      start: this.startAngle,
      end: this.endAngle
    };
    this.y = {
      start: this.innerRadius * maxRadius,
      end: this.innerRadius * maxRadius + this.d * 0.99
    };
  };
  Helix2.prototype.convertPoint = function(point2) {
    var _a2;
    var x2 = point2.x, y2 = point2.y;
    if (this.isTransposed) {
      _a2 = [y2, x2], x2 = _a2[0], y2 = _a2[1];
    }
    var thi = this.convertDim(x2, "x");
    var r2 = this.a * thi;
    var newY = this.convertDim(y2, "y");
    return {
      x: this.center.x + Math.cos(thi) * (r2 + newY),
      y: this.center.y + Math.sin(thi) * (r2 + newY)
    };
  };
  Helix2.prototype.invertPoint = function(point2) {
    var _a2;
    var d2 = this.d + this.y.start;
    var v2 = subtract([0, 0], [point2.x, point2.y], [this.center.x, this.center.y]);
    var thi = angleTo(v2, [1, 0], true);
    var rMin = thi * this.a;
    if (length(v2) < rMin) {
      rMin = length(v2);
    }
    var index2 = Math.floor((length(v2) - rMin) / d2);
    thi = 2 * index2 * Math.PI + thi;
    var r2 = this.a * thi;
    var newY = length(v2) - r2;
    newY = isNumberEqual$1(newY, 0) ? 0 : newY;
    var x2 = this.invertDim(thi, "x");
    var y2 = this.invertDim(newY, "y");
    x2 = isNumberEqual$1(x2, 0) ? 0 : x2;
    y2 = isNumberEqual$1(y2, 0) ? 0 : y2;
    if (this.isTransposed) {
      _a2 = [y2, x2], x2 = _a2[0], y2 = _a2[1];
    }
    return { x: x2, y: y2 };
  };
  return Helix2;
}(Coordinate);
var Polar = function(_super) {
  __extends$3(Polar2, _super);
  function Polar2(cfg) {
    var _this = _super.call(this, cfg) || this;
    _this.isPolar = true;
    _this.type = "polar";
    var _a2 = cfg.startAngle, startAngle = _a2 === void 0 ? -Math.PI / 2 : _a2, _b = cfg.endAngle, endAngle = _b === void 0 ? Math.PI * 3 / 2 : _b, _c = cfg.innerRadius, innerRadius = _c === void 0 ? 0 : _c, radius = cfg.radius;
    _this.startAngle = startAngle;
    _this.endAngle = endAngle;
    _this.innerRadius = innerRadius;
    _this.radius = radius;
    _this.initial();
    return _this;
  }
  Polar2.prototype.initial = function() {
    _super.prototype.initial.call(this);
    while (this.endAngle < this.startAngle) {
      this.endAngle += Math.PI * 2;
    }
    var oneBox = this.getOneBox();
    var oneWidth = oneBox.maxX - oneBox.minX;
    var oneHeight = oneBox.maxY - oneBox.minY;
    var left2 = Math.abs(oneBox.minX) / oneWidth;
    var top = Math.abs(oneBox.minY) / oneHeight;
    var maxRadius;
    if (this.height / oneHeight > this.width / oneWidth) {
      maxRadius = this.width / oneWidth;
      this.circleCenter = {
        x: this.center.x - (0.5 - left2) * this.width,
        y: this.center.y - (0.5 - top) * maxRadius * oneHeight
      };
    } else {
      maxRadius = this.height / oneHeight;
      this.circleCenter = {
        x: this.center.x - (0.5 - left2) * maxRadius * oneWidth,
        y: this.center.y - (0.5 - top) * this.height
      };
    }
    this.polarRadius = this.radius;
    if (!this.radius) {
      this.polarRadius = maxRadius;
    } else if (this.radius > 0 && this.radius <= 1) {
      this.polarRadius = maxRadius * this.radius;
    } else if (this.radius <= 0 || this.radius > maxRadius) {
      this.polarRadius = maxRadius;
    }
    this.x = {
      start: this.startAngle,
      end: this.endAngle
    };
    this.y = {
      start: this.innerRadius * this.polarRadius,
      end: this.polarRadius
    };
  };
  Polar2.prototype.getRadius = function() {
    return this.polarRadius;
  };
  Polar2.prototype.convertPoint = function(point2) {
    var _a2;
    var center2 = this.getCenter();
    var x2 = point2.x, y2 = point2.y;
    if (this.isTransposed) {
      _a2 = [y2, x2], x2 = _a2[0], y2 = _a2[1];
    }
    x2 = this.convertDim(x2, "x");
    y2 = this.convertDim(y2, "y");
    return {
      x: center2.x + Math.cos(x2) * y2,
      y: center2.y + Math.sin(x2) * y2
    };
  };
  Polar2.prototype.invertPoint = function(point2) {
    var _a2;
    var center2 = this.getCenter();
    var vPoint = [point2.x - center2.x, point2.y - center2.y];
    var _b = this, startAngle = _b.startAngle, endAngle = _b.endAngle;
    if (this.isReflect("x")) {
      _a2 = [endAngle, startAngle], startAngle = _a2[0], endAngle = _a2[1];
    }
    var m2 = [1, 0, 0, 0, 1, 0, 0, 0, 1];
    leftRotate(m2, m2, startAngle);
    var vStart3 = [1, 0, 0];
    transformMat3$1(vStart3, vStart3, m2);
    var vStart2 = [vStart3[0], vStart3[1]];
    var angle2 = angleTo(vStart2, vPoint, endAngle < startAngle);
    if (isNumberEqual$1(angle2, Math.PI * 2)) {
      angle2 = 0;
    }
    var radius = length(vPoint);
    var xPercent = angle2 / (endAngle - startAngle);
    xPercent = endAngle - startAngle > 0 ? xPercent : -xPercent;
    var yPercent = this.invertDim(radius, "y");
    var rst = { x: 0, y: 0 };
    rst.x = this.isTransposed ? yPercent : xPercent;
    rst.y = this.isTransposed ? xPercent : yPercent;
    return rst;
  };
  Polar2.prototype.getCenter = function() {
    return this.circleCenter;
  };
  Polar2.prototype.getOneBox = function() {
    var startAngle = this.startAngle;
    var endAngle = this.endAngle;
    if (Math.abs(endAngle - startAngle) >= Math.PI * 2) {
      return {
        minX: -1,
        maxX: 1,
        minY: -1,
        maxY: 1
      };
    }
    var xs = [0, Math.cos(startAngle), Math.cos(endAngle)];
    var ys = [0, Math.sin(startAngle), Math.sin(endAngle)];
    for (var i2 = Math.min(startAngle, endAngle); i2 < Math.max(startAngle, endAngle); i2 += Math.PI / 18) {
      xs.push(Math.cos(i2));
      ys.push(Math.sin(i2));
    }
    return {
      minX: Math.min.apply(Math, xs),
      maxX: Math.max.apply(Math, xs),
      minY: Math.min.apply(Math, ys),
      maxY: Math.max.apply(Math, ys)
    };
  };
  return Polar2;
}(Coordinate);
var COORDINATE_MAP = {};
var getCoordinate = function(type4) {
  return COORDINATE_MAP[type4.toLowerCase()];
};
var registerCoordinate = function(type4, ctor) {
  COORDINATE_MAP[type4.toLowerCase()] = ctor;
};
registerCoordinate("rect", Cartesian);
registerCoordinate("cartesian", Cartesian);
registerCoordinate("polar", Polar);
registerCoordinate("helix", Helix);
function propagationDelegate(group2, eventName, eventObject) {
  var event = new GraphEvent(eventName, eventObject);
  event.target = group2;
  event.propagationPath.push(group2);
  group2.emitDelegation(eventName, event);
  var parent = group2.getParent();
  while (parent) {
    parent.emitDelegation(eventName, event);
    event.propagationPath.push(parent);
    parent = parent.getParent();
  }
}
var identityMatrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];
function getMatrixByAngle(point2, angle2, matrix) {
  if (matrix === void 0) {
    matrix = identityMatrix;
  }
  if (!angle2) {
    return null;
  }
  var m2 = transform$6(matrix, [
    ["t", -point2.x, -point2.y],
    ["r", angle2],
    ["t", point2.x, point2.y]
  ]);
  return m2;
}
function getMatrixByTranslate(point2, currentMatrix) {
  if (!point2.x && !point2.y) {
    return null;
  }
  return transform$6(currentMatrix || identityMatrix, [["t", point2.x, point2.y]]);
}
function getAngleByMatrix(matrix) {
  var xVector = [1, 0, 0];
  var out = [0, 0, 0];
  transformMat3$1(out, xVector, matrix);
  return Math.atan2(out[1], out[0]);
}
function multiplyVec2(matrix, v2) {
  var out = [0, 0];
  transformMat3(out, v2, matrix);
  return out;
}
function applyMatrix2BBox(matrix, bbox) {
  var topLeft = multiplyVec2(matrix, [bbox.minX, bbox.minY]);
  var topRight = multiplyVec2(matrix, [bbox.maxX, bbox.minY]);
  var bottomLeft = multiplyVec2(matrix, [bbox.minX, bbox.maxY]);
  var bottomRight = multiplyVec2(matrix, [bbox.maxX, bbox.maxY]);
  var minX = Math.min(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]);
  var maxX = Math.max(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]);
  var minY = Math.min(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1]);
  var maxY2 = Math.max(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1]);
  return {
    x: minX,
    y: minY,
    minX,
    minY,
    maxX,
    maxY: maxY2,
    width: maxX - minX,
    height: maxY2 - minY
  };
}
function applyRotate(shape, rotate2, x2, y2) {
  if (rotate2) {
    var matrix = getMatrixByAngle({ x: x2, y: y2 }, rotate2, shape.getMatrix());
    shape.setMatrix(matrix);
  }
}
function applyTranslate(shape, x2, y2) {
  var translateMatrix = getMatrixByTranslate({ x: x2, y: y2 });
  shape.attr("matrix", translateMatrix);
}
function formatPadding(padding2) {
  var top = 0;
  var left2 = 0;
  var right2 = 0;
  var bottom = 0;
  if (isNumber$1(padding2)) {
    top = left2 = right2 = bottom = padding2;
  } else if (isArray$1(padding2)) {
    top = padding2[0];
    right2 = !isNil(padding2[1]) ? padding2[1] : padding2[0];
    bottom = !isNil(padding2[2]) ? padding2[2] : padding2[0];
    left2 = !isNil(padding2[3]) ? padding2[3] : right2;
  }
  return [top, right2, bottom, left2];
}
function clearDom(container) {
  var children = container.childNodes;
  var length2 = children.length;
  for (var i2 = length2 - 1; i2 >= 0; i2--) {
    container.removeChild(children[i2]);
  }
}
function hasClass(elements, cName) {
  return !!elements.className.match(new RegExp("(\\s|^)" + cName + "(\\s|$)"));
}
function regionToBBox(region) {
  var start = region.start, end = region.end;
  var minX = Math.min(start.x, end.x);
  var minY = Math.min(start.y, end.y);
  var maxX = Math.max(start.x, end.x);
  var maxY2 = Math.max(start.y, end.y);
  return {
    x: minX,
    y: minY,
    minX,
    minY,
    maxX,
    maxY: maxY2,
    width: maxX - minX,
    height: maxY2 - minY
  };
}
function pointsToBBox(points2) {
  var xs = points2.map(function(point2) {
    return point2.x;
  });
  var ys = points2.map(function(point2) {
    return point2.y;
  });
  var minX = Math.min.apply(Math, xs);
  var minY = Math.min.apply(Math, ys);
  var maxX = Math.max.apply(Math, xs);
  var maxY2 = Math.max.apply(Math, ys);
  return {
    x: minX,
    y: minY,
    minX,
    minY,
    maxX,
    maxY: maxY2,
    width: maxX - minX,
    height: maxY2 - minY
  };
}
function createBBox(x2, y2, width, height) {
  var maxX = x2 + width;
  var maxY2 = y2 + height;
  return {
    x: x2,
    y: y2,
    width,
    height,
    minX: x2,
    minY: y2,
    maxX: isNaN(maxX) ? 0 : maxX,
    maxY: isNaN(maxY2) ? 0 : maxY2
  };
}
function getValueByPercent(min2, max2, percent2) {
  return (1 - percent2) * min2 + max2 * percent2;
}
function getCirclePoint(center2, radius, angle2) {
  return {
    x: center2.x + Math.cos(angle2) * radius,
    y: center2.y + Math.sin(angle2) * radius
  };
}
function distance$4(p1, p2) {
  var dx = p2.x - p1.x;
  var dy = p2.y - p1.y;
  return Math.sqrt(dx * dx + dy * dy);
}
var near = function(x2, y2, e3) {
  if (e3 === void 0) {
    e3 = Math.pow(Number.EPSILON, 0.5);
  }
  return [x2, y2].includes(Infinity) ? Math.abs(x2) === Math.abs(y2) : Math.abs(x2 - y2) < e3;
};
function intersectBBox(box1, box2) {
  var minX = Math.max(box1.minX, box2.minX);
  var minY = Math.max(box1.minY, box2.minY);
  var maxX = Math.min(box1.maxX, box2.maxX);
  var maxY2 = Math.min(box1.maxY, box2.maxY);
  return createBBox(minX, minY, maxX - minX, maxY2 - minY);
}
function getBBoxWithClip(element) {
  var clipShape = element.getClip();
  var clipBBox = clipShape && clipShape.getBBox();
  var bbox;
  if (!element.isGroup()) {
    bbox = element.getBBox();
  } else {
    var minX_1 = Infinity;
    var maxX_1 = -Infinity;
    var minY_1 = Infinity;
    var maxY_1 = -Infinity;
    var children = element.getChildren();
    if (children.length > 0) {
      each$1(children, function(child) {
        if (child.get("visible")) {
          if (child.isGroup() && child.get("children").length === 0) {
            return true;
          }
          var box2 = getBBoxWithClip(child);
          var leftTop = child.applyToMatrix([box2.minX, box2.minY, 1]);
          var leftBottom = child.applyToMatrix([box2.minX, box2.maxY, 1]);
          var rightTop = child.applyToMatrix([box2.maxX, box2.minY, 1]);
          var rightBottom = child.applyToMatrix([box2.maxX, box2.maxY, 1]);
          var boxMinX = Math.min(leftTop[0], leftBottom[0], rightTop[0], rightBottom[0]);
          var boxMaxX = Math.max(leftTop[0], leftBottom[0], rightTop[0], rightBottom[0]);
          var boxMinY = Math.min(leftTop[1], leftBottom[1], rightTop[1], rightBottom[1]);
          var boxMaxY = Math.max(leftTop[1], leftBottom[1], rightTop[1], rightBottom[1]);
          if (boxMinX < minX_1) {
            minX_1 = boxMinX;
          }
          if (boxMaxX > maxX_1) {
            maxX_1 = boxMaxX;
          }
          if (boxMinY < minY_1) {
            minY_1 = boxMinY;
          }
          if (boxMaxY > maxY_1) {
            maxY_1 = boxMaxY;
          }
        }
      });
    } else {
      minX_1 = 0;
      maxX_1 = 0;
      minY_1 = 0;
      maxY_1 = 0;
    }
    bbox = createBBox(minX_1, minY_1, maxX_1 - minX_1, maxY_1 - minY_1);
  }
  if (clipBBox) {
    return intersectBBox(bbox, clipBBox);
  } else {
    return bbox;
  }
}
function updateClip(element, newElement) {
  if (!element.getClip() && !newElement.getClip()) {
    return;
  }
  var newClipShape = newElement.getClip();
  if (!newClipShape) {
    element.setClip(null);
    return;
  }
  var clipCfg = {
    type: newClipShape.get("type"),
    attrs: newClipShape.attr()
  };
  element.setClip(clipCfg);
}
function toPx(number4) {
  return number4 + "px";
}
function getTextPoint(start, end, position, offset3) {
  var lineLength = distance$4(start, end);
  var offsetPercent = offset3 / lineLength;
  var percent2 = 0;
  if (position === "start") {
    percent2 = 0 - offsetPercent;
  } else if (position === "end") {
    percent2 = 1 + offsetPercent;
  }
  return {
    x: getValueByPercent(start.x, end.x, percent2),
    y: getValueByPercent(start.y, end.y, percent2)
  };
}
var LOCATION_FIELD_MAP = {
  none: [],
  point: ["x", "y"],
  region: ["start", "end"],
  points: ["points"],
  circle: ["center", "radius", "startAngle", "endAngle"]
};
var Component = function(_super) {
  __extends$3(Component2, _super);
  function Component2(cfg) {
    var _this = _super.call(this, cfg) || this;
    _this.initCfg();
    return _this;
  }
  Component2.prototype.getDefaultCfg = function() {
    return {
      id: "",
      name: "",
      type: "",
      locationType: "none",
      offsetX: 0,
      offsetY: 0,
      animate: false,
      capture: true,
      updateAutoRender: false,
      animateOption: {
        appear: null,
        update: {
          duration: 400,
          easing: "easeQuadInOut"
        },
        enter: {
          duration: 400,
          easing: "easeQuadInOut"
        },
        leave: {
          duration: 350,
          easing: "easeQuadIn"
        }
      },
      events: null,
      defaultCfg: {},
      visible: true
    };
  };
  Component2.prototype.clear = function() {
  };
  Component2.prototype.update = function(cfg) {
    var _this = this;
    var defaultCfg = this.get("defaultCfg") || {};
    each$1(cfg, function(value2, name) {
      var originCfg = _this.get(name);
      var newCfg = value2;
      if (originCfg !== value2) {
        if (isObject(value2) && defaultCfg[name]) {
          newCfg = deepMix({}, defaultCfg[name], value2);
        }
        _this.set(name, newCfg);
      }
    });
    this.updateInner(cfg);
    this.afterUpdate(cfg);
  };
  Component2.prototype.updateInner = function(cfg) {
  };
  Component2.prototype.afterUpdate = function(cfg) {
    if (has(cfg, "visible")) {
      if (cfg.visible) {
        this.show();
      } else {
        this.hide();
      }
    }
    if (has(cfg, "capture")) {
      this.setCapture(cfg.capture);
    }
  };
  Component2.prototype.getLayoutBBox = function() {
    return this.getBBox();
  };
  Component2.prototype.getLocationType = function() {
    return this.get("locationType");
  };
  Component2.prototype.getOffset = function() {
    return {
      offsetX: this.get("offsetX"),
      offsetY: this.get("offsetY")
    };
  };
  Component2.prototype.setOffset = function(offsetX, offsetY) {
    this.update({
      offsetX,
      offsetY
    });
  };
  Component2.prototype.setLocation = function(cfg) {
    var location = __assign$4({}, cfg);
    this.update(location);
  };
  Component2.prototype.getLocation = function() {
    var _this = this;
    var location = {};
    var locationType = this.get("locationType");
    var fields = LOCATION_FIELD_MAP[locationType];
    each$1(fields, function(field2) {
      location[field2] = _this.get(field2);
    });
    return location;
  };
  Component2.prototype.isList = function() {
    return false;
  };
  Component2.prototype.isSlider = function() {
    return false;
  };
  Component2.prototype.init = function() {
  };
  Component2.prototype.initCfg = function() {
    var _this = this;
    var defaultCfg = this.get("defaultCfg");
    each$1(defaultCfg, function(value2, name) {
      var cfg = _this.get(name);
      if (isObject(cfg)) {
        var newCfg = deepMix({}, value2, cfg);
        _this.set(name, newCfg);
      }
    });
  };
  return Component2;
}(Base);
var STATUS_UPDATE = "update_status";
var COPY_PROPERTIES = ["visible", "tip", "delegateObject"];
var COPY_PROPERTIES_EXCLUDES = ["container", "group", "shapesMap", "isRegister", "isUpdating", "destroyed"];
var GroupComponent = function(_super) {
  __extends$3(GroupComponent2, _super);
  function GroupComponent2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  GroupComponent2.prototype.getDefaultCfg = function() {
    var cfg = _super.prototype.getDefaultCfg.call(this);
    return __assign$4(__assign$4({}, cfg), {
      container: null,
      shapesMap: {},
      group: null,
      capture: true,
      isRegister: false,
      isUpdating: false,
      isInit: true
    });
  };
  GroupComponent2.prototype.remove = function() {
    this.clear();
    var group2 = this.get("group");
    group2.remove();
  };
  GroupComponent2.prototype.clear = function() {
    var group2 = this.get("group");
    group2.clear();
    this.set("shapesMap", {});
    this.clearOffScreenCache();
    this.set("isInit", true);
  };
  GroupComponent2.prototype.getChildComponentById = function(id2) {
    var group2 = this.getElementById(id2);
    var inst = group2 && group2.get("component");
    return inst;
  };
  GroupComponent2.prototype.getElementById = function(id2) {
    return this.get("shapesMap")[id2];
  };
  GroupComponent2.prototype.getElementByLocalId = function(localId) {
    var id2 = this.getElementId(localId);
    return this.getElementById(id2);
  };
  GroupComponent2.prototype.getElementsByName = function(name) {
    var rst = [];
    each$1(this.get("shapesMap"), function(elem) {
      if (elem.get("name") === name) {
        rst.push(elem);
      }
    });
    return rst;
  };
  GroupComponent2.prototype.getContainer = function() {
    return this.get("container");
  };
  GroupComponent2.prototype.updateInner = function(cfg) {
    this.offScreenRender();
    if (this.get("updateAutoRender")) {
      this.render();
    }
  };
  GroupComponent2.prototype.render = function() {
    var offScreenGroup = this.get("offScreenGroup");
    if (!offScreenGroup) {
      offScreenGroup = this.offScreenRender();
    }
    var group2 = this.get("group");
    this.updateElements(offScreenGroup, group2);
    this.deleteElements();
    this.applyOffset();
    if (!this.get("eventInitted")) {
      this.initEvent();
      this.set("eventInitted", true);
    }
    this.set("isInit", false);
  };
  GroupComponent2.prototype.show = function() {
    var group2 = this.get("group");
    group2.show();
    this.set("visible", true);
  };
  GroupComponent2.prototype.hide = function() {
    var group2 = this.get("group");
    group2.hide();
    this.set("visible", false);
  };
  GroupComponent2.prototype.setCapture = function(capture) {
    var group2 = this.get("group");
    group2.set("capture", capture);
    this.set("capture", capture);
  };
  GroupComponent2.prototype.destroy = function() {
    this.removeEvent();
    this.remove();
    _super.prototype.destroy.call(this);
  };
  GroupComponent2.prototype.getBBox = function() {
    return this.get("group").getCanvasBBox();
  };
  GroupComponent2.prototype.getLayoutBBox = function() {
    var group2 = this.get("group");
    var bbox = this.getInnerLayoutBBox();
    var matrix = group2.getTotalMatrix();
    if (matrix) {
      bbox = applyMatrix2BBox(matrix, bbox);
    }
    return bbox;
  };
  GroupComponent2.prototype.on = function(evt, callback, once) {
    var group2 = this.get("group");
    group2.on(evt, callback, once);
    return this;
  };
  GroupComponent2.prototype.off = function(evt, callback) {
    var group2 = this.get("group");
    group2 && group2.off(evt, callback);
    return this;
  };
  GroupComponent2.prototype.emit = function(eventName, eventObject) {
    var group2 = this.get("group");
    group2.emit(eventName, eventObject);
  };
  GroupComponent2.prototype.init = function() {
    _super.prototype.init.call(this);
    if (!this.get("group")) {
      this.initGroup();
    }
    this.offScreenRender();
  };
  GroupComponent2.prototype.getInnerLayoutBBox = function() {
    return this.get("offScreenBBox") || this.get("group").getBBox();
  };
  GroupComponent2.prototype.delegateEmit = function(eventName, eventObject) {
    var group2 = this.get("group");
    eventObject.target = group2;
    group2.emit(eventName, eventObject);
    propagationDelegate(group2, eventName, eventObject);
  };
  GroupComponent2.prototype.createOffScreenGroup = function() {
    var group2 = this.get("group");
    var GroupClass = group2.getGroupBase();
    var newGroup = new GroupClass({
      delegateObject: this.getDelegateObject()
    });
    return newGroup;
  };
  GroupComponent2.prototype.applyOffset = function() {
    var offsetX = this.get("offsetX");
    var offsetY = this.get("offsetY");
    this.moveElementTo(this.get("group"), {
      x: offsetX,
      y: offsetY
    });
  };
  GroupComponent2.prototype.initGroup = function() {
    var container = this.get("container");
    this.set("group", container.addGroup({
      id: this.get("id"),
      name: this.get("name"),
      capture: this.get("capture"),
      visible: this.get("visible"),
      isComponent: true,
      component: this,
      delegateObject: this.getDelegateObject()
    }));
  };
  GroupComponent2.prototype.offScreenRender = function() {
    this.clearOffScreenCache();
    var offScreenGroup = this.createOffScreenGroup();
    this.renderInner(offScreenGroup);
    this.set("offScreenGroup", offScreenGroup);
    this.set("offScreenBBox", getBBoxWithClip(offScreenGroup));
    return offScreenGroup;
  };
  GroupComponent2.prototype.addGroup = function(parent, cfg) {
    this.appendDelegateObject(parent, cfg);
    var group2 = parent.addGroup(cfg);
    if (this.get("isRegister")) {
      this.registerElement(group2);
    }
    return group2;
  };
  GroupComponent2.prototype.addShape = function(parent, cfg) {
    this.appendDelegateObject(parent, cfg);
    var shape = parent.addShape(cfg);
    if (this.get("isRegister")) {
      this.registerElement(shape);
    }
    return shape;
  };
  GroupComponent2.prototype.addComponent = function(parent, cfg) {
    var id2 = cfg.id, Ctor = cfg.component, restCfg = __rest$3(cfg, ["id", "component"]);
    var inst = new Ctor(__assign$4(__assign$4({}, restCfg), { id: id2, container: parent, updateAutoRender: this.get("updateAutoRender") }));
    inst.init();
    inst.render();
    if (this.get("isRegister")) {
      this.registerElement(inst.get("group"));
    }
    return inst;
  };
  GroupComponent2.prototype.initEvent = function() {
  };
  GroupComponent2.prototype.removeEvent = function() {
    var group2 = this.get("group");
    group2.off();
  };
  GroupComponent2.prototype.getElementId = function(localId) {
    var id2 = this.get("id");
    var name = this.get("name");
    return id2 + "-" + name + "-" + localId;
  };
  GroupComponent2.prototype.registerElement = function(element) {
    var id2 = element.get("id");
    this.get("shapesMap")[id2] = element;
  };
  GroupComponent2.prototype.unregisterElement = function(element) {
    var id2 = element.get("id");
    delete this.get("shapesMap")[id2];
  };
  GroupComponent2.prototype.moveElementTo = function(element, point2) {
    var matrix = getMatrixByTranslate(point2);
    element.attr("matrix", matrix);
  };
  GroupComponent2.prototype.addAnimation = function(elmentName, newElement, animateCfg) {
    var originOpacity = newElement.attr("opacity");
    if (isNil(originOpacity)) {
      originOpacity = 1;
    }
    newElement.attr("opacity", 0);
    newElement.animate({ opacity: originOpacity }, animateCfg);
  };
  GroupComponent2.prototype.removeAnimation = function(elementName, originElement, animateCfg) {
    originElement.animate({ opacity: 0 }, animateCfg);
  };
  GroupComponent2.prototype.updateAnimation = function(elementName, originElement, newAttrs, animateCfg) {
    originElement.animate(newAttrs, animateCfg);
  };
  GroupComponent2.prototype.updateElements = function(newGroup, originGroup) {
    var _this = this;
    var animate = this.get("animate");
    var animateOption = this.get("animateOption");
    var children = newGroup.getChildren().slice(0);
    var preElement;
    each$1(children, function(element) {
      var elementId = element.get("id");
      var originElement = _this.getElementById(elementId);
      var elementName = element.get("name");
      if (originElement) {
        if (element.get("isComponent")) {
          var childComponent = element.get("component");
          var origChildComponent = originElement.get("component");
          var newCfg = pick$1(childComponent.cfg, difference(keys(childComponent.cfg), COPY_PROPERTIES_EXCLUDES));
          origChildComponent.update(newCfg);
          originElement.set(STATUS_UPDATE, "update");
        } else {
          var replaceAttrs = _this.getReplaceAttrs(originElement, element);
          if (animate && animateOption.update) {
            _this.updateAnimation(elementName, originElement, replaceAttrs, animateOption.update);
          } else {
            originElement.attr(replaceAttrs);
          }
          if (element.isGroup()) {
            _this.updateElements(element, originElement);
          }
          each$1(COPY_PROPERTIES, function(name) {
            originElement.set(name, element.get(name));
          });
          updateClip(originElement, element);
          preElement = originElement;
          originElement.set(STATUS_UPDATE, "update");
        }
      } else {
        originGroup.add(element);
        var siblings2 = originGroup.getChildren();
        siblings2.splice(siblings2.length - 1, 1);
        if (preElement) {
          var index2 = siblings2.indexOf(preElement);
          siblings2.splice(index2 + 1, 0, element);
        } else {
          siblings2.unshift(element);
        }
        _this.registerElement(element);
        element.set(STATUS_UPDATE, "add");
        if (element.get("isComponent")) {
          var childComponent = element.get("component");
          childComponent.set("container", originGroup);
        } else if (element.isGroup()) {
          _this.registerNewGroup(element);
        }
        preElement = element;
        if (animate) {
          var animateCfg = _this.get("isInit") ? animateOption.appear : animateOption.enter;
          if (animateCfg) {
            _this.addAnimation(elementName, element, animateCfg);
          }
        }
      }
    });
  };
  GroupComponent2.prototype.clearUpdateStatus = function(group2) {
    var children = group2.getChildren();
    each$1(children, function(el) {
      el.set(STATUS_UPDATE, null);
    });
  };
  GroupComponent2.prototype.clearOffScreenCache = function() {
    var offScreenGroup = this.get("offScreenGroup");
    if (offScreenGroup) {
      offScreenGroup.destroy();
    }
    this.set("offScreenGroup", null);
    this.set("offScreenBBox", null);
  };
  GroupComponent2.prototype.getDelegateObject = function() {
    var _a2;
    var name = this.get("name");
    var delegateObject = (_a2 = {}, _a2[name] = this, _a2.component = this, _a2);
    return delegateObject;
  };
  GroupComponent2.prototype.appendDelegateObject = function(parent, cfg) {
    var parentObject = parent.get("delegateObject");
    if (!cfg.delegateObject) {
      cfg.delegateObject = {};
    }
    mix(cfg.delegateObject, parentObject);
  };
  GroupComponent2.prototype.getReplaceAttrs = function(originElement, newElement) {
    var originAttrs = originElement.attr();
    var newAttrs = newElement.attr();
    each$1(originAttrs, function(v2, k2) {
      if (newAttrs[k2] === void 0) {
        newAttrs[k2] = void 0;
      }
    });
    return newAttrs;
  };
  GroupComponent2.prototype.registerNewGroup = function(group2) {
    var _this = this;
    var children = group2.getChildren();
    each$1(children, function(element) {
      _this.registerElement(element);
      element.set(STATUS_UPDATE, "add");
      if (element.isGroup()) {
        _this.registerNewGroup(element);
      }
    });
  };
  GroupComponent2.prototype.deleteElements = function() {
    var _this = this;
    var shapesMap = this.get("shapesMap");
    var deleteArray = [];
    each$1(shapesMap, function(element, id2) {
      if (!element.get(STATUS_UPDATE) || element.destroyed) {
        deleteArray.push([id2, element]);
      } else {
        element.set(STATUS_UPDATE, null);
      }
    });
    var animate = this.get("animate");
    var animateOption = this.get("animateOption");
    each$1(deleteArray, function(item) {
      var id2 = item[0], element = item[1];
      if (!element.destroyed) {
        var elementName = element.get("name");
        if (animate && animateOption.leave) {
          var callbackAnimCfg = mix({
            callback: function() {
              _this.removeElement(element);
            }
          }, animateOption.leave);
          _this.removeAnimation(elementName, element, callbackAnimCfg);
        } else {
          _this.removeElement(element);
        }
      }
      delete shapesMap[id2];
    });
  };
  GroupComponent2.prototype.removeElement = function(element) {
    if (element.get("isGroup")) {
      var component2 = element.get("component");
      if (component2) {
        component2.destroy();
      }
    }
    element.remove();
  };
  return GroupComponent2;
}(Component);
var ELLIPSIS_CODE$1 = "\u2026";
function strLen(str) {
  var len = 0;
  for (var i2 = 0; i2 < str.length; i2++) {
    len += charAtLength(str, i2);
  }
  return len;
}
function charAtLength(str, i2) {
  if (str.charCodeAt(i2) > 0 && str.charCodeAt(i2) < 128) {
    return 1;
  } else {
    return 2;
  }
}
function ellipsisString(str, reseveLength, position) {
  if (position === void 0) {
    position = "tail";
  }
  var count2 = str.length;
  var rst = "";
  if (position === "tail") {
    for (var i2 = 0, index2 = 0; i2 < reseveLength; ) {
      var charLength = charAtLength(str, index2);
      if (i2 + charLength <= reseveLength) {
        rst += str[index2];
        i2 += charAtLength(str, index2);
        index2++;
      } else {
        break;
      }
    }
    rst += ELLIPSIS_CODE$1;
  } else if (position === "head") {
    for (var i2 = 0, index2 = count2 - 1; i2 < reseveLength; ) {
      var charLength = charAtLength(str, index2);
      if (i2 + charLength <= reseveLength) {
        rst += str[index2];
        i2 += charAtLength(str, index2);
        index2--;
      } else {
        break;
      }
    }
    rst = ELLIPSIS_CODE$1 + rst;
  } else {
    var startStr = "";
    var endStr = "";
    for (var i2 = 0, startIndex = 0, endIndex = count2 - 1; i2 < reseveLength; ) {
      var startCodeLen = charAtLength(str, startIndex);
      var hasAdd = false;
      if (startCodeLen + i2 <= reseveLength) {
        startStr += str[startIndex];
        startIndex++;
        i2 += startCodeLen;
        hasAdd = true;
      }
      var endCodeLen = charAtLength(str, endIndex);
      if (endCodeLen + i2 <= reseveLength) {
        endStr = str[endIndex] + endStr;
        i2 += endCodeLen;
        endIndex--;
        hasAdd = true;
      }
      if (!hasAdd) {
        break;
      }
    }
    rst = startStr + ELLIPSIS_CODE$1 + endStr;
  }
  return rst;
}
var ELLIPSIS_CODE = "\u2026";
var ELLIPSIS_CODE_LENGTH = 2;
var OPTIMIZE_THRESHOLD = 400;
function getMaxLabelWidthOptimized(labels) {
  var texts = labels.map(function(label2) {
    var text2 = label2.attr("text");
    return isNil(text2) ? "" : "" + text2;
  });
  var maxLen = 0;
  var maxIdx = 0;
  for (var i2 = 0; i2 < texts.length; i2 += 1) {
    var len = 0;
    for (var j2 = 0; j2 <= texts[i2].length; j2 += 1) {
      var code2 = texts[i2].charCodeAt(j2);
      if (code2 >= 19968 && code2 <= 40869) {
        len += 2;
      } else {
        len += 1;
      }
    }
    if (len > maxLen) {
      maxLen = len;
      maxIdx = i2;
    }
  }
  return labels[maxIdx].getBBox().width;
}
function getMaxLabelWidth(labels) {
  if (labels.length > OPTIMIZE_THRESHOLD) {
    return getMaxLabelWidthOptimized(labels);
  }
  var max2 = 0;
  each$1(labels, function(label2) {
    var bbox = label2.getBBox();
    var width = bbox.width;
    if (max2 < width) {
      max2 = width;
    }
  });
  return max2;
}
function getLabelLength(isVertical2, label2) {
  var bbox = label2.getCanvasBBox();
  return isVertical2 ? bbox.width : bbox.height;
}
function ellipsisLabel(isVertical2, label2, limitLength, position) {
  var _a2;
  if (position === void 0) {
    position = "tail";
  }
  var text2 = (_a2 = label2.attr("text")) !== null && _a2 !== void 0 ? _a2 : "";
  if (position === "tail") {
    var font = pick$1(label2.attr(), ["fontSize", "fontFamily", "fontWeight", "fontStyle", "fontVariant"]);
    var ellipsisText = getEllipsisText$1(text2, limitLength, font, "\u2026");
    if (text2 !== ellipsisText) {
      label2.attr("text", ellipsisText);
      label2.set("tip", text2);
      return true;
    }
    label2.set("tip", null);
    return false;
  }
  var labelLength = getLabelLength(isVertical2, label2);
  var codeLength = strLen(text2);
  var ellipsisFlag = false;
  if (limitLength < labelLength) {
    var reserveLength = Math.floor(limitLength / labelLength * codeLength) - ELLIPSIS_CODE_LENGTH;
    var newText = void 0;
    if (reserveLength >= 0) {
      newText = ellipsisString(text2, reserveLength, position);
    } else {
      newText = ELLIPSIS_CODE;
    }
    if (newText) {
      label2.attr("text", newText);
      ellipsisFlag = true;
    }
  }
  if (ellipsisFlag) {
    label2.set("tip", text2);
  } else {
    label2.set("tip", null);
  }
  return ellipsisFlag;
}
function renderTag$1(container, tagCfg) {
  var x2 = tagCfg.x, y2 = tagCfg.y, content = tagCfg.content, style2 = tagCfg.style, id2 = tagCfg.id, name = tagCfg.name, rotate2 = tagCfg.rotate, maxLength = tagCfg.maxLength, autoEllipsis2 = tagCfg.autoEllipsis, isVertical2 = tagCfg.isVertical, ellipsisPosition = tagCfg.ellipsisPosition, background = tagCfg.background;
  var tagGroup = container.addGroup({
    id: id2 + "-group",
    name: name + "-group",
    attrs: {
      x: x2,
      y: y2
    }
  });
  var text2 = tagGroup.addShape({
    type: "text",
    id: id2,
    name,
    attrs: __assign$4({ x: 0, y: 0, text: content }, style2)
  });
  var padding2 = formatPadding(get(background, "padding", 0));
  if (maxLength && autoEllipsis2) {
    var maxTextLength = maxLength - (padding2[1] + padding2[3]);
    ellipsisLabel(!isVertical2, text2, maxTextLength, ellipsisPosition);
  }
  if (background) {
    var backgroundStyle = get(background, "style", {});
    var _a2 = text2.getCanvasBBox(), minX = _a2.minX, minY = _a2.minY, width = _a2.width, height = _a2.height;
    var tagBg = tagGroup.addShape("rect", {
      id: id2 + "-bg",
      name: id2 + "-bg",
      attrs: __assign$4({ x: minX - padding2[3], y: minY - padding2[0], width: width + padding2[1] + padding2[3], height: height + padding2[0] + padding2[2] }, backgroundStyle)
    });
    tagBg.toBack();
  }
  applyTranslate(tagGroup, x2, y2);
  applyRotate(tagGroup, rotate2, x2, y2);
}
var Theme = {
  fontFamily: '\n  BlinkMacSystemFont, "Segoe UI", Roboto,"Helvetica Neue",\n  Helvetica, "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei",\n  SimSun, "sans-serif"',
  textColor: "#2C3542",
  activeTextColor: "#333333",
  uncheckedColor: "#D8D8D8",
  lineColor: "#416180",
  regionColor: "#CCD7EB",
  verticalAxisRotate: -Math.PI / 4,
  horizontalAxisRotate: Math.PI / 4,
  descriptionIconStroke: "#fff",
  descriptionIconFill: "rgba(58, 73, 101, .25)"
};
var LineAnnotation = function(_super) {
  __extends$3(LineAnnotation2, _super);
  function LineAnnotation2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  LineAnnotation2.prototype.getDefaultCfg = function() {
    var cfg = _super.prototype.getDefaultCfg.call(this);
    return __assign$4(__assign$4({}, cfg), { name: "annotation", type: "line", locationType: "region", start: null, end: null, style: {}, text: null, defaultCfg: {
      style: {
        fill: Theme.textColor,
        fontSize: 12,
        textAlign: "center",
        textBaseline: "bottom",
        fontFamily: Theme.fontFamily
      },
      text: {
        position: "center",
        autoRotate: true,
        content: null,
        offsetX: 0,
        offsetY: 0,
        style: {
          stroke: Theme.lineColor,
          lineWidth: 1
        }
      }
    } });
  };
  LineAnnotation2.prototype.renderInner = function(group2) {
    this.renderLine(group2);
    if (this.get("text")) {
      this.renderLabel(group2);
    }
  };
  LineAnnotation2.prototype.renderLine = function(group2) {
    var start = this.get("start");
    var end = this.get("end");
    var style2 = this.get("style");
    this.addShape(group2, {
      type: "line",
      id: this.getElementId("line"),
      name: "annotation-line",
      attrs: __assign$4({ x1: start.x, y1: start.y, x2: end.x, y2: end.y }, style2)
    });
  };
  LineAnnotation2.prototype.getLabelPoint = function(start, end, position) {
    var percent2;
    if (position === "start") {
      percent2 = 0;
    } else if (position === "center") {
      percent2 = 0.5;
    } else if (isString(position) && position.indexOf("%") !== -1) {
      percent2 = parseInt(position, 10) / 100;
    } else if (isNumber$1(position)) {
      percent2 = position;
    } else {
      percent2 = 1;
    }
    if (percent2 > 1 || percent2 < 0) {
      percent2 = 1;
    }
    return {
      x: getValueByPercent(start.x, end.x, percent2),
      y: getValueByPercent(start.y, end.y, percent2)
    };
  };
  LineAnnotation2.prototype.renderLabel = function(group2) {
    var text2 = this.get("text");
    var start = this.get("start");
    var end = this.get("end");
    var position = text2.position, content = text2.content, style2 = text2.style, offsetX = text2.offsetX, offsetY = text2.offsetY, autoRotate2 = text2.autoRotate, maxLength = text2.maxLength, autoEllipsis2 = text2.autoEllipsis, ellipsisPosition = text2.ellipsisPosition, background = text2.background, _a2 = text2.isVertical, isVertical2 = _a2 === void 0 ? false : _a2;
    var point2 = this.getLabelPoint(start, end, position);
    var x2 = point2.x + offsetX;
    var y2 = point2.y + offsetY;
    var cfg = {
      id: this.getElementId("line-text"),
      name: "annotation-line-text",
      x: x2,
      y: y2,
      content,
      style: style2,
      maxLength,
      autoEllipsis: autoEllipsis2,
      ellipsisPosition,
      background,
      isVertical: isVertical2
    };
    if (autoRotate2) {
      var vector = [end.x - start.x, end.y - start.y];
      cfg.rotate = Math.atan2(vector[1], vector[0]);
    }
    renderTag$1(group2, cfg);
  };
  return LineAnnotation2;
}(GroupComponent);
var TextAnnotation = function(_super) {
  __extends$3(TextAnnotation2, _super);
  function TextAnnotation2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  TextAnnotation2.prototype.getDefaultCfg = function() {
    var cfg = _super.prototype.getDefaultCfg.call(this);
    return __assign$4(__assign$4({}, cfg), { name: "annotation", type: "text", locationType: "point", x: 0, y: 0, content: "", rotate: null, style: {}, background: null, maxLength: null, autoEllipsis: true, isVertical: false, ellipsisPosition: "tail", defaultCfg: {
      style: {
        fill: Theme.textColor,
        fontSize: 12,
        textAlign: "center",
        textBaseline: "middle",
        fontFamily: Theme.fontFamily
      }
    } });
  };
  TextAnnotation2.prototype.setLocation = function(location) {
    this.set("x", location.x);
    this.set("y", location.y);
    this.resetLocation();
  };
  TextAnnotation2.prototype.renderInner = function(group2) {
    var _a2 = this.getLocation(), x2 = _a2.x, y2 = _a2.y;
    var content = this.get("content");
    var style2 = this.get("style");
    var id2 = this.getElementId("text");
    var name = this.get("name") + "-text";
    var maxLength = this.get("maxLength");
    var autoEllipsis2 = this.get("autoEllipsis");
    var isVertical2 = this.get("isVertical");
    var ellipsisPosition = this.get("ellipsisPosition");
    var background = this.get("background");
    var rotate2 = this.get("rotate");
    var cfg = {
      id: id2,
      name,
      x: x2,
      y: y2,
      content,
      style: style2,
      maxLength,
      autoEllipsis: autoEllipsis2,
      isVertical: isVertical2,
      ellipsisPosition,
      background,
      rotate: rotate2
    };
    renderTag$1(group2, cfg);
  };
  TextAnnotation2.prototype.resetLocation = function() {
    var textGroup = this.getElementByLocalId("text-group");
    if (textGroup) {
      var _a2 = this.getLocation(), x2 = _a2.x, y2 = _a2.y;
      var rotate2 = this.get("rotate");
      applyTranslate(textGroup, x2, y2);
      applyRotate(textGroup, rotate2, x2, y2);
    }
  };
  return TextAnnotation2;
}(GroupComponent);
var ArcAnnotation = function(_super) {
  __extends$3(ArcAnnotation2, _super);
  function ArcAnnotation2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  ArcAnnotation2.prototype.getDefaultCfg = function() {
    var cfg = _super.prototype.getDefaultCfg.call(this);
    return __assign$4(__assign$4({}, cfg), { name: "annotation", type: "arc", locationType: "circle", center: null, radius: 100, startAngle: -Math.PI / 2, endAngle: Math.PI * 3 / 2, style: {
      stroke: "#999",
      lineWidth: 1
    } });
  };
  ArcAnnotation2.prototype.renderInner = function(group2) {
    this.renderArc(group2);
  };
  ArcAnnotation2.prototype.getArcPath = function() {
    var _a2 = this.getLocation(), center2 = _a2.center, radius = _a2.radius, startAngle = _a2.startAngle, endAngle = _a2.endAngle;
    var startPoint = getCirclePoint(center2, radius, startAngle);
    var endPoint = getCirclePoint(center2, radius, endAngle);
    var largeFlag = endAngle - startAngle > Math.PI ? 1 : 0;
    var path2 = [["M", startPoint.x, startPoint.y]];
    if (endAngle - startAngle === Math.PI * 2) {
      var middlePoint = getCirclePoint(center2, radius, startAngle + Math.PI);
      path2.push(["A", radius, radius, 0, largeFlag, 1, middlePoint.x, middlePoint.y]);
      path2.push(["A", radius, radius, 0, largeFlag, 1, endPoint.x, endPoint.y]);
    } else {
      path2.push(["A", radius, radius, 0, largeFlag, 1, endPoint.x, endPoint.y]);
    }
    return path2;
  };
  ArcAnnotation2.prototype.renderArc = function(group2) {
    var path2 = this.getArcPath();
    var style2 = this.get("style");
    this.addShape(group2, {
      type: "path",
      id: this.getElementId("arc"),
      name: "annotation-arc",
      attrs: __assign$4({ path: path2 }, style2)
    });
  };
  return ArcAnnotation2;
}(GroupComponent);
var RegionAnnotation = function(_super) {
  __extends$3(RegionAnnotation2, _super);
  function RegionAnnotation2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  RegionAnnotation2.prototype.getDefaultCfg = function() {
    var cfg = _super.prototype.getDefaultCfg.call(this);
    return __assign$4(__assign$4({}, cfg), { name: "annotation", type: "region", locationType: "region", start: null, end: null, style: {}, defaultCfg: {
      style: {
        lineWidth: 0,
        fill: Theme.regionColor,
        opacity: 0.4
      }
    } });
  };
  RegionAnnotation2.prototype.renderInner = function(group2) {
    this.renderRegion(group2);
  };
  RegionAnnotation2.prototype.renderRegion = function(group2) {
    var start = this.get("start");
    var end = this.get("end");
    var style2 = this.get("style");
    var bbox = regionToBBox({ start, end });
    this.addShape(group2, {
      type: "rect",
      id: this.getElementId("region"),
      name: "annotation-region",
      attrs: __assign$4({ x: bbox.x, y: bbox.y, width: bbox.width, height: bbox.height }, style2)
    });
  };
  return RegionAnnotation2;
}(GroupComponent);
var ImageAnnotation = function(_super) {
  __extends$3(ImageAnnotation2, _super);
  function ImageAnnotation2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  ImageAnnotation2.prototype.getDefaultCfg = function() {
    var cfg = _super.prototype.getDefaultCfg.call(this);
    return __assign$4(__assign$4({}, cfg), { name: "annotation", type: "image", locationType: "region", start: null, end: null, src: null, style: {} });
  };
  ImageAnnotation2.prototype.renderInner = function(group2) {
    this.renderImage(group2);
  };
  ImageAnnotation2.prototype.getImageAttrs = function() {
    var start = this.get("start");
    var end = this.get("end");
    var style2 = this.get("style");
    var bbox = regionToBBox({ start, end });
    var src2 = this.get("src");
    return __assign$4({ x: bbox.x, y: bbox.y, img: src2, width: bbox.width, height: bbox.height }, style2);
  };
  ImageAnnotation2.prototype.renderImage = function(group2) {
    this.addShape(group2, {
      type: "image",
      id: this.getElementId("image"),
      name: "annotation-image",
      attrs: this.getImageAttrs()
    });
  };
  return ImageAnnotation2;
}(GroupComponent);
var DataMarkerAnnotation = function(_super) {
  __extends$3(DataMarkerAnnotation2, _super);
  function DataMarkerAnnotation2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  DataMarkerAnnotation2.prototype.getDefaultCfg = function() {
    var cfg = _super.prototype.getDefaultCfg.call(this);
    return __assign$4(__assign$4({}, cfg), { name: "annotation", type: "dataMarker", locationType: "point", x: 0, y: 0, point: {}, line: {}, text: {}, direction: "upward", autoAdjust: true, coordinateBBox: null, defaultCfg: {
      point: {
        display: true,
        style: {
          r: 3,
          fill: "#FFFFFF",
          stroke: "#1890FF",
          lineWidth: 2
        }
      },
      line: {
        display: true,
        length: 20,
        style: {
          stroke: Theme.lineColor,
          lineWidth: 1
        }
      },
      text: {
        content: "",
        display: true,
        style: {
          fill: Theme.textColor,
          opacity: 0.65,
          fontSize: 12,
          textAlign: "start",
          fontFamily: Theme.fontFamily
        }
      }
    } });
  };
  DataMarkerAnnotation2.prototype.renderInner = function(group2) {
    if (get(this.get("line"), "display")) {
      this.renderLine(group2);
    }
    if (get(this.get("text"), "display")) {
      this.renderText(group2);
    }
    if (get(this.get("point"), "display")) {
      this.renderPoint(group2);
    }
    if (this.get("autoAdjust")) {
      this.autoAdjust(group2);
    }
  };
  DataMarkerAnnotation2.prototype.applyOffset = function() {
    this.moveElementTo(this.get("group"), {
      x: this.get("x") + this.get("offsetX"),
      y: this.get("y") + this.get("offsetY")
    });
  };
  DataMarkerAnnotation2.prototype.renderPoint = function(group2) {
    var point2 = this.getShapeAttrs().point;
    this.addShape(group2, {
      type: "circle",
      id: this.getElementId("point"),
      name: "annotation-point",
      attrs: point2
    });
  };
  DataMarkerAnnotation2.prototype.renderLine = function(group2) {
    var line2 = this.getShapeAttrs().line;
    this.addShape(group2, {
      type: "path",
      id: this.getElementId("line"),
      name: "annotation-line",
      attrs: line2
    });
  };
  DataMarkerAnnotation2.prototype.renderText = function(group2) {
    var textAttrs = this.getShapeAttrs().text;
    var x2 = textAttrs.x, y2 = textAttrs.y, text2 = textAttrs.text, style2 = __rest$3(textAttrs, ["x", "y", "text"]);
    var _a2 = this.get("text"), background = _a2.background, maxLength = _a2.maxLength, autoEllipsis2 = _a2.autoEllipsis, isVertival = _a2.isVertival, ellipsisPosition = _a2.ellipsisPosition;
    var tagCfg = {
      x: x2,
      y: y2,
      id: this.getElementId("text"),
      name: "annotation-text",
      content: text2,
      style: style2,
      background,
      maxLength,
      autoEllipsis: autoEllipsis2,
      isVertival,
      ellipsisPosition
    };
    renderTag$1(group2, tagCfg);
  };
  DataMarkerAnnotation2.prototype.autoAdjust = function(group2) {
    var direction2 = this.get("direction");
    var x2 = this.get("x");
    var y2 = this.get("y");
    var lineLength = get(this.get("line"), "length", 0);
    var coordinateBBox = this.get("coordinateBBox");
    var _a2 = group2.getBBox(), minX = _a2.minX, maxX = _a2.maxX, minY = _a2.minY, maxY2 = _a2.maxY;
    var textGroup = group2.findById(this.getElementId("text-group"));
    var textShape = group2.findById(this.getElementId("text"));
    var lineShape = group2.findById(this.getElementId("line"));
    if (!coordinateBBox) {
      return;
    }
    if (textGroup) {
      if (x2 + minX <= coordinateBBox.minX) {
        var overflow = coordinateBBox.minX - (x2 + minX);
        applyTranslate(textGroup, textGroup.attr("x") + overflow, textGroup.attr("y"));
      }
      if (x2 + maxX >= coordinateBBox.maxX) {
        var overflow = x2 + maxX - coordinateBBox.maxX;
        applyTranslate(textGroup, textGroup.attr("x") - overflow, textGroup.attr("y"));
      }
    }
    if (direction2 === "upward" && y2 + minY <= coordinateBBox.minY || direction2 !== "upward" && y2 + maxY2 >= coordinateBBox.maxY) {
      var textBaseline = void 0;
      var factor = void 0;
      if (direction2 === "upward" && y2 + minY <= coordinateBBox.minY) {
        textBaseline = "top";
        factor = 1;
      } else {
        textBaseline = "bottom";
        factor = -1;
      }
      textShape.attr("textBaseline", textBaseline);
      if (lineShape) {
        lineShape.attr("path", [
          ["M", 0, 0],
          ["L", 0, lineLength * factor]
        ]);
      }
      applyTranslate(textGroup, textGroup.attr("x"), (lineLength + 2) * factor);
    }
  };
  DataMarkerAnnotation2.prototype.getShapeAttrs = function() {
    var lineDisplay = get(this.get("line"), "display");
    var pointStyle = get(this.get("point"), "style", {});
    var lineStyle = get(this.get("line"), "style", {});
    var textStyle2 = get(this.get("text"), "style", {});
    var direction2 = this.get("direction");
    var lineLength = lineDisplay ? get(this.get("line"), "length", 0) : 0;
    var factor = direction2 === "upward" ? -1 : 1;
    return {
      point: __assign$4({ x: 0, y: 0 }, pointStyle),
      line: __assign$4({ path: [
        ["M", 0, 0],
        ["L", 0, lineLength * factor]
      ] }, lineStyle),
      text: __assign$4({ x: 0, y: (lineLength + 2) * factor, text: get(this.get("text"), "content", ""), textBaseline: direction2 === "upward" ? "bottom" : "top" }, textStyle2)
    };
  };
  return DataMarkerAnnotation2;
}(GroupComponent);
var DataRegionAnnotation = function(_super) {
  __extends$3(DataRegionAnnotation2, _super);
  function DataRegionAnnotation2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  DataRegionAnnotation2.prototype.getDefaultCfg = function() {
    var cfg = _super.prototype.getDefaultCfg.call(this);
    return __assign$4(__assign$4({}, cfg), { name: "annotation", type: "dataRegion", locationType: "points", points: [], lineLength: 0, region: {}, text: {}, defaultCfg: {
      region: {
        style: {
          lineWidth: 0,
          fill: Theme.regionColor,
          opacity: 0.4
        }
      },
      text: {
        content: "",
        style: {
          textAlign: "center",
          textBaseline: "bottom",
          fontSize: 12,
          fill: Theme.textColor,
          fontFamily: Theme.fontFamily
        }
      }
    } });
  };
  DataRegionAnnotation2.prototype.renderInner = function(group2) {
    var regionStyle = get(this.get("region"), "style", {});
    get(this.get("text"), "style", {});
    var lineLength = this.get("lineLength") || 0;
    var points2 = this.get("points");
    if (!points2.length) {
      return;
    }
    var bbox = pointsToBBox(points2);
    var path2 = [];
    path2.push(["M", points2[0].x, bbox.minY - lineLength]);
    points2.forEach(function(point2) {
      path2.push(["L", point2.x, point2.y]);
    });
    path2.push(["L", points2[points2.length - 1].x, points2[points2.length - 1].y - lineLength]);
    this.addShape(group2, {
      type: "path",
      id: this.getElementId("region"),
      name: "annotation-region",
      attrs: __assign$4({ path: path2 }, regionStyle)
    });
    var textCfg = __assign$4({ id: this.getElementId("text"), name: "annotation-text", x: (bbox.minX + bbox.maxX) / 2, y: bbox.minY - lineLength }, this.get("text"));
    renderTag$1(group2, textCfg);
  };
  return DataRegionAnnotation2;
}(GroupComponent);
var RegionFilterAnnotation = function(_super) {
  __extends$3(RegionFilterAnnotation2, _super);
  function RegionFilterAnnotation2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  RegionFilterAnnotation2.prototype.getDefaultCfg = function() {
    var cfg = _super.prototype.getDefaultCfg.call(this);
    return __assign$4(__assign$4({}, cfg), { name: "annotation", type: "regionFilter", locationType: "region", start: null, end: null, color: null, shape: [] });
  };
  RegionFilterAnnotation2.prototype.renderInner = function(group2) {
    var _this = this;
    var start = this.get("start");
    var end = this.get("end");
    var layer = this.addGroup(group2, {
      id: this.getElementId("region-filter"),
      capture: false
    });
    each$1(this.get("shapes"), function(shape, shapeIdx) {
      var type4 = shape.get("type");
      var attrs = clone$1(shape.attr());
      _this.adjustShapeAttrs(attrs);
      _this.addShape(layer, {
        id: _this.getElementId("shape-" + type4 + "-" + shapeIdx),
        capture: false,
        type: type4,
        attrs
      });
    });
    var clipBBox = regionToBBox({ start, end });
    layer.setClip({
      type: "rect",
      attrs: {
        x: clipBBox.minX,
        y: clipBBox.minY,
        width: clipBBox.width,
        height: clipBBox.height
      }
    });
  };
  RegionFilterAnnotation2.prototype.adjustShapeAttrs = function(attr) {
    var color2 = this.get("color");
    if (attr.fill) {
      attr.fill = attr.fillStyle = color2;
    }
    attr.stroke = attr.strokeStyle = color2;
  };
  return RegionFilterAnnotation2;
}(GroupComponent);
var ShapeAnnotation = function(_super) {
  __extends$3(ShapeAnnotation2, _super);
  function ShapeAnnotation2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  ShapeAnnotation2.prototype.getDefaultCfg = function() {
    var cfg = _super.prototype.getDefaultCfg.call(this);
    return __assign$4(__assign$4({}, cfg), { name: "annotation", type: "shape", draw: noop });
  };
  ShapeAnnotation2.prototype.renderInner = function(group2) {
    var render2 = this.get("render");
    if (isFunction(render2)) {
      render2(group2);
    }
  };
  return ShapeAnnotation2;
}(GroupComponent);
var HtmlComponent = function(_super) {
  __extends$3(HtmlComponent2, _super);
  function HtmlComponent2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  HtmlComponent2.prototype.getDefaultCfg = function() {
    var cfg = _super.prototype.getDefaultCfg.call(this);
    return __assign$4(__assign$4({}, cfg), { container: null, containerTpl: "<div></div>", updateAutoRender: true, containerClassName: "", parent: null });
  };
  HtmlComponent2.prototype.getContainer = function() {
    return this.get("container");
  };
  HtmlComponent2.prototype.show = function() {
    var container = this.get("container");
    container.style.display = "";
    this.set("visible", true);
  };
  HtmlComponent2.prototype.hide = function() {
    var container = this.get("container");
    container.style.display = "none";
    this.set("visible", false);
  };
  HtmlComponent2.prototype.setCapture = function(capture) {
    var container = this.getContainer();
    var value2 = capture ? "auto" : "none";
    container.style.pointerEvents = value2;
    this.set("capture", capture);
  };
  HtmlComponent2.prototype.getBBox = function() {
    var container = this.getContainer();
    var x2 = parseFloat(container.style.left) || 0;
    var y2 = parseFloat(container.style.top) || 0;
    return createBBox(x2, y2, container.clientWidth, container.clientHeight);
  };
  HtmlComponent2.prototype.clear = function() {
    var container = this.get("container");
    clearDom(container);
  };
  HtmlComponent2.prototype.destroy = function() {
    this.removeEvent();
    this.removeDom();
    _super.prototype.destroy.call(this);
  };
  HtmlComponent2.prototype.init = function() {
    _super.prototype.init.call(this);
    this.initContainer();
    this.initDom();
    this.resetStyles();
    this.applyStyles();
    this.initEvent();
    this.initCapture();
    this.initVisible();
  };
  HtmlComponent2.prototype.initCapture = function() {
    this.setCapture(this.get("capture"));
  };
  HtmlComponent2.prototype.initVisible = function() {
    if (!this.get("visible")) {
      this.hide();
    } else {
      this.show();
    }
  };
  HtmlComponent2.prototype.initDom = function() {
  };
  HtmlComponent2.prototype.initContainer = function() {
    var container = this.get("container");
    if (isNil(container)) {
      container = this.createDom();
      var parent_1 = this.get("parent");
      if (isString(parent_1)) {
        parent_1 = document.getElementById(parent_1);
        this.set("parent", parent_1);
      }
      parent_1.appendChild(container);
      if (this.get("containerId")) {
        container.setAttribute("id", this.get("containerId"));
      }
      this.set("container", container);
    } else if (isString(container)) {
      container = document.getElementById(container);
      this.set("container", container);
    }
    if (!this.get("parent")) {
      this.set("parent", container.parentNode);
    }
  };
  HtmlComponent2.prototype.resetStyles = function() {
    var style2 = this.get("domStyles");
    var defaultStyles = this.get("defaultStyles");
    if (!style2) {
      style2 = defaultStyles;
    } else {
      style2 = deepMix({}, defaultStyles, style2);
    }
    this.set("domStyles", style2);
  };
  HtmlComponent2.prototype.applyStyles = function() {
    var domStyles = this.get("domStyles");
    if (!domStyles) {
      return;
    }
    var container = this.getContainer();
    this.applyChildrenStyles(container, domStyles);
    var containerClassName = this.get("containerClassName");
    if (containerClassName && hasClass(container, containerClassName)) {
      var containerCss = domStyles[containerClassName];
      modifyCSS(container, containerCss);
    }
  };
  HtmlComponent2.prototype.applyChildrenStyles = function(element, styles) {
    each$1(styles, function(style2, name) {
      var elements = element.getElementsByClassName(name);
      each$1(elements, function(el) {
        modifyCSS(el, style2);
      });
    });
  };
  HtmlComponent2.prototype.applyStyle = function(cssName, dom) {
    var domStyles = this.get("domStyles");
    modifyCSS(dom, domStyles[cssName]);
  };
  HtmlComponent2.prototype.createDom = function() {
    var containerTpl = this.get("containerTpl");
    return createDom$1(containerTpl);
  };
  HtmlComponent2.prototype.initEvent = function() {
  };
  HtmlComponent2.prototype.removeDom = function() {
    var container = this.get("container");
    container && container.parentNode && container.parentNode.removeChild(container);
  };
  HtmlComponent2.prototype.removeEvent = function() {
  };
  HtmlComponent2.prototype.updateInner = function(cfg) {
    if (has(cfg, "domStyles")) {
      this.resetStyles();
      this.applyStyles();
    }
    this.resetPosition();
  };
  HtmlComponent2.prototype.resetPosition = function() {
  };
  return HtmlComponent2;
}(Component);
var HtmlAnnotation = function(_super) {
  __extends$3(HtmlAnnotation2, _super);
  function HtmlAnnotation2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  HtmlAnnotation2.prototype.getDefaultCfg = function() {
    var cfg = _super.prototype.getDefaultCfg.call(this);
    return __assign$4(__assign$4({}, cfg), { name: "annotation", type: "html", locationType: "point", x: 0, y: 0, containerTpl: '<div class="g2-html-annotation" style="position:absolute"></div>', alignX: "left", alignY: "top", html: "", zIndex: 7 });
  };
  HtmlAnnotation2.prototype.render = function() {
    var container = this.getContainer();
    var html = this.get("html");
    clearDom(container);
    var rst = isFunction(html) ? html(container) : html;
    if (isElement(rst)) {
      container.appendChild(rst);
    } else if (isString(rst) || isNumber$1(rst)) {
      var dom = createDom$1("" + rst);
      if (dom) {
        container.appendChild(dom);
      }
    }
    this.resetPosition();
  };
  HtmlAnnotation2.prototype.resetPosition = function() {
    var container = this.getContainer();
    var _a2 = this.getLocation(), x2 = _a2.x, y2 = _a2.y;
    var alignX = this.get("alignX");
    var alignY = this.get("alignY");
    var offsetX = this.get("offsetX");
    var offsetY = this.get("offsetY");
    var domWidth = getOuterWidth(container);
    var domHeight = getOuterHeight(container);
    var position = {
      x: x2,
      y: y2
    };
    if (alignX === "middle") {
      position.x -= Math.round(domWidth / 2);
    } else if (alignX === "right") {
      position.x -= Math.round(domWidth);
    }
    if (alignY === "middle") {
      position.y -= Math.round(domHeight / 2);
    } else if (alignY === "bottom") {
      position.y -= Math.round(domHeight);
    }
    if (offsetX) {
      position.x += offsetX;
    }
    if (offsetY) {
      position.y += offsetY;
    }
    modifyCSS(container, {
      position: "absolute",
      left: position.x + "px",
      top: position.y + "px",
      zIndex: this.get("zIndex")
    });
  };
  return HtmlAnnotation2;
}(HtmlComponent);
var AnnotationComponent = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Line: LineAnnotation,
  Text: TextAnnotation,
  Arc: ArcAnnotation,
  Region: RegionAnnotation,
  Image: ImageAnnotation,
  DataMarker: DataMarkerAnnotation,
  DataRegion: DataRegionAnnotation,
  RegionFilter: RegionFilterAnnotation,
  Shape: ShapeAnnotation,
  Html: HtmlAnnotation
}, Symbol.toStringTag, { value: "Module" }));
function getStatesStyle(item, elementName, stateStyles) {
  var styleName = elementName + "Style";
  var styles = null;
  each$1(stateStyles, function(v2, state2) {
    if (item[state2] && v2[styleName]) {
      if (!styles) {
        styles = {};
      }
      mix(styles, v2[styleName]);
    }
  });
  return styles;
}
var AxisBase = function(_super) {
  __extends$3(AxisBase2, _super);
  function AxisBase2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  AxisBase2.prototype.getDefaultCfg = function() {
    var cfg = _super.prototype.getDefaultCfg.call(this);
    return __assign$4(__assign$4({}, cfg), {
      name: "axis",
      ticks: [],
      line: {},
      tickLine: {},
      subTickLine: null,
      title: null,
      label: {},
      verticalFactor: 1,
      verticalLimitLength: null,
      overlapOrder: ["autoRotate", "autoEllipsis", "autoHide"],
      tickStates: {},
      optimize: {},
      defaultCfg: {
        line: {
          style: {
            lineWidth: 1,
            stroke: Theme.lineColor
          }
        },
        tickLine: {
          style: {
            lineWidth: 1,
            stroke: Theme.lineColor
          },
          alignTick: true,
          length: 5,
          displayWithLabel: true
        },
        subTickLine: {
          style: {
            lineWidth: 1,
            stroke: Theme.lineColor
          },
          count: 4,
          length: 2
        },
        label: {
          autoRotate: true,
          autoHide: false,
          autoEllipsis: false,
          style: {
            fontSize: 12,
            fill: Theme.textColor,
            fontFamily: Theme.fontFamily,
            fontWeight: "normal"
          },
          offset: 10,
          offsetX: 0,
          offsetY: 0
        },
        title: {
          autoRotate: true,
          spacing: 5,
          position: "center",
          style: {
            fontSize: 12,
            fill: Theme.textColor,
            textBaseline: "middle",
            fontFamily: Theme.fontFamily,
            textAlign: "center"
          },
          iconStyle: {
            fill: Theme.descriptionIconFill,
            stroke: Theme.descriptionIconStroke
          },
          description: ""
        },
        tickStates: {
          active: {
            labelStyle: {
              fontWeight: 500
            },
            tickLineStyle: {
              lineWidth: 2
            }
          },
          inactive: {
            labelStyle: {
              fill: Theme.uncheckedColor
            }
          }
        },
        optimize: {
          enable: true,
          threshold: 400
        }
      },
      theme: {}
    });
  };
  AxisBase2.prototype.renderInner = function(group2) {
    if (this.get("line")) {
      this.drawLine(group2);
    }
    this.drawTicks(group2);
    if (this.get("title")) {
      this.drawTitle(group2);
    }
  };
  AxisBase2.prototype.isList = function() {
    return true;
  };
  AxisBase2.prototype.getItems = function() {
    return this.get("ticks");
  };
  AxisBase2.prototype.setItems = function(items) {
    this.update({
      ticks: items
    });
  };
  AxisBase2.prototype.updateItem = function(item, cfg) {
    mix(item, cfg);
    this.clear();
    this.render();
  };
  AxisBase2.prototype.clearItems = function() {
    var itemGroup = this.getElementByLocalId("label-group");
    itemGroup && itemGroup.clear();
  };
  AxisBase2.prototype.setItemState = function(item, state2, value2) {
    item[state2] = value2;
    this.updateTickStates(item);
  };
  AxisBase2.prototype.hasState = function(item, state2) {
    return !!item[state2];
  };
  AxisBase2.prototype.getItemStates = function(item) {
    var tickStates = this.get("tickStates");
    var rst = [];
    each$1(tickStates, function(v2, k2) {
      if (item[k2]) {
        rst.push(k2);
      }
    });
    return rst;
  };
  AxisBase2.prototype.clearItemsState = function(state2) {
    var _this = this;
    var items = this.getItemsByState(state2);
    each$1(items, function(item) {
      _this.setItemState(item, state2, false);
    });
  };
  AxisBase2.prototype.getItemsByState = function(state2) {
    var _this = this;
    var items = this.getItems();
    return filter(items, function(item) {
      return _this.hasState(item, state2);
    });
  };
  AxisBase2.prototype.getSidePoint = function(point2, offset3) {
    var self2 = this;
    var vector = self2.getSideVector(offset3, point2);
    return {
      x: point2.x + vector[0],
      y: point2.y + vector[1]
    };
  };
  AxisBase2.prototype.getTextAnchor = function(vector) {
    var align;
    if (isNumberEqual$1(vector[0], 0)) {
      align = "center";
    } else if (vector[0] > 0) {
      align = "start";
    } else if (vector[0] < 0) {
      align = "end";
    }
    return align;
  };
  AxisBase2.prototype.getTextBaseline = function(vector) {
    var base;
    if (isNumberEqual$1(vector[1], 0)) {
      base = "middle";
    } else if (vector[1] > 0) {
      base = "top";
    } else if (vector[1] < 0) {
      base = "bottom";
    }
    return base;
  };
  AxisBase2.prototype.processOverlap = function(labelGroup) {
  };
  AxisBase2.prototype.drawLine = function(group2) {
    var path2 = this.getLinePath();
    var line2 = this.get("line");
    this.addShape(group2, {
      type: "path",
      id: this.getElementId("line"),
      name: "axis-line",
      attrs: mix({
        path: path2
      }, line2.style)
    });
  };
  AxisBase2.prototype.getTickLineItems = function(ticks) {
    var _this = this;
    var tickLineItems = [];
    var tickLine = this.get("tickLine");
    var alignTick = tickLine.alignTick;
    var tickLineLength = tickLine.length;
    var tickSegment = 1;
    var tickCount = ticks.length;
    if (tickCount >= 2) {
      tickSegment = ticks[1].value - ticks[0].value;
    }
    each$1(ticks, function(tick) {
      var point2 = tick.point;
      if (!alignTick) {
        point2 = _this.getTickPoint(tick.value - tickSegment / 2);
      }
      var endPoint = _this.getSidePoint(point2, tickLineLength);
      tickLineItems.push({
        startPoint: point2,
        tickValue: tick.value,
        endPoint,
        tickId: tick.id,
        id: "tickline-" + tick.id
      });
    });
    return tickLineItems;
  };
  AxisBase2.prototype.getSubTickLineItems = function(tickLineItems) {
    var subTickLineItems = [];
    var subTickLine = this.get("subTickLine");
    var subCount = subTickLine.count;
    var tickLineCount = tickLineItems.length;
    if (tickLineCount >= 2) {
      for (var i2 = 0; i2 < tickLineCount - 1; i2++) {
        var pre = tickLineItems[i2];
        var next = tickLineItems[i2 + 1];
        for (var j2 = 0; j2 < subCount; j2++) {
          var percent2 = (j2 + 1) / (subCount + 1);
          var tickValue = (1 - percent2) * pre.tickValue + percent2 * next.tickValue;
          var point2 = this.getTickPoint(tickValue);
          var endPoint = this.getSidePoint(point2, subTickLine.length);
          subTickLineItems.push({
            startPoint: point2,
            endPoint,
            tickValue,
            id: "sub-" + pre.id + "-" + j2
          });
        }
      }
    }
    return subTickLineItems;
  };
  AxisBase2.prototype.getTickLineAttrs = function(tickItem, type4, index2, tickItems) {
    var style2 = this.get(type4).style;
    var item = {
      points: [tickItem.startPoint, tickItem.endPoint]
    };
    var defaultTickLineStyle = get(this.get("theme"), ["tickLine", "style"], {});
    style2 = isFunction(style2) ? mix({}, defaultTickLineStyle, style2(item, index2, tickItems)) : style2;
    var startPoint = tickItem.startPoint, endPoint = tickItem.endPoint;
    return __assign$4({ x1: startPoint.x, y1: startPoint.y, x2: endPoint.x, y2: endPoint.y }, style2);
  };
  AxisBase2.prototype.drawTick = function(tickItem, tickLineGroup, type4, index2, tickItems) {
    this.addShape(tickLineGroup, {
      type: "line",
      id: this.getElementId(tickItem.id),
      name: "axis-" + type4,
      attrs: this.getTickLineAttrs(tickItem, type4, index2, tickItems)
    });
  };
  AxisBase2.prototype.drawTickLines = function(group2) {
    var _this = this;
    var ticks = this.get("ticks");
    var subTickLine = this.get("subTickLine");
    var tickLineItems = this.getTickLineItems(ticks);
    var tickLineGroup = this.addGroup(group2, {
      name: "axis-tickline-group",
      id: this.getElementId("tickline-group")
    });
    var tickCfg = this.get("tickLine");
    each$1(tickLineItems, function(item, index2) {
      if (tickCfg.displayWithLabel) {
        var labelId = _this.getElementId("label-" + item.tickId);
        if (group2.findById(labelId)) {
          _this.drawTick(item, tickLineGroup, "tickLine", index2, tickLineItems);
        }
      } else {
        _this.drawTick(item, tickLineGroup, "tickLine", index2, tickLineItems);
      }
    });
    if (subTickLine) {
      var subTickLineItems_1 = this.getSubTickLineItems(tickLineItems);
      each$1(subTickLineItems_1, function(item, index2) {
        _this.drawTick(item, tickLineGroup, "subTickLine", index2, subTickLineItems_1);
      });
    }
  };
  AxisBase2.prototype.processTicks = function() {
    var _this = this;
    var ticks = this.get("ticks");
    each$1(ticks, function(tick) {
      tick.point = _this.getTickPoint(tick.value);
      if (isNil(tick.id)) {
        tick.id = tick.name;
      }
    });
  };
  AxisBase2.prototype.drawTicks = function(group2) {
    var _this = this;
    this.optimizeTicks();
    this.processTicks();
    if (this.get("label")) {
      this.drawLabels(group2);
    }
    if (this.get("tickLine")) {
      this.drawTickLines(group2);
    }
    var ticks = this.get("ticks");
    each$1(ticks, function(tick) {
      _this.applyTickStates(tick, group2);
    });
  };
  AxisBase2.prototype.optimizeTicks = function() {
    var optimize = this.get("optimize");
    var ticks = this.get("ticks");
    if (optimize && optimize.enable && optimize.threshold > 0) {
      var len = size(ticks);
      if (len > optimize.threshold) {
        var page_1 = Math.ceil(len / optimize.threshold);
        var optimizedTicks = ticks.filter(function(tick, idx) {
          return idx % page_1 === 0;
        });
        this.set("ticks", optimizedTicks);
        this.set("originalTicks", ticks);
      }
    }
  };
  AxisBase2.prototype.getLabelAttrs = function(tick, index2, ticks) {
    var labelCfg = this.get("label");
    var offset3 = labelCfg.offset, offsetX = labelCfg.offsetX, offsetY = labelCfg.offsetY, rotate2 = labelCfg.rotate, formatter = labelCfg.formatter;
    var point2 = this.getSidePoint(tick.point, offset3);
    var vector = this.getSideVector(offset3, point2);
    var text2 = formatter ? formatter(tick.name, tick, index2) : tick.name;
    var style2 = labelCfg.style;
    style2 = isFunction(style2) ? get(this.get("theme"), ["label", "style"], {}) : style2;
    var attrs = mix({
      x: point2.x + offsetX,
      y: point2.y + offsetY,
      text: text2,
      textAlign: this.getTextAnchor(vector),
      textBaseline: this.getTextBaseline(vector)
    }, style2);
    if (rotate2) {
      attrs.matrix = getMatrixByAngle(point2, rotate2);
    }
    return attrs;
  };
  AxisBase2.prototype.drawLabels = function(group2) {
    var _this = this;
    var ticks = this.get("ticks");
    var labelGroup = this.addGroup(group2, {
      name: "axis-label-group",
      id: this.getElementId("label-group")
    });
    each$1(ticks, function(tick, index2) {
      _this.addShape(labelGroup, {
        type: "text",
        name: "axis-label",
        id: _this.getElementId("label-" + tick.id),
        attrs: _this.getLabelAttrs(tick, index2, ticks),
        delegateObject: {
          tick,
          item: tick,
          index: index2
        }
      });
    });
    this.processOverlap(labelGroup);
    var labels = labelGroup.getChildren();
    var defaultLabelStyle = get(this.get("theme"), ["label", "style"], {});
    var _a2 = this.get("label"), style2 = _a2.style, formatter = _a2.formatter;
    if (isFunction(style2)) {
      var afterProcessTicks_1 = labels.map(function(label2) {
        return get(label2.get("delegateObject"), "tick");
      });
      each$1(labels, function(label2, index2) {
        var tick = label2.get("delegateObject").tick;
        var text2 = formatter ? formatter(tick.name, tick, index2) : tick.name;
        var newStyle = mix({}, defaultLabelStyle, style2(text2, index2, afterProcessTicks_1));
        label2.attr(newStyle);
      });
    }
  };
  AxisBase2.prototype.getTitleAttrs = function() {
    var titleCfg = this.get("title");
    var style2 = titleCfg.style, position = titleCfg.position, offset3 = titleCfg.offset, _a2 = titleCfg.spacing, spacing = _a2 === void 0 ? 0 : _a2, autoRotate2 = titleCfg.autoRotate;
    var titleHeight = style2.fontSize;
    var percent2 = 0.5;
    if (position === "start") {
      percent2 = 0;
    } else if (position === "end") {
      percent2 = 1;
    }
    var point2 = this.getTickPoint(percent2);
    var titlePoint = this.getSidePoint(point2, offset3 || spacing + titleHeight / 2);
    var attrs = mix({
      x: titlePoint.x,
      y: titlePoint.y,
      text: titleCfg.text
    }, style2);
    var rotate2 = titleCfg.rotate;
    var angle2 = rotate2;
    if (isNil(rotate2) && autoRotate2) {
      var vector = this.getAxisVector(point2);
      var v1 = [1, 0];
      angle2 = angleTo(vector, v1, true);
    }
    if (angle2) {
      var matrix = getMatrixByAngle(titlePoint, angle2);
      attrs.matrix = matrix;
    }
    return attrs;
  };
  AxisBase2.prototype.drawTitle = function(group2) {
    var _a2;
    var titleAttrs = this.getTitleAttrs();
    var titleShape = this.addShape(group2, {
      type: "text",
      id: this.getElementId("title"),
      name: "axis-title",
      attrs: titleAttrs
    });
    if ((_a2 = this.get("title")) === null || _a2 === void 0 ? void 0 : _a2.description) {
      this.drawDescriptionIcon(group2, titleShape, titleAttrs.matrix);
    }
  };
  AxisBase2.prototype.drawDescriptionIcon = function(group2, titleShape, matrix) {
    var descriptionShape = this.addGroup(group2, {
      name: "axis-description",
      id: this.getElementById("description")
    });
    var _a2 = titleShape.getBBox(), maxX = _a2.maxX, maxY2 = _a2.maxY, height = _a2.height;
    var iconStyle = this.get("title").iconStyle;
    var spacing = 4;
    var r2 = height / 2;
    var lineWidth = r2 / 6;
    var startX = maxX + spacing;
    var startY = maxY2 - height / 2;
    var _b = [startX + r2, startY - r2], x0 = _b[0], y0 = _b[1];
    var _c = [x0 + r2, y0 + r2], x1 = _c[0], y1 = _c[1];
    var _d = [x0, y1 + r2], x2 = _d[0], y2 = _d[1];
    var _e = [startX, y0 + r2], x3 = _e[0], y3 = _e[1];
    var _f = [startX + r2, startY - height / 4], x4 = _f[0], y4 = _f[1];
    var _g = [x4, y4 + lineWidth], x5 = _g[0], y5 = _g[1];
    var _h = [x5, y5 + lineWidth], x6 = _h[0], y6 = _h[1];
    var _j = [x6, y6 + r2 * 3 / 4], x7 = _j[0], y7 = _j[1];
    this.addShape(descriptionShape, {
      type: "path",
      id: this.getElementId("title-description-icon"),
      name: "axis-title-description-icon",
      attrs: __assign$4({
        path: [
          ["M", x0, y0],
          ["A", r2, r2, 0, 0, 1, x1, y1],
          ["A", r2, r2, 0, 0, 1, x2, y2],
          ["A", r2, r2, 0, 0, 1, x3, y3],
          ["A", r2, r2, 0, 0, 1, x0, y0],
          ["M", x4, y4],
          ["L", x5, y5],
          ["M", x6, y6],
          ["L", x7, y7]
        ],
        lineWidth,
        matrix
      }, iconStyle)
    });
    this.addShape(descriptionShape, {
      type: "rect",
      id: this.getElementId("title-description-rect"),
      name: "axis-title-description-rect",
      attrs: {
        x: startX,
        y: startY - height / 2,
        width: height,
        height,
        stroke: "#000",
        fill: "#000",
        opacity: 0,
        matrix,
        cursor: "pointer"
      }
    });
  };
  AxisBase2.prototype.applyTickStates = function(tick, group2) {
    var states = this.getItemStates(tick);
    if (states.length) {
      var tickStates = this.get("tickStates");
      var labelId = this.getElementId("label-" + tick.id);
      var labelShape = group2.findById(labelId);
      if (labelShape) {
        var labelStateStyle = getStatesStyle(tick, "label", tickStates);
        labelStateStyle && labelShape.attr(labelStateStyle);
      }
      var tickLineId = this.getElementId("tickline-" + tick.id);
      var tickLineShape = group2.findById(tickLineId);
      if (tickLineShape) {
        var tickLineStateStyle = getStatesStyle(tick, "tickLine", tickStates);
        tickLineStateStyle && tickLineShape.attr(tickLineStateStyle);
      }
    }
  };
  AxisBase2.prototype.updateTickStates = function(tick) {
    var states = this.getItemStates(tick);
    var tickStates = this.get("tickStates");
    var labelCfg = this.get("label");
    var labelShape = this.getElementByLocalId("label-" + tick.id);
    var tickLineCfg = this.get("tickLine");
    var tickLineShape = this.getElementByLocalId("tickline-" + tick.id);
    if (states.length) {
      if (labelShape) {
        var labelStateStyle = getStatesStyle(tick, "label", tickStates);
        labelStateStyle && labelShape.attr(labelStateStyle);
      }
      if (tickLineShape) {
        var tickLineStateStyle = getStatesStyle(tick, "tickLine", tickStates);
        tickLineStateStyle && tickLineShape.attr(tickLineStateStyle);
      }
    } else {
      if (labelShape) {
        labelShape.attr(labelCfg.style);
      }
      if (tickLineShape) {
        tickLineShape.attr(tickLineCfg.style);
      }
    }
  };
  return AxisBase2;
}(GroupComponent);
function ellipseLabels(isVertical2, labelGroup, limitLength, position) {
  var children = labelGroup.getChildren();
  var ellipsisFlag = false;
  each$1(children, function(label2) {
    var rst = ellipsisLabel(isVertical2, label2, limitLength, position);
    ellipsisFlag = ellipsisFlag || rst;
  });
  return ellipsisFlag;
}
function getDefault$2() {
  return ellipsisTail;
}
function ellipsisHead(isVertical2, labelGroup, limitLength) {
  return ellipseLabels(isVertical2, labelGroup, limitLength, "head");
}
function ellipsisTail(isVertical2, labelGroup, limitLength) {
  return ellipseLabels(isVertical2, labelGroup, limitLength, "tail");
}
function ellipsisMiddle(isVertical2, labelGroup, limitLength) {
  return ellipseLabels(isVertical2, labelGroup, limitLength, "middle");
}
var autoEllipsis = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  getDefault: getDefault$2,
  ellipsisHead,
  ellipsisTail,
  ellipsisMiddle
}, Symbol.toStringTag, { value: "Module" }));
function isRotate(label2) {
  var matrix = label2.attr("matrix");
  return matrix && matrix[0] !== 1;
}
function getRotateAngle(label2) {
  var angle2 = isRotate(label2) ? getAngleByMatrix(label2.attr("matrix")) : 0;
  return angle2 % 360;
}
function isOverlap(isVertical2, first, second, minGap) {
  var overlap2 = false;
  var angle2 = getRotateAngle(first);
  var distance2 = isVertical2 ? Math.abs(second.attr("y") - first.attr("y")) : Math.abs(second.attr("x") - first.attr("x"));
  var prevBBox = (isVertical2 ? second.attr("y") > first.attr("y") : second.attr("x") > first.attr("x")) ? first.getBBox() : second.getBBox();
  if (isVertical2) {
    var ratio = Math.abs(Math.cos(angle2));
    if (near(ratio, 0, Math.PI / 180)) {
      overlap2 = prevBBox.width + minGap > distance2;
    } else {
      overlap2 = prevBBox.height / ratio + minGap > distance2;
    }
  } else {
    var ratio = Math.abs(Math.sin(angle2));
    if (near(ratio, 0, Math.PI / 180)) {
      overlap2 = prevBBox.width + minGap > distance2;
    } else {
      overlap2 = prevBBox.height / ratio + minGap > distance2;
    }
  }
  return overlap2;
}
function reserveOne(isVertical2, labelsGroup, reversed, autoHideCfg) {
  var minGap = (autoHideCfg === null || autoHideCfg === void 0 ? void 0 : autoHideCfg.minGap) || 0;
  var labels = labelsGroup.getChildren().slice().filter(function(item) {
    return item.get("visible");
  });
  if (!labels.length) {
    return false;
  }
  var hasHide = false;
  if (reversed) {
    labels.reverse();
  }
  var count2 = labels.length;
  var first = labels[0];
  var prev = first;
  for (var i2 = 1; i2 < count2; i2++) {
    var label2 = labels[i2];
    label2.getBBox();
    var isHide = isOverlap(isVertical2, prev, label2, minGap);
    if (isHide) {
      label2.hide();
      hasHide = true;
    } else {
      prev = label2;
    }
  }
  return hasHide;
}
function parityHide(isVertical2, labelsGroup, autoHideCfg) {
  var minGap = (autoHideCfg === null || autoHideCfg === void 0 ? void 0 : autoHideCfg.minGap) || 0;
  var labels = labelsGroup.getChildren().slice();
  if (labels.length < 2) {
    return false;
  }
  var hasHide = false;
  var first = labels[0];
  var firstBBox = first.getBBox();
  var second = labels[1];
  var count2 = labels.length;
  var angle2 = getRotateAngle(first);
  var distance2 = isVertical2 ? Math.abs(second.attr("y") - first.attr("y")) : Math.abs(second.attr("x") - first.attr("x"));
  var interval2 = 0;
  if (isVertical2) {
    var ratio = Math.abs(Math.cos(angle2));
    if (near(ratio, 0, Math.PI / 180)) {
      var maxWidth = getMaxLabelWidth(labels);
      interval2 = (maxWidth + minGap) / distance2;
    } else {
      interval2 = (firstBBox.height / ratio + minGap) / distance2;
    }
  } else {
    var ratio = Math.abs(Math.sin(angle2));
    if (near(ratio, 0, Math.PI / 180)) {
      var maxWidth = getMaxLabelWidth(labels);
      interval2 = (maxWidth + minGap) / distance2;
    } else {
      interval2 = (firstBBox.height / ratio + minGap) / distance2;
    }
  }
  if (interval2 > 1) {
    interval2 = Math.ceil(interval2);
    for (var i2 = 0; i2 < count2; i2++) {
      if (i2 % interval2 !== 0) {
        labels[i2].hide();
        hasHide = true;
      }
    }
  }
  return hasHide;
}
function getDefault$1() {
  return equidistance;
}
function reserveFirst(isVertical2, labelsGroup, limitLength, autoHideCfg) {
  return reserveOne(isVertical2, labelsGroup, false, autoHideCfg);
}
function reserveLast(isVertical2, labelsGroup, limitLength, autoHideCfg) {
  return reserveOne(isVertical2, labelsGroup, true, autoHideCfg);
}
function reserveBoth(isVertical2, labelsGroup, limitLength, autoHideCfg) {
  var minGap = (autoHideCfg === null || autoHideCfg === void 0 ? void 0 : autoHideCfg.minGap) || 0;
  var labels = labelsGroup.getChildren().slice();
  if (labels.length <= 2) {
    return false;
  }
  var hasHide = false;
  var count2 = labels.length;
  var first = labels[0];
  var last2 = labels[count2 - 1];
  var preLabel = first;
  for (var i2 = 1; i2 < count2 - 1; i2++) {
    var label2 = labels[i2];
    label2.getBBox();
    var isHide = isOverlap(isVertical2, preLabel, label2, minGap);
    if (isHide) {
      label2.hide();
      hasHide = true;
    } else {
      preLabel = label2;
    }
  }
  var overlap2 = isOverlap(isVertical2, preLabel, last2, minGap);
  if (overlap2) {
    preLabel.hide();
    hasHide = true;
  }
  return hasHide;
}
function equidistance(isVertical2, labelsGroup, limitLength, autoHideCfg) {
  var hasHide = parityHide(isVertical2, labelsGroup, autoHideCfg);
  if (reserveOne(isVertical2, labelsGroup, false)) {
    hasHide = true;
  }
  return hasHide;
}
function equidistanceWithReverseBoth(isVertical2, labelsGroup, limitLength, autoHideCfg) {
  var labels = labelsGroup.getChildren().slice();
  var hasHide = parityHide(isVertical2, labelsGroup, autoHideCfg);
  if (labels.length > 2) {
    var first = labels[0];
    var last2 = labels[labels.length - 1];
    if (!first.get("visible")) {
      first.show();
      if (reserveOne(isVertical2, labelsGroup, false, autoHideCfg)) {
        hasHide = true;
      }
    }
    if (!last2.get("visible")) {
      last2.show();
      if (reserveOne(isVertical2, labelsGroup, true, autoHideCfg)) {
        hasHide = true;
      }
    }
  }
  return hasHide;
}
var autoHide = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  getDefault: getDefault$1,
  reserveFirst,
  reserveLast,
  reserveBoth,
  equidistance,
  equidistanceWithReverseBoth
}, Symbol.toStringTag, { value: "Module" }));
function setLabelsAngle(labels, angle2) {
  each$1(labels, function(label2) {
    var x2 = label2.attr("x");
    var y2 = label2.attr("y");
    var matrix = getMatrixByAngle({ x: x2, y: y2 }, angle2);
    label2.attr("matrix", matrix);
  });
}
function labelRotate(isVertical2, labelsGroup, limitLength, getAngle2) {
  var labels = labelsGroup.getChildren();
  if (!labels.length) {
    return false;
  }
  if (!isVertical2 && labels.length < 2) {
    return false;
  }
  var maxWidth = getMaxLabelWidth(labels);
  var isOverlap2 = false;
  if (isVertical2) {
    isOverlap2 = !!limitLength && maxWidth > limitLength;
  } else {
    var tickWidth = Math.abs(labels[1].attr("x") - labels[0].attr("x"));
    isOverlap2 = maxWidth > tickWidth;
  }
  if (isOverlap2) {
    var angle2 = getAngle2(limitLength, maxWidth);
    setLabelsAngle(labels, angle2);
  }
  return isOverlap2;
}
function getDefault() {
  return fixedAngle;
}
function fixedAngle(isVertical2, labelsGroup, limitLength, customRotate) {
  return labelRotate(isVertical2, labelsGroup, limitLength, function() {
    if (isNumber$1(customRotate)) {
      return customRotate;
    }
    return isVertical2 ? Theme.verticalAxisRotate : Theme.horizontalAxisRotate;
  });
}
function unfixedAngle(isVertical2, labelsGroup, limitLength) {
  return labelRotate(isVertical2, labelsGroup, limitLength, function(length2, maxWidth) {
    if (!length2) {
      return isVertical2 ? Theme.verticalAxisRotate : Theme.horizontalAxisRotate;
    }
    if (isVertical2) {
      return -Math.acos(length2 / maxWidth);
    } else {
      var angle2 = 0;
      if (length2 > maxWidth) {
        angle2 = Math.PI / 4;
      } else {
        angle2 = Math.asin(length2 / maxWidth);
        if (angle2 > Math.PI / 4) {
          angle2 = Math.PI / 4;
        }
      }
      return angle2;
    }
  });
}
var autoRotate = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  getDefault,
  fixedAngle,
  unfixedAngle
}, Symbol.toStringTag, { value: "Module" }));
var OverlapUtil = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  autoHide,
  autoRotate,
  autoEllipsis
}, Symbol.toStringTag, { value: "Module" }));
var Line$8 = function(_super) {
  __extends$3(Line2, _super);
  function Line2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Line2.prototype.getDefaultCfg = function() {
    var cfg = _super.prototype.getDefaultCfg.call(this);
    return __assign$4(__assign$4({}, cfg), {
      type: "line",
      locationType: "region",
      start: null,
      end: null
    });
  };
  Line2.prototype.getLinePath = function() {
    var start = this.get("start");
    var end = this.get("end");
    var path2 = [];
    path2.push(["M", start.x, start.y]);
    path2.push(["L", end.x, end.y]);
    return path2;
  };
  Line2.prototype.getInnerLayoutBBox = function() {
    var start = this.get("start");
    var end = this.get("end");
    var bbox = _super.prototype.getInnerLayoutBBox.call(this);
    var minX = Math.min(start.x, end.x, bbox.x);
    var minY = Math.min(start.y, end.y, bbox.y);
    var maxX = Math.max(start.x, end.x, bbox.maxX);
    var maxY2 = Math.max(start.y, end.y, bbox.maxY);
    return {
      x: minX,
      y: minY,
      minX,
      minY,
      maxX,
      maxY: maxY2,
      width: maxX - minX,
      height: maxY2 - minY
    };
  };
  Line2.prototype.isVertical = function() {
    var start = this.get("start");
    var end = this.get("end");
    return isNumberEqual$1(start.x, end.x);
  };
  Line2.prototype.isHorizontal = function() {
    var start = this.get("start");
    var end = this.get("end");
    return isNumberEqual$1(start.y, end.y);
  };
  Line2.prototype.getTickPoint = function(tickValue) {
    var self2 = this;
    var start = self2.get("start");
    var end = self2.get("end");
    var regionX = end.x - start.x;
    var regionY = end.y - start.y;
    return {
      x: start.x + regionX * tickValue,
      y: start.y + regionY * tickValue
    };
  };
  Line2.prototype.getSideVector = function(offset3) {
    var axisVector = this.getAxisVector();
    var normal = normalize([0, 0], axisVector);
    var factor = this.get("verticalFactor");
    var verticalVector = [normal[1], normal[0] * -1];
    return scale$3([0, 0], verticalVector, offset3 * factor);
  };
  Line2.prototype.getAxisVector = function() {
    var start = this.get("start");
    var end = this.get("end");
    return [end.x - start.x, end.y - start.y];
  };
  Line2.prototype.processOverlap = function(labelGroup) {
    var _this = this;
    var isVertical2 = this.isVertical();
    var isHorizontal2 = this.isHorizontal();
    if (!isVertical2 && !isHorizontal2) {
      return;
    }
    var labelCfg = this.get("label");
    var titleCfg = this.get("title");
    var verticalLimitLength = this.get("verticalLimitLength");
    var labelOffset = labelCfg.offset;
    var limitLength = verticalLimitLength;
    var titleHeight = 0;
    var titleSpacing = 0;
    if (titleCfg) {
      titleHeight = titleCfg.style.fontSize;
      titleSpacing = titleCfg.spacing;
    }
    if (limitLength) {
      limitLength = limitLength - labelOffset - titleSpacing - titleHeight;
    }
    var overlapOrder = this.get("overlapOrder");
    each$1(overlapOrder, function(name) {
      if (labelCfg[name] && _this.canProcessOverlap(name)) {
        _this.autoProcessOverlap(name, labelCfg[name], labelGroup, limitLength);
      }
    });
    if (titleCfg) {
      if (isNil(titleCfg.offset)) {
        var bbox = labelGroup.getCanvasBBox();
        var length_1 = isVertical2 ? bbox.width : bbox.height;
        titleCfg.offset = labelOffset + length_1 + titleSpacing + titleHeight / 2;
      }
    }
  };
  Line2.prototype.canProcessOverlap = function(name) {
    var labelCfg = this.get("label");
    if (name === "autoRotate") {
      return isNil(labelCfg.rotate);
    }
    return true;
  };
  Line2.prototype.autoProcessOverlap = function(name, value2, labelGroup, limitLength) {
    var _this = this;
    var isVertical2 = this.isVertical();
    var hasAdjusted = false;
    var util = OverlapUtil[name];
    if (value2 === true) {
      this.get("label");
      hasAdjusted = util.getDefault()(isVertical2, labelGroup, limitLength);
    } else if (isFunction(value2)) {
      hasAdjusted = value2(isVertical2, labelGroup, limitLength);
    } else if (isObject(value2)) {
      var overlapCfg = value2;
      if (util[overlapCfg.type]) {
        hasAdjusted = util[overlapCfg.type](isVertical2, labelGroup, limitLength, overlapCfg.cfg);
      }
    } else if (util[value2]) {
      hasAdjusted = util[value2](isVertical2, labelGroup, limitLength);
    }
    if (name === "autoRotate") {
      if (hasAdjusted) {
        var labels = labelGroup.getChildren();
        var verticalFactor_1 = this.get("verticalFactor");
        each$1(labels, function(label2) {
          var textAlign = label2.attr("textAlign");
          if (textAlign === "center") {
            var newAlign = verticalFactor_1 > 0 ? "end" : "start";
            label2.attr("textAlign", newAlign);
          }
        });
      }
    } else if (name === "autoHide") {
      var children = labelGroup.getChildren().slice(0);
      each$1(children, function(label2) {
        if (!label2.get("visible")) {
          if (_this.get("isRegister")) {
            _this.unregisterElement(label2);
          }
          label2.remove();
        }
      });
    }
  };
  return Line2;
}(AxisBase);
var Circle$6 = function(_super) {
  __extends$3(Circle2, _super);
  function Circle2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Circle2.prototype.getDefaultCfg = function() {
    var cfg = _super.prototype.getDefaultCfg.call(this);
    return __assign$4(__assign$4({}, cfg), { type: "circle", locationType: "circle", center: null, radius: null, startAngle: -Math.PI / 2, endAngle: Math.PI * 3 / 2 });
  };
  Circle2.prototype.getLinePath = function() {
    var center2 = this.get("center");
    var x2 = center2.x;
    var y2 = center2.y;
    var rx = this.get("radius");
    var ry = rx;
    var startAngle = this.get("startAngle");
    var endAngle = this.get("endAngle");
    var path2 = [];
    if (Math.abs(endAngle - startAngle) === Math.PI * 2) {
      path2 = [["M", x2, y2 - ry], ["A", rx, ry, 0, 1, 1, x2, y2 + ry], ["A", rx, ry, 0, 1, 1, x2, y2 - ry], ["Z"]];
    } else {
      var startPoint = this.getCirclePoint(startAngle);
      var endPoint = this.getCirclePoint(endAngle);
      var large = Math.abs(endAngle - startAngle) > Math.PI ? 1 : 0;
      var sweep = startAngle > endAngle ? 0 : 1;
      path2 = [
        ["M", x2, y2],
        ["L", startPoint.x, startPoint.y],
        ["A", rx, ry, 0, large, sweep, endPoint.x, endPoint.y],
        ["L", x2, y2]
      ];
    }
    return path2;
  };
  Circle2.prototype.getTickPoint = function(tickValue) {
    var startAngle = this.get("startAngle");
    var endAngle = this.get("endAngle");
    var angle2 = startAngle + (endAngle - startAngle) * tickValue;
    return this.getCirclePoint(angle2);
  };
  Circle2.prototype.getSideVector = function(offset3, point2) {
    var center2 = this.get("center");
    var vector = [point2.x - center2.x, point2.y - center2.y];
    var factor = this.get("verticalFactor");
    var vecLen = length(vector);
    scale$3(vector, vector, factor * offset3 / vecLen);
    return vector;
  };
  Circle2.prototype.getAxisVector = function(point2) {
    var center2 = this.get("center");
    var vector = [point2.x - center2.x, point2.y - center2.y];
    return [vector[1], -1 * vector[0]];
  };
  Circle2.prototype.getCirclePoint = function(angle2, radius) {
    var center2 = this.get("center");
    radius = radius || this.get("radius");
    return {
      x: center2.x + Math.cos(angle2) * radius,
      y: center2.y + Math.sin(angle2) * radius
    };
  };
  Circle2.prototype.canProcessOverlap = function(name) {
    var labelCfg = this.get("label");
    if (name === "autoRotate") {
      return isNil(labelCfg.rotate);
    }
    return true;
  };
  Circle2.prototype.processOverlap = function(labelGroup) {
    var _this = this;
    var labelCfg = this.get("label");
    var titleCfg = this.get("title");
    var verticalLimitLength = this.get("verticalLimitLength");
    var labelOffset = labelCfg.offset;
    var limitLength = verticalLimitLength;
    var titleHeight = 0;
    var titleSpacing = 0;
    if (titleCfg) {
      titleHeight = titleCfg.style.fontSize;
      titleSpacing = titleCfg.spacing;
    }
    if (limitLength) {
      limitLength = limitLength - labelOffset - titleSpacing - titleHeight;
    }
    var overlapOrder = this.get("overlapOrder");
    each$1(overlapOrder, function(name) {
      if (labelCfg[name] && _this.canProcessOverlap(name)) {
        _this.autoProcessOverlap(name, labelCfg[name], labelGroup, limitLength);
      }
    });
    if (titleCfg) {
      if (isNil(titleCfg.offset)) {
        var length_1 = labelGroup.getCanvasBBox().height;
        titleCfg.offset = labelOffset + length_1 + titleSpacing + titleHeight / 2;
      }
    }
  };
  Circle2.prototype.autoProcessOverlap = function(name, value2, labelGroup, limitLength) {
    var _this = this;
    var hasAdjusted = false;
    var util = OverlapUtil[name];
    if (limitLength > 0) {
      if (value2 === true) {
        hasAdjusted = util.getDefault()(false, labelGroup, limitLength);
      } else if (isFunction(value2)) {
        hasAdjusted = value2(false, labelGroup, limitLength);
      } else if (isObject(value2)) {
        var overlapCfg = value2;
        if (util[overlapCfg.type]) {
          hasAdjusted = util[overlapCfg.type](false, labelGroup, limitLength, overlapCfg.cfg);
        }
      } else if (util[value2]) {
        hasAdjusted = util[value2](false, labelGroup, limitLength);
      }
    }
    if (name === "autoRotate") {
      if (hasAdjusted) {
        var labels = labelGroup.getChildren();
        var verticalFactor_1 = this.get("verticalFactor");
        each$1(labels, function(label2) {
          var textAlign = label2.attr("textAlign");
          if (textAlign === "center") {
            var newAlign = verticalFactor_1 > 0 ? "end" : "start";
            label2.attr("textAlign", newAlign);
          }
        });
      }
    } else if (name === "autoHide") {
      var children = labelGroup.getChildren().slice(0);
      each$1(children, function(label2) {
        if (!label2.get("visible")) {
          if (_this.get("isRegister")) {
            _this.unregisterElement(label2);
          }
          label2.remove();
        }
      });
    }
  };
  return Circle2;
}(AxisBase);
var CrosshairBase = function(_super) {
  __extends$3(CrosshairBase2, _super);
  function CrosshairBase2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  CrosshairBase2.prototype.getDefaultCfg = function() {
    var cfg = _super.prototype.getDefaultCfg.call(this);
    return __assign$4(__assign$4({}, cfg), { name: "crosshair", type: "base", line: {}, text: null, textBackground: {}, capture: false, defaultCfg: {
      line: {
        style: {
          lineWidth: 1,
          stroke: Theme.lineColor
        }
      },
      text: {
        position: "start",
        offset: 10,
        autoRotate: false,
        content: null,
        style: {
          fill: Theme.textColor,
          textAlign: "center",
          textBaseline: "middle",
          fontFamily: Theme.fontFamily
        }
      },
      textBackground: {
        padding: 5,
        style: {
          stroke: Theme.lineColor
        }
      }
    } });
  };
  CrosshairBase2.prototype.renderInner = function(group2) {
    if (this.get("line")) {
      this.renderLine(group2);
    }
    if (this.get("text")) {
      this.renderText(group2);
      this.renderBackground(group2);
    }
  };
  CrosshairBase2.prototype.renderText = function(group2) {
    var text2 = this.get("text");
    var style2 = text2.style, autoRotate2 = text2.autoRotate, content = text2.content;
    if (!isNil(content)) {
      var textPoint = this.getTextPoint();
      var matrix = null;
      if (autoRotate2) {
        var angle2 = this.getRotateAngle();
        matrix = getMatrixByAngle(textPoint, angle2);
      }
      this.addShape(group2, {
        type: "text",
        name: "crosshair-text",
        id: this.getElementId("text"),
        attrs: __assign$4(__assign$4(__assign$4({}, textPoint), { text: content, matrix }), style2)
      });
    }
  };
  CrosshairBase2.prototype.renderLine = function(group2) {
    var path2 = this.getLinePath();
    var line2 = this.get("line");
    var style2 = line2.style;
    this.addShape(group2, {
      type: "path",
      name: "crosshair-line",
      id: this.getElementId("line"),
      attrs: __assign$4({ path: path2 }, style2)
    });
  };
  CrosshairBase2.prototype.renderBackground = function(group2) {
    var textId = this.getElementId("text");
    var textShape = group2.findById(textId);
    var textBackground = this.get("textBackground");
    if (textBackground && textShape) {
      var textBBox = textShape.getBBox();
      var padding2 = formatPadding(textBackground.padding);
      var style2 = textBackground.style;
      var backgroundShape = this.addShape(group2, {
        type: "rect",
        name: "crosshair-text-background",
        id: this.getElementId("text-background"),
        attrs: __assign$4({ x: textBBox.x - padding2[3], y: textBBox.y - padding2[0], width: textBBox.width + padding2[1] + padding2[3], height: textBBox.height + padding2[0] + padding2[2], matrix: textShape.attr("matrix") }, style2)
      });
      backgroundShape.toBack();
    }
  };
  return CrosshairBase2;
}(GroupComponent);
var LineCrosshair$1 = function(_super) {
  __extends$3(LineCrosshair2, _super);
  function LineCrosshair2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  LineCrosshair2.prototype.getDefaultCfg = function() {
    var cfg = _super.prototype.getDefaultCfg.call(this);
    return __assign$4(__assign$4({}, cfg), { type: "line", locationType: "region", start: null, end: null });
  };
  LineCrosshair2.prototype.getRotateAngle = function() {
    var _a2 = this.getLocation(), start = _a2.start, end = _a2.end;
    var position = this.get("text").position;
    var angle2 = Math.atan2(end.y - start.y, end.x - start.x);
    var tangentAngle = position === "start" ? angle2 - Math.PI / 2 : angle2 + Math.PI / 2;
    return tangentAngle;
  };
  LineCrosshair2.prototype.getTextPoint = function() {
    var _a2 = this.getLocation(), start = _a2.start, end = _a2.end;
    var _b = this.get("text"), position = _b.position, offset3 = _b.offset;
    return getTextPoint(start, end, position, offset3);
  };
  LineCrosshair2.prototype.getLinePath = function() {
    var _a2 = this.getLocation(), start = _a2.start, end = _a2.end;
    return [
      ["M", start.x, start.y],
      ["L", end.x, end.y]
    ];
  };
  return LineCrosshair2;
}(CrosshairBase);
var LineCrosshair = function(_super) {
  __extends$3(LineCrosshair2, _super);
  function LineCrosshair2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  LineCrosshair2.prototype.getDefaultCfg = function() {
    var cfg = _super.prototype.getDefaultCfg.call(this);
    return __assign$4(__assign$4({}, cfg), { type: "circle", locationType: "circle", center: null, radius: 100, startAngle: -Math.PI / 2, endAngle: Math.PI * 3 / 2 });
  };
  LineCrosshair2.prototype.getRotateAngle = function() {
    var _a2 = this.getLocation(), startAngle = _a2.startAngle, endAngle = _a2.endAngle;
    var position = this.get("text").position;
    var tangentAngle = position === "start" ? startAngle + Math.PI / 2 : endAngle - Math.PI / 2;
    return tangentAngle;
  };
  LineCrosshair2.prototype.getTextPoint = function() {
    var text2 = this.get("text");
    var position = text2.position, offset3 = text2.offset;
    var _a2 = this.getLocation(), center2 = _a2.center, radius = _a2.radius, startAngle = _a2.startAngle, endAngle = _a2.endAngle;
    var angle2 = position === "start" ? startAngle : endAngle;
    var tangentAngle = this.getRotateAngle() - Math.PI;
    var point2 = getCirclePoint(center2, radius, angle2);
    var offsetX = Math.cos(tangentAngle) * offset3;
    var offsetY = Math.sin(tangentAngle) * offset3;
    return {
      x: point2.x + offsetX,
      y: point2.y + offsetY
    };
  };
  LineCrosshair2.prototype.getLinePath = function() {
    var _a2 = this.getLocation(), center2 = _a2.center, radius = _a2.radius, startAngle = _a2.startAngle, endAngle = _a2.endAngle;
    var path2 = null;
    if (endAngle - startAngle === Math.PI * 2) {
      var x2 = center2.x, y2 = center2.y;
      path2 = [
        ["M", x2, y2 - radius],
        ["A", radius, radius, 0, 1, 1, x2, y2 + radius],
        ["A", radius, radius, 0, 1, 1, x2, y2 - radius],
        ["Z"]
      ];
    } else {
      var startPoint = getCirclePoint(center2, radius, startAngle);
      var endPoint = getCirclePoint(center2, radius, endAngle);
      var large = Math.abs(endAngle - startAngle) > Math.PI ? 1 : 0;
      var sweep = startAngle > endAngle ? 0 : 1;
      path2 = [
        ["M", startPoint.x, startPoint.y],
        ["A", radius, radius, 0, large, sweep, endPoint.x, endPoint.y]
      ];
    }
    return path2;
  };
  return LineCrosshair2;
}(CrosshairBase);
var CONTAINER_CLASS$1 = "g2-crosshair";
var CROSSHAIR_LINE = CONTAINER_CLASS$1 + "-line";
var CROSSHAIR_TEXT = CONTAINER_CLASS$1 + "-text";
var _a$4;
var HtmlTheme = (_a$4 = {}, _a$4["" + CONTAINER_CLASS$1] = {
  position: "relative"
}, _a$4["" + CROSSHAIR_LINE] = {
  position: "absolute",
  backgroundColor: "rgba(0, 0, 0, 0.25)"
}, _a$4["" + CROSSHAIR_TEXT] = {
  position: "absolute",
  color: Theme.textColor,
  fontFamily: Theme.fontFamily
}, _a$4);
var HtmlCrosshair = function(_super) {
  __extends$3(HtmlCrosshair2, _super);
  function HtmlCrosshair2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  HtmlCrosshair2.prototype.getDefaultCfg = function() {
    var cfg = _super.prototype.getDefaultCfg.call(this);
    return __assign$4(__assign$4({}, cfg), { name: "crosshair", type: "html", locationType: "region", start: { x: 0, y: 0 }, end: { x: 0, y: 0 }, capture: false, text: null, containerTpl: '<div class="' + CONTAINER_CLASS$1 + '"></div>', crosshairTpl: '<div class="' + CROSSHAIR_LINE + '"></div>', textTpl: '<span class="' + CROSSHAIR_TEXT + '">{content}</span>', domStyles: null, containerClassName: CONTAINER_CLASS$1, defaultStyles: HtmlTheme, defaultCfg: {
      text: {
        position: "start",
        content: null,
        align: "center",
        offset: 10
      }
    } });
  };
  HtmlCrosshair2.prototype.render = function() {
    this.resetText();
    this.resetPosition();
  };
  HtmlCrosshair2.prototype.initCrossHair = function() {
    var container = this.getContainer();
    var crosshairTpl = this.get("crosshairTpl");
    var crosshairEl = createDom$1(crosshairTpl);
    container.appendChild(crosshairEl);
    this.applyStyle(CROSSHAIR_LINE, crosshairEl);
    this.set("crosshairEl", crosshairEl);
  };
  HtmlCrosshair2.prototype.getTextPoint = function() {
    var _a2 = this.getLocation(), start = _a2.start, end = _a2.end;
    var _b = this.get("text"), position = _b.position, offset3 = _b.offset;
    return getTextPoint(start, end, position, offset3);
  };
  HtmlCrosshair2.prototype.resetText = function() {
    var text2 = this.get("text");
    var textEl = this.get("textEl");
    if (text2) {
      var content = text2.content;
      if (!textEl) {
        var container = this.getContainer();
        var textTpl = substitute(this.get("textTpl"), text2);
        textEl = createDom$1(textTpl);
        container.appendChild(textEl);
        this.applyStyle(CROSSHAIR_TEXT, textEl);
        this.set("textEl", textEl);
      }
      textEl.innerHTML = content;
    } else if (textEl) {
      textEl.remove();
    }
  };
  HtmlCrosshair2.prototype.isVertical = function(start, end) {
    return start.x === end.x;
  };
  HtmlCrosshair2.prototype.resetPosition = function() {
    var crosshairEl = this.get("crosshairEl");
    if (!crosshairEl) {
      this.initCrossHair();
      crosshairEl = this.get("crosshairEl");
    }
    var start = this.get("start");
    var end = this.get("end");
    var minX = Math.min(start.x, end.x);
    var minY = Math.min(start.y, end.y);
    if (this.isVertical(start, end)) {
      modifyCSS(crosshairEl, {
        width: "1px",
        height: toPx(Math.abs(end.y - start.y))
      });
    } else {
      modifyCSS(crosshairEl, {
        height: "1px",
        width: toPx(Math.abs(end.x - start.x))
      });
    }
    modifyCSS(crosshairEl, {
      top: toPx(minY),
      left: toPx(minX)
    });
    this.alignText();
  };
  HtmlCrosshair2.prototype.alignText = function() {
    var textEl = this.get("textEl");
    if (textEl) {
      var align = this.get("text").align;
      var clientWidth = textEl.clientWidth;
      var point2 = this.getTextPoint();
      switch (align) {
        case "center":
          point2.x = point2.x - clientWidth / 2;
          break;
        case "right":
          point2.x = point2.x - clientWidth;
      }
      modifyCSS(textEl, {
        top: toPx(point2.y),
        left: toPx(point2.x)
      });
    }
  };
  HtmlCrosshair2.prototype.updateInner = function(cfg) {
    if (has(cfg, "text")) {
      this.resetText();
    }
    _super.prototype.updateInner.call(this, cfg);
  };
  return HtmlCrosshair2;
}(HtmlComponent);
var Crosshair = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Line: LineCrosshair$1,
  Circle: LineCrosshair,
  Base: CrosshairBase,
  Html: HtmlCrosshair
}, Symbol.toStringTag, { value: "Module" }));
var GridBase = function(_super) {
  __extends$3(GridBase2, _super);
  function GridBase2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  GridBase2.prototype.getDefaultCfg = function() {
    var cfg = _super.prototype.getDefaultCfg.call(this);
    return __assign$4(__assign$4({}, cfg), { name: "grid", line: {}, alternateColor: null, capture: false, items: [], closed: false, defaultCfg: {
      line: {
        type: "line",
        style: {
          lineWidth: 1,
          stroke: Theme.lineColor
        }
      }
    } });
  };
  GridBase2.prototype.getLineType = function() {
    var line2 = this.get("line") || this.get("defaultCfg").line;
    return line2.type;
  };
  GridBase2.prototype.renderInner = function(group2) {
    this.drawGrid(group2);
  };
  GridBase2.prototype.getAlternatePath = function(prePoints, points2) {
    var regionPath = this.getGridPath(prePoints);
    var reversePoints = points2.slice(0).reverse();
    var nextPath = this.getGridPath(reversePoints, true);
    var closed = this.get("closed");
    if (closed) {
      regionPath = regionPath.concat(nextPath);
    } else {
      nextPath[0][0] = "L";
      regionPath = regionPath.concat(nextPath);
      regionPath.push(["Z"]);
    }
    return regionPath;
  };
  GridBase2.prototype.getPathStyle = function() {
    return this.get("line").style;
  };
  GridBase2.prototype.drawGrid = function(group2) {
    var _this = this;
    var line2 = this.get("line");
    var items = this.get("items");
    var alternateColor = this.get("alternateColor");
    var preItem = null;
    each$1(items, function(item, index2) {
      var id2 = item.id || index2;
      if (line2) {
        var style2 = _this.getPathStyle();
        style2 = isFunction(style2) ? style2(item, index2, items) : style2;
        var lineId = _this.getElementId("line-" + id2);
        var gridPath = _this.getGridPath(item.points);
        _this.addShape(group2, {
          type: "path",
          name: "grid-line",
          id: lineId,
          attrs: mix({
            path: gridPath
          }, style2)
        });
      }
      if (alternateColor && index2 > 0) {
        var regionId = _this.getElementId("region-" + id2);
        var isEven = index2 % 2 === 0;
        if (isString(alternateColor)) {
          if (isEven) {
            _this.drawAlternateRegion(regionId, group2, preItem.points, item.points, alternateColor);
          }
        } else {
          var color2 = isEven ? alternateColor[1] : alternateColor[0];
          _this.drawAlternateRegion(regionId, group2, preItem.points, item.points, color2);
        }
      }
      preItem = item;
    });
  };
  GridBase2.prototype.drawAlternateRegion = function(id2, group2, prePoints, points2, color2) {
    var regionPath = this.getAlternatePath(prePoints, points2);
    this.addShape(group2, {
      type: "path",
      id: id2,
      name: "grid-region",
      attrs: {
        path: regionPath,
        fill: color2
      }
    });
  };
  return GridBase2;
}(GroupComponent);
function distance$3(x1, y1, x2, y2) {
  var dx = x2 - x1;
  var dy = y2 - y1;
  return Math.sqrt(dx * dx + dy * dy);
}
var Circle$5 = function(_super) {
  __extends$3(Circle2, _super);
  function Circle2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Circle2.prototype.getDefaultCfg = function() {
    var cfg = _super.prototype.getDefaultCfg.call(this);
    return __assign$4(__assign$4({}, cfg), {
      type: "circle",
      center: null,
      closed: true
    });
  };
  Circle2.prototype.getGridPath = function(points2, reversed) {
    var lineType = this.getLineType();
    var closed = this.get("closed");
    var path2 = [];
    if (points2.length) {
      if (lineType === "circle") {
        var center2 = this.get("center");
        var firstPoint = points2[0];
        var radius_1 = distance$3(center2.x, center2.y, firstPoint.x, firstPoint.y);
        var sweepFlag_1 = reversed ? 0 : 1;
        if (closed) {
          path2.push(["M", center2.x, center2.y - radius_1]);
          path2.push(["A", radius_1, radius_1, 0, 0, sweepFlag_1, center2.x, center2.y + radius_1]);
          path2.push(["A", radius_1, radius_1, 0, 0, sweepFlag_1, center2.x, center2.y - radius_1]);
          path2.push(["Z"]);
        } else {
          each$1(points2, function(point2, index2) {
            if (index2 === 0) {
              path2.push(["M", point2.x, point2.y]);
            } else {
              path2.push(["A", radius_1, radius_1, 0, 0, sweepFlag_1, point2.x, point2.y]);
            }
          });
        }
      } else {
        each$1(points2, function(point2, index2) {
          if (index2 === 0) {
            path2.push(["M", point2.x, point2.y]);
          } else {
            path2.push(["L", point2.x, point2.y]);
          }
        });
        if (closed) {
          path2.push(["Z"]);
        }
      }
    }
    return path2;
  };
  return Circle2;
}(GridBase);
var Line$7 = function(_super) {
  __extends$3(Line2, _super);
  function Line2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Line2.prototype.getDefaultCfg = function() {
    var cfg = _super.prototype.getDefaultCfg.call(this);
    return __assign$4(__assign$4({}, cfg), { type: "line" });
  };
  Line2.prototype.getGridPath = function(points2) {
    var path2 = [];
    each$1(points2, function(point2, index2) {
      if (index2 === 0) {
        path2.push(["M", point2.x, point2.y]);
      } else {
        path2.push(["L", point2.x, point2.y]);
      }
    });
    return path2;
  };
  return Line2;
}(GridBase);
var LegendBase = function(_super) {
  __extends$3(LegendBase2, _super);
  function LegendBase2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  LegendBase2.prototype.getDefaultCfg = function() {
    var cfg = _super.prototype.getDefaultCfg.call(this);
    return __assign$4(__assign$4({}, cfg), {
      name: "legend",
      layout: "horizontal",
      locationType: "point",
      x: 0,
      y: 0,
      offsetX: 0,
      offsetY: 0,
      title: null,
      background: null
    });
  };
  LegendBase2.prototype.getLayoutBBox = function() {
    var bbox = _super.prototype.getLayoutBBox.call(this);
    var maxWidth = this.get("maxWidth");
    var maxHeight = this.get("maxHeight");
    var width = bbox.width, height = bbox.height;
    if (maxWidth) {
      width = Math.min(width, maxWidth);
    }
    if (maxHeight) {
      height = Math.min(height, maxHeight);
    }
    return createBBox(bbox.minX, bbox.minY, width, height);
  };
  LegendBase2.prototype.setLocation = function(cfg) {
    this.set("x", cfg.x);
    this.set("y", cfg.y);
    this.resetLocation();
  };
  LegendBase2.prototype.resetLocation = function() {
    var x2 = this.get("x");
    var y2 = this.get("y");
    var offsetX = this.get("offsetX");
    var offsetY = this.get("offsetY");
    this.moveElementTo(this.get("group"), {
      x: x2 + offsetX,
      y: y2 + offsetY
    });
  };
  LegendBase2.prototype.applyOffset = function() {
    this.resetLocation();
  };
  LegendBase2.prototype.getDrawPoint = function() {
    return this.get("currentPoint");
  };
  LegendBase2.prototype.setDrawPoint = function(point2) {
    return this.set("currentPoint", point2);
  };
  LegendBase2.prototype.renderInner = function(group2) {
    this.resetDraw();
    if (this.get("title")) {
      this.drawTitle(group2);
    }
    this.drawLegendContent(group2);
    if (this.get("background")) {
      this.drawBackground(group2);
    }
  };
  LegendBase2.prototype.drawBackground = function(group2) {
    var background = this.get("background");
    var bbox = group2.getBBox();
    var padding2 = formatPadding(background.padding);
    var attrs = __assign$4({
      x: 0,
      y: 0,
      width: bbox.width + padding2[1] + padding2[3],
      height: bbox.height + padding2[0] + padding2[2]
    }, background.style);
    var backgroundShape = this.addShape(group2, {
      type: "rect",
      id: this.getElementId("background"),
      name: "legend-background",
      attrs
    });
    backgroundShape.toBack();
  };
  LegendBase2.prototype.drawTitle = function(group2) {
    var currentPoint = this.get("currentPoint");
    var titleCfg = this.get("title");
    var spacing = titleCfg.spacing, style2 = titleCfg.style, text2 = titleCfg.text;
    var shape = this.addShape(group2, {
      type: "text",
      id: this.getElementId("title"),
      name: "legend-title",
      attrs: __assign$4({ text: text2, x: currentPoint.x, y: currentPoint.y }, style2)
    });
    var bbox = shape.getBBox();
    this.set("currentPoint", { x: currentPoint.x, y: bbox.maxY + spacing });
  };
  LegendBase2.prototype.resetDraw = function() {
    var background = this.get("background");
    var currentPoint = { x: 0, y: 0 };
    if (background) {
      var padding2 = formatPadding(background.padding);
      currentPoint.x = padding2[3];
      currentPoint.y = padding2[0];
    }
    this.set("currentPoint", currentPoint);
  };
  return LegendBase2;
}(GroupComponent);
var DEFAULT_PAGE_NAVIGATOR = {
  marker: {
    style: {
      inactiveFill: "#000",
      inactiveOpacity: 0.45,
      fill: "#000",
      opacity: 1,
      size: 12
    }
  },
  text: {
    style: {
      fill: "#ccc",
      fontSize: 12
    }
  }
};
var textStyle = {
  fill: Theme.textColor,
  fontSize: 12,
  textAlign: "start",
  textBaseline: "middle",
  fontFamily: Theme.fontFamily,
  fontWeight: "normal",
  lineHeight: 12
};
var RIGHT_ARROW_NAME = "navigation-arrow-right";
var LEFT_ARROW_NAME = "navigation-arrow-left";
var ROTATE_MAP = {
  right: 90 * Math.PI / 180,
  left: (360 - 90) * Math.PI / 180,
  up: 0,
  down: 180 * Math.PI / 180
};
var Category = function(_super) {
  __extends$3(Category2, _super);
  function Category2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.currentPageIndex = 1;
    _this.totalPagesCnt = 1;
    _this.pageWidth = 0;
    _this.pageHeight = 0;
    _this.startX = 0;
    _this.startY = 0;
    _this.onNavigationBack = function() {
      var itemGroup = _this.getElementByLocalId("item-group");
      if (_this.currentPageIndex > 1) {
        _this.currentPageIndex -= 1;
        _this.updateNavigation();
        var matrix = _this.getCurrentNavigationMatrix();
        if (_this.get("animate")) {
          itemGroup.animate({
            matrix
          }, 100);
        } else {
          itemGroup.attr({ matrix });
        }
      }
    };
    _this.onNavigationAfter = function() {
      var itemGroup = _this.getElementByLocalId("item-group");
      if (_this.currentPageIndex < _this.totalPagesCnt) {
        _this.currentPageIndex += 1;
        _this.updateNavigation();
        var matrix = _this.getCurrentNavigationMatrix();
        if (_this.get("animate")) {
          itemGroup.animate({
            matrix
          }, 100);
        } else {
          itemGroup.attr({ matrix });
        }
      }
    };
    return _this;
  }
  Category2.prototype.getDefaultCfg = function() {
    var cfg = _super.prototype.getDefaultCfg.call(this);
    return __assign$4(__assign$4({}, cfg), { name: "legend", type: "category", itemSpacing: 24, itemMarginBottom: 8, maxItemWidth: null, itemWidth: null, itemHeight: null, itemName: {}, itemValue: null, maxWidth: null, maxHeight: null, marker: {}, radio: null, items: [], itemStates: {}, itemBackground: {}, pageNavigator: {}, defaultCfg: {
      title: {
        spacing: 5,
        style: {
          fill: Theme.textColor,
          fontSize: 12,
          textAlign: "start",
          textBaseline: "top"
        }
      },
      background: {
        padding: 5,
        style: {
          stroke: Theme.lineColor
        }
      },
      itemBackground: {
        style: {
          opacity: 0,
          fill: "#fff"
        }
      },
      pageNavigator: DEFAULT_PAGE_NAVIGATOR,
      itemName: {
        spacing: 16,
        style: textStyle
      },
      marker: {
        spacing: 8,
        style: {
          r: 6,
          symbol: "circle"
        }
      },
      itemValue: {
        alignRight: false,
        formatter: null,
        style: textStyle,
        spacing: 6
      },
      itemStates: {
        active: {
          nameStyle: {
            opacity: 0.8
          }
        },
        unchecked: {
          nameStyle: {
            fill: Theme.uncheckedColor
          },
          markerStyle: {
            fill: Theme.uncheckedColor,
            stroke: Theme.uncheckedColor
          }
        },
        inactive: {
          nameStyle: {
            fill: Theme.uncheckedColor
          },
          markerStyle: {
            opacity: 0.2
          }
        }
      }
    } });
  };
  Category2.prototype.isList = function() {
    return true;
  };
  Category2.prototype.getItems = function() {
    return this.get("items");
  };
  Category2.prototype.setItems = function(items) {
    this.update({
      items
    });
  };
  Category2.prototype.updateItem = function(item, cfg) {
    mix(item, cfg);
    this.clear();
    this.render();
  };
  Category2.prototype.clearItems = function() {
    var itemGroup = this.getElementByLocalId("item-group");
    itemGroup && itemGroup.clear();
  };
  Category2.prototype.setItemState = function(item, state2, value2) {
    item[state2] = value2;
    var itemElement = this.getElementByLocalId("item-" + item.id);
    if (itemElement) {
      var items = this.getItems();
      var index2 = items.indexOf(item);
      var offsetGroup = this.createOffScreenGroup();
      var newElement = this.drawItem(item, index2, this.getItemHeight(), offsetGroup);
      this.updateElements(newElement, itemElement);
      this.clearUpdateStatus(itemElement);
    }
  };
  Category2.prototype.hasState = function(item, state2) {
    return !!item[state2];
  };
  Category2.prototype.getItemStates = function(item) {
    var itemStates = this.get("itemStates");
    var rst = [];
    each$1(itemStates, function(v2, k2) {
      if (item[k2]) {
        rst.push(k2);
      }
    });
    return rst;
  };
  Category2.prototype.clearItemsState = function(state2) {
    var _this = this;
    var items = this.getItemsByState(state2);
    each$1(items, function(item) {
      _this.setItemState(item, state2, false);
    });
  };
  Category2.prototype.getItemsByState = function(state2) {
    var _this = this;
    var items = this.getItems();
    return filter(items, function(item) {
      return _this.hasState(item, state2);
    });
  };
  Category2.prototype.drawLegendContent = function(group2) {
    this.processItems();
    this.drawItems(group2);
  };
  Category2.prototype.processItems = function() {
    var items = this.get("items");
    each$1(items, function(item) {
      if (!item.id) {
        item.id = item.name;
      }
    });
  };
  Category2.prototype.drawItems = function(group2) {
    var _this = this;
    var itemContainerGroup = this.addGroup(group2, {
      id: this.getElementId("item-container-group"),
      name: "legend-item-container-group"
    });
    var itemGroup = this.addGroup(itemContainerGroup, {
      id: this.getElementId("item-group"),
      name: "legend-item-group"
    });
    var itemHeight = this.getItemHeight();
    var itemWidth = this.get("itemWidth");
    var itemSpacing = this.get("itemSpacing");
    var itemMarginBottom = this.get("itemMarginBottom");
    var currentPoint = this.get("currentPoint");
    var startX = currentPoint.x;
    var startY = currentPoint.y;
    var layout2 = this.get("layout");
    var items = this.get("items");
    var wrapped = false;
    var pageWidth = 0;
    var maxWidth = this.get("maxWidth");
    var maxHeight = this.get("maxHeight");
    each$1(items, function(item, index2) {
      var subGroup = _this.drawItem(item, index2, itemHeight, itemGroup);
      var bbox = subGroup.getBBox();
      var width = itemWidth || bbox.width;
      if (width > pageWidth) {
        pageWidth = width;
      }
      if (layout2 === "horizontal") {
        if (maxWidth && maxWidth < currentPoint.x + width - startX) {
          wrapped = true;
          currentPoint.x = startX;
          currentPoint.y += itemHeight + itemMarginBottom;
        }
        _this.moveElementTo(subGroup, currentPoint);
        currentPoint.x += width + itemSpacing;
      } else {
        if (maxHeight && maxHeight < currentPoint.y + itemHeight + itemMarginBottom - startY) {
          wrapped = true;
          currentPoint.x += pageWidth + itemSpacing;
          currentPoint.y = startY;
          pageWidth = 0;
        }
        _this.moveElementTo(subGroup, currentPoint);
        currentPoint.y += itemHeight + itemMarginBottom;
      }
    });
    if (wrapped && this.get("flipPage")) {
      this.pageHeight = 0;
      this.pageWidth = 0;
      this.totalPagesCnt = 1;
      this.startX = startX;
      this.startY = startY;
      this.adjustNavigation(group2, itemGroup);
    }
  };
  Category2.prototype.getItemHeight = function() {
    var itemHeight = this.get("itemHeight");
    if (!itemHeight) {
      var style_1 = (this.get("itemName") || {}).style;
      if (isFunction(style_1)) {
        var items_1 = this.getItems();
        items_1.forEach(function(item, index2) {
          var fontSize = __assign$4(__assign$4({}, textStyle), style_1(item, index2, items_1)).fontSize;
          if (itemHeight < fontSize) {
            itemHeight = fontSize;
          }
        });
      } else if (style_1) {
        itemHeight = style_1.fontSize;
      }
    }
    return itemHeight;
  };
  Category2.prototype.drawMarker = function(container, markerCfg, item, itemHeight) {
    var markerAttrs = __assign$4(__assign$4(__assign$4({ x: 0, y: itemHeight / 2 }, markerCfg.style), { symbol: get(item.marker, "symbol", "circle") }), get(item.marker, "style", {}));
    var shape = this.addShape(container, {
      type: "marker",
      id: this.getElementId("item-" + item.id + "-marker"),
      name: "legend-item-marker",
      attrs: markerAttrs
    });
    var bbox = shape.getBBox();
    shape.attr("x", bbox.width / 2);
    var _a2 = shape.attr(), stroke = _a2.stroke, fill = _a2.fill;
    if (stroke) {
      shape.set("isStroke", true);
    }
    if (fill) {
      shape.set("isFill", true);
    }
    return shape;
  };
  Category2.prototype.drawItemText = function(container, textName, cfg, item, itemHeight, xPosition, index2) {
    var formatter = cfg.formatter;
    var style2 = cfg.style;
    var attrs = __assign$4(__assign$4({ x: xPosition, y: itemHeight / 2, text: formatter ? formatter(item[textName], item, index2) : item[textName] }, textStyle), isFunction(style2) ? style2(item, index2, this.getItems()) : style2);
    return this.addShape(container, {
      type: "text",
      id: this.getElementId("item-" + item.id + "-" + textName),
      name: "legend-item-" + textName,
      attrs
    });
  };
  Category2.prototype.drawRadio = function(container, radioCfg, item, itemHeight, x2) {
    var _a2, _b;
    var style2 = radioCfg.style || {};
    var r2 = (_a2 = style2.r) !== null && _a2 !== void 0 ? _a2 : itemHeight / 2;
    var lineWidth = r2 * 3.6 / 8;
    var _c = [x2 + r2, itemHeight / 2 - r2], x0 = _c[0], y0 = _c[1];
    var _d = [x0 + r2, y0 + r2], x1 = _d[0], y1 = _d[1];
    var _e = [x0, y1 + r2], x22 = _e[0], y2 = _e[1];
    var _f = [x2, y0 + r2], x3 = _f[0], y3 = _f[1];
    var showRadio = item.showRadio;
    var attrs = __assign$4(__assign$4({ path: [
      ["M", x0, y0],
      ["A", r2, r2, 0, 0, 1, x1, y1],
      ["L", x1 - lineWidth, y1],
      ["L", x1, y1],
      ["A", r2, r2, 0, 0, 1, x22, y2],
      ["L", x22, y2 - lineWidth],
      ["L", x22, y2],
      ["A", r2, r2, 0, 0, 1, x3, y3],
      ["L", x3 + lineWidth, y3],
      ["L", x3, y3],
      ["A", r2, r2, 0, 0, 1, x0, y0],
      ["L", x0, y0 + lineWidth]
    ], stroke: "#000000", fill: "#ffffff" }, style2), { opacity: showRadio ? (_b = style2 === null || style2 === void 0 ? void 0 : style2.opacity) !== null && _b !== void 0 ? _b : 0.45 : 0 });
    var radioShape = this.addShape(container, {
      type: "path",
      id: this.getElementId("item-" + item.id + "-radio"),
      name: "legend-item-radio",
      attrs
    });
    radioShape.set("tip", radioCfg.tip);
    return radioShape;
  };
  Category2.prototype.drawItem = function(item, index2, itemHeight, itemGroup) {
    var groupId = "item-" + item.id;
    var subContainer = this.addGroup(itemGroup, {
      name: "legend-item-container",
      id: this.getElementId("item-container-" + groupId),
      delegateObject: {
        item,
        index: index2
      }
    });
    var subGroup = this.addGroup(subContainer, {
      name: "legend-item",
      id: this.getElementId(groupId),
      delegateObject: {
        item,
        index: index2
      }
    });
    var marker = this.get("marker");
    var itemName = this.get("itemName");
    var itemValue = this.get("itemValue");
    var itemBackground = this.get("itemBackground");
    var radio = this.get("radio");
    var itemWidth = this.getLimitItemWidth();
    var curX = 0;
    if (marker) {
      var markerShape = this.drawMarker(subGroup, marker, item, itemHeight);
      var spacing = marker.spacing;
      var itemMarkerSpacing = get(item, ["marker", "spacing"]);
      if (isNumber$1(itemMarkerSpacing)) {
        spacing = itemMarkerSpacing;
      }
      curX = markerShape.getBBox().maxX + spacing;
    }
    if (itemName) {
      var nameShape = this.drawItemText(subGroup, "name", itemName, item, itemHeight, curX, index2);
      if (itemWidth) {
        ellipsisLabel(true, nameShape, clamp(itemWidth - curX, 0, itemWidth));
      }
      curX = nameShape.getBBox().maxX + itemName.spacing;
    }
    if (itemValue) {
      var valueShape = this.drawItemText(subGroup, "value", itemValue, item, itemHeight, curX, index2);
      if (itemWidth) {
        if (itemValue.alignRight) {
          valueShape.attr({
            textAlign: "right",
            x: itemWidth
          });
          ellipsisLabel(true, valueShape, clamp(itemWidth - curX, 0, itemWidth), "head");
        } else {
          ellipsisLabel(true, valueShape, clamp(itemWidth - curX, 0, itemWidth));
        }
      }
      curX = valueShape.getBBox().maxX + itemValue.spacing;
    }
    if (radio) {
      this.drawRadio(subGroup, radio, item, itemHeight, curX);
    }
    if (itemBackground) {
      var bbox = subGroup.getBBox();
      var backShape = this.addShape(subGroup, {
        type: "rect",
        name: "legend-item-background",
        id: this.getElementId(groupId + "-background"),
        attrs: __assign$4({ x: 0, y: 0, width: bbox.width, height: itemHeight }, itemBackground.style)
      });
      backShape.toBack();
    }
    this.applyItemStates(item, subGroup);
    return subGroup;
  };
  Category2.prototype.adjustNavigation = function(container, itemGroup) {
    var _this = this;
    var startX = this.startX;
    var startY = this.startY;
    var layout2 = this.get("layout");
    var subGroups = itemGroup.findAll(function(item) {
      return item.get("name") === "legend-item";
    });
    var maxWidth = this.get("maxWidth");
    var maxHeight = this.get("maxHeight");
    var itemWidth = this.get("itemWidth");
    var itemSpacing = this.get("itemSpacing");
    var itemHeight = this.getItemHeight();
    var pageNavigator = deepMix({}, DEFAULT_PAGE_NAVIGATOR, this.get("pageNavigator"));
    var navigation = this.drawNavigation(container, layout2, "00/00", pageNavigator);
    var navigationBBox = navigation.getBBox();
    var currentPoint = { x: startX, y: startY };
    var pages = 1;
    var widthLimit = 0;
    var pageWidth = 0;
    var maxItemWidth = 0;
    var itemMarginBottom = this.get("itemMarginBottom");
    if (layout2 === "horizontal") {
      var maxRow = this.get("maxRow") || 1;
      var maxRowHeight_1 = itemHeight + (maxRow === 1 ? 0 : itemMarginBottom);
      this.pageHeight = maxRowHeight_1 * maxRow;
      each$1(subGroups, function(item) {
        var bbox = item.getBBox();
        var width = itemWidth || bbox.width;
        if (widthLimit && widthLimit < currentPoint.x + width + itemSpacing || maxWidth < currentPoint.x + width + itemSpacing + navigationBBox.width) {
          if (pages === 1) {
            widthLimit = currentPoint.x + itemSpacing;
            _this.pageWidth = widthLimit;
            _this.moveElementTo(navigation, {
              x: maxWidth - itemSpacing - navigationBBox.width - navigationBBox.minX,
              y: currentPoint.y + itemHeight / 2 - navigationBBox.height / 2 - navigationBBox.minY
            });
          }
          pages += 1;
          currentPoint.x = startX;
          currentPoint.y += maxRowHeight_1;
        }
        _this.moveElementTo(item, currentPoint);
        item.getParent().setClip({
          type: "rect",
          attrs: {
            x: currentPoint.x,
            y: currentPoint.y,
            width: width + itemSpacing,
            height: itemHeight
          }
        });
        currentPoint.x += width + itemSpacing;
      });
    } else {
      each$1(subGroups, function(item) {
        var bbox = item.getBBox();
        if (bbox.width > pageWidth) {
          pageWidth = bbox.width;
        }
      });
      maxItemWidth = pageWidth;
      pageWidth += itemSpacing;
      if (maxWidth) {
        pageWidth = Math.min(maxWidth, pageWidth);
        maxItemWidth = Math.min(maxWidth, maxItemWidth);
      }
      this.pageWidth = pageWidth;
      this.pageHeight = maxHeight - Math.max(navigationBBox.height, itemHeight + itemMarginBottom);
      var cntPerPage_1 = Math.floor(this.pageHeight / (itemHeight + itemMarginBottom));
      each$1(subGroups, function(item, index2) {
        if (index2 !== 0 && index2 % cntPerPage_1 === 0) {
          pages += 1;
          currentPoint.x += pageWidth;
          currentPoint.y = startY;
        }
        _this.moveElementTo(item, currentPoint);
        item.getParent().setClip({
          type: "rect",
          attrs: {
            x: currentPoint.x,
            y: currentPoint.y,
            width: pageWidth,
            height: itemHeight
          }
        });
        currentPoint.y += itemHeight + itemMarginBottom;
      });
      this.totalPagesCnt = pages;
      this.moveElementTo(navigation, {
        x: startX + maxItemWidth / 2 - navigationBBox.width / 2 - navigationBBox.minX,
        y: maxHeight - navigationBBox.height - navigationBBox.minY
      });
    }
    if (this.pageHeight && this.pageWidth) {
      itemGroup.getParent().setClip({
        type: "rect",
        attrs: {
          x: this.startX,
          y: this.startY,
          width: this.pageWidth,
          height: this.pageHeight
        }
      });
    }
    if (layout2 === "horizontal" && this.get("maxRow")) {
      this.totalPagesCnt = Math.ceil(pages / this.get("maxRow"));
    } else {
      this.totalPagesCnt = pages;
    }
    if (this.currentPageIndex > this.totalPagesCnt) {
      this.currentPageIndex = 1;
    }
    this.updateNavigation(navigation);
    itemGroup.attr("matrix", this.getCurrentNavigationMatrix());
  };
  Category2.prototype.drawNavigation = function(group2, layout2, text2, styleCfg) {
    var currentPoint = { x: 0, y: 0 };
    var subGroup = this.addGroup(group2, {
      id: this.getElementId("navigation-group"),
      name: "legend-navigation"
    });
    var _a2 = get(styleCfg.marker, "style", {}), _b = _a2.size, size2 = _b === void 0 ? 12 : _b, arrowStyle = __rest$3(_a2, ["size"]);
    var leftArrow = this.drawArrow(subGroup, currentPoint, LEFT_ARROW_NAME, layout2 === "horizontal" ? "up" : "left", size2, arrowStyle);
    leftArrow.on("click", this.onNavigationBack);
    var leftArrowBBox = leftArrow.getBBox();
    currentPoint.x += leftArrowBBox.width + 2;
    var textShape = this.addShape(subGroup, {
      type: "text",
      id: this.getElementId("navigation-text"),
      name: "navigation-text",
      attrs: __assign$4({ x: currentPoint.x, y: currentPoint.y + size2 / 2, text: text2, textBaseline: "middle" }, get(styleCfg.text, "style"))
    });
    var textBBox = textShape.getBBox();
    currentPoint.x += textBBox.width + 2;
    var rightArrow = this.drawArrow(subGroup, currentPoint, RIGHT_ARROW_NAME, layout2 === "horizontal" ? "down" : "right", size2, arrowStyle);
    rightArrow.on("click", this.onNavigationAfter);
    return subGroup;
  };
  Category2.prototype.updateNavigation = function(navigation) {
    var pageNavigator = deepMix({}, DEFAULT_PAGE_NAVIGATOR, this.get("pageNavigator"));
    var _a2 = pageNavigator.marker.style, fill = _a2.fill, opacity = _a2.opacity, inactiveFill = _a2.inactiveFill, inactiveOpacity = _a2.inactiveOpacity;
    var text2 = this.currentPageIndex + "/" + this.totalPagesCnt;
    var textShape = navigation ? navigation.getChildren()[1] : this.getElementByLocalId("navigation-text");
    var leftArrow = navigation ? navigation.findById(this.getElementId(LEFT_ARROW_NAME)) : this.getElementByLocalId(LEFT_ARROW_NAME);
    var rightArrow = navigation ? navigation.findById(this.getElementId(RIGHT_ARROW_NAME)) : this.getElementByLocalId(RIGHT_ARROW_NAME);
    textShape.attr("text", text2);
    leftArrow.attr("opacity", this.currentPageIndex === 1 ? inactiveOpacity : opacity);
    leftArrow.attr("fill", this.currentPageIndex === 1 ? inactiveFill : fill);
    leftArrow.attr("cursor", this.currentPageIndex === 1 ? "not-allowed" : "pointer");
    rightArrow.attr("opacity", this.currentPageIndex === this.totalPagesCnt ? inactiveOpacity : opacity);
    rightArrow.attr("fill", this.currentPageIndex === this.totalPagesCnt ? inactiveFill : fill);
    rightArrow.attr("cursor", this.currentPageIndex === this.totalPagesCnt ? "not-allowed" : "pointer");
    var cursorX = leftArrow.getBBox().maxX + 2;
    textShape.attr("x", cursorX);
    cursorX += textShape.getBBox().width + 2;
    this.updateArrowPath(rightArrow, { x: cursorX, y: 0 });
  };
  Category2.prototype.drawArrow = function(group2, currentPoint, name, direction2, size2, style2) {
    var x2 = currentPoint.x, y2 = currentPoint.y;
    var shape = this.addShape(group2, {
      type: "path",
      id: this.getElementId(name),
      name,
      attrs: __assign$4({
        size: size2,
        direction: direction2,
        path: [["M", x2 + size2 / 2, y2], ["L", x2, y2 + size2], ["L", x2 + size2, y2 + size2], ["Z"]],
        cursor: "pointer"
      }, style2)
    });
    shape.attr("matrix", getMatrixByAngle({ x: x2 + size2 / 2, y: y2 + size2 / 2 }, ROTATE_MAP[direction2]));
    return shape;
  };
  Category2.prototype.updateArrowPath = function(arrow, point2) {
    var x2 = point2.x, y2 = point2.y;
    var _a2 = arrow.attr(), size2 = _a2.size, direction2 = _a2.direction;
    var matrix = getMatrixByAngle({ x: x2 + size2 / 2, y: y2 + size2 / 2 }, ROTATE_MAP[direction2]);
    arrow.attr("path", [["M", x2 + size2 / 2, y2], ["L", x2, y2 + size2], ["L", x2 + size2, y2 + size2], ["Z"]]);
    arrow.attr("matrix", matrix);
  };
  Category2.prototype.getCurrentNavigationMatrix = function() {
    var _a2 = this, currentPageIndex = _a2.currentPageIndex, pageWidth = _a2.pageWidth, pageHeight = _a2.pageHeight;
    var layout2 = this.get("layout");
    var translate2 = layout2 === "horizontal" ? {
      x: 0,
      y: pageHeight * (1 - currentPageIndex)
    } : {
      x: pageWidth * (1 - currentPageIndex),
      y: 0
    };
    return getMatrixByTranslate(translate2);
  };
  Category2.prototype.applyItemStates = function(item, subGroup) {
    var states = this.getItemStates(item);
    var hasStates = states.length > 0;
    if (hasStates) {
      var children = subGroup.getChildren();
      var itemStates_1 = this.get("itemStates");
      each$1(children, function(element) {
        var name = element.get("name");
        var elName = name.split("-")[2];
        var statesStyle = getStatesStyle(item, elName, itemStates_1);
        if (statesStyle) {
          element.attr(statesStyle);
          if (elName === "marker" && !(element.get("isStroke") && element.get("isFill"))) {
            if (element.get("isStroke")) {
              element.attr("fill", null);
            }
            if (element.get("isFill")) {
              element.attr("stroke", null);
            }
          }
        }
      });
    }
  };
  Category2.prototype.getLimitItemWidth = function() {
    var itemWidth = this.get("itemWidth");
    var maxItemWidth = this.get("maxItemWidth");
    if (maxItemWidth) {
      if (itemWidth) {
        maxItemWidth = itemWidth <= maxItemWidth ? itemWidth : maxItemWidth;
      }
    } else if (itemWidth) {
      maxItemWidth = itemWidth;
    }
    return maxItemWidth;
  };
  return Category2;
}(LegendBase);
var HANDLER_HEIGHT_RATIO = 1.4;
var HANDLER_TRIANGLE_RATIO = 0.4;
var ContinueLegend = function(_super) {
  __extends$3(ContinueLegend2, _super);
  function ContinueLegend2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  ContinueLegend2.prototype.getDefaultCfg = function() {
    var cfg = _super.prototype.getDefaultCfg.call(this);
    return __assign$4(__assign$4({}, cfg), { type: "continue", min: 0, max: 100, value: null, colors: [], track: {}, rail: {}, label: {}, handler: {}, slidable: true, tip: null, step: null, maxWidth: null, maxHeight: null, defaultCfg: {
      label: {
        align: "rail",
        spacing: 5,
        formatter: null,
        style: {
          fontSize: 12,
          fill: Theme.textColor,
          textBaseline: "middle",
          fontFamily: Theme.fontFamily
        }
      },
      handler: {
        size: 10,
        style: {
          fill: "#fff",
          stroke: "#333"
        }
      },
      track: {},
      rail: {
        type: "color",
        size: 20,
        defaultLength: 100,
        style: {
          fill: "#DCDEE2"
        }
      },
      title: {
        spacing: 5,
        style: {
          fill: Theme.textColor,
          fontSize: 12,
          textAlign: "start",
          textBaseline: "top"
        }
      }
    } });
  };
  ContinueLegend2.prototype.isSlider = function() {
    return true;
  };
  ContinueLegend2.prototype.getValue = function() {
    return this.getCurrentValue();
  };
  ContinueLegend2.prototype.getRange = function() {
    return {
      min: this.get("min"),
      max: this.get("max")
    };
  };
  ContinueLegend2.prototype.setRange = function(min2, max2) {
    this.update({
      min: min2,
      max: max2
    });
  };
  ContinueLegend2.prototype.setValue = function(value2) {
    var originValue = this.getValue();
    this.set("value", value2);
    var group2 = this.get("group");
    this.resetTrackClip();
    if (this.get("slidable")) {
      this.resetHandlers(group2);
    }
    this.delegateEmit("valuechanged", {
      originValue,
      value: value2
    });
  };
  ContinueLegend2.prototype.initEvent = function() {
    var group2 = this.get("group");
    this.bindSliderEvent(group2);
    this.bindRailEvent(group2);
    this.bindTrackEvent(group2);
  };
  ContinueLegend2.prototype.drawLegendContent = function(group2) {
    this.drawRail(group2);
    this.drawLabels(group2);
    this.fixedElements(group2);
    this.resetTrack(group2);
    this.resetTrackClip(group2);
    if (this.get("slidable")) {
      this.resetHandlers(group2);
    }
  };
  ContinueLegend2.prototype.bindSliderEvent = function(group2) {
    this.bindHandlersEvent(group2);
  };
  ContinueLegend2.prototype.bindHandlersEvent = function(group2) {
    var _this = this;
    group2.on("legend-handler-min:drag", function(ev) {
      var minValue = _this.getValueByCanvasPoint(ev.x, ev.y);
      var currentValue = _this.getCurrentValue();
      var maxValue = currentValue[1];
      if (maxValue < minValue) {
        maxValue = minValue;
      }
      _this.setValue([minValue, maxValue]);
    });
    group2.on("legend-handler-max:drag", function(ev) {
      var maxValue = _this.getValueByCanvasPoint(ev.x, ev.y);
      var currentValue = _this.getCurrentValue();
      var minValue = currentValue[0];
      if (minValue > maxValue) {
        minValue = maxValue;
      }
      _this.setValue([minValue, maxValue]);
    });
  };
  ContinueLegend2.prototype.bindRailEvent = function(group2) {
  };
  ContinueLegend2.prototype.bindTrackEvent = function(group2) {
    var _this = this;
    var prePoint = null;
    group2.on("legend-track:dragstart", function(ev) {
      prePoint = {
        x: ev.x,
        y: ev.y
      };
    });
    group2.on("legend-track:drag", function(ev) {
      if (!prePoint) {
        return;
      }
      var preValue = _this.getValueByCanvasPoint(prePoint.x, prePoint.y);
      var curValue = _this.getValueByCanvasPoint(ev.x, ev.y);
      var currentValue = _this.getCurrentValue();
      var curDiff = currentValue[1] - currentValue[0];
      var range3 = _this.getRange();
      var dValue = curValue - preValue;
      if (dValue < 0) {
        if (currentValue[0] + dValue > range3.min) {
          _this.setValue([currentValue[0] + dValue, currentValue[1] + dValue]);
        } else {
          _this.setValue([range3.min, range3.min + curDiff]);
        }
      } else if (dValue > 0) {
        if (dValue > 0 && currentValue[1] + dValue < range3.max) {
          _this.setValue([currentValue[0] + dValue, currentValue[1] + dValue]);
        } else {
          _this.setValue([range3.max - curDiff, range3.max]);
        }
      }
      prePoint = {
        x: ev.x,
        y: ev.y
      };
    });
    group2.on("legend-track:dragend", function(ev) {
      prePoint = null;
    });
  };
  ContinueLegend2.prototype.drawLabels = function(group2) {
    this.drawLabel("min", group2);
    this.drawLabel("max", group2);
  };
  ContinueLegend2.prototype.drawLabel = function(name, group2) {
    var labelCfg = this.get("label");
    var style2 = labelCfg.style;
    var labelAlign = labelCfg.align;
    var labelFormatter = labelCfg.formatter;
    var value2 = this.get(name);
    var alignAttrs = this.getLabelAlignAttrs(name, labelAlign);
    var localId = "label-" + name;
    this.addShape(group2, {
      type: "text",
      id: this.getElementId(localId),
      name: "legend-label-" + name,
      attrs: __assign$4(__assign$4({ x: 0, y: 0, text: isFunction(labelFormatter) ? labelFormatter(value2) : value2 }, style2), alignAttrs)
    });
  };
  ContinueLegend2.prototype.getLabelAlignAttrs = function(name, align) {
    var isVertical2 = this.isVertical();
    var textAlign = "center";
    var textBaseline = "middle";
    if (isVertical2) {
      textAlign = "start";
      if (align !== "rail") {
        if (name === "min") {
          textBaseline = "top";
        } else {
          textBaseline = "bottom";
        }
      } else {
        textBaseline = "top";
      }
    } else {
      if (align !== "rail") {
        textBaseline = "top";
        if (name === "min") {
          textAlign = "start";
        } else {
          textAlign = "end";
        }
      } else {
        textAlign = "start";
        textBaseline = "middle";
      }
    }
    return {
      textAlign,
      textBaseline
    };
  };
  ContinueLegend2.prototype.getRailPath = function(x2, y2, w2, h2) {
    var railCfg = this.get("rail");
    var size2 = railCfg.size, defaultLength = railCfg.defaultLength, type4 = railCfg.type;
    var isVertical2 = this.isVertical();
    var length2 = defaultLength;
    var width = w2;
    var height = h2;
    if (!width) {
      width = isVertical2 ? size2 : length2;
    }
    if (!height) {
      height = isVertical2 ? length2 : size2;
    }
    var path2 = [];
    if (type4 === "color") {
      path2.push(["M", x2, y2]);
      path2.push(["L", x2 + width, y2]);
      path2.push(["L", x2 + width, y2 + height]);
      path2.push(["L", x2, y2 + height]);
      path2.push(["Z"]);
    } else {
      path2.push(["M", x2 + width, y2]);
      path2.push(["L", x2 + width, y2 + height]);
      path2.push(["L", x2, y2 + height]);
      path2.push(["Z"]);
    }
    return path2;
  };
  ContinueLegend2.prototype.drawRail = function(group2) {
    var railCfg = this.get("rail");
    var style2 = railCfg.style;
    this.addShape(group2, {
      type: "path",
      id: this.getElementId("rail"),
      name: "legend-rail",
      attrs: __assign$4({ path: this.getRailPath(0, 0) }, style2)
    });
  };
  ContinueLegend2.prototype.getTrackColor = function(colors) {
    var count2 = colors.length;
    if (!count2) {
      return null;
    }
    if (count2 === 1) {
      return colors[0];
    }
    var color2;
    if (this.isVertical()) {
      color2 = "l(90)";
    } else {
      color2 = "l(0)";
    }
    for (var i2 = 0; i2 < count2; i2++) {
      var percent2 = i2 / (count2 - 1);
      color2 += " " + percent2 + ":" + colors[i2];
    }
    return color2;
  };
  ContinueLegend2.prototype.getTrackPath = function(group2) {
    var railShape = this.getRailShape(group2);
    var path2 = railShape.attr("path");
    return clone$1(path2);
  };
  ContinueLegend2.prototype.getClipTrackAttrs = function(group2) {
    var value2 = this.getCurrentValue();
    var min2 = value2[0], max2 = value2[1];
    var railBBox = this.getRailBBox(group2);
    var startPoint = this.getPointByValue(min2, group2);
    var endPoint = this.getPointByValue(max2, group2);
    var isVertical2 = this.isVertical();
    var x2;
    var y2;
    var width;
    var height;
    if (isVertical2) {
      x2 = railBBox.minX;
      y2 = startPoint.y;
      width = railBBox.width;
      height = endPoint.y - startPoint.y;
    } else {
      x2 = startPoint.x;
      y2 = railBBox.minY;
      width = endPoint.x - startPoint.x;
      height = railBBox.height;
    }
    return {
      x: x2,
      y: y2,
      width,
      height
    };
  };
  ContinueLegend2.prototype.getTrackAttrs = function(group2) {
    var trackCfg = this.get("track");
    var colors = this.get("colors");
    var path2 = this.getTrackPath(group2);
    return mix({
      path: path2,
      fill: this.getTrackColor(colors)
    }, trackCfg.style);
  };
  ContinueLegend2.prototype.resetTrackClip = function(group2) {
    var container = group2 || this.get("group");
    var trackId = this.getElementId("track");
    var trackShape = container.findById(trackId);
    var clipShape = trackShape.getClip();
    var attrs = this.getClipTrackAttrs(group2);
    if (!clipShape) {
      trackShape.setClip({
        type: "rect",
        attrs
      });
    } else {
      clipShape.attr(attrs);
    }
  };
  ContinueLegend2.prototype.resetTrack = function(group2) {
    var trackId = this.getElementId("track");
    var trackShape = group2.findById(trackId);
    var trackAttrs = this.getTrackAttrs(group2);
    if (trackShape) {
      trackShape.attr(trackAttrs);
    } else {
      this.addShape(group2, {
        type: "path",
        id: trackId,
        draggable: this.get("slidable"),
        name: "legend-track",
        attrs: trackAttrs
      });
    }
  };
  ContinueLegend2.prototype.getPointByValue = function(value2, group2) {
    var _a2 = this.getRange(), min2 = _a2.min, max2 = _a2.max;
    var percent2 = (value2 - min2) / (max2 - min2);
    var bbox = this.getRailBBox(group2);
    var isVertcal = this.isVertical();
    var point2 = { x: 0, y: 0 };
    if (isVertcal) {
      point2.x = bbox.minX + bbox.width / 2;
      point2.y = getValueByPercent(bbox.minY, bbox.maxY, percent2);
    } else {
      point2.x = getValueByPercent(bbox.minX, bbox.maxX, percent2);
      point2.y = bbox.minY + bbox.height / 2;
    }
    return point2;
  };
  ContinueLegend2.prototype.getRailShape = function(group2) {
    var container = group2 || this.get("group");
    return container.findById(this.getElementId("rail"));
  };
  ContinueLegend2.prototype.getRailBBox = function(group2) {
    var railShape = this.getRailShape(group2);
    var bbox = railShape.getBBox();
    return bbox;
  };
  ContinueLegend2.prototype.getRailCanvasBBox = function() {
    var container = this.get("group");
    var railShape = container.findById(this.getElementId("rail"));
    var bbox = railShape.getCanvasBBox();
    return bbox;
  };
  ContinueLegend2.prototype.isVertical = function() {
    return this.get("layout") === "vertical";
  };
  ContinueLegend2.prototype.getValueByCanvasPoint = function(x2, y2) {
    var _a2 = this.getRange(), min2 = _a2.min, max2 = _a2.max;
    var bbox = this.getRailCanvasBBox();
    var isVertcal = this.isVertical();
    var step = this.get("step");
    var percent2;
    if (isVertcal) {
      percent2 = (y2 - bbox.minY) / bbox.height;
    } else {
      percent2 = (x2 - bbox.minX) / bbox.width;
    }
    var value2 = getValueByPercent(min2, max2, percent2);
    if (step) {
      var count2 = Math.round((value2 - min2) / step);
      value2 = min2 + count2 * step;
    }
    if (value2 > max2) {
      value2 = max2;
    }
    if (value2 < min2) {
      value2 = min2;
    }
    return value2;
  };
  ContinueLegend2.prototype.getCurrentValue = function() {
    var value2 = this.get("value");
    if (!value2) {
      var values2 = this.get("values");
      if (!values2) {
        return [this.get("min"), this.get("max")];
      }
      return [Math.max(Math.min.apply(Math, __spreadArrays(values2, [this.get("max")])), this.get("min")), Math.min(Math.max.apply(Math, __spreadArrays(values2, [this.get("min")])), this.get("max"))];
    }
    return value2;
  };
  ContinueLegend2.prototype.resetHandlers = function(group2) {
    var currentValue = this.getCurrentValue();
    var min2 = currentValue[0], max2 = currentValue[1];
    this.resetHandler(group2, "min", min2);
    this.resetHandler(group2, "max", max2);
  };
  ContinueLegend2.prototype.getHandlerPath = function(handlerCfg, point2) {
    var isVertical2 = this.isVertical();
    var path2 = [];
    var width = handlerCfg.size;
    var x2 = point2.x, y2 = point2.y;
    var height = width * HANDLER_HEIGHT_RATIO;
    var halfWidth = width / 2;
    var oneSixthWidth = width / 6;
    if (isVertical2) {
      var triangleX = x2 + height * HANDLER_TRIANGLE_RATIO;
      path2.push(["M", x2, y2]);
      path2.push(["L", triangleX, y2 + halfWidth]);
      path2.push(["L", x2 + height, y2 + halfWidth]);
      path2.push(["L", x2 + height, y2 - halfWidth]);
      path2.push(["L", triangleX, y2 - halfWidth]);
      path2.push(["Z"]);
      path2.push(["M", triangleX, y2 + oneSixthWidth]);
      path2.push(["L", x2 + height - 2, y2 + oneSixthWidth]);
      path2.push(["M", triangleX, y2 - oneSixthWidth]);
      path2.push(["L", x2 + height - 2, y2 - oneSixthWidth]);
    } else {
      var triangleY = y2 + height * HANDLER_TRIANGLE_RATIO;
      path2.push(["M", x2, y2]);
      path2.push(["L", x2 - halfWidth, triangleY]);
      path2.push(["L", x2 - halfWidth, y2 + height]);
      path2.push(["L", x2 + halfWidth, y2 + height]);
      path2.push(["L", x2 + halfWidth, triangleY]);
      path2.push(["Z"]);
      path2.push(["M", x2 - oneSixthWidth, triangleY]);
      path2.push(["L", x2 - oneSixthWidth, y2 + height - 2]);
      path2.push(["M", x2 + oneSixthWidth, triangleY]);
      path2.push(["L", x2 + oneSixthWidth, y2 + height - 2]);
    }
    return path2;
  };
  ContinueLegend2.prototype.resetHandler = function(group2, name, value2) {
    var point2 = this.getPointByValue(value2, group2);
    var handlerCfg = this.get("handler");
    var path2 = this.getHandlerPath(handlerCfg, point2);
    var id2 = this.getElementId("handler-" + name);
    var handlerShape = group2.findById(id2);
    var isVertical2 = this.isVertical();
    if (handlerShape) {
      handlerShape.attr("path", path2);
    } else {
      this.addShape(group2, {
        type: "path",
        name: "legend-handler-" + name,
        draggable: true,
        id: id2,
        attrs: __assign$4(__assign$4({ path: path2 }, handlerCfg.style), { cursor: isVertical2 ? "ns-resize" : "ew-resize" })
      });
    }
  };
  ContinueLegend2.prototype.fixedElements = function(group2) {
    var railShape = group2.findById(this.getElementId("rail"));
    var minLabel = group2.findById(this.getElementId("label-min"));
    var maxLabel = group2.findById(this.getElementId("label-max"));
    var startPoint = this.getDrawPoint();
    if (this.isVertical()) {
      this.fixedVertail(minLabel, maxLabel, railShape, startPoint);
    } else {
      this.fixedHorizontal(minLabel, maxLabel, railShape, startPoint);
    }
  };
  ContinueLegend2.prototype.fitRailLength = function(minLabelBBox, maxLabelBBox, railBBox, railShape) {
    var isVertical2 = this.isVertical();
    var lengthField = isVertical2 ? "height" : "width";
    var labelCfg = this.get("label");
    var labelAlign = labelCfg.align;
    var spacing = labelCfg.spacing;
    var maxLength = this.get("max" + upperFirst(lengthField));
    if (maxLength) {
      var elementsLength = labelAlign === "rail" ? railBBox[lengthField] + minLabelBBox[lengthField] + maxLabelBBox[lengthField] + spacing * 2 : railBBox[lengthField];
      var diff2 = elementsLength - maxLength;
      if (diff2 > 0) {
        this.changeRailLength(railShape, lengthField, railBBox[lengthField] - diff2);
      }
    }
  };
  ContinueLegend2.prototype.changeRailLength = function(railShape, lengthField, length2) {
    var bbox = railShape.getBBox();
    var path2;
    if (lengthField === "height") {
      path2 = this.getRailPath(bbox.x, bbox.y, bbox.width, length2);
    } else {
      path2 = this.getRailPath(bbox.x, bbox.y, length2, bbox.height);
    }
    railShape.attr("path", path2);
  };
  ContinueLegend2.prototype.changeRailPosition = function(railShape, x2, y2) {
    var bbox = railShape.getBBox();
    var path2 = this.getRailPath(x2, y2, bbox.width, bbox.height);
    railShape.attr("path", path2);
  };
  ContinueLegend2.prototype.fixedHorizontal = function(minLabel, maxLabel, railShape, startPoint) {
    var labelCfg = this.get("label");
    var labelAlign = labelCfg.align;
    var spacing = labelCfg.spacing;
    var railBBox = railShape.getBBox();
    var minLabelBBox = minLabel.getBBox();
    var maxLabelBBox = maxLabel.getBBox();
    var railHeight = railBBox.height;
    this.fitRailLength(minLabelBBox, maxLabelBBox, railBBox, railShape);
    railBBox = railShape.getBBox();
    if (labelAlign === "rail") {
      minLabel.attr({
        x: startPoint.x,
        y: startPoint.y + railHeight / 2
      });
      this.changeRailPosition(railShape, startPoint.x + minLabelBBox.width + spacing, startPoint.y);
      maxLabel.attr({
        x: startPoint.x + minLabelBBox.width + railBBox.width + spacing * 2,
        y: startPoint.y + railHeight / 2
      });
    } else if (labelAlign === "top") {
      minLabel.attr({
        x: startPoint.x,
        y: startPoint.y
      });
      maxLabel.attr({
        x: startPoint.x + railBBox.width,
        y: startPoint.y
      });
      this.changeRailPosition(railShape, startPoint.x, startPoint.y + minLabelBBox.height + spacing);
    } else {
      this.changeRailPosition(railShape, startPoint.x, startPoint.y);
      minLabel.attr({
        x: startPoint.x,
        y: startPoint.y + railBBox.height + spacing
      });
      maxLabel.attr({
        x: startPoint.x + railBBox.width,
        y: startPoint.y + railBBox.height + spacing
      });
    }
  };
  ContinueLegend2.prototype.fixedVertail = function(minLabel, maxLabel, railShape, startPoint) {
    var labelCfg = this.get("label");
    var labelAlign = labelCfg.align;
    var spacing = labelCfg.spacing;
    var railBBox = railShape.getBBox();
    var minLabelBBox = minLabel.getBBox();
    var maxLabelBBox = maxLabel.getBBox();
    this.fitRailLength(minLabelBBox, maxLabelBBox, railBBox, railShape);
    railBBox = railShape.getBBox();
    if (labelAlign === "rail") {
      minLabel.attr({
        x: startPoint.x,
        y: startPoint.y
      });
      this.changeRailPosition(railShape, startPoint.x, startPoint.y + minLabelBBox.height + spacing);
      maxLabel.attr({
        x: startPoint.x,
        y: startPoint.y + minLabelBBox.height + railBBox.height + spacing * 2
      });
    } else if (labelAlign === "right") {
      minLabel.attr({
        x: startPoint.x + railBBox.width + spacing,
        y: startPoint.y
      });
      this.changeRailPosition(railShape, startPoint.x, startPoint.y);
      maxLabel.attr({
        x: startPoint.x + railBBox.width + spacing,
        y: startPoint.y + railBBox.height
      });
    } else {
      var maxLabelWidth = Math.max(minLabelBBox.width, maxLabelBBox.width);
      minLabel.attr({
        x: startPoint.x,
        y: startPoint.y
      });
      this.changeRailPosition(railShape, startPoint.x + maxLabelWidth + spacing, startPoint.y);
      maxLabel.attr({
        x: startPoint.x,
        y: startPoint.y + railBBox.height
      });
    }
  };
  return ContinueLegend2;
}(LegendBase);
var CONTAINER_CLASS = "g2-tooltip";
var TITLE_CLASS = "g2-tooltip-title";
var LIST_CLASS = "g2-tooltip-list";
var LIST_ITEM_CLASS = "g2-tooltip-list-item";
var MARKER_CLASS = "g2-tooltip-marker";
var VALUE_CLASS = "g2-tooltip-value";
var NAME_CLASS = "g2-tooltip-name";
var CROSSHAIR_X = "g2-tooltip-crosshair-x";
var CROSSHAIR_Y = "g2-tooltip-crosshair-y";
var CssConst = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  CONTAINER_CLASS,
  TITLE_CLASS,
  LIST_CLASS,
  LIST_ITEM_CLASS,
  MARKER_CLASS,
  VALUE_CLASS,
  NAME_CLASS,
  CROSSHAIR_X,
  CROSSHAIR_Y
}, Symbol.toStringTag, { value: "Module" }));
var _a$3;
var TooltipTheme = (_a$3 = {}, _a$3["" + CONTAINER_CLASS] = {
  position: "absolute",
  visibility: "visible",
  zIndex: 8,
  transition: "visibility 0.2s cubic-bezier(0.23, 1, 0.32, 1), left 0.4s cubic-bezier(0.23, 1, 0.32, 1), top 0.4s cubic-bezier(0.23, 1, 0.32, 1)",
  backgroundColor: "rgba(255, 255, 255, 0.9)",
  boxShadow: "0px 0px 10px #aeaeae",
  borderRadius: "3px",
  color: "rgb(87, 87, 87)",
  fontSize: "12px",
  fontFamily: Theme.fontFamily,
  lineHeight: "20px",
  padding: "10px 10px 6px 10px"
}, _a$3["" + TITLE_CLASS] = {
  marginBottom: "4px"
}, _a$3["" + LIST_CLASS] = {
  margin: "0px",
  listStyleType: "none",
  padding: "0px"
}, _a$3["" + LIST_ITEM_CLASS] = {
  listStyleType: "none",
  marginBottom: "4px"
}, _a$3["" + MARKER_CLASS] = {
  width: "8px",
  height: "8px",
  borderRadius: "50%",
  display: "inline-block",
  marginRight: "8px"
}, _a$3["" + VALUE_CLASS] = {
  display: "inline-block",
  float: "right",
  marginLeft: "30px"
}, _a$3["" + CROSSHAIR_X] = {
  position: "absolute",
  width: "1px",
  backgroundColor: "rgba(0, 0, 0, 0.25)"
}, _a$3["" + CROSSHAIR_Y] = {
  position: "absolute",
  height: "1px",
  backgroundColor: "rgba(0, 0, 0, 0.25)"
}, _a$3);
function getOutSides(x2, y2, width, height, limitBox) {
  var hits = {
    left: x2 < limitBox.x,
    right: x2 + width > limitBox.x + limitBox.width,
    top: y2 < limitBox.y,
    bottom: y2 + height > limitBox.y + limitBox.height
  };
  return hits;
}
function getPointByPosition(x2, y2, offset3, width, height, position) {
  var px = x2;
  var py = y2;
  switch (position) {
    case "left":
      px = x2 - width - offset3;
      py = y2 - height / 2;
      break;
    case "right":
      px = x2 + offset3;
      py = y2 - height / 2;
      break;
    case "top":
      px = x2 - width / 2;
      py = y2 - height - offset3;
      break;
    case "bottom":
      px = x2 - width / 2;
      py = y2 + offset3;
      break;
    default:
      px = x2 + offset3;
      py = y2 - height - offset3;
      break;
  }
  return {
    x: px,
    y: py
  };
}
function getAlignPoint(x2, y2, offset3, width, height, position, limitBox) {
  var point2 = getPointByPosition(x2, y2, offset3, width, height, position);
  if (limitBox) {
    var outSides = getOutSides(point2.x, point2.y, width, height, limitBox);
    if (position === "auto") {
      if (outSides.right) {
        point2.x = Math.max(0, x2 - width - offset3);
      }
      if (outSides.top) {
        point2.y = Math.max(0, y2 - height - offset3);
      }
    } else if (position === "top" || position === "bottom") {
      if (outSides.left) {
        point2.x = limitBox.x;
      }
      if (outSides.right) {
        point2.x = limitBox.x + limitBox.width - width;
      }
      if (position === "top" && outSides.top) {
        point2.y = y2 + offset3;
      }
      if (position === "bottom" && outSides.bottom) {
        point2.y = y2 - height - offset3;
      }
    } else {
      if (outSides.top) {
        point2.y = limitBox.y;
      }
      if (outSides.bottom) {
        point2.y = limitBox.y + limitBox.height - height;
      }
      if (position === "left" && outSides.left) {
        point2.x = x2 + offset3;
      }
      if (position === "right" && outSides.right) {
        point2.x = x2 - width - offset3;
      }
    }
  }
  return point2;
}
function hasOneKey(obj, keys2) {
  var result = false;
  each$1(keys2, function(key2) {
    if (has(obj, key2)) {
      result = true;
      return false;
    }
  });
  return result;
}
var Tooltip$1 = function(_super) {
  __extends$3(Tooltip3, _super);
  function Tooltip3() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Tooltip3.prototype.getDefaultCfg = function() {
    var cfg = _super.prototype.getDefaultCfg.call(this);
    return __assign$4(__assign$4({}, cfg), {
      name: "tooltip",
      type: "html",
      x: 0,
      y: 0,
      items: [],
      customContent: null,
      containerTpl: '<div class="' + CONTAINER_CLASS + '"><div class="' + TITLE_CLASS + '"></div><ul class="' + LIST_CLASS + '"></ul></div>',
      itemTpl: '<li class="' + LIST_ITEM_CLASS + '" data-index={index}>\n          <span class="' + MARKER_CLASS + '" style="background:{color}"></span>\n          <span class="' + NAME_CLASS + '">{name}</span>:\n          <span class="' + VALUE_CLASS + '">{value}</span>\n        </li>',
      xCrosshairTpl: '<div class="' + CROSSHAIR_X + '"></div>',
      yCrosshairTpl: '<div class="' + CROSSHAIR_Y + '"></div>',
      title: null,
      showTitle: true,
      region: null,
      crosshairsRegion: null,
      containerClassName: CONTAINER_CLASS,
      crosshairs: null,
      offset: 10,
      position: "right",
      domStyles: null,
      defaultStyles: TooltipTheme
    });
  };
  Tooltip3.prototype.render = function() {
    if (this.get("customContent")) {
      this.renderCustomContent();
    } else {
      this.resetTitle();
      this.renderItems();
    }
    this.resetPosition();
  };
  Tooltip3.prototype.clear = function() {
    this.clearCrosshairs();
    this.setTitle("");
    this.clearItemDoms();
  };
  Tooltip3.prototype.show = function() {
    var container = this.getContainer();
    if (!container || this.destroyed) {
      return;
    }
    this.set("visible", true);
    modifyCSS(container, {
      visibility: "visible"
    });
    this.setCrossHairsVisible(true);
  };
  Tooltip3.prototype.hide = function() {
    var container = this.getContainer();
    if (!container || this.destroyed) {
      return;
    }
    this.set("visible", false);
    modifyCSS(container, {
      visibility: "hidden"
    });
    this.setCrossHairsVisible(false);
  };
  Tooltip3.prototype.getLocation = function() {
    return { x: this.get("x"), y: this.get("y") };
  };
  Tooltip3.prototype.setLocation = function(point2) {
    this.set("x", point2.x);
    this.set("y", point2.y);
    this.resetPosition();
  };
  Tooltip3.prototype.setCrossHairsVisible = function(visible) {
    var display = visible ? "" : "none";
    var xCrosshairDom = this.get("xCrosshairDom");
    var yCrosshairDom = this.get("yCrosshairDom");
    xCrosshairDom && modifyCSS(xCrosshairDom, {
      display
    });
    yCrosshairDom && modifyCSS(yCrosshairDom, {
      display
    });
  };
  Tooltip3.prototype.initContainer = function() {
    _super.prototype.initContainer.call(this);
    if (this.get("customContent")) {
      if (this.get("container")) {
        this.get("container").remove();
      }
      var container = this.getHtmlContentNode();
      this.get("parent").appendChild(container);
      this.set("container", container);
      this.resetStyles();
      this.applyStyles();
    }
  };
  Tooltip3.prototype.updateInner = function(cfg) {
    if (this.get("customContent")) {
      this.renderCustomContent();
    } else {
      if (hasOneKey(cfg, ["title", "showTitle"])) {
        this.resetTitle();
      }
      if (has(cfg, "items")) {
        this.renderItems();
      }
    }
    _super.prototype.updateInner.call(this, cfg);
  };
  Tooltip3.prototype.initDom = function() {
    this.cacheDoms();
  };
  Tooltip3.prototype.removeDom = function() {
    _super.prototype.removeDom.call(this);
    this.clearCrosshairs();
  };
  Tooltip3.prototype.resetPosition = function() {
    var x2 = this.get("x");
    var y2 = this.get("y");
    var offset3 = this.get("offset");
    var _a2 = this.getOffset(), offsetX = _a2.offsetX, offsetY = _a2.offsetY;
    var position = this.get("position");
    var region = this.get("region");
    var container = this.getContainer();
    var bbox = this.getBBox();
    var width = bbox.width, height = bbox.height;
    var limitBox;
    if (region) {
      limitBox = regionToBBox(region);
    }
    var point2 = getAlignPoint(x2, y2, offset3, width, height, position, limitBox);
    modifyCSS(container, {
      left: toPx(point2.x + offsetX),
      top: toPx(point2.y + offsetY)
    });
    this.resetCrosshairs();
  };
  Tooltip3.prototype.renderCustomContent = function() {
    var node = this.getHtmlContentNode();
    var parent = this.get("parent");
    var curContainer = this.get("container");
    if (curContainer && curContainer.parentNode === parent) {
      parent.replaceChild(node, curContainer);
    } else {
      parent.appendChild(node);
    }
    this.set("container", node);
    this.resetStyles();
    this.applyStyles();
  };
  Tooltip3.prototype.getHtmlContentNode = function() {
    var node;
    var customContent = this.get("customContent");
    if (customContent) {
      var elem = customContent(this.get("title"), this.get("items"));
      if (isElement(elem)) {
        node = elem;
      } else {
        node = createDom$1(elem);
      }
    }
    return node;
  };
  Tooltip3.prototype.cacheDoms = function() {
    var container = this.getContainer();
    var titleDom = container.getElementsByClassName(TITLE_CLASS)[0];
    var listDom = container.getElementsByClassName(LIST_CLASS)[0];
    this.set("titleDom", titleDom);
    this.set("listDom", listDom);
  };
  Tooltip3.prototype.resetTitle = function() {
    var title = this.get("title");
    var showTitle = this.get("showTitle");
    if (showTitle && title) {
      this.setTitle(title);
    } else {
      this.setTitle("");
    }
  };
  Tooltip3.prototype.setTitle = function(text2) {
    var titleDom = this.get("titleDom");
    if (titleDom) {
      titleDom.innerText = text2;
    }
  };
  Tooltip3.prototype.resetCrosshairs = function() {
    var crosshairsRegion = this.get("crosshairsRegion");
    var crosshairs = this.get("crosshairs");
    if (!crosshairsRegion || !crosshairs) {
      this.clearCrosshairs();
    } else {
      var crosshairBox = regionToBBox(crosshairsRegion);
      var xCrosshairDom = this.get("xCrosshairDom");
      var yCrosshairDom = this.get("yCrosshairDom");
      if (crosshairs === "x") {
        this.resetCrosshair("x", crosshairBox);
        if (yCrosshairDom) {
          yCrosshairDom.remove();
          this.set("yCrosshairDom", null);
        }
      } else if (crosshairs === "y") {
        this.resetCrosshair("y", crosshairBox);
        if (xCrosshairDom) {
          xCrosshairDom.remove();
          this.set("xCrosshairDom", null);
        }
      } else {
        this.resetCrosshair("x", crosshairBox);
        this.resetCrosshair("y", crosshairBox);
      }
      this.setCrossHairsVisible(this.get("visible"));
    }
  };
  Tooltip3.prototype.resetCrosshair = function(name, bbox) {
    var croshairDom = this.checkCrosshair(name);
    var value2 = this.get(name);
    if (name === "x") {
      modifyCSS(croshairDom, {
        left: toPx(value2),
        top: toPx(bbox.y),
        height: toPx(bbox.height)
      });
    } else {
      modifyCSS(croshairDom, {
        top: toPx(value2),
        left: toPx(bbox.x),
        width: toPx(bbox.width)
      });
    }
  };
  Tooltip3.prototype.checkCrosshair = function(name) {
    var domName = name + "CrosshairDom";
    var tplName = name + "CrosshairTpl";
    var constName = "CROSSHAIR_" + name.toUpperCase();
    var styleName = CssConst[constName];
    var croshairDom = this.get(domName);
    var parent = this.get("parent");
    if (!croshairDom) {
      croshairDom = createDom$1(this.get(tplName));
      this.applyStyle(styleName, croshairDom);
      parent.appendChild(croshairDom);
      this.set(domName, croshairDom);
    }
    return croshairDom;
  };
  Tooltip3.prototype.renderItems = function() {
    this.clearItemDoms();
    var items = this.get("items");
    var itemTpl = this.get("itemTpl");
    var listDom = this.get("listDom");
    if (listDom) {
      each$1(items, function(item) {
        var color2 = colorUtil.toCSSGradient(item.color);
        var substituteObj = __assign$4(__assign$4({}, item), { color: color2 });
        var domStr = substitute(itemTpl, substituteObj);
        var itemDom = createDom$1(domStr);
        listDom.appendChild(itemDom);
      });
      this.applyChildrenStyles(listDom, this.get("domStyles"));
    }
  };
  Tooltip3.prototype.clearItemDoms = function() {
    if (this.get("listDom")) {
      clearDom(this.get("listDom"));
    }
  };
  Tooltip3.prototype.clearCrosshairs = function() {
    var xCrosshairDom = this.get("xCrosshairDom");
    var yCrosshairDom = this.get("yCrosshairDom");
    xCrosshairDom && xCrosshairDom.remove();
    yCrosshairDom && yCrosshairDom.remove();
    this.set("xCrosshairDom", null);
    this.set("yCrosshairDom", null);
  };
  return Tooltip3;
}(HtmlComponent);
var BACKGROUND_STYLE$1 = {
  opacity: 0
};
var LINE_STYLE = {
  stroke: "#C5C5C5",
  strokeOpacity: 0.85
};
var AREA_STYLE = {
  fill: "#CACED4",
  opacity: 0.85
};
function pointsToPath(points2) {
  return map$2(points2, function(p2, idx) {
    var command = idx === 0 ? "M" : "L";
    var x2 = p2[0], y2 = p2[1];
    return [command, x2, y2];
  });
}
function getLinePath$1(points2) {
  return pointsToPath(points2);
}
function getSmoothLinePath(points2) {
  if (points2.length <= 2) {
    return getLinePath$1(points2);
  }
  var data2 = [];
  each$1(points2, function(p2) {
    if (!isEqual$1(p2, data2.slice(data2.length - 2))) {
      data2.push(p2[0], p2[1]);
    }
  });
  var path2 = catmullRom2Bezier(data2, false);
  var _a2 = head(points2), x2 = _a2[0], y2 = _a2[1];
  path2.unshift(["M", x2, y2]);
  return path2;
}
function dataToPath(data2, width, height, smooth) {
  if (smooth === void 0) {
    smooth = true;
  }
  var y2 = new Linear({
    values: data2
  });
  var x2 = new Category$1({
    values: map$2(data2, function(v2, idx) {
      return idx;
    })
  });
  var points2 = map$2(data2, function(v2, idx) {
    return [x2.scale(idx) * width, height - y2.scale(v2) * height];
  });
  return smooth ? getSmoothLinePath(points2) : getLinePath$1(points2);
}
function getAreaLineY(data2, height) {
  var y2 = new Linear({
    values: data2
  });
  var lineY = y2.max < 0 ? y2.max : Math.max(0, y2.min);
  return height - y2.scale(lineY) * height;
}
function linePathToAreaPath(path2, width, height, data2) {
  var areaPath = __spreadArrays(path2);
  var lineYPx = getAreaLineY(data2, height);
  areaPath.push(["L", width, lineYPx]);
  areaPath.push(["L", 0, lineYPx]);
  areaPath.push(["Z"]);
  return areaPath;
}
var Trend = function(_super) {
  __extends$3(Trend2, _super);
  function Trend2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Trend2.prototype.getDefaultCfg = function() {
    var cfg = _super.prototype.getDefaultCfg.call(this);
    return __assign$4(__assign$4({}, cfg), { name: "trend", x: 0, y: 0, width: 200, height: 16, smooth: true, isArea: false, data: [], backgroundStyle: BACKGROUND_STYLE$1, lineStyle: LINE_STYLE, areaStyle: AREA_STYLE });
  };
  Trend2.prototype.renderInner = function(group2) {
    var _a2 = this.cfg, width = _a2.width, height = _a2.height, data2 = _a2.data, smooth = _a2.smooth, isArea = _a2.isArea, backgroundStyle = _a2.backgroundStyle, lineStyle = _a2.lineStyle, areaStyle = _a2.areaStyle;
    this.addShape(group2, {
      id: this.getElementId("background"),
      type: "rect",
      attrs: __assign$4({
        x: 0,
        y: 0,
        width,
        height
      }, backgroundStyle)
    });
    var path2 = dataToPath(data2, width, height, smooth);
    this.addShape(group2, {
      id: this.getElementId("line"),
      type: "path",
      attrs: __assign$4({ path: path2 }, lineStyle)
    });
    if (isArea) {
      var areaPath = linePathToAreaPath(path2, width, height, data2);
      this.addShape(group2, {
        id: this.getElementId("area"),
        type: "path",
        attrs: __assign$4({ path: areaPath }, areaStyle)
      });
    }
  };
  Trend2.prototype.applyOffset = function() {
    var _a2 = this.cfg, x2 = _a2.x, y2 = _a2.y;
    this.moveElementTo(this.get("group"), {
      x: x2,
      y: y2
    });
  };
  return Trend2;
}(GroupComponent);
var DEFAULT_HANDLER_STYLE = {
  fill: "#F7F7F7",
  stroke: "#BFBFBF",
  radius: 2,
  opacity: 1,
  cursor: "ew-resize",
  highLightFill: "#FFF"
};
var Handler = function(_super) {
  __extends$3(Handler2, _super);
  function Handler2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Handler2.prototype.getDefaultCfg = function() {
    var cfg = _super.prototype.getDefaultCfg.call(this);
    return __assign$4(__assign$4({}, cfg), { name: "handler", x: 0, y: 0, width: 10, height: 24, style: DEFAULT_HANDLER_STYLE });
  };
  Handler2.prototype.renderInner = function(group2) {
    var _a2 = this.cfg, width = _a2.width, height = _a2.height, style2 = _a2.style;
    var fill = style2.fill, stroke = style2.stroke, radius = style2.radius, opacity = style2.opacity, cursor = style2.cursor;
    this.addShape(group2, {
      type: "rect",
      id: this.getElementId("background"),
      attrs: {
        x: 0,
        y: 0,
        width,
        height,
        fill,
        stroke,
        radius,
        opacity,
        cursor
      }
    });
    var x1 = 1 / 3 * width;
    var x2 = 2 / 3 * width;
    var y1 = 1 / 4 * height;
    var y2 = 3 / 4 * height;
    this.addShape(group2, {
      id: this.getElementId("line-left"),
      type: "line",
      attrs: {
        x1,
        y1,
        x2: x1,
        y2,
        stroke,
        cursor
      }
    });
    this.addShape(group2, {
      id: this.getElementId("line-right"),
      type: "line",
      attrs: {
        x1: x2,
        y1,
        x2,
        y2,
        stroke,
        cursor
      }
    });
  };
  Handler2.prototype.applyOffset = function() {
    this.moveElementTo(this.get("group"), {
      x: this.get("x"),
      y: this.get("y")
    });
  };
  Handler2.prototype.initEvent = function() {
    this.bindEvents();
  };
  Handler2.prototype.bindEvents = function() {
    var _this = this;
    this.get("group").on("mouseenter", function() {
      var highLightFill = _this.get("style").highLightFill;
      _this.getElementByLocalId("background").attr("fill", highLightFill);
      _this.draw();
    });
    this.get("group").on("mouseleave", function() {
      var fill = _this.get("style").fill;
      _this.getElementByLocalId("background").attr("fill", fill);
      _this.draw();
    });
  };
  Handler2.prototype.draw = function() {
    var canvas = this.get("container").get("canvas");
    if (canvas) {
      canvas.draw();
    }
  };
  return Handler2;
}(GroupComponent);
var BACKGROUND_STYLE = {
  fill: "#416180",
  opacity: 0.05
};
var FOREGROUND_STYLE = {
  fill: "#5B8FF9",
  opacity: 0.15,
  cursor: "move"
};
var DEFAULT_HANDLER_WIDTH = 10;
var HANDLER_STYLE = {
  width: DEFAULT_HANDLER_WIDTH,
  height: 24
};
var TEXT_STYLE = {
  textBaseline: "middle",
  fill: "#000",
  opacity: 0.45
};
var SLIDER_CHANGE = "sliderchange";
var Slider$1 = function(_super) {
  __extends$3(Slider2, _super);
  function Slider2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.onMouseDown = function(target) {
      return function(e3) {
        _this.currentTarget = target;
        var event = e3.originalEvent;
        event.stopPropagation();
        event.preventDefault();
        _this.prevX = get(event, "touches.0.pageX", event.pageX);
        _this.prevY = get(event, "touches.0.pageY", event.pageY);
        var containerDOM = _this.getContainerDOM();
        containerDOM.addEventListener("mousemove", _this.onMouseMove);
        containerDOM.addEventListener("mouseup", _this.onMouseUp);
        containerDOM.addEventListener("mouseleave", _this.onMouseUp);
        containerDOM.addEventListener("touchmove", _this.onMouseMove);
        containerDOM.addEventListener("touchend", _this.onMouseUp);
        containerDOM.addEventListener("touchcancel", _this.onMouseUp);
      };
    };
    _this.onMouseMove = function(event) {
      var width = _this.cfg.width;
      var originValue = [_this.get("start"), _this.get("end")];
      event.stopPropagation();
      event.preventDefault();
      var x2 = get(event, "touches.0.pageX", event.pageX);
      var y2 = get(event, "touches.0.pageY", event.pageY);
      var offsetX = x2 - _this.prevX;
      var offsetXRange = _this.adjustOffsetRange(offsetX / width);
      _this.updateStartEnd(offsetXRange);
      _this.updateUI(_this.getElementByLocalId("foreground"), _this.getElementByLocalId("minText"), _this.getElementByLocalId("maxText"));
      _this.prevX = x2;
      _this.prevY = y2;
      _this.draw();
      _this.emit(SLIDER_CHANGE, [_this.get("start"), _this.get("end")].sort());
      _this.delegateEmit("valuechanged", {
        originValue,
        value: [_this.get("start"), _this.get("end")]
      });
    };
    _this.onMouseUp = function() {
      if (_this.currentTarget) {
        _this.currentTarget = void 0;
      }
      var containerDOM = _this.getContainerDOM();
      if (containerDOM) {
        containerDOM.removeEventListener("mousemove", _this.onMouseMove);
        containerDOM.removeEventListener("mouseup", _this.onMouseUp);
        containerDOM.removeEventListener("mouseleave", _this.onMouseUp);
        containerDOM.removeEventListener("touchmove", _this.onMouseMove);
        containerDOM.removeEventListener("touchend", _this.onMouseUp);
        containerDOM.removeEventListener("touchcancel", _this.onMouseUp);
      }
    };
    return _this;
  }
  Slider2.prototype.setRange = function(min2, max2) {
    this.set("minLimit", min2);
    this.set("maxLimit", max2);
    var oldStart = this.get("start");
    var oldEnd = this.get("end");
    var newStart = clamp(oldStart, min2, max2);
    var newEnd = clamp(oldEnd, min2, max2);
    if (!this.get("isInit") && (oldStart !== newStart || oldEnd !== newEnd)) {
      this.setValue([newStart, newEnd]);
    }
  };
  Slider2.prototype.getRange = function() {
    return {
      min: this.get("minLimit") || 0,
      max: this.get("maxLimit") || 1
    };
  };
  Slider2.prototype.setValue = function(value2) {
    var range3 = this.getRange();
    if (isArray$1(value2) && value2.length === 2) {
      var originValue = [this.get("start"), this.get("end")];
      this.update({
        start: clamp(value2[0], range3.min, range3.max),
        end: clamp(value2[1], range3.min, range3.max)
      });
      if (!this.get("updateAutoRender")) {
        this.render();
      }
      this.delegateEmit("valuechanged", {
        originValue,
        value: value2
      });
    }
  };
  Slider2.prototype.getValue = function() {
    return [this.get("start"), this.get("end")];
  };
  Slider2.prototype.getDefaultCfg = function() {
    var cfg = _super.prototype.getDefaultCfg.call(this);
    return __assign$4(__assign$4({}, cfg), { name: "slider", x: 0, y: 0, width: 100, height: 16, backgroundStyle: {}, foregroundStyle: {}, handlerStyle: {}, textStyle: {}, defaultCfg: {
      backgroundStyle: BACKGROUND_STYLE,
      foregroundStyle: FOREGROUND_STYLE,
      handlerStyle: HANDLER_STYLE,
      textStyle: TEXT_STYLE
    } });
  };
  Slider2.prototype.update = function(cfg) {
    var start = cfg.start, end = cfg.end;
    var validCfg = __assign$4({}, cfg);
    if (!isNil(start)) {
      validCfg.start = clamp(start, 0, 1);
    }
    if (!isNil(end)) {
      validCfg.end = clamp(end, 0, 1);
    }
    _super.prototype.update.call(this, validCfg);
    this.minHandler = this.getChildComponentById(this.getElementId("minHandler"));
    this.maxHandler = this.getChildComponentById(this.getElementId("maxHandler"));
    this.trend = this.getChildComponentById(this.getElementId("trend"));
  };
  Slider2.prototype.init = function() {
    this.set("start", clamp(this.get("start"), 0, 1));
    this.set("end", clamp(this.get("end"), 0, 1));
    _super.prototype.init.call(this);
  };
  Slider2.prototype.render = function() {
    _super.prototype.render.call(this);
    this.updateUI(this.getElementByLocalId("foreground"), this.getElementByLocalId("minText"), this.getElementByLocalId("maxText"));
  };
  Slider2.prototype.renderInner = function(group2) {
    var _a2 = this.cfg;
    _a2.start;
    _a2.end;
    var width = _a2.width, height = _a2.height, _b = _a2.trendCfg, trendCfg = _b === void 0 ? {} : _b, minText = _a2.minText, maxText = _a2.maxText, _c = _a2.backgroundStyle, backgroundStyle = _c === void 0 ? {} : _c, _d = _a2.foregroundStyle, foregroundStyle = _d === void 0 ? {} : _d, _e = _a2.textStyle, textStyle2 = _e === void 0 ? {} : _e;
    var handlerStyle = deepMix({}, DEFAULT_HANDLER_STYLE, this.cfg.handlerStyle);
    if (size(get(trendCfg, "data"))) {
      this.trend = this.addComponent(group2, __assign$4({
        component: Trend,
        id: this.getElementId("trend"),
        x: 0,
        y: 0,
        width,
        height
      }, trendCfg));
    }
    this.addShape(group2, {
      id: this.getElementId("background"),
      type: "rect",
      attrs: __assign$4({
        x: 0,
        y: 0,
        width,
        height
      }, backgroundStyle)
    });
    this.addShape(group2, {
      id: this.getElementId("minText"),
      type: "text",
      attrs: __assign$4({
        y: height / 2,
        textAlign: "right",
        text: minText,
        silent: false
      }, textStyle2)
    });
    this.addShape(group2, {
      id: this.getElementId("maxText"),
      type: "text",
      attrs: __assign$4({
        y: height / 2,
        textAlign: "left",
        text: maxText,
        silent: false
      }, textStyle2)
    });
    this.addShape(group2, {
      id: this.getElementId("foreground"),
      name: "foreground",
      type: "rect",
      attrs: __assign$4({
        y: 0,
        height
      }, foregroundStyle)
    });
    var handlerWidth = get(handlerStyle, "width", DEFAULT_HANDLER_WIDTH);
    var handlerHeight = get(handlerStyle, "height", 24);
    this.minHandler = this.addComponent(group2, {
      component: Handler,
      id: this.getElementId("minHandler"),
      name: "handler-min",
      x: 0,
      y: (height - handlerHeight) / 2,
      width: handlerWidth,
      height: handlerHeight,
      cursor: "ew-resize",
      style: handlerStyle
    });
    this.maxHandler = this.addComponent(group2, {
      component: Handler,
      id: this.getElementId("maxHandler"),
      name: "handler-max",
      x: 0,
      y: (height - handlerHeight) / 2,
      width: handlerWidth,
      height: handlerHeight,
      cursor: "ew-resize",
      style: handlerStyle
    });
  };
  Slider2.prototype.applyOffset = function() {
    this.moveElementTo(this.get("group"), {
      x: this.get("x"),
      y: this.get("y")
    });
  };
  Slider2.prototype.initEvent = function() {
    this.bindEvents();
  };
  Slider2.prototype.updateUI = function(foregroundShape, minTextShape, maxTextShape) {
    var _a2 = this.cfg, start = _a2.start, end = _a2.end, width = _a2.width, minText = _a2.minText, maxText = _a2.maxText, handlerStyle = _a2.handlerStyle, height = _a2.height;
    var min2 = start * width;
    var max2 = end * width;
    if (this.trend) {
      this.trend.update({
        width,
        height
      });
      if (!this.get("updateAutoRender")) {
        this.trend.render();
      }
    }
    foregroundShape.attr("x", min2);
    foregroundShape.attr("width", max2 - min2);
    var handlerWidth = get(handlerStyle, "width", DEFAULT_HANDLER_WIDTH);
    minTextShape.attr("text", minText);
    maxTextShape.attr("text", maxText);
    var _b = this._dodgeText([min2, max2], minTextShape, maxTextShape), minAttrs = _b[0], maxAttrs = _b[1];
    if (this.minHandler) {
      this.minHandler.update({
        x: min2 - handlerWidth / 2
      });
      if (!this.get("updateAutoRender")) {
        this.minHandler.render();
      }
    }
    each$1(minAttrs, function(v2, k2) {
      return minTextShape.attr(k2, v2);
    });
    if (this.maxHandler) {
      this.maxHandler.update({
        x: max2 - handlerWidth / 2
      });
      if (!this.get("updateAutoRender")) {
        this.maxHandler.render();
      }
    }
    each$1(maxAttrs, function(v2, k2) {
      return maxTextShape.attr(k2, v2);
    });
  };
  Slider2.prototype.bindEvents = function() {
    var group2 = this.get("group");
    group2.on("handler-min:mousedown", this.onMouseDown("minHandler"));
    group2.on("handler-min:touchstart", this.onMouseDown("minHandler"));
    group2.on("handler-max:mousedown", this.onMouseDown("maxHandler"));
    group2.on("handler-max:touchstart", this.onMouseDown("maxHandler"));
    var foreground = group2.findById(this.getElementId("foreground"));
    foreground.on("mousedown", this.onMouseDown("foreground"));
    foreground.on("touchstart", this.onMouseDown("foreground"));
  };
  Slider2.prototype.adjustOffsetRange = function(offsetRange) {
    var _a2 = this.cfg, start = _a2.start, end = _a2.end;
    switch (this.currentTarget) {
      case "minHandler": {
        var min2 = 0 - start;
        var max2 = 1 - start;
        return Math.min(max2, Math.max(min2, offsetRange));
      }
      case "maxHandler": {
        var min2 = 0 - end;
        var max2 = 1 - end;
        return Math.min(max2, Math.max(min2, offsetRange));
      }
      case "foreground": {
        var min2 = 0 - start;
        var max2 = 1 - end;
        return Math.min(max2, Math.max(min2, offsetRange));
      }
    }
  };
  Slider2.prototype.updateStartEnd = function(offsetRange) {
    var _a2 = this.cfg, start = _a2.start, end = _a2.end;
    switch (this.currentTarget) {
      case "minHandler":
        start += offsetRange;
        break;
      case "maxHandler":
        end += offsetRange;
        break;
      case "foreground":
        start += offsetRange;
        end += offsetRange;
        break;
    }
    this.set("start", start);
    this.set("end", end);
  };
  Slider2.prototype._dodgeText = function(range3, minTextShape, maxTextShape) {
    var _a2, _b;
    var _c = this.cfg, handlerStyle = _c.handlerStyle, width = _c.width;
    var PADDING2 = 2;
    var handlerWidth = get(handlerStyle, "width", DEFAULT_HANDLER_WIDTH);
    var min2 = range3[0], max2 = range3[1];
    var sorted = false;
    if (min2 > max2) {
      _a2 = [max2, min2], min2 = _a2[0], max2 = _a2[1];
      _b = [maxTextShape, minTextShape], minTextShape = _b[0], maxTextShape = _b[1];
      sorted = true;
    }
    var minBBox = minTextShape.getBBox();
    var maxBBox = maxTextShape.getBBox();
    var minAttrs = minBBox.width > min2 - PADDING2 ? { x: min2 + handlerWidth / 2 + PADDING2, textAlign: "left" } : { x: min2 - handlerWidth / 2 - PADDING2, textAlign: "right" };
    var maxAttrs = maxBBox.width > width - max2 - PADDING2 ? { x: max2 - handlerWidth / 2 - PADDING2, textAlign: "right" } : { x: max2 + handlerWidth / 2 + PADDING2, textAlign: "left" };
    return !sorted ? [minAttrs, maxAttrs] : [maxAttrs, minAttrs];
  };
  Slider2.prototype.draw = function() {
    var container = this.get("container");
    var canvas = container && container.get("canvas");
    if (canvas) {
      canvas.draw();
    }
  };
  Slider2.prototype.getContainerDOM = function() {
    var container = this.get("container");
    var canvas = container && container.get("canvas");
    return canvas && canvas.get("container");
  };
  return Slider2;
}(GroupComponent);
var DEFAULT_STYLE = {
  trackColor: "rgba(0,0,0,0)",
  thumbColor: "rgba(0,0,0,0.15)",
  size: 8,
  lineCap: "round"
};
var DEFAULT_THEME = {
  default: DEFAULT_STYLE,
  hover: {
    thumbColor: "rgba(0,0,0,0.2)"
  }
};
var Scrollbar$1 = function(_super) {
  __extends$3(Scrollbar2, _super);
  function Scrollbar2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.clearEvents = noop;
    _this.onStartEvent = function(isMobile2) {
      return function(e3) {
        _this.isMobile = isMobile2;
        e3.originalEvent.preventDefault();
        var clientX = isMobile2 ? get(e3.originalEvent, "touches.0.clientX") : e3.clientX;
        var clientY = isMobile2 ? get(e3.originalEvent, "touches.0.clientY") : e3.clientY;
        _this.startPos = _this.cfg.isHorizontal ? clientX : clientY;
        _this.bindLaterEvent();
      };
    };
    _this.bindLaterEvent = function() {
      var containerDOM = _this.getContainerDOM();
      var events = [];
      if (_this.isMobile) {
        events = [
          addEventListener(containerDOM, "touchmove", _this.onMouseMove),
          addEventListener(containerDOM, "touchend", _this.onMouseUp),
          addEventListener(containerDOM, "touchcancel", _this.onMouseUp)
        ];
      } else {
        events = [
          addEventListener(containerDOM, "mousemove", _this.onMouseMove),
          addEventListener(containerDOM, "mouseup", _this.onMouseUp),
          addEventListener(containerDOM, "mouseleave", _this.onMouseUp)
        ];
      }
      _this.clearEvents = function() {
        events.forEach(function(e3) {
          e3.remove();
        });
      };
    };
    _this.onMouseMove = function(e3) {
      var _a2 = _this.cfg, isHorizontal2 = _a2.isHorizontal, thumbOffset = _a2.thumbOffset;
      e3.preventDefault();
      var clientX = _this.isMobile ? get(e3, "touches.0.clientX") : e3.clientX;
      var clientY = _this.isMobile ? get(e3, "touches.0.clientY") : e3.clientY;
      var endPos = isHorizontal2 ? clientX : clientY;
      var diff2 = endPos - _this.startPos;
      _this.startPos = endPos;
      _this.updateThumbOffset(thumbOffset + diff2);
    };
    _this.onMouseUp = function(e3) {
      e3.preventDefault();
      _this.clearEvents();
    };
    _this.onTrackClick = function(e3) {
      var _a2 = _this.cfg, isHorizontal2 = _a2.isHorizontal, x2 = _a2.x, y2 = _a2.y, thumbLen = _a2.thumbLen;
      var containerDOM = _this.getContainerDOM();
      var rect2 = containerDOM.getBoundingClientRect();
      var clientX = e3.clientX, clientY = e3.clientY;
      var offset3 = isHorizontal2 ? clientX - rect2.left - x2 - thumbLen / 2 : clientY - rect2.top - y2 - thumbLen / 2;
      var newOffset = _this.validateRange(offset3);
      _this.updateThumbOffset(newOffset);
    };
    _this.onThumbMouseOver = function() {
      var thumbColor = _this.cfg.theme.hover.thumbColor;
      _this.getElementByLocalId("thumb").attr("stroke", thumbColor);
      _this.draw();
    };
    _this.onThumbMouseOut = function() {
      var thumbColor = _this.cfg.theme.default.thumbColor;
      _this.getElementByLocalId("thumb").attr("stroke", thumbColor);
      _this.draw();
    };
    return _this;
  }
  Scrollbar2.prototype.setRange = function(min2, max2) {
    this.set("minLimit", min2);
    this.set("maxLimit", max2);
    var curValue = this.getValue();
    var newValue = clamp(curValue, min2, max2);
    if (curValue !== newValue && !this.get("isInit")) {
      this.setValue(newValue);
    }
  };
  Scrollbar2.prototype.getRange = function() {
    var min2 = this.get("minLimit") || 0;
    var max2 = this.get("maxLimit") || 1;
    return { min: min2, max: max2 };
  };
  Scrollbar2.prototype.setValue = function(value2) {
    var range3 = this.getRange();
    var originalValue = this.getValue();
    this.update({
      thumbOffset: (this.get("trackLen") - this.get("thumbLen")) * clamp(value2, range3.min, range3.max)
    });
    this.delegateEmit("valuechange", {
      originalValue,
      value: this.getValue()
    });
  };
  Scrollbar2.prototype.getValue = function() {
    return clamp(this.get("thumbOffset") / (this.get("trackLen") - this.get("thumbLen")), 0, 1);
  };
  Scrollbar2.prototype.getDefaultCfg = function() {
    var cfg = _super.prototype.getDefaultCfg.call(this);
    return __assign$4(__assign$4({}, cfg), { name: "scrollbar", isHorizontal: true, minThumbLen: 20, thumbOffset: 0, theme: DEFAULT_THEME });
  };
  Scrollbar2.prototype.renderInner = function(group2) {
    this.renderTrackShape(group2);
    this.renderThumbShape(group2);
  };
  Scrollbar2.prototype.applyOffset = function() {
    this.moveElementTo(this.get("group"), {
      x: this.get("x"),
      y: this.get("y")
    });
  };
  Scrollbar2.prototype.initEvent = function() {
    this.bindEvents();
  };
  Scrollbar2.prototype.renderTrackShape = function(group2) {
    var _a2 = this.cfg, trackLen = _a2.trackLen, _b = _a2.theme, theme2 = _b === void 0 ? { default: {} } : _b;
    var _c = deepMix({}, DEFAULT_THEME, theme2).default, lineCap = _c.lineCap, trackColor = _c.trackColor, themeSize = _c.size;
    var size2 = get(this.cfg, "size", themeSize);
    var attrs = this.get("isHorizontal") ? {
      x1: 0 + size2 / 2,
      y1: size2 / 2,
      x2: trackLen - size2 / 2,
      y2: size2 / 2,
      lineWidth: size2,
      stroke: trackColor,
      lineCap
    } : {
      x1: size2 / 2,
      y1: 0 + size2 / 2,
      x2: size2 / 2,
      y2: trackLen - size2 / 2,
      lineWidth: size2,
      stroke: trackColor,
      lineCap
    };
    return this.addShape(group2, {
      id: this.getElementId("track"),
      name: "track",
      type: "line",
      attrs
    });
  };
  Scrollbar2.prototype.renderThumbShape = function(group2) {
    var _a2 = this.cfg, thumbOffset = _a2.thumbOffset, thumbLen = _a2.thumbLen, theme2 = _a2.theme;
    var _b = deepMix({}, DEFAULT_THEME, theme2).default, themeSize = _b.size, lineCap = _b.lineCap, thumbColor = _b.thumbColor;
    var size2 = get(this.cfg, "size", themeSize);
    var attrs = this.get("isHorizontal") ? {
      x1: thumbOffset + size2 / 2,
      y1: size2 / 2,
      x2: thumbOffset + thumbLen - size2 / 2,
      y2: size2 / 2,
      lineWidth: size2,
      stroke: thumbColor,
      lineCap,
      cursor: "default"
    } : {
      x1: size2 / 2,
      y1: thumbOffset + size2 / 2,
      x2: size2 / 2,
      y2: thumbOffset + thumbLen - size2 / 2,
      lineWidth: size2,
      stroke: thumbColor,
      lineCap,
      cursor: "default"
    };
    return this.addShape(group2, {
      id: this.getElementId("thumb"),
      name: "thumb",
      type: "line",
      attrs
    });
  };
  Scrollbar2.prototype.bindEvents = function() {
    var group2 = this.get("group");
    group2.on("mousedown", this.onStartEvent(false));
    group2.on("mouseup", this.onMouseUp);
    group2.on("touchstart", this.onStartEvent(true));
    group2.on("touchend", this.onMouseUp);
    var trackShape = group2.findById(this.getElementId("track"));
    trackShape.on("click", this.onTrackClick);
    var thumbShape = group2.findById(this.getElementId("thumb"));
    thumbShape.on("mouseover", this.onThumbMouseOver);
    thumbShape.on("mouseout", this.onThumbMouseOut);
  };
  Scrollbar2.prototype.getContainerDOM = function() {
    var container = this.get("container");
    var canvas = container && container.get("canvas");
    return canvas && canvas.get("container");
  };
  Scrollbar2.prototype.validateRange = function(offset3) {
    var _a2 = this.cfg, thumbLen = _a2.thumbLen, trackLen = _a2.trackLen;
    var newOffset = offset3;
    if (offset3 + thumbLen > trackLen) {
      newOffset = trackLen - thumbLen;
    } else if (offset3 + thumbLen < thumbLen) {
      newOffset = 0;
    }
    return newOffset;
  };
  Scrollbar2.prototype.draw = function() {
    var container = this.get("container");
    var canvas = container && container.get("canvas");
    if (canvas) {
      canvas.draw();
    }
  };
  Scrollbar2.prototype.updateThumbOffset = function(offset3) {
    var _a2 = this.cfg, thumbOffset = _a2.thumbOffset, isHorizontal2 = _a2.isHorizontal, thumbLen = _a2.thumbLen, size2 = _a2.size;
    var newOffset = this.validateRange(offset3);
    if (newOffset === thumbOffset) {
      return;
    }
    var thumbShape = this.getElementByLocalId("thumb");
    if (isHorizontal2) {
      thumbShape.attr({
        x1: newOffset + size2 / 2,
        x2: newOffset + thumbLen - size2 / 2
      });
    } else {
      thumbShape.attr({
        y1: newOffset + size2 / 2,
        y2: newOffset + thumbLen - size2 / 2
      });
    }
    this.emitOffsetChange(newOffset);
  };
  Scrollbar2.prototype.emitOffsetChange = function(offset3) {
    var _a2 = this.cfg, originalValue = _a2.thumbOffset, trackLen = _a2.trackLen, thumbLen = _a2.thumbLen;
    this.cfg.thumbOffset = offset3;
    this.emit("scrollchange", {
      thumbOffset: offset3,
      ratio: clamp(offset3 / (trackLen - thumbLen), 0, 1)
    });
    this.delegateEmit("valuechange", {
      originalValue,
      value: offset3
    });
  };
  return Scrollbar2;
}(GroupComponent);
var LineAxis = Line$8, CircleAxis = Circle$6;
var LineGrid = Line$7, CircleGrid = Circle$5;
var CategoryLegend = Category, ContinuousLegend = ContinueLegend;
var HtmlTooltip = Tooltip$1;
function getPointsBox(points2) {
  if (isEmpty(points2)) {
    return null;
  }
  var minX = points2[0].x;
  var maxX = points2[0].x;
  var minY = points2[0].y;
  var maxY2 = points2[0].y;
  each$1(points2, function(point2) {
    minX = minX > point2.x ? point2.x : minX;
    maxX = maxX < point2.x ? point2.x : maxX;
    minY = minY > point2.y ? point2.y : minY;
    maxY2 = maxY2 < point2.y ? point2.y : maxY2;
  });
  return {
    minX,
    maxX,
    minY,
    maxY: maxY2,
    centerX: (minX + maxX) / 2,
    centerY: (minY + maxY2) / 2
  };
}
function uniqueValues(array4) {
  return Array.from(new Set(array4)).length === 1;
}
function mid(array4) {
  return (min$2(array4) + max$2(array4)) / 2;
}
function polarToCartesian(centerX, centerY, radius, angleInRadian) {
  return {
    x: centerX + radius * Math.cos(angleInRadian),
    y: centerY + radius * Math.sin(angleInRadian)
  };
}
function getSectorPath(centerX, centerY, radius, startAngleInRadian, endAngleInRadian, innerRadius) {
  if (innerRadius === void 0) {
    innerRadius = 0;
  }
  var start = polarToCartesian(centerX, centerY, radius, startAngleInRadian);
  var end = polarToCartesian(centerX, centerY, radius, endAngleInRadian);
  var innerStart = polarToCartesian(centerX, centerY, innerRadius, startAngleInRadian);
  var innerEnd = polarToCartesian(centerX, centerY, innerRadius, endAngleInRadian);
  if (endAngleInRadian - startAngleInRadian === Math.PI * 2) {
    var middlePoint = polarToCartesian(centerX, centerY, radius, startAngleInRadian + Math.PI);
    var innerMiddlePoint = polarToCartesian(centerX, centerY, innerRadius, startAngleInRadian + Math.PI);
    var circlePathCommands = [
      ["M", start.x, start.y],
      ["A", radius, radius, 0, 1, 1, middlePoint.x, middlePoint.y],
      ["A", radius, radius, 0, 1, 1, end.x, end.y],
      ["M", innerStart.x, innerStart.y]
    ];
    if (innerRadius) {
      circlePathCommands.push(["A", innerRadius, innerRadius, 0, 1, 0, innerMiddlePoint.x, innerMiddlePoint.y]);
      circlePathCommands.push(["A", innerRadius, innerRadius, 0, 1, 0, innerEnd.x, innerEnd.y]);
    }
    circlePathCommands.push(["M", start.x, start.y]);
    circlePathCommands.push(["Z"]);
    return circlePathCommands;
  }
  var arcSweep = endAngleInRadian - startAngleInRadian <= Math.PI ? 0 : 1;
  var sectorPathCommands = [
    ["M", start.x, start.y],
    ["A", radius, radius, 0, arcSweep, 1, end.x, end.y],
    ["L", innerEnd.x, innerEnd.y]
  ];
  if (innerRadius) {
    sectorPathCommands.push(["A", innerRadius, innerRadius, 0, arcSweep, 0, innerStart.x, innerStart.y]);
  }
  sectorPathCommands.push(["L", start.x, start.y]);
  sectorPathCommands.push(["Z"]);
  return sectorPathCommands;
}
function getArcPath(centerX, centerY, radius, startAngleInRadian, endAngleInRadian) {
  var start = polarToCartesian(centerX, centerY, radius, startAngleInRadian);
  var end = polarToCartesian(centerX, centerY, radius, endAngleInRadian);
  if (isNumberEqual$1(endAngleInRadian - startAngleInRadian, Math.PI * 2)) {
    var middlePoint = polarToCartesian(centerX, centerY, radius, startAngleInRadian + Math.PI);
    return [
      ["M", start.x, start.y],
      ["A", radius, radius, 0, 1, 1, middlePoint.x, middlePoint.y],
      ["A", radius, radius, 0, 1, 1, start.x, start.y],
      ["A", radius, radius, 0, 1, 0, middlePoint.x, middlePoint.y],
      ["A", radius, radius, 0, 1, 0, start.x, start.y],
      ["Z"]
    ];
  }
  var arcSweep = endAngleInRadian - startAngleInRadian <= Math.PI ? 0 : 1;
  return [
    ["M", start.x, start.y],
    ["A", radius, radius, 0, arcSweep, 1, end.x, end.y]
  ];
}
function getAngle$1(shapeModel, coordinate2) {
  var points2 = shapeModel.points;
  var box2 = getPointsBox(points2);
  var endAngle;
  var startAngle;
  var coordStartAngle = coordinate2.startAngle, coordEndAngle = coordinate2.endAngle;
  var diffAngle = coordEndAngle - coordStartAngle;
  if (coordinate2.isTransposed) {
    endAngle = box2.maxY * diffAngle;
    startAngle = box2.minY * diffAngle;
  } else {
    endAngle = box2.maxX * diffAngle;
    startAngle = box2.minX * diffAngle;
  }
  endAngle += coordStartAngle;
  startAngle += coordStartAngle;
  return {
    startAngle,
    endAngle
  };
}
function getPolygonCentroid(xs, ys) {
  if (isNumber$1(xs) && isNumber$1(ys)) {
    return [xs, ys];
  }
  xs = xs;
  ys = ys;
  if (uniqueValues(xs) || uniqueValues(ys))
    return [mid(xs), mid(ys)];
  var i2 = -1;
  var x2 = 0;
  var y2 = 0;
  var former;
  var current = xs.length - 1;
  var diff2;
  var k2 = 0;
  while (++i2 < xs.length) {
    former = current;
    current = i2;
    k2 += diff2 = xs[former] * ys[current] - xs[current] * ys[former];
    x2 += (xs[former] + xs[current]) * diff2;
    y2 += (ys[former] + ys[current]) * diff2;
  }
  k2 *= 3;
  return [x2 / k2, y2 / k2];
}
function getReplaceAttrs(sourceShape, targetShape) {
  var originAttrs = sourceShape.attr();
  var newAttrs = targetShape.attr();
  each$1(originAttrs, function(v2, k2) {
    if (newAttrs[k2] === void 0) {
      newAttrs[k2] = void 0;
    }
  });
  return newAttrs;
}
function isBetween$1(value2, start, end) {
  var min2 = Math.min(start, end);
  var max2 = Math.max(start, end);
  return value2 >= min2 && value2 <= max2;
}
function padEnd(source, targetLength, padValue) {
  if (isString(source)) {
    return source.padEnd(targetLength, padValue);
  } else if (isArray$1(source)) {
    var sourceLength = source.length;
    if (sourceLength < targetLength) {
      var diff2 = targetLength - sourceLength;
      for (var i2 = 0; i2 < diff2; i2++) {
        source.push(padValue);
      }
    }
  }
  return source;
}
function omit(obj, keys2) {
  if (typeof obj === "object") {
    keys2.forEach(function(key2) {
      delete obj[key2];
    });
  }
  return obj;
}
function uniq$1(sourceArray, targetArray, map2) {
  var e_1, _a2;
  if (targetArray === void 0) {
    targetArray = [];
  }
  if (map2 === void 0) {
    map2 = /* @__PURE__ */ new Map();
  }
  try {
    for (var sourceArray_1 = __values(sourceArray), sourceArray_1_1 = sourceArray_1.next(); !sourceArray_1_1.done; sourceArray_1_1 = sourceArray_1.next()) {
      var source = sourceArray_1_1.value;
      if (!map2.has(source)) {
        targetArray.push(source);
        map2.set(source, true);
      }
    }
  } catch (e_1_1) {
    e_1 = { error: e_1_1 };
  } finally {
    try {
      if (sourceArray_1_1 && !sourceArray_1_1.done && (_a2 = sourceArray_1.return))
        _a2.call(sourceArray_1);
    } finally {
      if (e_1)
        throw e_1.error;
    }
  }
  return targetArray;
}
var BBox = function() {
  function BBox2(x2, y2, width, height) {
    if (x2 === void 0) {
      x2 = 0;
    }
    if (y2 === void 0) {
      y2 = 0;
    }
    if (width === void 0) {
      width = 0;
    }
    if (height === void 0) {
      height = 0;
    }
    this.x = x2;
    this.y = y2;
    this.height = height;
    this.width = width;
  }
  BBox2.fromRange = function(minX, minY, maxX, maxY2) {
    return new BBox2(minX, minY, maxX - minX, maxY2 - minY);
  };
  BBox2.fromObject = function(bbox) {
    return new BBox2(bbox.minX, bbox.minY, bbox.width, bbox.height);
  };
  Object.defineProperty(BBox2.prototype, "minX", {
    get: function() {
      return this.x;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BBox2.prototype, "maxX", {
    get: function() {
      return this.x + this.width;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BBox2.prototype, "minY", {
    get: function() {
      return this.y;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BBox2.prototype, "maxY", {
    get: function() {
      return this.y + this.height;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BBox2.prototype, "tl", {
    get: function() {
      return { x: this.x, y: this.y };
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BBox2.prototype, "tr", {
    get: function() {
      return { x: this.maxX, y: this.y };
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BBox2.prototype, "bl", {
    get: function() {
      return { x: this.x, y: this.maxY };
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BBox2.prototype, "br", {
    get: function() {
      return { x: this.maxX, y: this.maxY };
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BBox2.prototype, "top", {
    get: function() {
      return {
        x: this.x + this.width / 2,
        y: this.minY
      };
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BBox2.prototype, "right", {
    get: function() {
      return {
        x: this.maxX,
        y: this.y + this.height / 2
      };
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BBox2.prototype, "bottom", {
    get: function() {
      return {
        x: this.x + this.width / 2,
        y: this.maxY
      };
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BBox2.prototype, "left", {
    get: function() {
      return {
        x: this.minX,
        y: this.y + this.height / 2
      };
    },
    enumerable: false,
    configurable: true
  });
  BBox2.prototype.isEqual = function(bbox) {
    return this.x === bbox.x && this.y === bbox.y && this.width === bbox.width && this.height === bbox.height;
  };
  BBox2.prototype.contains = function(child) {
    return child.minX >= this.minX && child.maxX <= this.maxX && child.minY >= this.minY && child.maxY <= this.maxY;
  };
  BBox2.prototype.clone = function() {
    return new BBox2(this.x, this.y, this.width, this.height);
  };
  BBox2.prototype.add = function() {
    var subBBox = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      subBBox[_i] = arguments[_i];
    }
    var bbox = this.clone();
    each$1(subBBox, function(b10) {
      bbox.x = Math.min(b10.x, bbox.x);
      bbox.y = Math.min(b10.y, bbox.y);
      bbox.width = Math.max(b10.maxX, bbox.maxX) - bbox.x;
      bbox.height = Math.max(b10.maxY, bbox.maxY) - bbox.y;
    });
    return bbox;
  };
  BBox2.prototype.merge = function() {
    var subBBox = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      subBBox[_i] = arguments[_i];
    }
    var bbox = this.clone();
    each$1(subBBox, function(b10) {
      bbox.x = Math.max(b10.x, bbox.x);
      bbox.y = Math.max(b10.y, bbox.y);
      bbox.width = Math.min(b10.maxX, bbox.maxX) - bbox.x;
      bbox.height = Math.min(b10.maxY, bbox.maxY) - bbox.y;
    });
    return bbox;
  };
  BBox2.prototype.cut = function(subBBox, direction2) {
    var width = subBBox.width;
    var height = subBBox.height;
    switch (direction2) {
      case DIRECTION.TOP:
      case DIRECTION.TOP_LEFT:
      case DIRECTION.TOP_RIGHT:
        return BBox2.fromRange(this.minX, this.minY + height, this.maxX, this.maxY);
      case DIRECTION.RIGHT:
      case DIRECTION.RIGHT_TOP:
      case DIRECTION.RIGHT_BOTTOM:
        return BBox2.fromRange(this.minX, this.minY, this.maxX - width, this.maxY);
      case DIRECTION.BOTTOM:
      case DIRECTION.BOTTOM_LEFT:
      case DIRECTION.BOTTOM_RIGHT:
        return BBox2.fromRange(this.minX, this.minY, this.maxX, this.maxY - height);
      case DIRECTION.LEFT:
      case DIRECTION.LEFT_TOP:
      case DIRECTION.LEFT_BOTTOM:
        return BBox2.fromRange(this.minX + width, this.minY, this.maxX, this.maxY);
      default:
        return this;
    }
  };
  BBox2.prototype.shrink = function(gap) {
    var _a2 = __read(gap, 4), top = _a2[0], right2 = _a2[1], bottom = _a2[2], left2 = _a2[3];
    return new BBox2(this.x + left2, this.y + top, this.width - left2 - right2, this.height - top - bottom);
  };
  BBox2.prototype.expand = function(gap) {
    var _a2 = __read(gap, 4), top = _a2[0], right2 = _a2[1], bottom = _a2[2], left2 = _a2[3];
    return new BBox2(this.x - left2, this.y - top, this.width + left2 + right2, this.height + top + bottom);
  };
  BBox2.prototype.exceed = function(bbox) {
    return [
      Math.max(-this.minY + bbox.minY, 0),
      Math.max(this.maxX - bbox.maxX, 0),
      Math.max(this.maxY - bbox.maxY, 0),
      Math.max(-this.minX + bbox.minX, 0)
    ];
  };
  BBox2.prototype.collide = function(bbox) {
    return this.minX < bbox.maxX && this.maxX > bbox.minX && this.minY < bbox.maxY && this.maxY > bbox.minY;
  };
  BBox2.prototype.size = function() {
    return this.width * this.height;
  };
  BBox2.prototype.isPointIn = function(p2) {
    return p2.x >= this.minX && p2.x <= this.maxX && p2.y >= this.minY && p2.y <= this.maxY;
  };
  return BBox2;
}();
function toPoints(bbox) {
  return [
    [bbox.minX, bbox.minY],
    [bbox.maxX, bbox.minY],
    [bbox.maxX, bbox.maxY],
    [bbox.minX, bbox.maxY]
  ];
}
function getXDimensionLength(coordinate2) {
  if (coordinate2.isPolar && !coordinate2.isTransposed) {
    return (coordinate2.endAngle - coordinate2.startAngle) * coordinate2.getRadius();
  }
  var start = coordinate2.convert({ x: 0, y: 0 });
  var end = coordinate2.convert({ x: 1, y: 0 });
  return Math.sqrt(Math.pow(end.x - start.x, 2) + Math.pow(end.y - start.y, 2));
}
function isFullCircle(coordinate2) {
  if (coordinate2.isPolar) {
    var startAngle = coordinate2.startAngle, endAngle = coordinate2.endAngle;
    return endAngle - startAngle === Math.PI * 2;
  }
  return false;
}
function getDistanceToCenter(coordinate2, point2) {
  var center2 = coordinate2.getCenter();
  return Math.sqrt(Math.pow(point2.x - center2.x, 2) + Math.pow(point2.y - center2.y, 2));
}
function isPointInCoordinate(coordinate2, point2) {
  var result = false;
  if (coordinate2) {
    if (coordinate2.type === "theta") {
      var start = coordinate2.start, end = coordinate2.end;
      result = isBetween$1(point2.x, start.x, end.x) && isBetween$1(point2.y, start.y, end.y);
    } else {
      var invertPoint = coordinate2.invert(point2);
      result = isBetween$1(invertPoint.x, 0, 1) && isBetween$1(invertPoint.y, 0, 1);
    }
  }
  return result;
}
function getAngleByPoint(coordinate2, point2) {
  var center2 = coordinate2.getCenter();
  return Math.atan2(point2.y - center2.y, point2.x - center2.x);
}
function getCoordinateClipCfg(coordinate2, margin) {
  if (margin === void 0) {
    margin = 0;
  }
  var start = coordinate2.start, end = coordinate2.end;
  var width = coordinate2.getWidth();
  var height = coordinate2.getHeight();
  if (coordinate2.isPolar) {
    var startAngle_1 = coordinate2.startAngle, endAngle_1 = coordinate2.endAngle;
    var center_1 = coordinate2.getCenter();
    var radius_1 = coordinate2.getRadius();
    return {
      type: "path",
      startState: {
        path: getSectorPath(center_1.x, center_1.y, radius_1 + margin, startAngle_1, startAngle_1)
      },
      endState: function(ratio) {
        var diff2 = (endAngle_1 - startAngle_1) * ratio + startAngle_1;
        var path2 = getSectorPath(center_1.x, center_1.y, radius_1 + margin, startAngle_1, diff2);
        return {
          path: path2
        };
      },
      attrs: {
        path: getSectorPath(center_1.x, center_1.y, radius_1 + margin, startAngle_1, endAngle_1)
      }
    };
  }
  var endState;
  if (coordinate2.isTransposed) {
    endState = {
      height: height + margin * 2
    };
  } else {
    endState = {
      width: width + margin * 2
    };
  }
  return {
    type: "rect",
    startState: {
      x: start.x - margin,
      y: end.y - margin,
      width: coordinate2.isTransposed ? width + margin * 2 : 0,
      height: coordinate2.isTransposed ? 0 : height + margin * 2
    },
    endState,
    attrs: {
      x: start.x - margin,
      y: end.y - margin,
      width: width + margin * 2,
      height: height + margin * 2
    }
  };
}
function getCoordinateBBox(coordinate2, margin) {
  if (margin === void 0) {
    margin = 0;
  }
  var start = coordinate2.start, end = coordinate2.end;
  var width = coordinate2.getWidth();
  var height = coordinate2.getHeight();
  var minX = Math.min(start.x, end.x);
  var minY = Math.min(start.y, end.y);
  return BBox.fromRange(minX - margin, minY - margin, minX + width + margin, minY + height + margin);
}
var dateRegex = /^(?:(?!0000)[0-9]{4}([-/.]+)(?:(?:0?[1-9]|1[0-2])\1(?:0?[1-9]|1[0-9]|2[0-8])|(?:0?[13-9]|1[0-2])\1(?:29|30)|(?:0?[13578]|1[02])\1(?:31))|(?:[0-9]{2}(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)([-/.]+)0?2\2(?:29))(\s+([01]|([01][0-9]|2[0-3])):([0-9]|[0-5][0-9]):([0-9]|[0-5][0-9]))?$/;
function getDefaultType(value2) {
  var type4 = "linear";
  if (dateRegex.test(value2)) {
    type4 = "timeCat";
  } else if (isString(value2)) {
    type4 = "cat";
  }
  return type4;
}
function inferScaleType(scale2, scaleDef, attrType, geometryType) {
  if (scaleDef === void 0) {
    scaleDef = {};
  }
  if (scaleDef.type)
    return scaleDef.type;
  if (scale2.type !== "identity" && GROUP_ATTRS.includes(attrType) && ["interval"].includes(geometryType)) {
    return "cat";
  }
  return scale2.isCategory ? "cat" : scale2.type;
}
function createScaleByField(field2, data2, scaleDef) {
  var validData = data2 || [];
  if (isNumber$1(field2) || isNil(firstValue(validData, field2)) && isEmpty(scaleDef)) {
    var Identity2 = getClass("identity");
    return new Identity2({
      field: field2.toString(),
      values: [field2]
    });
  }
  var values2 = valuesOfKey(validData, field2);
  var type4 = get(scaleDef, "type", getDefaultType(values2[0]));
  var ScaleCtor = getClass(type4);
  return new ScaleCtor(__assign$4({ field: field2, values: values2 }, scaleDef));
}
function syncScale(scale2, newScale) {
  if (scale2.type !== "identity" && newScale.type !== "identity") {
    var obj = {};
    for (var k2 in newScale) {
      if (Object.prototype.hasOwnProperty.call(newScale, k2)) {
        obj[k2] = newScale[k2];
      }
    }
    scale2.change(obj);
  }
}
function getName(scale2) {
  return scale2.alias || scale2.field;
}
function getDefaultCategoryScaleRange(scale2, coordinate2, theme2) {
  var values2 = scale2.values;
  var count2 = values2.length;
  var range3;
  if (count2 === 1) {
    range3 = [0.5, 1];
  } else {
    var widthRatio = 1;
    var offset3 = 0;
    if (isFullCircle(coordinate2)) {
      if (!coordinate2.isTransposed) {
        range3 = [0, 1 - 1 / count2];
      } else {
        widthRatio = get(theme2, "widthRatio.multiplePie", 1 / 1.3);
        offset3 = 1 / count2 * widthRatio;
        range3 = [offset3 / 2, 1 - offset3 / 2];
      }
    } else {
      offset3 = 1 / count2 / 2;
      range3 = [offset3, 1 - offset3];
    }
  }
  return range3;
}
function getMaxScale(scale2) {
  var values2 = scale2.values.filter(function(item) {
    return !isNil(item) && !isNaN(item);
  });
  return Math.max.apply(Math, __spreadArray$1(__spreadArray$1([], __read(values2), false), [isNil(scale2.max) ? -Infinity : scale2.max], false));
}
function getLineAxisRelativeRegion(direction2) {
  var start;
  var end;
  switch (direction2) {
    case DIRECTION.TOP:
      start = { x: 0, y: 1 };
      end = { x: 1, y: 1 };
      break;
    case DIRECTION.RIGHT:
      start = { x: 1, y: 0 };
      end = { x: 1, y: 1 };
      break;
    case DIRECTION.BOTTOM:
      start = { x: 0, y: 0 };
      end = { x: 1, y: 0 };
      break;
    case DIRECTION.LEFT:
      start = { x: 0, y: 0 };
      end = { x: 0, y: 1 };
      break;
    default:
      start = end = { x: 0, y: 0 };
  }
  return { start, end };
}
function getCircleAxisRelativeRegion(coordinate2) {
  var start;
  var end;
  if (coordinate2.isTransposed) {
    start = {
      x: 0,
      y: 0
    };
    end = {
      x: 1,
      y: 0
    };
  } else {
    start = {
      x: 0,
      y: 0
    };
    end = {
      x: 0,
      y: 1
    };
  }
  return { start, end };
}
function getAxisRegion(coordinate2, direction2) {
  var region = { start: { x: 0, y: 0 }, end: { x: 0, y: 0 } };
  if (coordinate2.isRect) {
    region = getLineAxisRelativeRegion(direction2);
  } else if (coordinate2.isPolar) {
    region = getCircleAxisRelativeRegion(coordinate2);
  }
  var start = region.start, end = region.end;
  return {
    start: coordinate2.convert(start),
    end: coordinate2.convert(end)
  };
}
function isVertical(region) {
  var start = region.start, end = region.end;
  return start.x === end.x;
}
function getAxisFactorByRegion(region, center2) {
  var start = region.start, end = region.end;
  var isAxisVertical = isVertical(region);
  if (isAxisVertical) {
    if ((start.y - end.y) * (center2.x - start.x) > 0) {
      return 1;
    } else {
      return -1;
    }
  } else {
    if ((end.x - start.x) * (start.y - center2.y) > 0) {
      return -1;
    } else {
      return 1;
    }
  }
}
function getAxisThemeCfg(theme2, direction2) {
  var axisTheme = get(theme2, ["components", "axis"], {});
  return deepMix({}, get(axisTheme, ["common"], {}), deepMix({}, get(axisTheme, [direction2], {})));
}
function getAxisTitleOptions(theme2, direction2, axisOptions) {
  var axisTheme = get(theme2, ["components", "axis"], {});
  return deepMix({}, get(axisTheme, ["common", "title"], {}), deepMix({}, get(axisTheme, [direction2, "title"], {})), axisOptions);
}
function getCircleAxisCenterRadius(coordinate2) {
  var x2 = coordinate2.x, y2 = coordinate2.y, center2 = coordinate2.circleCenter;
  var isReflectY = y2.start > y2.end;
  var start = coordinate2.isTransposed ? coordinate2.convert({
    x: isReflectY ? 0 : 1,
    y: 0
  }) : coordinate2.convert({
    x: 0,
    y: isReflectY ? 0 : 1
  });
  var startVector = [start.x - center2.x, start.y - center2.y];
  var normalVector = [1, 0];
  var startAngle = start.y > center2.y ? angle$1(startVector, normalVector) : angle$1(startVector, normalVector) * -1;
  var endAngle = startAngle + (x2.end - x2.start);
  var radius = Math.sqrt(Math.pow(start.x - center2.x, 2) + Math.pow(start.y - center2.y, 2));
  return {
    center: center2,
    radius,
    startAngle,
    endAngle
  };
}
function getAxisOption(axes, field2) {
  if (isBoolean(axes)) {
    return axes === false ? false : {};
  }
  return get(axes, [field2]);
}
function getAxisDirection(axisOption, def) {
  return get(axisOption, "position", def);
}
function getAxisTitleText(scale2, axisOption) {
  return get(axisOption, ["title", "text"], getName(scale2));
}
var Facet = function() {
  function Facet2(view, cfg) {
    this.destroyed = false;
    this.facets = [];
    this.view = view;
    this.cfg = deepMix({}, this.getDefaultCfg(), cfg);
  }
  Facet2.prototype.init = function() {
    if (!this.container) {
      this.container = this.createContainer();
    }
    var data2 = this.view.getData();
    this.facets = this.generateFacets(data2);
  };
  Facet2.prototype.render = function() {
    this.renderViews();
  };
  Facet2.prototype.update = function() {
  };
  Facet2.prototype.clear = function() {
    this.clearFacetViews();
  };
  Facet2.prototype.destroy = function() {
    this.clear();
    if (this.container) {
      this.container.remove(true);
      this.container = void 0;
    }
    this.destroyed = true;
    this.view = void 0;
    this.facets = [];
  };
  Facet2.prototype.facetToView = function(facet) {
    var region = facet.region, data2 = facet.data, _a2 = facet.padding, padding2 = _a2 === void 0 ? this.cfg.padding : _a2;
    var view = this.view.createView({
      region,
      padding: padding2
    });
    view.data(data2 || []);
    facet.view = view;
    this.beforeEachView(view, facet);
    var eachView = this.cfg.eachView;
    if (eachView) {
      eachView(view, facet);
    }
    this.afterEachView(view, facet);
    return view;
  };
  Facet2.prototype.createContainer = function() {
    var foregroundGroup = this.view.getLayer(LAYER.FORE);
    return foregroundGroup.addGroup();
  };
  Facet2.prototype.renderViews = function() {
    this.createFacetViews();
  };
  Facet2.prototype.createFacetViews = function() {
    var _this = this;
    return this.facets.map(function(facet) {
      return _this.facetToView(facet);
    });
  };
  Facet2.prototype.clearFacetViews = function() {
    var _this = this;
    each$1(this.facets, function(facet) {
      if (facet.view) {
        _this.view.removeView(facet.view);
        facet.view = void 0;
      }
    });
  };
  Facet2.prototype.parseSpacing = function() {
    var _a2 = this.view.viewBBox, width = _a2.width, height = _a2.height;
    var spacing = this.cfg.spacing;
    return spacing.map(function(s2, idx) {
      if (isNumber$1(s2))
        return s2 / (idx === 0 ? width : height);
      else
        return parseFloat(s2) / 100;
    });
  };
  Facet2.prototype.getFieldValues = function(data2, field2) {
    var rst = [];
    var cache2 = {};
    each$1(data2, function(d2) {
      var value2 = d2[field2];
      if (!isNil(value2) && !cache2[value2]) {
        rst.push(value2);
        cache2[value2] = true;
      }
    });
    return rst;
  };
  Facet2.prototype.getRegion = function(rows, cols, xIndex, yIndex) {
    var _a2 = __read(this.parseSpacing(), 2), xSpacing = _a2[0], ySpacing = _a2[1];
    var xRatio = (1 + xSpacing) / (cols === 0 ? 1 : cols) - xSpacing;
    var yRatio = (1 + ySpacing) / (rows === 0 ? 1 : rows) - ySpacing;
    var start = {
      x: (xRatio + xSpacing) * xIndex,
      y: (yRatio + ySpacing) * yIndex
    };
    var end = {
      x: start.x + xRatio,
      y: start.y + yRatio
    };
    return { start, end };
  };
  Facet2.prototype.getDefaultCfg = function() {
    return {
      eachView: void 0,
      showTitle: true,
      spacing: [0, 0],
      padding: 10,
      fields: []
    };
  };
  Facet2.prototype.getDefaultTitleCfg = function() {
    var fontFamily = this.view.getTheme().fontFamily;
    return {
      style: {
        fontSize: 14,
        fill: "#666",
        fontFamily
      }
    };
  };
  Facet2.prototype.processAxis = function(view, facet) {
    var options = view.getOptions();
    var coordinateOption = options.coordinate;
    var geometries = view.geometries;
    var coordinateType = get(coordinateOption, "type", "rect");
    if (coordinateType === "rect" && geometries.length) {
      if (isNil(options.axes)) {
        options.axes = {};
      }
      var axes = options.axes;
      var _a2 = __read(geometries[0].getXYFields(), 2), x2 = _a2[0], y2 = _a2[1];
      var xOption = getAxisOption(axes, x2);
      var yOption = getAxisOption(axes, y2);
      if (xOption !== false) {
        options.axes[x2] = this.getXAxisOption(x2, axes, xOption, facet);
      }
      if (yOption !== false) {
        options.axes[y2] = this.getYAxisOption(y2, axes, yOption, facet);
      }
    }
  };
  Facet2.prototype.getFacetDataFilter = function(conditions) {
    return function(datum) {
      return every(conditions, function(condition) {
        var field2 = condition.field, value2 = condition.value;
        if (!isNil(value2) && field2) {
          return datum[field2] === value2;
        }
        return true;
      });
    };
  };
  return Facet2;
}();
var Facets = {};
var getFacet = function(type4) {
  return Facets[lowerCase(type4)];
};
var registerFacet = function(type4, ctor) {
  Facets[lowerCase(type4)] = ctor;
};
var Action = function() {
  function Action2(context2, cfg) {
    this.context = context2;
    this.cfg = cfg;
    context2.addAction(this);
  }
  Action2.prototype.applyCfg = function(cfg) {
    mix(this, cfg);
  };
  Action2.prototype.init = function() {
    this.applyCfg(this.cfg);
  };
  Action2.prototype.destroy = function() {
    this.context.removeAction(this);
    this.context = null;
  };
  return Action2;
}();
var CallbackAction = function(_super) {
  __extends$3(CallbackAction2, _super);
  function CallbackAction2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  CallbackAction2.prototype.execute = function() {
    if (this.callback) {
      this.callback(this.context);
    }
  };
  CallbackAction2.prototype.destroy = function() {
    _super.prototype.destroy.call(this);
    this.callback = null;
  };
  return CallbackAction2;
}(Action);
var ActionCache = {};
function createAction(actionName, context2) {
  var actionOption = ActionCache[actionName];
  var action = null;
  if (actionOption) {
    var ActionClass = actionOption.ActionClass, cfg = actionOption.cfg;
    action = new ActionClass(context2, cfg);
    action.name = actionName;
    action.init();
  }
  return action;
}
function getActionClass(actionName) {
  var actionOption = ActionCache[actionName];
  return get(actionOption, "ActionClass");
}
function registerAction(actionName, ActionClass, cfg) {
  ActionCache[actionName] = {
    ActionClass,
    cfg
  };
}
function createCallbackAction(callback, context2) {
  var action = new CallbackAction(context2);
  action.callback = callback;
  action.name = "callback";
  return action;
}
function _points2path(points2, isInCircle) {
  var path2 = [];
  if (points2.length) {
    path2.push(["M", points2[0].x, points2[0].y]);
    for (var i2 = 1, length_1 = points2.length; i2 < length_1; i2 += 1) {
      var item = points2[i2];
      path2.push(["L", item.x, item.y]);
    }
    if (isInCircle) {
      path2.push(["Z"]);
    }
  }
  return path2;
}
function _convertArr(arr, coord2) {
  var tmp = [arr[0]];
  for (var i2 = 1, len = arr.length; i2 < len; i2 = i2 + 2) {
    var point2 = coord2.convert({
      x: arr[i2],
      y: arr[i2 + 1]
    });
    tmp.push(point2.x, point2.y);
  }
  return tmp;
}
function _convertArcPath(path2, coord2) {
  var isTransposed = coord2.isTransposed;
  var r2 = path2[1];
  var x2 = path2[6];
  var y2 = path2[7];
  var point2 = coord2.convert({ x: x2, y: y2 });
  var direction2 = isTransposed ? 0 : 1;
  return ["A", r2, r2, 0, 0, direction2, point2.x, point2.y];
}
function _convertPolarPath(pre, cur, coord2) {
  var isTransposed = coord2.isTransposed, startAngle = coord2.startAngle, endAngle = coord2.endAngle;
  var prePoint = pre[0].toLowerCase() === "a" ? {
    x: pre[6],
    y: pre[7]
  } : {
    x: pre[1],
    y: pre[2]
  };
  var curPoint = {
    x: cur[1],
    y: cur[2]
  };
  var rst = [];
  var xDim = isTransposed ? "y" : "x";
  var angleRange = Math.abs(curPoint[xDim] - prePoint[xDim]) * (endAngle - startAngle);
  var direction2 = curPoint[xDim] >= prePoint[xDim] ? 1 : 0;
  var flag = angleRange > Math.PI ? 1 : 0;
  var convertPoint = coord2.convert(curPoint);
  var r2 = getDistanceToCenter(coord2, convertPoint);
  if (r2 >= 0.5) {
    if (angleRange === Math.PI * 2) {
      var middlePoint = {
        x: (curPoint.x + prePoint.x) / 2,
        y: (curPoint.y + prePoint.y) / 2
      };
      var middleConvertPoint = coord2.convert(middlePoint);
      rst.push(["A", r2, r2, 0, flag, direction2, middleConvertPoint.x, middleConvertPoint.y]);
      rst.push(["A", r2, r2, 0, flag, direction2, convertPoint.x, convertPoint.y]);
    } else {
      rst.push(["A", r2, r2, 0, flag, direction2, convertPoint.x, convertPoint.y]);
    }
  }
  return rst;
}
function _filterFullCirleLine(path2) {
  each$1(path2, function(subPath, index2) {
    var cur = subPath;
    if (cur[0].toLowerCase() === "a") {
      var pre = path2[index2 - 1];
      var next = path2[index2 + 1];
      if (next && next[0].toLowerCase() === "a") {
        if (pre && pre[0].toLowerCase() === "l") {
          pre[0] = "M";
        }
      } else if (pre && pre[0].toLowerCase() === "a") {
        if (next && next[0].toLowerCase() === "l") {
          next[0] = "M";
        }
      }
    }
  });
}
var smoothBezier$1 = function(points2, smooth, isLoop, constraint) {
  var _a2;
  var cps = [];
  var hasConstraint = !!constraint;
  var prevPoint;
  var nextPoint;
  var min2;
  var max2;
  var nextCp0;
  var cp1;
  var cp0;
  if (hasConstraint) {
    _a2 = __read(constraint, 2), min2 = _a2[0], max2 = _a2[1];
    for (var i2 = 0, l2 = points2.length; i2 < l2; i2++) {
      var point2 = points2[i2];
      min2 = min$1([0, 0], min2, point2);
      max2 = max$1([0, 0], max2, point2);
    }
  }
  for (var i2 = 0, len = points2.length; i2 < len; i2++) {
    var point2 = points2[i2];
    if (i2 === 0 && !isLoop) {
      cp0 = point2;
    } else if (i2 === len - 1 && !isLoop) {
      cp1 = point2;
      cps.push(cp0);
      cps.push(cp1);
    } else {
      prevPoint = points2[isLoop ? i2 ? i2 - 1 : len - 1 : i2 - 1];
      nextPoint = points2[isLoop ? (i2 + 1) % len : i2 + 1];
      var v2 = [0, 0];
      v2 = sub(v2, nextPoint, prevPoint);
      v2 = scale$3(v2, v2, smooth);
      var d0 = distance$6(point2, prevPoint);
      var d1 = distance$6(point2, nextPoint);
      var sum = d0 + d1;
      if (sum !== 0) {
        d0 /= sum;
        d1 /= sum;
      }
      var v1 = scale$3([0, 0], v2, -d0);
      var v22 = scale$3([0, 0], v2, d1);
      cp1 = add([0, 0], point2, v1);
      nextCp0 = add([0, 0], point2, v22);
      nextCp0 = min$1([0, 0], nextCp0, max$1([0, 0], nextPoint, point2));
      nextCp0 = max$1([0, 0], nextCp0, min$1([0, 0], nextPoint, point2));
      v1 = sub([0, 0], nextCp0, point2);
      v1 = scale$3([0, 0], v1, -d0 / d1);
      cp1 = add([0, 0], point2, v1);
      cp1 = min$1([0, 0], cp1, max$1([0, 0], prevPoint, point2));
      cp1 = max$1([0, 0], cp1, min$1([0, 0], prevPoint, point2));
      v22 = sub([0, 0], point2, cp1);
      v22 = scale$3([0, 0], v22, d1 / d0);
      nextCp0 = add([0, 0], point2, v22);
      if (hasConstraint) {
        cp1 = max$1([0, 0], cp1, min2);
        cp1 = min$1([0, 0], cp1, max2);
        nextCp0 = max$1([0, 0], nextCp0, min2);
        nextCp0 = min$1([0, 0], nextCp0, max2);
      }
      cps.push(cp0);
      cps.push(cp1);
      cp0 = nextCp0;
    }
  }
  if (isLoop) {
    cps.push(cps.shift());
  }
  return cps;
};
function catmullRom2bezier$1(crp, z2, constraint) {
  var isLoop = !!z2;
  var pointList = [];
  for (var i2 = 0, l2 = crp.length; i2 < l2; i2 += 2) {
    pointList.push([crp[i2], crp[i2 + 1]]);
  }
  var controlPointList = smoothBezier$1(pointList, 0.4, isLoop, constraint);
  var len = pointList.length;
  var d1 = [];
  var cp1;
  var cp2;
  var p2;
  for (var i2 = 0; i2 < len - 1; i2++) {
    cp1 = controlPointList[i2 * 2];
    cp2 = controlPointList[i2 * 2 + 1];
    p2 = pointList[i2 + 1];
    d1.push(["C", cp1[0], cp1[1], cp2[0], cp2[1], p2[0], p2[1]]);
  }
  if (isLoop) {
    cp1 = controlPointList[len];
    cp2 = controlPointList[len + 1];
    p2 = pointList[0];
    d1.push(["C", cp1[0], cp1[1], cp2[0], cp2[1], p2[0], p2[1]]);
  }
  return d1;
}
function getLinePath(points2, isInCircle) {
  return _points2path(points2, isInCircle);
}
function getSplinePath$1(points2, isInCircle, constaint) {
  var data2 = [];
  var first = points2[0];
  var prePoint = null;
  if (points2.length <= 2) {
    return getLinePath(points2, isInCircle);
  }
  for (var i2 = 0, len = points2.length; i2 < len; i2++) {
    var point2 = points2[i2];
    if (!prePoint || !(prePoint.x === point2.x && prePoint.y === point2.y)) {
      data2.push(point2.x);
      data2.push(point2.y);
      prePoint = point2;
    }
  }
  var constraint = constaint || [
    [0, 0],
    [1, 1]
  ];
  var splinePath2 = catmullRom2bezier$1(data2, isInCircle, constraint);
  splinePath2.unshift(["M", first.x, first.y]);
  return splinePath2;
}
function convertNormalPath(coord2, path2) {
  var tmp = [];
  each$1(path2, function(subPath) {
    var action = subPath[0];
    switch (action.toLowerCase()) {
      case "m":
      case "l":
      case "c":
        tmp.push(_convertArr(subPath, coord2));
        break;
      case "a":
        tmp.push(_convertArcPath(subPath, coord2));
        break;
      case "z":
      default:
        tmp.push(subPath);
        break;
    }
  });
  return tmp;
}
function convertPolarPath(coord2, path2) {
  var tmp = [];
  var pre;
  var cur;
  var transposed;
  var equals;
  each$1(path2, function(subPath, index2) {
    var action = subPath[0];
    switch (action.toLowerCase()) {
      case "m":
      case "c":
      case "q":
        tmp.push(_convertArr(subPath, coord2));
        break;
      case "l":
        pre = path2[index2 - 1];
        cur = subPath;
        transposed = coord2.isTransposed;
        equals = transposed ? pre[pre.length - 2] === cur[1] : pre[pre.length - 1] === cur[2];
        if (equals) {
          tmp = tmp.concat(_convertPolarPath(pre, cur, coord2));
        } else {
          tmp.push(_convertArr(subPath, coord2));
        }
        break;
      case "a":
        tmp.push(_convertArcPath(subPath, coord2));
        break;
      case "z":
      default:
        tmp.push(subPath);
        break;
    }
  });
  _filterFullCirleLine(tmp);
  return tmp;
}
function getMaskBBox(context2, tolerance2) {
  var event = context2.event;
  var maskShape = event.target;
  var maskBBox = maskShape.getCanvasBBox();
  if (!(maskBBox.width >= tolerance2 || maskBBox.height >= tolerance2)) {
    return null;
  }
  return maskBBox;
}
function getMaskPath(context2, tolerance2) {
  var event = context2.event;
  var maskShape = event.target;
  var maskBBox = maskShape.getCanvasBBox();
  if (!(maskBBox.width >= tolerance2 || maskBBox.height >= tolerance2)) {
    return null;
  }
  return maskShape.attr("path");
}
function getCurrentElement$1(context2) {
  var event = context2.event;
  var element;
  var target = event.target;
  if (target) {
    element = target.get("element");
  }
  return element;
}
function getDelegationObject(context2) {
  var event = context2.event;
  var target = event.target;
  var delegateObject;
  if (target) {
    delegateObject = target.get("delegateObject");
  }
  return delegateObject;
}
function isElementChange(context2) {
  var event = context2.event.gEvent;
  if (event && event.fromShape && event.toShape && event.fromShape.get("element") === event.toShape.get("element")) {
    return false;
  }
  return true;
}
function isList(delegateObject) {
  return delegateObject && delegateObject.component && delegateObject.component.isList();
}
function isSlider(delegateObject) {
  return delegateObject && delegateObject.component && delegateObject.component.isSlider();
}
function isMask(context2) {
  var event = context2.event;
  var target = event.target;
  return target && target.get("name") === "mask";
}
function getMaskedElements(context2, tolerance2) {
  var target = context2.event.target;
  if (target.get("type") === "path") {
    var maskPath = getMaskPath(context2, tolerance2);
    if (!maskPath) {
      return;
    }
    return getElementsByPath(context2.view, maskPath);
  }
  var maskBBox = getMaskBBox(context2, tolerance2);
  if (!maskBBox) {
    return null;
  }
  return getIntersectElements(context2.view, maskBBox);
}
function getSiblingMaskElements(context2, sibling, tolerance2) {
  var maskBBox = getMaskBBox(context2, tolerance2);
  if (!maskBBox) {
    return null;
  }
  var view = context2.view;
  var start = getSiblingPoint(view, sibling, { x: maskBBox.x, y: maskBBox.y });
  var end = getSiblingPoint(view, sibling, { x: maskBBox.maxX, y: maskBBox.maxY });
  var box2 = {
    minX: start.x,
    minY: start.y,
    maxX: end.x,
    maxY: end.y
  };
  return getIntersectElements(sibling, box2);
}
function getElements(view) {
  var geometries = view.geometries;
  var rst = [];
  each$1(geometries, function(geom) {
    var elements = geom.elements;
    rst = rst.concat(elements);
  });
  if (view.views && view.views.length) {
    each$1(view.views, function(subView) {
      rst = rst.concat(getElements(subView));
    });
  }
  return rst;
}
function getElementsByField(view, field2, value2) {
  var elements = getElements(view);
  return elements.filter(function(el) {
    return getElementValue$1(el, field2) === value2;
  });
}
function getElementsByState(view, stateName) {
  var geometries = view.geometries;
  var rst = [];
  each$1(geometries, function(geom) {
    var elements = geom.getElementsBy(function(el) {
      return el.hasState(stateName);
    });
    rst = rst.concat(elements);
  });
  return rst;
}
function getElementValue$1(element, field2) {
  var model = element.getModel();
  var record = model.data;
  var value2;
  if (isArray$1(record)) {
    value2 = record[0][field2];
  } else {
    value2 = record[field2];
  }
  return value2;
}
function intersectRect$1(box1, box2) {
  return !(box2.minX > box1.maxX || box2.maxX < box1.minX || box2.minY > box1.maxY || box2.maxY < box1.minY);
}
function getIntersectElements(view, box2) {
  var elements = getElements(view);
  var rst = [];
  each$1(elements, function(el) {
    var shape = el.shape;
    var shapeBBox = shape.getCanvasBBox();
    if (intersectRect$1(box2, shapeBBox)) {
      rst.push(el);
    }
  });
  return rst;
}
function pathToPoints(path2) {
  var points2 = [];
  each$1(path2, function(seg) {
    var command = seg[0];
    if (command !== "A") {
      for (var i2 = 1; i2 < seg.length; i2 = i2 + 2) {
        points2.push([seg[i2], seg[i2 + 1]]);
      }
    } else {
      var length_1 = seg.length;
      points2.push([seg[length_1 - 2], seg[length_1 - 1]]);
    }
  });
  return points2;
}
function getElementsByPath(view, path2) {
  var elements = getElements(view);
  var points2 = pathToPoints(path2);
  var rst = elements.filter(function(el) {
    var shape = el.shape;
    var shapePoints;
    if (shape.get("type") === "path") {
      shapePoints = pathToPoints(shape.attr("path"));
    } else {
      var shapeBBox = shape.getCanvasBBox();
      shapePoints = toPoints(shapeBBox);
    }
    return isPolygonsIntersect(points2, shapePoints);
  });
  return rst;
}
function getComponents(view) {
  return view.getComponents().map(function(co) {
    return co.component;
  });
}
function distance$2(p1, p2) {
  var dx = p2.x - p1.x;
  var dy = p2.y - p1.y;
  return Math.sqrt(dx * dx + dy * dy);
}
function getSpline(points2, z2) {
  if (points2.length <= 2) {
    return getLinePath(points2, false);
  }
  var first = points2[0];
  var arr = [];
  each$1(points2, function(point2) {
    arr.push(point2.x);
    arr.push(point2.y);
  });
  var path2 = catmullRom2bezier$1(arr, z2, null);
  path2.unshift(["M", first.x, first.y]);
  return path2;
}
function isInBox(box2, point2) {
  return box2.x <= point2.x && box2.maxX >= point2.x && box2.y <= point2.y && box2.maxY > point2.y;
}
function getSilbings(view) {
  var parent = view.parent;
  var siblings2 = null;
  if (parent) {
    siblings2 = parent.views.filter(function(sub2) {
      return sub2 !== view;
    });
  }
  return siblings2;
}
function point2Normalize(view, point2) {
  var coord2 = view.getCoordinate();
  return coord2.invert(point2);
}
function getSiblingPoint(view, sibling, point2) {
  var normalPoint = point2Normalize(view, point2);
  return sibling.getCoordinate().convert(normalPoint);
}
function isInRecords(records, record, xFiled, yField) {
  var isIn = false;
  each$1(records, function(r2) {
    if (r2[xFiled] === record[xFiled] && r2[yField] === record[yField]) {
      isIn = true;
      return false;
    }
  });
  return isIn;
}
function getScaleByField(view, field2) {
  var scale2 = view.getScaleByField(field2);
  if (!scale2 && view.views) {
    each$1(view.views, function(subView) {
      scale2 = getScaleByField(subView, field2);
      if (scale2) {
        return false;
      }
    });
  }
  return scale2;
}
var Context = function() {
  function Context2(view) {
    this.actions = [];
    this.event = null;
    this.cacheMap = {};
    this.view = view;
  }
  Context2.prototype.cache = function() {
    var params = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      params[_i] = arguments[_i];
    }
    if (params.length === 1) {
      return this.cacheMap[params[0]];
    } else if (params.length === 2) {
      this.cacheMap[params[0]] = params[1];
    }
  };
  Context2.prototype.getAction = function(name) {
    return this.actions.find(function(action) {
      return action.name === name;
    });
  };
  Context2.prototype.addAction = function(action) {
    this.actions.push(action);
  };
  Context2.prototype.removeAction = function(action) {
    var actions = this.actions;
    var index2 = this.actions.indexOf(action);
    if (index2 >= 0) {
      actions.splice(index2, 1);
    }
  };
  Context2.prototype.getCurrentPoint = function() {
    var event = this.event;
    if (event) {
      if (event.target instanceof HTMLElement) {
        var canvas = this.view.getCanvas();
        var point2 = canvas.getPointByClient(event.clientX, event.clientY);
        return point2;
      } else {
        return {
          x: event.x,
          y: event.y
        };
      }
    }
    return null;
  };
  Context2.prototype.getCurrentShape = function() {
    return get(this.event, ["gEvent", "shape"]);
  };
  Context2.prototype.isInPlot = function() {
    var point2 = this.getCurrentPoint();
    if (point2) {
      return this.view.isPointInPlot(point2);
    }
    return false;
  };
  Context2.prototype.isInShape = function(name) {
    var shape = this.getCurrentShape();
    if (shape) {
      return shape.get("name") === name;
    }
    return false;
  };
  Context2.prototype.isInComponent = function(name) {
    var components = getComponents(this.view);
    var point2 = this.getCurrentPoint();
    if (point2) {
      return !!components.find(function(component2) {
        var bbox = component2.getBBox();
        if (name) {
          return component2.get("name") === name && isInBox(bbox, point2);
        } else {
          return isInBox(bbox, point2);
        }
      });
    }
    return false;
  };
  Context2.prototype.destroy = function() {
    each$1(this.actions.slice(), function(action) {
      action.destroy();
    });
    this.view = null;
    this.event = null;
    this.actions = null;
    this.cacheMap = null;
  };
  return Context2;
}();
var Interaction = function() {
  function Interaction2(view, cfg) {
    this.view = view;
    this.cfg = cfg;
  }
  Interaction2.prototype.init = function() {
    this.initEvents();
  };
  Interaction2.prototype.initEvents = function() {
  };
  Interaction2.prototype.clearEvents = function() {
  };
  Interaction2.prototype.destroy = function() {
    this.clearEvents();
  };
  return Interaction2;
}();
function parseAction(actionStr, context2, arg) {
  var arr = actionStr.split(":");
  var actionName = arr[0];
  var action = context2.getAction(actionName) || createAction(actionName, context2);
  if (!action) {
    throw new Error("There is no action named ".concat(actionName));
  }
  var methodName = arr[1];
  return {
    action,
    methodName,
    arg
  };
}
function executeAction(actionObject) {
  var action = actionObject.action, methodName = actionObject.methodName, arg = actionObject.arg;
  if (action[methodName]) {
    action[methodName](arg);
  } else {
    throw new Error("Action(".concat(action.name, ") doesn't have a method called ").concat(methodName));
  }
}
var STEP_NAMES = {
  START: "start",
  SHOW_ENABLE: "showEnable",
  END: "end",
  ROLLBACK: "rollback",
  PROCESSING: "processing"
};
var GrammarInteraction = function(_super) {
  __extends$3(GrammarInteraction2, _super);
  function GrammarInteraction2(view, steps) {
    var _this = _super.call(this, view, steps) || this;
    _this.callbackCaches = {};
    _this.emitCaches = {};
    _this.steps = steps;
    return _this;
  }
  GrammarInteraction2.prototype.init = function() {
    this.initContext();
    _super.prototype.init.call(this);
  };
  GrammarInteraction2.prototype.destroy = function() {
    _super.prototype.destroy.call(this);
    this.steps = null;
    if (this.context) {
      this.context.destroy();
      this.context = null;
    }
    this.callbackCaches = null;
    this.view = null;
  };
  GrammarInteraction2.prototype.initEvents = function() {
    var _this = this;
    each$1(this.steps, function(stepArr, stepName) {
      each$1(stepArr, function(step) {
        var callback = _this.getActionCallback(stepName, step);
        if (callback) {
          _this.bindEvent(step.trigger, callback);
        }
      });
    });
  };
  GrammarInteraction2.prototype.clearEvents = function() {
    var _this = this;
    each$1(this.steps, function(stepArr, stepName) {
      each$1(stepArr, function(step) {
        var callback = _this.getActionCallback(stepName, step);
        if (callback) {
          _this.offEvent(step.trigger, callback);
        }
      });
    });
  };
  GrammarInteraction2.prototype.initContext = function() {
    var view = this.view;
    var context2 = new Context(view);
    this.context = context2;
    var steps = this.steps;
    each$1(steps, function(subSteps) {
      each$1(subSteps, function(step) {
        if (isFunction(step.action)) {
          step.actionObject = {
            action: createCallbackAction(step.action, context2),
            methodName: "execute"
          };
        } else if (isString(step.action)) {
          step.actionObject = parseAction(step.action, context2, step.arg);
        } else if (isArray$1(step.action)) {
          var actionArr = step.action;
          var argArr_1 = isArray$1(step.arg) ? step.arg : [step.arg];
          step.actionObject = [];
          each$1(actionArr, function(actionStr, idx) {
            step.actionObject.push(parseAction(actionStr, context2, argArr_1[idx]));
          });
        }
      });
    });
  };
  GrammarInteraction2.prototype.isAllowStep = function(stepName) {
    var currentStepName = this.currentStepName;
    var steps = this.steps;
    if (currentStepName === stepName) {
      return true;
    }
    if (stepName === STEP_NAMES.SHOW_ENABLE) {
      return true;
    }
    if (stepName === STEP_NAMES.PROCESSING) {
      return currentStepName === STEP_NAMES.START;
    }
    if (stepName === STEP_NAMES.START) {
      return currentStepName !== STEP_NAMES.PROCESSING;
    }
    if (stepName === STEP_NAMES.END) {
      return currentStepName === STEP_NAMES.PROCESSING || currentStepName === STEP_NAMES.START;
    }
    if (stepName === STEP_NAMES.ROLLBACK) {
      if (steps[STEP_NAMES.END]) {
        return currentStepName === STEP_NAMES.END;
      } else if (currentStepName === STEP_NAMES.START) {
        return true;
      }
    }
    return false;
  };
  GrammarInteraction2.prototype.isAllowExecute = function(stepName, step) {
    if (this.isAllowStep(stepName)) {
      var key2 = this.getKey(stepName, step);
      if (step.once && this.emitCaches[key2]) {
        return false;
      }
      if (step.isEnable) {
        return step.isEnable(this.context);
      }
      return true;
    }
    return false;
  };
  GrammarInteraction2.prototype.enterStep = function(stepName) {
    this.currentStepName = stepName;
    this.emitCaches = {};
  };
  GrammarInteraction2.prototype.afterExecute = function(stepName, step) {
    if (stepName !== STEP_NAMES.SHOW_ENABLE && this.currentStepName !== stepName) {
      this.enterStep(stepName);
    }
    var key2 = this.getKey(stepName, step);
    this.emitCaches[key2] = true;
  };
  GrammarInteraction2.prototype.getKey = function(stepName, step) {
    return stepName + step.trigger + step.action;
  };
  GrammarInteraction2.prototype.getActionCallback = function(stepName, step) {
    var _this = this;
    var context2 = this.context;
    var callbackCaches = this.callbackCaches;
    var actionObject = step.actionObject;
    if (step.action && actionObject) {
      var key2 = this.getKey(stepName, step);
      if (!callbackCaches[key2]) {
        var actionCallback = function(event) {
          context2.event = event;
          if (_this.isAllowExecute(stepName, step)) {
            if (isArray$1(actionObject)) {
              each$1(actionObject, function(obj) {
                context2.event = event;
                executeAction(obj);
              });
            } else {
              context2.event = event;
              executeAction(actionObject);
            }
            _this.afterExecute(stepName, step);
            if (step.callback) {
              context2.event = event;
              step.callback(context2);
            }
          } else {
            context2.event = null;
          }
        };
        if (step.debounce) {
          callbackCaches[key2] = debounce$1(actionCallback, step.debounce.wait, step.debounce.immediate);
        } else if (step.throttle) {
          callbackCaches[key2] = throttle(actionCallback, step.throttle.wait, {
            leading: step.throttle.leading,
            trailing: step.throttle.trailing
          });
        } else {
          callbackCaches[key2] = actionCallback;
        }
      }
      return callbackCaches[key2];
    }
    return null;
  };
  GrammarInteraction2.prototype.bindEvent = function(eventName, callback) {
    var nameArr = eventName.split(":");
    if (nameArr[0] === "window") {
      window.addEventListener(nameArr[1], callback);
    } else if (nameArr[0] === "document") {
      document.addEventListener(nameArr[1], callback);
    } else {
      this.view.on(eventName, callback);
    }
  };
  GrammarInteraction2.prototype.offEvent = function(eventName, callback) {
    var nameArr = eventName.split(":");
    if (nameArr[0] === "window") {
      window.removeEventListener(nameArr[1], callback);
    } else if (nameArr[0] === "document") {
      document.removeEventListener(nameArr[1], callback);
    } else {
      this.view.off(eventName, callback);
    }
  };
  return GrammarInteraction2;
}(Interaction);
var Interactions = {};
function getInteraction(name) {
  return Interactions[lowerCase(name)];
}
function registerInteraction(name, interaction2) {
  Interactions[lowerCase(name)] = interaction2;
}
function createInteraction(name, view, cfg) {
  var interaciton = getInteraction(name);
  if (!interaciton) {
    return null;
  }
  if (isPlainObject$1(interaciton)) {
    var steps = mix(clone$1(interaciton), cfg);
    return new GrammarInteraction(view, steps);
  } else {
    var cls = interaciton;
    return new cls(view, cfg);
  }
}
function createAxisStyles(styleSheet) {
  return {
    title: {
      autoRotate: true,
      position: "center",
      spacing: styleSheet.axisTitleSpacing,
      style: {
        fill: styleSheet.axisTitleTextFillColor,
        fontSize: styleSheet.axisTitleTextFontSize,
        lineHeight: styleSheet.axisTitleTextLineHeight,
        textBaseline: "middle",
        fontFamily: styleSheet.fontFamily
      },
      iconStyle: {
        fill: styleSheet.axisDescriptionIconFillColor
      }
    },
    label: {
      autoRotate: false,
      autoEllipsis: false,
      autoHide: { type: "equidistance", cfg: { minGap: 6 } },
      offset: styleSheet.axisLabelOffset,
      style: {
        fill: styleSheet.axisLabelFillColor,
        fontSize: styleSheet.axisLabelFontSize,
        lineHeight: styleSheet.axisLabelLineHeight,
        fontFamily: styleSheet.fontFamily
      }
    },
    line: {
      style: {
        lineWidth: styleSheet.axisLineBorder,
        stroke: styleSheet.axisLineBorderColor
      }
    },
    grid: {
      line: {
        type: "line",
        style: {
          stroke: styleSheet.axisGridBorderColor,
          lineWidth: styleSheet.axisGridBorder,
          lineDash: styleSheet.axisGridLineDash
        }
      },
      alignTick: true,
      animate: true
    },
    tickLine: {
      style: {
        lineWidth: styleSheet.axisTickLineBorder,
        stroke: styleSheet.axisTickLineBorderColor
      },
      alignTick: true,
      length: styleSheet.axisTickLineLength
    },
    subTickLine: null,
    animate: true
  };
}
function createLegendStyles(styleSheet) {
  return {
    title: null,
    marker: {
      symbol: "circle",
      spacing: styleSheet.legendMarkerSpacing,
      style: {
        r: styleSheet.legendCircleMarkerSize,
        fill: styleSheet.legendMarkerColor
      }
    },
    itemName: {
      spacing: 5,
      style: {
        fill: styleSheet.legendItemNameFillColor,
        fontFamily: styleSheet.fontFamily,
        fontSize: styleSheet.legendItemNameFontSize,
        lineHeight: styleSheet.legendItemNameLineHeight,
        fontWeight: styleSheet.legendItemNameFontWeight,
        textAlign: "start",
        textBaseline: "middle"
      }
    },
    itemStates: {
      active: {
        nameStyle: {
          opacity: 0.8
        }
      },
      unchecked: {
        nameStyle: {
          fill: "#D8D8D8"
        },
        markerStyle: {
          fill: "#D8D8D8",
          stroke: "#D8D8D8"
        }
      },
      inactive: {
        nameStyle: {
          fill: "#D8D8D8"
        },
        markerStyle: {
          opacity: 0.2
        }
      }
    },
    flipPage: true,
    pageNavigator: {
      marker: {
        style: {
          size: styleSheet.legendPageNavigatorMarkerSize,
          inactiveFill: styleSheet.legendPageNavigatorMarkerInactiveFillColor,
          inactiveOpacity: styleSheet.legendPageNavigatorMarkerInactiveFillOpacity,
          fill: styleSheet.legendPageNavigatorMarkerFillColor,
          opacity: styleSheet.legendPageNavigatorMarkerFillOpacity
        }
      },
      text: {
        style: {
          fill: styleSheet.legendPageNavigatorTextFillColor,
          fontSize: styleSheet.legendPageNavigatorTextFontSize
        }
      }
    },
    animate: false,
    maxItemWidth: 200,
    itemSpacing: styleSheet.legendItemSpacing,
    itemMarginBottom: styleSheet.legendItemMarginBottom,
    padding: styleSheet.legendPadding
  };
}
function createThemeByStyleSheet(styleSheet) {
  var _a2;
  var shapeStyles = {
    point: {
      default: {
        fill: styleSheet.pointFillColor,
        r: styleSheet.pointSize,
        stroke: styleSheet.pointBorderColor,
        lineWidth: styleSheet.pointBorder,
        fillOpacity: styleSheet.pointFillOpacity
      },
      active: {
        stroke: styleSheet.pointActiveBorderColor,
        lineWidth: styleSheet.pointActiveBorder
      },
      selected: {
        stroke: styleSheet.pointSelectedBorderColor,
        lineWidth: styleSheet.pointSelectedBorder
      },
      inactive: {
        fillOpacity: styleSheet.pointInactiveFillOpacity,
        strokeOpacity: styleSheet.pointInactiveBorderOpacity
      }
    },
    hollowPoint: {
      default: {
        fill: styleSheet.hollowPointFillColor,
        lineWidth: styleSheet.hollowPointBorder,
        stroke: styleSheet.hollowPointBorderColor,
        strokeOpacity: styleSheet.hollowPointBorderOpacity,
        r: styleSheet.hollowPointSize
      },
      active: {
        stroke: styleSheet.hollowPointActiveBorderColor,
        strokeOpacity: styleSheet.hollowPointActiveBorderOpacity
      },
      selected: {
        lineWidth: styleSheet.hollowPointSelectedBorder,
        stroke: styleSheet.hollowPointSelectedBorderColor,
        strokeOpacity: styleSheet.hollowPointSelectedBorderOpacity
      },
      inactive: {
        strokeOpacity: styleSheet.hollowPointInactiveBorderOpacity
      }
    },
    area: {
      default: {
        fill: styleSheet.areaFillColor,
        fillOpacity: styleSheet.areaFillOpacity,
        stroke: null
      },
      active: {
        fillOpacity: styleSheet.areaActiveFillOpacity
      },
      selected: {
        fillOpacity: styleSheet.areaSelectedFillOpacity
      },
      inactive: {
        fillOpacity: styleSheet.areaInactiveFillOpacity
      }
    },
    hollowArea: {
      default: {
        fill: null,
        stroke: styleSheet.hollowAreaBorderColor,
        lineWidth: styleSheet.hollowAreaBorder,
        strokeOpacity: styleSheet.hollowAreaBorderOpacity
      },
      active: {
        fill: null,
        lineWidth: styleSheet.hollowAreaActiveBorder
      },
      selected: {
        fill: null,
        lineWidth: styleSheet.hollowAreaSelectedBorder
      },
      inactive: {
        strokeOpacity: styleSheet.hollowAreaInactiveBorderOpacity
      }
    },
    interval: {
      default: {
        fill: styleSheet.intervalFillColor,
        fillOpacity: styleSheet.intervalFillOpacity
      },
      active: {
        stroke: styleSheet.intervalActiveBorderColor,
        lineWidth: styleSheet.intervalActiveBorder
      },
      selected: {
        stroke: styleSheet.intervalSelectedBorderColor,
        lineWidth: styleSheet.intervalSelectedBorder
      },
      inactive: {
        fillOpacity: styleSheet.intervalInactiveFillOpacity,
        strokeOpacity: styleSheet.intervalInactiveBorderOpacity
      }
    },
    hollowInterval: {
      default: {
        fill: styleSheet.hollowIntervalFillColor,
        stroke: styleSheet.hollowIntervalBorderColor,
        lineWidth: styleSheet.hollowIntervalBorder,
        strokeOpacity: styleSheet.hollowIntervalBorderOpacity
      },
      active: {
        stroke: styleSheet.hollowIntervalActiveBorderColor,
        lineWidth: styleSheet.hollowIntervalActiveBorder,
        strokeOpacity: styleSheet.hollowIntervalActiveBorderOpacity
      },
      selected: {
        stroke: styleSheet.hollowIntervalSelectedBorderColor,
        lineWidth: styleSheet.hollowIntervalSelectedBorder,
        strokeOpacity: styleSheet.hollowIntervalSelectedBorderOpacity
      },
      inactive: {
        stroke: styleSheet.hollowIntervalInactiveBorderColor,
        lineWidth: styleSheet.hollowIntervalInactiveBorder,
        strokeOpacity: styleSheet.hollowIntervalInactiveBorderOpacity
      }
    },
    line: {
      default: {
        stroke: styleSheet.lineBorderColor,
        lineWidth: styleSheet.lineBorder,
        strokeOpacity: styleSheet.lineBorderOpacity,
        fill: null,
        lineAppendWidth: 10,
        lineCap: "round",
        lineJoin: "round"
      },
      active: {
        lineWidth: styleSheet.lineActiveBorder
      },
      selected: {
        lineWidth: styleSheet.lineSelectedBorder
      },
      inactive: {
        strokeOpacity: styleSheet.lineInactiveBorderOpacity
      }
    }
  };
  var axisStyles = createAxisStyles(styleSheet);
  var legendStyles = createLegendStyles(styleSheet);
  return {
    background: styleSheet.backgroundColor,
    defaultColor: styleSheet.brandColor,
    subColor: styleSheet.subColor,
    semanticRed: styleSheet.paletteSemanticRed,
    semanticGreen: styleSheet.paletteSemanticGreen,
    padding: "auto",
    fontFamily: styleSheet.fontFamily,
    columnWidthRatio: 1 / 2,
    maxColumnWidth: null,
    minColumnWidth: null,
    roseWidthRatio: 0.9999999,
    multiplePieWidthRatio: 1 / 1.3,
    colors10: styleSheet.paletteQualitative10,
    colors20: styleSheet.paletteQualitative20,
    sequenceColors: styleSheet.paletteSequence,
    shapes: {
      point: [
        "hollow-circle",
        "hollow-square",
        "hollow-bowtie",
        "hollow-diamond",
        "hollow-hexagon",
        "hollow-triangle",
        "hollow-triangle-down",
        "circle",
        "square",
        "bowtie",
        "diamond",
        "hexagon",
        "triangle",
        "triangle-down",
        "cross",
        "tick",
        "plus",
        "hyphen",
        "line"
      ],
      line: ["line", "dash", "dot", "smooth"],
      area: ["area", "smooth", "line", "smooth-line"],
      interval: ["rect", "hollow-rect", "line", "tick"]
    },
    sizes: [1, 10],
    geometries: {
      interval: {
        rect: {
          default: {
            style: shapeStyles.interval.default
          },
          active: {
            style: shapeStyles.interval.active
          },
          inactive: {
            style: shapeStyles.interval.inactive
          },
          selected: {
            style: function(element) {
              var coordinate2 = element.geometry.coordinate;
              if (coordinate2.isPolar && coordinate2.isTransposed) {
                var _a3 = getAngle$1(element.getModel(), coordinate2), startAngle = _a3.startAngle, endAngle = _a3.endAngle;
                var middleAngle = (startAngle + endAngle) / 2;
                var r2 = 7.5;
                var x2 = r2 * Math.cos(middleAngle);
                var y2 = r2 * Math.sin(middleAngle);
                return {
                  matrix: transform$6(null, [["t", x2, y2]])
                };
              }
              return shapeStyles.interval.selected;
            }
          }
        },
        "hollow-rect": {
          default: {
            style: shapeStyles.hollowInterval.default
          },
          active: {
            style: shapeStyles.hollowInterval.active
          },
          inactive: {
            style: shapeStyles.hollowInterval.inactive
          },
          selected: {
            style: shapeStyles.hollowInterval.selected
          }
        },
        line: {
          default: {
            style: shapeStyles.hollowInterval.default
          },
          active: {
            style: shapeStyles.hollowInterval.active
          },
          inactive: {
            style: shapeStyles.hollowInterval.inactive
          },
          selected: {
            style: shapeStyles.hollowInterval.selected
          }
        },
        tick: {
          default: {
            style: shapeStyles.hollowInterval.default
          },
          active: {
            style: shapeStyles.hollowInterval.active
          },
          inactive: {
            style: shapeStyles.hollowInterval.inactive
          },
          selected: {
            style: shapeStyles.hollowInterval.selected
          }
        },
        funnel: {
          default: {
            style: shapeStyles.interval.default
          },
          active: {
            style: shapeStyles.interval.active
          },
          inactive: {
            style: shapeStyles.interval.inactive
          },
          selected: {
            style: shapeStyles.interval.selected
          }
        },
        pyramid: {
          default: {
            style: shapeStyles.interval.default
          },
          active: {
            style: shapeStyles.interval.active
          },
          inactive: {
            style: shapeStyles.interval.inactive
          },
          selected: {
            style: shapeStyles.interval.selected
          }
        }
      },
      line: {
        line: {
          default: {
            style: shapeStyles.line.default
          },
          active: {
            style: shapeStyles.line.active
          },
          inactive: {
            style: shapeStyles.line.inactive
          },
          selected: {
            style: shapeStyles.line.selected
          }
        },
        dot: {
          default: {
            style: __assign$4(__assign$4({}, shapeStyles.line.default), { lineCap: null, lineDash: [1, 1] })
          },
          active: {
            style: __assign$4(__assign$4({}, shapeStyles.line.active), { lineCap: null, lineDash: [1, 1] })
          },
          inactive: {
            style: __assign$4(__assign$4({}, shapeStyles.line.inactive), { lineCap: null, lineDash: [1, 1] })
          },
          selected: {
            style: __assign$4(__assign$4({}, shapeStyles.line.selected), { lineCap: null, lineDash: [1, 1] })
          }
        },
        dash: {
          default: {
            style: __assign$4(__assign$4({}, shapeStyles.line.default), { lineCap: null, lineDash: [5.5, 1] })
          },
          active: {
            style: __assign$4(__assign$4({}, shapeStyles.line.active), { lineCap: null, lineDash: [5.5, 1] })
          },
          inactive: {
            style: __assign$4(__assign$4({}, shapeStyles.line.inactive), { lineCap: null, lineDash: [5.5, 1] })
          },
          selected: {
            style: __assign$4(__assign$4({}, shapeStyles.line.selected), { lineCap: null, lineDash: [5.5, 1] })
          }
        },
        smooth: {
          default: {
            style: shapeStyles.line.default
          },
          active: {
            style: shapeStyles.line.active
          },
          inactive: {
            style: shapeStyles.line.inactive
          },
          selected: {
            style: shapeStyles.line.selected
          }
        },
        hv: {
          default: {
            style: shapeStyles.line.default
          },
          active: {
            style: shapeStyles.line.active
          },
          inactive: {
            style: shapeStyles.line.inactive
          },
          selected: {
            style: shapeStyles.line.selected
          }
        },
        vh: {
          default: {
            style: shapeStyles.line.default
          },
          active: {
            style: shapeStyles.line.active
          },
          inactive: {
            style: shapeStyles.line.inactive
          },
          selected: {
            style: shapeStyles.line.selected
          }
        },
        hvh: {
          default: {
            style: shapeStyles.line.default
          },
          active: {
            style: shapeStyles.line.active
          },
          inactive: {
            style: shapeStyles.line.inactive
          },
          selected: {
            style: shapeStyles.line.selected
          }
        },
        vhv: {
          default: {
            style: shapeStyles.line.default
          },
          active: {
            style: shapeStyles.line.active
          },
          inactive: {
            style: shapeStyles.line.inactive
          },
          selected: {
            style: shapeStyles.line.selected
          }
        }
      },
      polygon: {
        polygon: {
          default: {
            style: shapeStyles.interval.default
          },
          active: {
            style: shapeStyles.interval.active
          },
          inactive: {
            style: shapeStyles.interval.inactive
          },
          selected: {
            style: shapeStyles.interval.selected
          }
        }
      },
      point: {
        circle: {
          default: {
            style: shapeStyles.point.default
          },
          active: {
            style: shapeStyles.point.active
          },
          inactive: {
            style: shapeStyles.point.inactive
          },
          selected: {
            style: shapeStyles.point.selected
          }
        },
        square: {
          default: {
            style: shapeStyles.point.default
          },
          active: {
            style: shapeStyles.point.active
          },
          inactive: {
            style: shapeStyles.point.inactive
          },
          selected: {
            style: shapeStyles.point.selected
          }
        },
        bowtie: {
          default: {
            style: shapeStyles.point.default
          },
          active: {
            style: shapeStyles.point.active
          },
          inactive: {
            style: shapeStyles.point.inactive
          },
          selected: {
            style: shapeStyles.point.selected
          }
        },
        diamond: {
          default: {
            style: shapeStyles.point.default
          },
          active: {
            style: shapeStyles.point.active
          },
          inactive: {
            style: shapeStyles.point.inactive
          },
          selected: {
            style: shapeStyles.point.selected
          }
        },
        hexagon: {
          default: {
            style: shapeStyles.point.default
          },
          active: {
            style: shapeStyles.point.active
          },
          inactive: {
            style: shapeStyles.point.inactive
          },
          selected: {
            style: shapeStyles.point.selected
          }
        },
        triangle: {
          default: {
            style: shapeStyles.point.default
          },
          active: {
            style: shapeStyles.point.active
          },
          inactive: {
            style: shapeStyles.point.inactive
          },
          selected: {
            style: shapeStyles.point.selected
          }
        },
        "triangle-down": {
          default: {
            style: shapeStyles.point.default
          },
          active: {
            style: shapeStyles.point.active
          },
          inactive: {
            style: shapeStyles.point.inactive
          },
          selected: {
            style: shapeStyles.point.selected
          }
        },
        "hollow-circle": {
          default: {
            style: shapeStyles.hollowPoint.default
          },
          active: {
            style: shapeStyles.hollowPoint.active
          },
          inactive: {
            style: shapeStyles.hollowPoint.inactive
          },
          selected: {
            style: shapeStyles.hollowPoint.selected
          }
        },
        "hollow-square": {
          default: {
            style: shapeStyles.hollowPoint.default
          },
          active: {
            style: shapeStyles.hollowPoint.active
          },
          inactive: {
            style: shapeStyles.hollowPoint.inactive
          },
          selected: {
            style: shapeStyles.hollowPoint.selected
          }
        },
        "hollow-bowtie": {
          default: {
            style: shapeStyles.hollowPoint.default
          },
          active: {
            style: shapeStyles.hollowPoint.active
          },
          inactive: {
            style: shapeStyles.hollowPoint.inactive
          },
          selected: {
            style: shapeStyles.hollowPoint.selected
          }
        },
        "hollow-diamond": {
          default: {
            style: shapeStyles.hollowPoint.default
          },
          active: {
            style: shapeStyles.hollowPoint.active
          },
          inactive: {
            style: shapeStyles.hollowPoint.inactive
          },
          selected: {
            style: shapeStyles.hollowPoint.selected
          }
        },
        "hollow-hexagon": {
          default: {
            style: shapeStyles.hollowPoint.default
          },
          active: {
            style: shapeStyles.hollowPoint.active
          },
          inactive: {
            style: shapeStyles.hollowPoint.inactive
          },
          selected: {
            style: shapeStyles.hollowPoint.selected
          }
        },
        "hollow-triangle": {
          default: {
            style: shapeStyles.hollowPoint.default
          },
          active: {
            style: shapeStyles.hollowPoint.active
          },
          inactive: {
            style: shapeStyles.hollowPoint.inactive
          },
          selected: {
            style: shapeStyles.hollowPoint.selected
          }
        },
        "hollow-triangle-down": {
          default: {
            style: shapeStyles.hollowPoint.default
          },
          active: {
            style: shapeStyles.hollowPoint.active
          },
          inactive: {
            style: shapeStyles.hollowPoint.inactive
          },
          selected: {
            style: shapeStyles.hollowPoint.selected
          }
        },
        cross: {
          default: {
            style: shapeStyles.hollowPoint.default
          },
          active: {
            style: shapeStyles.hollowPoint.active
          },
          inactive: {
            style: shapeStyles.hollowPoint.inactive
          },
          selected: {
            style: shapeStyles.hollowPoint.selected
          }
        },
        tick: {
          default: {
            style: shapeStyles.hollowPoint.default
          },
          active: {
            style: shapeStyles.hollowPoint.active
          },
          inactive: {
            style: shapeStyles.hollowPoint.inactive
          },
          selected: {
            style: shapeStyles.hollowPoint.selected
          }
        },
        plus: {
          default: {
            style: shapeStyles.hollowPoint.default
          },
          active: {
            style: shapeStyles.hollowPoint.active
          },
          inactive: {
            style: shapeStyles.hollowPoint.inactive
          },
          selected: {
            style: shapeStyles.hollowPoint.selected
          }
        },
        hyphen: {
          default: {
            style: shapeStyles.hollowPoint.default
          },
          active: {
            style: shapeStyles.hollowPoint.active
          },
          inactive: {
            style: shapeStyles.hollowPoint.inactive
          },
          selected: {
            style: shapeStyles.hollowPoint.selected
          }
        },
        line: {
          default: {
            style: shapeStyles.hollowPoint.default
          },
          active: {
            style: shapeStyles.hollowPoint.active
          },
          inactive: {
            style: shapeStyles.hollowPoint.inactive
          },
          selected: {
            style: shapeStyles.hollowPoint.selected
          }
        }
      },
      area: {
        area: {
          default: {
            style: shapeStyles.area.default
          },
          active: {
            style: shapeStyles.area.active
          },
          inactive: {
            style: shapeStyles.area.inactive
          },
          selected: {
            style: shapeStyles.area.selected
          }
        },
        smooth: {
          default: {
            style: shapeStyles.area.default
          },
          active: {
            style: shapeStyles.area.active
          },
          inactive: {
            style: shapeStyles.area.inactive
          },
          selected: {
            style: shapeStyles.area.selected
          }
        },
        line: {
          default: {
            style: shapeStyles.hollowArea.default
          },
          active: {
            style: shapeStyles.hollowArea.active
          },
          inactive: {
            style: shapeStyles.hollowArea.inactive
          },
          selected: {
            style: shapeStyles.hollowArea.selected
          }
        },
        "smooth-line": {
          default: {
            style: shapeStyles.hollowArea.default
          },
          active: {
            style: shapeStyles.hollowArea.active
          },
          inactive: {
            style: shapeStyles.hollowArea.inactive
          },
          selected: {
            style: shapeStyles.hollowArea.selected
          }
        }
      },
      schema: {
        candle: {
          default: {
            style: shapeStyles.hollowInterval.default
          },
          active: {
            style: shapeStyles.hollowInterval.active
          },
          inactive: {
            style: shapeStyles.hollowInterval.inactive
          },
          selected: {
            style: shapeStyles.hollowInterval.selected
          }
        },
        box: {
          default: {
            style: shapeStyles.hollowInterval.default
          },
          active: {
            style: shapeStyles.hollowInterval.active
          },
          inactive: {
            style: shapeStyles.hollowInterval.inactive
          },
          selected: {
            style: shapeStyles.hollowInterval.selected
          }
        }
      },
      edge: {
        line: {
          default: {
            style: shapeStyles.line.default
          },
          active: {
            style: shapeStyles.line.active
          },
          inactive: {
            style: shapeStyles.line.inactive
          },
          selected: {
            style: shapeStyles.line.selected
          }
        },
        vhv: {
          default: {
            style: shapeStyles.line.default
          },
          active: {
            style: shapeStyles.line.active
          },
          inactive: {
            style: shapeStyles.line.inactive
          },
          selected: {
            style: shapeStyles.line.selected
          }
        },
        smooth: {
          default: {
            style: shapeStyles.line.default
          },
          active: {
            style: shapeStyles.line.active
          },
          inactive: {
            style: shapeStyles.line.inactive
          },
          selected: {
            style: shapeStyles.line.selected
          }
        },
        arc: {
          default: {
            style: shapeStyles.line.default
          },
          active: {
            style: shapeStyles.line.active
          },
          inactive: {
            style: shapeStyles.line.inactive
          },
          selected: {
            style: shapeStyles.line.selected
          }
        }
      },
      violin: {
        violin: {
          default: {
            style: shapeStyles.line.default
          },
          active: {
            style: shapeStyles.line.active
          },
          inactive: {
            style: shapeStyles.line.inactive
          },
          selected: {
            style: shapeStyles.line.selected
          }
        },
        smooth: {
          default: {
            style: shapeStyles.line.default
          },
          active: {
            style: shapeStyles.line.active
          },
          inactive: {
            style: shapeStyles.line.inactive
          },
          selected: {
            style: shapeStyles.line.selected
          }
        },
        hollow: {
          default: {
            style: shapeStyles.hollowArea.default
          },
          active: {
            style: shapeStyles.hollowArea.active
          },
          inactive: {
            style: shapeStyles.hollowArea.inactive
          },
          selected: {
            style: shapeStyles.hollowArea.selected
          }
        },
        "hollow-smooth": {
          default: {
            style: shapeStyles.hollowArea.default
          },
          active: {
            style: shapeStyles.hollowArea.active
          },
          inactive: {
            style: shapeStyles.hollowArea.inactive
          },
          selected: {
            style: shapeStyles.hollowArea.selected
          }
        }
      }
    },
    components: {
      axis: {
        common: axisStyles,
        top: {
          position: "top",
          grid: null,
          title: null,
          verticalLimitLength: 1 / 2
        },
        bottom: {
          position: "bottom",
          grid: null,
          title: null,
          verticalLimitLength: 1 / 2
        },
        left: {
          position: "left",
          title: null,
          line: null,
          tickLine: null,
          verticalLimitLength: 1 / 3
        },
        right: {
          position: "right",
          title: null,
          line: null,
          tickLine: null,
          verticalLimitLength: 1 / 3
        },
        circle: {
          title: null,
          grid: deepMix({}, axisStyles.grid, { line: { type: "line" } })
        },
        radius: {
          title: null,
          grid: deepMix({}, axisStyles.grid, { line: { type: "circle" } })
        }
      },
      legend: {
        common: legendStyles,
        right: {
          layout: "vertical",
          padding: styleSheet.legendVerticalPadding
        },
        left: {
          layout: "vertical",
          padding: styleSheet.legendVerticalPadding
        },
        top: {
          layout: "horizontal",
          padding: styleSheet.legendHorizontalPadding
        },
        bottom: {
          layout: "horizontal",
          padding: styleSheet.legendHorizontalPadding
        },
        continuous: {
          title: null,
          background: null,
          track: {},
          rail: {
            type: "color",
            size: styleSheet.sliderRailHeight,
            defaultLength: styleSheet.sliderRailWidth,
            style: {
              fill: styleSheet.sliderRailFillColor,
              stroke: styleSheet.sliderRailBorderColor,
              lineWidth: styleSheet.sliderRailBorder
            }
          },
          label: {
            align: "rail",
            spacing: 4,
            formatter: null,
            style: {
              fill: styleSheet.sliderLabelTextFillColor,
              fontSize: styleSheet.sliderLabelTextFontSize,
              lineHeight: styleSheet.sliderLabelTextLineHeight,
              textBaseline: "middle",
              fontFamily: styleSheet.fontFamily
            }
          },
          handler: {
            size: styleSheet.sliderHandlerWidth,
            style: {
              fill: styleSheet.sliderHandlerFillColor,
              stroke: styleSheet.sliderHandlerBorderColor
            }
          },
          slidable: true,
          padding: legendStyles.padding
        }
      },
      tooltip: {
        showContent: true,
        follow: true,
        showCrosshairs: false,
        showMarkers: true,
        shared: false,
        enterable: false,
        position: "auto",
        marker: {
          symbol: "circle",
          stroke: "#fff",
          shadowBlur: 10,
          shadowOffsetX: 0,
          shadowOffsetY: 0,
          shadowColor: "rgba(0,0,0,0.09)",
          lineWidth: 2,
          r: 4
        },
        crosshairs: {
          line: {
            style: {
              stroke: styleSheet.tooltipCrosshairsBorderColor,
              lineWidth: styleSheet.tooltipCrosshairsBorder
            }
          },
          text: null,
          textBackground: {
            padding: 2,
            style: {
              fill: "rgba(0, 0, 0, 0.25)",
              lineWidth: 0,
              stroke: null
            }
          },
          follow: false
        },
        domStyles: (_a2 = {}, _a2["".concat(CONTAINER_CLASS)] = {
          position: "absolute",
          visibility: "hidden",
          zIndex: 8,
          transition: "left 0.4s cubic-bezier(0.23, 1, 0.32, 1) 0s, top 0.4s cubic-bezier(0.23, 1, 0.32, 1) 0s",
          backgroundColor: styleSheet.tooltipContainerFillColor,
          opacity: styleSheet.tooltipContainerFillOpacity,
          boxShadow: styleSheet.tooltipContainerShadow,
          borderRadius: "".concat(styleSheet.tooltipContainerBorderRadius, "px"),
          color: styleSheet.tooltipTextFillColor,
          fontSize: "".concat(styleSheet.tooltipTextFontSize, "px"),
          fontFamily: styleSheet.fontFamily,
          lineHeight: "".concat(styleSheet.tooltipTextLineHeight, "px"),
          padding: "0 12px 0 12px"
        }, _a2["".concat(TITLE_CLASS)] = {
          marginBottom: "12px",
          marginTop: "12px"
        }, _a2["".concat(LIST_CLASS)] = {
          margin: 0,
          listStyleType: "none",
          padding: 0
        }, _a2["".concat(LIST_ITEM_CLASS)] = {
          listStyleType: "none",
          padding: 0,
          marginBottom: "12px",
          marginTop: "12px",
          marginLeft: 0,
          marginRight: 0
        }, _a2["".concat(MARKER_CLASS)] = {
          width: "8px",
          height: "8px",
          borderRadius: "50%",
          display: "inline-block",
          marginRight: "8px"
        }, _a2["".concat(VALUE_CLASS)] = {
          display: "inline-block",
          float: "right",
          marginLeft: "30px"
        }, _a2)
      },
      annotation: {
        arc: {
          style: {
            stroke: styleSheet.annotationArcBorderColor,
            lineWidth: styleSheet.annotationArcBorder
          },
          animate: true
        },
        line: {
          style: {
            stroke: styleSheet.annotationLineBorderColor,
            lineDash: styleSheet.annotationLineDash,
            lineWidth: styleSheet.annotationLineBorder
          },
          text: {
            position: "start",
            autoRotate: true,
            style: {
              fill: styleSheet.annotationTextFillColor,
              stroke: styleSheet.annotationTextBorderColor,
              lineWidth: styleSheet.annotationTextBorder,
              fontSize: styleSheet.annotationTextFontSize,
              textAlign: "start",
              fontFamily: styleSheet.fontFamily,
              textBaseline: "bottom"
            }
          },
          animate: true
        },
        text: {
          style: {
            fill: styleSheet.annotationTextFillColor,
            stroke: styleSheet.annotationTextBorderColor,
            lineWidth: styleSheet.annotationTextBorder,
            fontSize: styleSheet.annotationTextFontSize,
            textBaseline: "middle",
            textAlign: "start",
            fontFamily: styleSheet.fontFamily
          },
          animate: true
        },
        region: {
          top: false,
          style: {
            lineWidth: styleSheet.annotationRegionBorder,
            stroke: styleSheet.annotationRegionBorderColor,
            fill: styleSheet.annotationRegionFillColor,
            fillOpacity: styleSheet.annotationRegionFillOpacity
          },
          animate: true
        },
        image: {
          top: false,
          animate: true
        },
        dataMarker: {
          top: true,
          point: {
            style: {
              r: 3,
              stroke: styleSheet.brandColor,
              lineWidth: 2
            }
          },
          line: {
            style: {
              stroke: styleSheet.annotationLineBorderColor,
              lineWidth: styleSheet.annotationLineBorder
            },
            length: styleSheet.annotationDataMarkerLineLength
          },
          text: {
            style: {
              textAlign: "start",
              fill: styleSheet.annotationTextFillColor,
              stroke: styleSheet.annotationTextBorderColor,
              lineWidth: styleSheet.annotationTextBorder,
              fontSize: styleSheet.annotationTextFontSize,
              fontFamily: styleSheet.fontFamily
            }
          },
          direction: "upward",
          autoAdjust: true,
          animate: true
        },
        dataRegion: {
          style: {
            region: {
              fill: styleSheet.annotationRegionFillColor,
              fillOpacity: styleSheet.annotationRegionFillOpacity
            },
            text: {
              textAlign: "center",
              textBaseline: "bottom",
              fill: styleSheet.annotationTextFillColor,
              stroke: styleSheet.annotationTextBorderColor,
              lineWidth: styleSheet.annotationTextBorder,
              fontSize: styleSheet.annotationTextFontSize,
              fontFamily: styleSheet.fontFamily
            }
          },
          animate: true
        }
      },
      slider: {
        common: {
          padding: [8, 8, 8, 8],
          backgroundStyle: {
            fill: styleSheet.cSliderBackgroundFillColor,
            opacity: styleSheet.cSliderBackgroundFillOpacity
          },
          foregroundStyle: {
            fill: styleSheet.cSliderForegroundFillColor,
            opacity: styleSheet.cSliderForegroundFillOpacity
          },
          handlerStyle: {
            width: styleSheet.cSliderHandlerWidth,
            height: styleSheet.cSliderHandlerHeight,
            fill: styleSheet.cSliderHandlerFillColor,
            opacity: styleSheet.cSliderHandlerFillOpacity,
            stroke: styleSheet.cSliderHandlerBorderColor,
            lineWidth: styleSheet.cSliderHandlerBorder,
            radius: styleSheet.cSliderHandlerBorderRadius,
            highLightFill: styleSheet.cSliderHandlerHighlightFillColor
          },
          textStyle: {
            fill: styleSheet.cSliderTextFillColor,
            opacity: styleSheet.cSliderTextFillOpacity,
            fontSize: styleSheet.cSliderTextFontSize,
            lineHeight: styleSheet.cSliderTextLineHeight,
            fontWeight: styleSheet.cSliderTextFontWeight,
            stroke: styleSheet.cSliderTextBorderColor,
            lineWidth: styleSheet.cSliderTextBorder
          }
        }
      },
      scrollbar: {
        common: {
          padding: [8, 8, 8, 8]
        },
        default: {
          style: {
            trackColor: styleSheet.scrollbarTrackFillColor,
            thumbColor: styleSheet.scrollbarThumbFillColor
          }
        },
        hover: {
          style: {
            thumbColor: styleSheet.scrollbarThumbHighlightFillColor
          }
        }
      }
    },
    labels: {
      offset: 12,
      style: {
        fill: styleSheet.labelFillColor,
        fontSize: styleSheet.labelFontSize,
        fontFamily: styleSheet.fontFamily,
        stroke: styleSheet.labelBorderColor,
        lineWidth: styleSheet.labelBorder
      },
      fillColorDark: styleSheet.labelFillColorDark,
      fillColorLight: styleSheet.labelFillColorLight,
      autoRotate: true
    },
    innerLabels: {
      style: {
        fill: styleSheet.innerLabelFillColor,
        fontSize: styleSheet.innerLabelFontSize,
        fontFamily: styleSheet.fontFamily,
        stroke: styleSheet.innerLabelBorderColor,
        lineWidth: styleSheet.innerLabelBorder
      },
      autoRotate: true
    },
    overflowLabels: {
      style: {
        fill: styleSheet.overflowLabelFillColor,
        fontSize: styleSheet.overflowLabelFontSize,
        fontFamily: styleSheet.fontFamily,
        stroke: styleSheet.overflowLabelBorderColor,
        lineWidth: styleSheet.overflowLabelBorder
      }
    },
    pieLabels: {
      labelHeight: 14,
      offset: 10,
      labelLine: {
        style: {
          lineWidth: styleSheet.labelLineBorder
        }
      },
      autoRotate: true
    }
  };
}
var BLACK_COLORS$1 = {
  100: "#000",
  95: "#0D0D0D",
  85: "#262626",
  65: "#595959",
  45: "#8C8C8C",
  25: "#BFBFBF",
  15: "#D9D9D9",
  6: "#F0F0F0"
};
var WHITE_COLORS$1 = {
  100: "#FFFFFF",
  95: "#F2F2F2",
  85: "#D9D9D9",
  65: "#A6A6A6",
  45: "#737373",
  25: "#404040",
  15: "#262626",
  6: "#0F0F0F"
};
var QUALITATIVE_10$1 = [
  "#5B8FF9",
  "#5AD8A6",
  "#5D7092",
  "#F6BD16",
  "#6F5EF9",
  "#6DC8EC",
  "#945FB9",
  "#FF9845",
  "#1E9493",
  "#FF99C3"
];
var QUALITATIVE_20$1 = [
  "#5B8FF9",
  "#CDDDFD",
  "#5AD8A6",
  "#CDF3E4",
  "#5D7092",
  "#CED4DE",
  "#F6BD16",
  "#FCEBB9",
  "#6F5EF9",
  "#D3CEFD",
  "#6DC8EC",
  "#D3EEF9",
  "#945FB9",
  "#DECFEA",
  "#FF9845",
  "#FFE0C7",
  "#1E9493",
  "#BBDEDE",
  "#FF99C3",
  "#FFE0ED"
];
var SINGLE_SEQUENCE$1 = [
  "#B8E1FF",
  "#9AC5FF",
  "#7DAAFF",
  "#5B8FF9",
  "#3D76DD",
  "#085EC0",
  "#0047A5",
  "#00318A",
  "#001D70"
];
var createLightStyleSheet = function(cfg) {
  if (cfg === void 0) {
    cfg = {};
  }
  var _a2 = cfg.paletteQualitative10, paletteQualitative10 = _a2 === void 0 ? QUALITATIVE_10$1 : _a2, _b = cfg.paletteQualitative20, paletteQualitative20 = _b === void 0 ? QUALITATIVE_20$1 : _b;
  var _c = cfg.brandColor, brandColor = _c === void 0 ? paletteQualitative10[0] : _c;
  var token2 = {
    backgroundColor: "transparent",
    brandColor,
    subColor: "rgba(0,0,0,0.05)",
    paletteQualitative10,
    paletteQualitative20,
    paletteSemanticRed: "#F4664A",
    paletteSemanticGreen: "#30BF78",
    paletteSemanticYellow: "#FAAD14",
    paletteSequence: SINGLE_SEQUENCE$1,
    fontFamily: '"Segoe UI", Roboto, "Helvetica Neue", Arial,\n    "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol",\n    "Noto Color Emoji"',
    axisLineBorderColor: BLACK_COLORS$1[25],
    axisLineBorder: 1,
    axisLineDash: null,
    axisTitleTextFillColor: BLACK_COLORS$1[65],
    axisTitleTextFontSize: 12,
    axisTitleTextLineHeight: 12,
    axisTitleTextFontWeight: "normal",
    axisTitleSpacing: 12,
    axisDescriptionIconFillColor: WHITE_COLORS$1[85],
    axisTickLineBorderColor: BLACK_COLORS$1[25],
    axisTickLineLength: 4,
    axisTickLineBorder: 1,
    axisSubTickLineBorderColor: BLACK_COLORS$1[15],
    axisSubTickLineLength: 2,
    axisSubTickLineBorder: 1,
    axisLabelFillColor: BLACK_COLORS$1[45],
    axisLabelFontSize: 12,
    axisLabelLineHeight: 12,
    axisLabelFontWeight: "normal",
    axisLabelOffset: 8,
    axisGridBorderColor: BLACK_COLORS$1[15],
    axisGridBorder: 1,
    axisGridLineDash: null,
    legendTitleTextFillColor: BLACK_COLORS$1[45],
    legendTitleTextFontSize: 12,
    legendTitleTextLineHeight: 21,
    legendTitleTextFontWeight: "normal",
    legendMarkerColor: brandColor,
    legendMarkerSpacing: 8,
    legendMarkerSize: 4,
    legendCircleMarkerSize: 4,
    legendSquareMarkerSize: 4,
    legendLineMarkerSize: 5,
    legendItemNameFillColor: BLACK_COLORS$1[65],
    legendItemNameFontSize: 12,
    legendItemNameLineHeight: 12,
    legendItemNameFontWeight: "normal",
    legendItemSpacing: 24,
    legendItemMarginBottom: 12,
    legendPadding: [8, 8, 8, 8],
    legendHorizontalPadding: [8, 0, 8, 0],
    legendVerticalPadding: [0, 8, 0, 8],
    legendPageNavigatorMarkerSize: 12,
    legendPageNavigatorMarkerInactiveFillColor: BLACK_COLORS$1[100],
    legendPageNavigatorMarkerInactiveFillOpacity: 0.45,
    legendPageNavigatorMarkerFillColor: BLACK_COLORS$1[100],
    legendPageNavigatorMarkerFillOpacity: 1,
    legendPageNavigatorTextFillColor: BLACK_COLORS$1[45],
    legendPageNavigatorTextFontSize: 12,
    sliderRailFillColor: BLACK_COLORS$1[15],
    sliderRailBorder: 0,
    sliderRailBorderColor: null,
    sliderRailWidth: 100,
    sliderRailHeight: 12,
    sliderLabelTextFillColor: BLACK_COLORS$1[45],
    sliderLabelTextFontSize: 12,
    sliderLabelTextLineHeight: 12,
    sliderLabelTextFontWeight: "normal",
    sliderHandlerFillColor: BLACK_COLORS$1[6],
    sliderHandlerWidth: 10,
    sliderHandlerHeight: 14,
    sliderHandlerBorder: 1,
    sliderHandlerBorderColor: BLACK_COLORS$1[25],
    annotationArcBorderColor: BLACK_COLORS$1[15],
    annotationArcBorder: 1,
    annotationLineBorderColor: BLACK_COLORS$1[25],
    annotationLineBorder: 1,
    annotationLineDash: null,
    annotationTextFillColor: BLACK_COLORS$1[65],
    annotationTextFontSize: 12,
    annotationTextLineHeight: 12,
    annotationTextFontWeight: "normal",
    annotationTextBorderColor: null,
    annotationTextBorder: 0,
    annotationRegionFillColor: BLACK_COLORS$1[100],
    annotationRegionFillOpacity: 0.06,
    annotationRegionBorder: 0,
    annotationRegionBorderColor: null,
    annotationDataMarkerLineLength: 16,
    tooltipCrosshairsBorderColor: BLACK_COLORS$1[25],
    tooltipCrosshairsBorder: 1,
    tooltipCrosshairsLineDash: null,
    tooltipContainerFillColor: "rgb(255, 255, 255)",
    tooltipContainerFillOpacity: 0.95,
    tooltipContainerShadow: "0px 0px 10px #aeaeae",
    tooltipContainerBorderRadius: 3,
    tooltipTextFillColor: BLACK_COLORS$1[65],
    tooltipTextFontSize: 12,
    tooltipTextLineHeight: 12,
    tooltipTextFontWeight: "bold",
    labelFillColor: BLACK_COLORS$1[65],
    labelFillColorDark: "#2c3542",
    labelFillColorLight: "#ffffff",
    labelFontSize: 12,
    labelLineHeight: 12,
    labelFontWeight: "normal",
    labelBorderColor: null,
    labelBorder: 0,
    innerLabelFillColor: WHITE_COLORS$1[100],
    innerLabelFontSize: 12,
    innerLabelLineHeight: 12,
    innerLabelFontWeight: "normal",
    innerLabelBorderColor: null,
    innerLabelBorder: 0,
    overflowLabelFillColor: BLACK_COLORS$1[65],
    overflowLabelFontSize: 12,
    overflowLabelLineHeight: 12,
    overflowLabelFontWeight: "normal",
    overflowLabelBorderColor: WHITE_COLORS$1[100],
    overflowLabelBorder: 1,
    labelLineBorder: 1,
    labelLineBorderColor: BLACK_COLORS$1[25],
    cSliderRailHieght: 16,
    cSliderBackgroundFillColor: "#416180",
    cSliderBackgroundFillOpacity: 0.05,
    cSliderForegroundFillColor: "#5B8FF9",
    cSliderForegroundFillOpacity: 0.15,
    cSliderHandlerHeight: 24,
    cSliderHandlerWidth: 10,
    cSliderHandlerFillColor: "#F7F7F7",
    cSliderHandlerFillOpacity: 1,
    cSliderHandlerHighlightFillColor: "#FFF",
    cSliderHandlerBorderColor: "#BFBFBF",
    cSliderHandlerBorder: 1,
    cSliderHandlerBorderRadius: 2,
    cSliderTextFillColor: "#000",
    cSliderTextFillOpacity: 0.45,
    cSliderTextFontSize: 12,
    cSliderTextLineHeight: 12,
    cSliderTextFontWeight: "normal",
    cSliderTextBorderColor: null,
    cSliderTextBorder: 0,
    scrollbarTrackFillColor: "rgba(0,0,0,0)",
    scrollbarThumbFillColor: "rgba(0,0,0,0.15)",
    scrollbarThumbHighlightFillColor: "rgba(0,0,0,0.2)",
    pointFillColor: brandColor,
    pointFillOpacity: 0.95,
    pointSize: 4,
    pointBorder: 1,
    pointBorderColor: WHITE_COLORS$1[100],
    pointBorderOpacity: 1,
    pointActiveBorderColor: BLACK_COLORS$1[100],
    pointSelectedBorder: 2,
    pointSelectedBorderColor: BLACK_COLORS$1[100],
    pointInactiveFillOpacity: 0.3,
    pointInactiveBorderOpacity: 0.3,
    hollowPointSize: 4,
    hollowPointBorder: 1,
    hollowPointBorderColor: brandColor,
    hollowPointBorderOpacity: 0.95,
    hollowPointFillColor: WHITE_COLORS$1[100],
    hollowPointActiveBorder: 1,
    hollowPointActiveBorderColor: BLACK_COLORS$1[100],
    hollowPointActiveBorderOpacity: 1,
    hollowPointSelectedBorder: 2,
    hollowPointSelectedBorderColor: BLACK_COLORS$1[100],
    hollowPointSelectedBorderOpacity: 1,
    hollowPointInactiveBorderOpacity: 0.3,
    lineBorder: 2,
    lineBorderColor: brandColor,
    lineBorderOpacity: 1,
    lineActiveBorder: 3,
    lineSelectedBorder: 3,
    lineInactiveBorderOpacity: 0.3,
    areaFillColor: brandColor,
    areaFillOpacity: 0.25,
    areaActiveFillColor: brandColor,
    areaActiveFillOpacity: 0.5,
    areaSelectedFillColor: brandColor,
    areaSelectedFillOpacity: 0.5,
    areaInactiveFillOpacity: 0.3,
    hollowAreaBorderColor: brandColor,
    hollowAreaBorder: 2,
    hollowAreaBorderOpacity: 1,
    hollowAreaActiveBorder: 3,
    hollowAreaActiveBorderColor: BLACK_COLORS$1[100],
    hollowAreaSelectedBorder: 3,
    hollowAreaSelectedBorderColor: BLACK_COLORS$1[100],
    hollowAreaInactiveBorderOpacity: 0.3,
    intervalFillColor: brandColor,
    intervalFillOpacity: 0.95,
    intervalActiveBorder: 1,
    intervalActiveBorderColor: BLACK_COLORS$1[100],
    intervalActiveBorderOpacity: 1,
    intervalSelectedBorder: 2,
    intervalSelectedBorderColor: BLACK_COLORS$1[100],
    intervalSelectedBorderOpacity: 1,
    intervalInactiveBorderOpacity: 0.3,
    intervalInactiveFillOpacity: 0.3,
    hollowIntervalBorder: 2,
    hollowIntervalBorderColor: brandColor,
    hollowIntervalBorderOpacity: 1,
    hollowIntervalFillColor: WHITE_COLORS$1[100],
    hollowIntervalActiveBorder: 2,
    hollowIntervalActiveBorderColor: BLACK_COLORS$1[100],
    hollowIntervalSelectedBorder: 3,
    hollowIntervalSelectedBorderColor: BLACK_COLORS$1[100],
    hollowIntervalSelectedBorderOpacity: 1,
    hollowIntervalInactiveBorderOpacity: 0.3
  };
  return __assign$4(__assign$4({}, token2), cfg);
};
createLightStyleSheet();
function createTheme(themeCfg) {
  var _a2 = themeCfg.styleSheet, styleSheetCfg = _a2 === void 0 ? {} : _a2, themeObject = __rest$3(themeCfg, ["styleSheet"]);
  var styleSheet = createLightStyleSheet(styleSheetCfg);
  return deepMix({}, createThemeByStyleSheet(styleSheet), themeObject);
}
var defaultTheme = createTheme({});
var Themes = {
  default: defaultTheme
};
function getTheme(theme2) {
  return get(Themes, lowerCase(theme2), Themes.default);
}
function registerTheme(theme2, value2) {
  Themes[lowerCase(theme2)] = createTheme(value2);
}
function snapEqual(v1, v2, scale2) {
  var value1 = scale2.translate(v1);
  var value2 = scale2.translate(v2);
  return isNumberEqual$1(value1, value2);
}
function getXValueByPoint(point2, geometry2) {
  var coordinate2 = geometry2.coordinate;
  var xScale = geometry2.getXScale();
  var range3 = xScale.range;
  var rangeMax = range3[range3.length - 1];
  var rangeMin = range3[0];
  var invertPoint = coordinate2.invert(point2);
  var xValue = invertPoint.x;
  if (coordinate2.isPolar && xValue > (1 + rangeMax) / 2) {
    xValue = rangeMin;
  }
  return xScale.translate(xScale.invert(xValue));
}
function filterYValue(data2, point2, geometry2) {
  var coordinate2 = geometry2.coordinate;
  var yScale = geometry2.getYScale();
  var yField = yScale.field;
  var invertPoint = coordinate2.invert(point2);
  var yValue = yScale.invert(invertPoint.y);
  var result = find$1(data2, function(obj) {
    var originData = obj[FIELD_ORIGIN];
    return originData[yField][0] <= yValue && originData[yField][1] >= yValue;
  });
  return result || data2[data2.length - 1];
}
var getXDistance = memoize(function(scale2) {
  if (scale2.isCategory) {
    return 1;
  }
  var scaleValues = scale2.values;
  var length2 = scaleValues.length;
  var min2 = scale2.translate(scaleValues[0]);
  var max2 = min2;
  for (var index2 = 0; index2 < length2; index2++) {
    var value2 = scaleValues[index2];
    var numericValue = scale2.translate(value2);
    if (numericValue < min2) {
      min2 = numericValue;
    }
    if (numericValue > max2) {
      max2 = numericValue;
    }
  }
  return (max2 - min2) / (length2 - 1);
});
function getTooltipTitle(originData, geometry2, title) {
  var positionAttr = geometry2.getAttribute("position");
  var fields = positionAttr.getFields();
  var scales = geometry2.scales;
  var titleField = isFunction(title) || !title ? fields[0] : title;
  var titleScale = scales[titleField];
  var tooltipTitle = titleScale ? titleScale.getText(originData[titleField]) : originData[titleField] || titleField;
  return isFunction(title) ? title(tooltipTitle, originData) : tooltipTitle;
}
function getAttributesForLegend(geometry2) {
  var attributes2 = values(geometry2.attributes);
  return filter(attributes2, function(attribute) {
    return contains(GROUP_ATTRS, attribute.type);
  });
}
function getTooltipValueScale(geometry2) {
  var e_1, _a2;
  var attributes2 = getAttributesForLegend(geometry2);
  var scale2;
  try {
    for (var attributes_1 = __values(attributes2), attributes_1_1 = attributes_1.next(); !attributes_1_1.done; attributes_1_1 = attributes_1.next()) {
      var attribute = attributes_1_1.value;
      var tmpScale = attribute.getScale(attribute.type);
      if (tmpScale && tmpScale.isLinear) {
        var tmpScaleDef = get(geometry2.scaleDefs, tmpScale.field);
        var inferedScaleType = inferScaleType(tmpScale, tmpScaleDef, attribute.type, geometry2.type);
        if (inferedScaleType !== "cat") {
          scale2 = tmpScale;
          break;
        }
      }
    }
  } catch (e_1_1) {
    e_1 = { error: e_1_1 };
  } finally {
    try {
      if (attributes_1_1 && !attributes_1_1.done && (_a2 = attributes_1.return))
        _a2.call(attributes_1);
    } finally {
      if (e_1)
        throw e_1.error;
    }
  }
  var xScale = geometry2.getXScale();
  var yScale = geometry2.getYScale();
  return scale2 || yScale || xScale;
}
function getTooltipValue(originData, valueScale) {
  var field2 = valueScale.field;
  var value2 = originData[field2];
  if (isArray$1(value2)) {
    var texts = value2.map(function(eachValue) {
      return valueScale.getText(eachValue);
    });
    return texts.join("-");
  }
  return valueScale.getText(value2);
}
function getTooltipName(originData, geometry2) {
  var nameScale;
  var groupScales = geometry2.getGroupScales();
  if (groupScales.length) {
    nameScale = groupScales[0];
  }
  if (nameScale) {
    var field2 = nameScale.field;
    return nameScale.getText(originData[field2]);
  }
  var valueScale = getTooltipValueScale(geometry2);
  return getName(valueScale);
}
function findDataByPoint(point2, data2, geometry2) {
  if (data2.length === 0) {
    return null;
  }
  var geometryType = geometry2.type;
  var xScale = geometry2.getXScale();
  var yScale = geometry2.getYScale();
  var xField = xScale.field;
  var yField = yScale.field;
  var rst = null;
  if (geometryType === "heatmap" || geometryType === "point") {
    var coordinate2 = geometry2.coordinate;
    var invertPoint = coordinate2.invert(point2);
    var x2 = xScale.invert(invertPoint.x);
    var y2 = yScale.invert(invertPoint.y);
    var min2 = Infinity;
    for (var index2 = 0; index2 < data2.length; index2++) {
      var obj = data2[index2];
      var originData = obj[FIELD_ORIGIN];
      var range3 = Math.pow(originData[xField] - x2, 2) + Math.pow(originData[yField] - y2, 2);
      if (range3 < min2) {
        min2 = range3;
        rst = obj;
      }
    }
    return rst;
  }
  var first = data2[0];
  var last2 = data2[data2.length - 1];
  var xValue = getXValueByPoint(point2, geometry2);
  var firstXValue = first[FIELD_ORIGIN][xField];
  var firstYValue = first[FIELD_ORIGIN][yField];
  var lastXValue = last2[FIELD_ORIGIN][xField];
  var isYArray = yScale.isLinear && isArray$1(firstYValue);
  if (isArray$1(firstXValue)) {
    for (var index2 = 0; index2 < data2.length; index2++) {
      var record = data2[index2];
      var originData = record[FIELD_ORIGIN];
      if (xScale.translate(originData[xField][0]) <= xValue && xScale.translate(originData[xField][1]) >= xValue) {
        if (isYArray) {
          if (!isArray$1(rst)) {
            rst = [];
          }
          rst.push(record);
        } else {
          rst = record;
          break;
        }
      }
    }
    if (isArray$1(rst)) {
      rst = filterYValue(rst, point2, geometry2);
    }
  } else {
    var next = void 0;
    if (!xScale.isLinear && xScale.type !== "timeCat") {
      for (var index2 = 0; index2 < data2.length; index2++) {
        var record = data2[index2];
        var originData = record[FIELD_ORIGIN];
        if (snapEqual(originData[xField], xValue, xScale)) {
          if (isYArray) {
            if (!isArray$1(rst)) {
              rst = [];
            }
            rst.push(record);
          } else {
            rst = record;
            break;
          }
        } else if (xScale.translate(originData[xField]) <= xValue) {
          last2 = record;
          next = data2[index2 + 1];
        }
      }
      if (isArray$1(rst)) {
        rst = filterYValue(rst, point2, geometry2);
      }
    } else {
      if ((xValue > xScale.translate(lastXValue) || xValue < xScale.translate(firstXValue)) && (xValue > xScale.max || xValue < xScale.min)) {
        return null;
      }
      var firstIdx = 0;
      var lastIdx = data2.length - 1;
      var middleIdx = void 0;
      while (firstIdx <= lastIdx) {
        middleIdx = Math.floor((firstIdx + lastIdx) / 2);
        var item = data2[middleIdx][FIELD_ORIGIN][xField];
        if (snapEqual(item, xValue, xScale)) {
          return data2[middleIdx];
        }
        if (xScale.translate(item) <= xScale.translate(xValue)) {
          firstIdx = middleIdx + 1;
          last2 = data2[middleIdx];
          next = data2[middleIdx + 1];
        } else {
          if (lastIdx === 0) {
            last2 = data2[0];
          }
          lastIdx = middleIdx - 1;
        }
      }
    }
    if (last2 && next) {
      if (Math.abs(xScale.translate(last2[FIELD_ORIGIN][xField]) - xValue) > Math.abs(xScale.translate(next[FIELD_ORIGIN][xField]) - xValue)) {
        last2 = next;
      }
    }
  }
  var distance2 = getXDistance(geometry2.getXScale());
  if (!rst && Math.abs(xScale.translate(last2[FIELD_ORIGIN][xField]) - xValue) <= distance2 / 2) {
    rst = last2;
  }
  return rst;
}
function getTooltipItems(data2, geometry2, title, showNil) {
  var e_2, _a2;
  if (title === void 0) {
    title = "";
  }
  if (showNil === void 0) {
    showNil = false;
  }
  var originData = data2[FIELD_ORIGIN];
  var tooltipTitle = getTooltipTitle(originData, geometry2, title);
  var tooltipOption = geometry2.tooltipOption;
  var defaultColor = geometry2.theme.defaultColor;
  var items = [];
  var name;
  var value2;
  function addItem(itemName, itemValue) {
    if (showNil || !isNil(itemValue) && itemValue !== "") {
      var item = {
        title: tooltipTitle,
        data: originData,
        mappingData: data2,
        name: itemName,
        value: itemValue,
        color: data2.color || defaultColor,
        marker: true
      };
      items.push(item);
    }
  }
  if (isObject(tooltipOption)) {
    var fields = tooltipOption.fields, callback = tooltipOption.callback;
    if (callback) {
      var callbackParams = fields.map(function(field3) {
        return data2[FIELD_ORIGIN][field3];
      });
      var cfg = callback.apply(void 0, __spreadArray$1([], __read(callbackParams), false));
      var itemCfg = __assign$4({ data: data2[FIELD_ORIGIN], mappingData: data2, title: tooltipTitle, color: data2.color || defaultColor, marker: true }, cfg);
      items.push(itemCfg);
    } else {
      var scales = geometry2.scales;
      try {
        for (var fields_1 = __values(fields), fields_1_1 = fields_1.next(); !fields_1_1.done; fields_1_1 = fields_1.next()) {
          var field2 = fields_1_1.value;
          if (!isNil(originData[field2])) {
            var scale2 = scales[field2];
            name = getName(scale2);
            value2 = scale2.getText(originData[field2]);
            addItem(name, value2);
          }
        }
      } catch (e_2_1) {
        e_2 = { error: e_2_1 };
      } finally {
        try {
          if (fields_1_1 && !fields_1_1.done && (_a2 = fields_1.return))
            _a2.call(fields_1);
        } finally {
          if (e_2)
            throw e_2.error;
        }
      }
    }
  } else {
    var valueScale = getTooltipValueScale(geometry2);
    value2 = getTooltipValue(originData, valueScale);
    name = getTooltipName(originData, geometry2);
    addItem(name, value2);
  }
  return items;
}
function getTooltipItemsByFindData(geometry2, point2, title, tooltipCfg) {
  var e_3, _a2;
  var showNil = tooltipCfg.showNil;
  var result = [];
  var dataArray = geometry2.dataArray;
  if (!isEmpty(dataArray)) {
    geometry2.sort(dataArray);
    try {
      for (var dataArray_1 = __values(dataArray), dataArray_1_1 = dataArray_1.next(); !dataArray_1_1.done; dataArray_1_1 = dataArray_1.next()) {
        var data2 = dataArray_1_1.value;
        var record = findDataByPoint(point2, data2, geometry2);
        if (record) {
          var elementId = geometry2.getElementId(record);
          var element = geometry2.elementsMap[elementId];
          if (geometry2.type === "heatmap" || element.visible) {
            var items = getTooltipItems(record, geometry2, title, showNil);
            if (items.length) {
              result.push(items);
            }
          }
        }
      }
    } catch (e_3_1) {
      e_3 = { error: e_3_1 };
    } finally {
      try {
        if (dataArray_1_1 && !dataArray_1_1.done && (_a2 = dataArray_1.return))
          _a2.call(dataArray_1);
      } finally {
        if (e_3)
          throw e_3.error;
      }
    }
  }
  return result;
}
function getTooltipItemsByHitShape(geometry2, point2, title, tooltipCfg) {
  var showNil = tooltipCfg.showNil;
  var result = [];
  var container = geometry2.container;
  var shape = container.getShape(point2.x, point2.y);
  if (shape && shape.get("visible") && shape.get("origin")) {
    var mappingData = shape.get("origin").mappingData;
    var items = getTooltipItems(mappingData, geometry2, title, showNil);
    if (items.length) {
      result.push(items);
    }
  }
  return result;
}
function findItemsFromView(view, point2, tooltipCfg) {
  var e_4, _a2;
  var result = [];
  var geometries = view.geometries;
  var shared = tooltipCfg.shared, title = tooltipCfg.title, reversed = tooltipCfg.reversed;
  try {
    for (var geometries_1 = __values(geometries), geometries_1_1 = geometries_1.next(); !geometries_1_1.done; geometries_1_1 = geometries_1.next()) {
      var geometry2 = geometries_1_1.value;
      if (geometry2.visible && geometry2.tooltipOption !== false) {
        var geometryType = geometry2.type;
        var tooltipItems = void 0;
        if (["point", "edge", "polygon"].includes(geometryType)) {
          tooltipItems = getTooltipItemsByHitShape(geometry2, point2, title, tooltipCfg);
        } else if (["area", "line", "path", "heatmap"].includes(geometryType)) {
          tooltipItems = getTooltipItemsByFindData(geometry2, point2, title, tooltipCfg);
        } else {
          if (shared !== false) {
            tooltipItems = getTooltipItemsByFindData(geometry2, point2, title, tooltipCfg);
          } else {
            tooltipItems = getTooltipItemsByHitShape(geometry2, point2, title, tooltipCfg);
          }
        }
        if (tooltipItems.length) {
          if (reversed) {
            tooltipItems.reverse();
          }
          result.push(tooltipItems);
        }
      }
    }
  } catch (e_4_1) {
    e_4 = { error: e_4_1 };
  } finally {
    try {
      if (geometries_1_1 && !geometries_1_1.done && (_a2 = geometries_1.return))
        _a2.call(geometries_1);
    } finally {
      if (e_4)
        throw e_4.error;
    }
  }
  return result;
}
function findItemsFromViewRecurisive(view, point2, tooltipCfg) {
  var e_5, _a2;
  var result = findItemsFromView(view, point2, tooltipCfg);
  try {
    for (var _b = __values(view.views), _c = _b.next(); !_c.done; _c = _b.next()) {
      var childView = _c.value;
      result = result.concat(findItemsFromView(childView, point2, tooltipCfg));
    }
  } catch (e_5_1) {
    e_5 = { error: e_5_1 };
  } finally {
    try {
      if (_c && !_c.done && (_a2 = _b.return))
        _a2.call(_b);
    } finally {
      if (e_5)
        throw e_5.error;
    }
  }
  return result;
}
function isAutoPadding(padding2) {
  return !isNumber$1(padding2) && !isArray$1(padding2);
}
function parsePadding(padding2) {
  if (padding2 === void 0) {
    padding2 = 0;
  }
  var paddingArray = isArray$1(padding2) ? padding2 : [padding2];
  switch (paddingArray.length) {
    case 0:
      paddingArray = [0, 0, 0, 0];
      break;
    case 1:
      paddingArray = new Array(4).fill(paddingArray[0]);
      break;
    case 2:
      paddingArray = __spreadArray$1(__spreadArray$1([], __read(paddingArray), false), __read(paddingArray), false);
      break;
    case 3:
      paddingArray = __spreadArray$1(__spreadArray$1([], __read(paddingArray), false), [paddingArray[1]], false);
      break;
    default:
      paddingArray = paddingArray.slice(0, 4);
      break;
  }
  return paddingArray;
}
var LOAD_COMPONENT_CONTROLLERS = {};
function registerComponentController(name, plugin) {
  LOAD_COMPONENT_CONTROLLERS[name] = plugin;
}
function getComponentControllerNames() {
  return Object.keys(LOAD_COMPONENT_CONTROLLERS);
}
function getComponentController(name) {
  return LOAD_COMPONENT_CONTROLLERS[name];
}
var CoordinateController = function() {
  function CoordinateController2(option) {
    this.option = this.wrapperOption(option);
  }
  CoordinateController2.prototype.update = function(option) {
    this.option = this.wrapperOption(option);
    return this;
  };
  CoordinateController2.prototype.hasAction = function(actionName) {
    var actions = this.option.actions;
    return some(actions, function(action) {
      return action[0] === actionName;
    });
  };
  CoordinateController2.prototype.create = function(start, end) {
    var _a2 = this.option, type4 = _a2.type, cfg = _a2.cfg;
    var isTheta = type4 === "theta";
    var props = __assign$4({ start, end }, cfg);
    var C2 = getCoordinate(isTheta ? "polar" : type4);
    this.coordinate = new C2(props);
    this.coordinate.type = type4;
    if (isTheta) {
      if (!this.hasAction("transpose")) {
        this.transpose();
      }
    }
    this.execActions();
    return this.coordinate;
  };
  CoordinateController2.prototype.adjust = function(start, end) {
    this.coordinate.update({
      start,
      end
    });
    this.coordinate.resetMatrix();
    this.execActions(["scale", "rotate", "translate"]);
    return this.coordinate;
  };
  CoordinateController2.prototype.rotate = function(angle2) {
    this.option.actions.push(["rotate", angle2]);
    return this;
  };
  CoordinateController2.prototype.reflect = function(dim) {
    this.option.actions.push(["reflect", dim]);
    return this;
  };
  CoordinateController2.prototype.scale = function(sx, sy) {
    this.option.actions.push(["scale", sx, sy]);
    return this;
  };
  CoordinateController2.prototype.transpose = function() {
    this.option.actions.push(["transpose"]);
    return this;
  };
  CoordinateController2.prototype.getOption = function() {
    return this.option;
  };
  CoordinateController2.prototype.getCoordinate = function() {
    return this.coordinate;
  };
  CoordinateController2.prototype.wrapperOption = function(option) {
    return __assign$4({ type: "rect", actions: [], cfg: {} }, option);
  };
  CoordinateController2.prototype.execActions = function(includeActions) {
    var _this = this;
    var actions = this.option.actions;
    each$1(actions, function(action) {
      var _a2;
      var _b = __read(action), actionName = _b[0], args = _b.slice(1);
      var shouldExec = isNil(includeActions) ? true : includeActions.includes(actionName);
      if (shouldExec) {
        (_a2 = _this.coordinate)[actionName].apply(_a2, __spreadArray$1([], __read(args), false));
      }
    });
  };
  return CoordinateController2;
}();
var Event = function() {
  function Event2(view, gEvent, data2) {
    this.view = view;
    this.gEvent = gEvent;
    this.data = data2;
    this.type = gEvent.type;
  }
  Event2.fromData = function(view, type4, data2) {
    return new Event2(view, new GraphEvent(type4, {}), data2);
  };
  Object.defineProperty(Event2.prototype, "target", {
    get: function() {
      return this.gEvent.target;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Event2.prototype, "event", {
    get: function() {
      return this.gEvent.originalEvent;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Event2.prototype, "x", {
    get: function() {
      return this.gEvent.x;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Event2.prototype, "y", {
    get: function() {
      return this.gEvent.y;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Event2.prototype, "clientX", {
    get: function() {
      return this.gEvent.clientX;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Event2.prototype, "clientY", {
    get: function() {
      return this.gEvent.clientY;
    },
    enumerable: false,
    configurable: true
  });
  Event2.prototype.toString = function() {
    return "[Event (type=".concat(this.type, ")]");
  };
  Event2.prototype.clone = function() {
    return new Event2(this.view, this.gEvent, this.data);
  };
  return Event2;
}();
function defaultLayout(view) {
  var axis2 = view.getController("axis");
  var legend2 = view.getController("legend");
  var annotation2 = view.getController("annotation");
  var slider2 = view.getController("slider");
  var scrollbar2 = view.getController("scrollbar");
  [axis2, slider2, scrollbar2, legend2, annotation2].forEach(function(controller) {
    if (controller) {
      controller.layout();
    }
  });
}
var ScalePool = function() {
  function ScalePool2() {
    this.scales = /* @__PURE__ */ new Map();
    this.syncScales = /* @__PURE__ */ new Map();
  }
  ScalePool2.prototype.createScale = function(field2, data2, scaleDef, key2) {
    var finalScaleDef = scaleDef;
    var cacheScaleMeta = this.getScaleMeta(key2);
    if (data2.length === 0 && cacheScaleMeta) {
      var cacheScale = cacheScaleMeta.scale;
      var cacheScaleDef = {
        type: cacheScale.type
      };
      if (cacheScale.isCategory) {
        cacheScaleDef.values = cacheScale.values;
      }
      finalScaleDef = deepMix(cacheScaleDef, cacheScaleMeta.scaleDef, scaleDef);
    }
    var scale2 = createScaleByField(field2, data2, finalScaleDef);
    this.cacheScale(scale2, scaleDef, key2);
    return scale2;
  };
  ScalePool2.prototype.sync = function(coordinate2, theme2) {
    var _this = this;
    this.syncScales.forEach(function(scaleKeys, syncKey) {
      var min2 = Number.MAX_SAFE_INTEGER;
      var max2 = Number.MIN_SAFE_INTEGER;
      var values2 = [];
      each$1(scaleKeys, function(key2) {
        var scale2 = _this.getScale(key2);
        max2 = isNumber$1(scale2.max) ? Math.max(max2, scale2.max) : max2;
        min2 = isNumber$1(scale2.min) ? Math.min(min2, scale2.min) : min2;
        each$1(scale2.values, function(v2) {
          if (!values2.includes(v2)) {
            values2.push(v2);
          }
        });
      });
      each$1(scaleKeys, function(key2) {
        var scale2 = _this.getScale(key2);
        if (scale2.isContinuous) {
          scale2.change({
            min: min2,
            max: max2,
            values: values2
          });
        } else if (scale2.isCategory) {
          var range3 = scale2.range;
          var cacheScaleMeta = _this.getScaleMeta(key2);
          if (values2 && !get(cacheScaleMeta, ["scaleDef", "range"])) {
            range3 = getDefaultCategoryScaleRange(deepMix({}, scale2, {
              values: values2
            }), coordinate2, theme2);
          }
          scale2.change({
            values: values2,
            range: range3
          });
        }
      });
    });
  };
  ScalePool2.prototype.cacheScale = function(scale2, scaleDef, key2) {
    var sm = this.getScaleMeta(key2);
    if (sm && sm.scale.type === scale2.type) {
      syncScale(sm.scale, scale2);
      sm.scaleDef = scaleDef;
    } else {
      sm = {
        key: key2,
        scale: scale2,
        scaleDef
      };
      this.scales.set(key2, sm);
    }
    var syncKey = this.getSyncKey(sm);
    sm.syncKey = syncKey;
    this.removeFromSyncScales(key2);
    if (syncKey) {
      var scaleKeys = this.syncScales.get(syncKey);
      if (!scaleKeys) {
        scaleKeys = [];
        this.syncScales.set(syncKey, scaleKeys);
      }
      scaleKeys.push(key2);
    }
  };
  ScalePool2.prototype.getScale = function(key2) {
    var scaleMeta = this.getScaleMeta(key2);
    if (!scaleMeta) {
      var field2 = last(key2.split("-"));
      var scaleKeys = this.syncScales.get(field2);
      if (scaleKeys && scaleKeys.length) {
        scaleMeta = this.getScaleMeta(scaleKeys[0]);
      }
    }
    return scaleMeta && scaleMeta.scale;
  };
  ScalePool2.prototype.deleteScale = function(key2) {
    var scaleMeta = this.getScaleMeta(key2);
    if (scaleMeta) {
      var syncKey = scaleMeta.syncKey;
      var scaleKeys = this.syncScales.get(syncKey);
      if (scaleKeys && scaleKeys.length) {
        var idx = scaleKeys.indexOf(key2);
        if (idx !== -1) {
          scaleKeys.splice(idx, 1);
        }
      }
    }
    this.scales.delete(key2);
  };
  ScalePool2.prototype.clear = function() {
    this.scales.clear();
    this.syncScales.clear();
  };
  ScalePool2.prototype.removeFromSyncScales = function(key2) {
    var _this = this;
    this.syncScales.forEach(function(scaleKeys, syncKey) {
      var idx = scaleKeys.indexOf(key2);
      if (idx !== -1) {
        scaleKeys.splice(idx, 1);
        if (scaleKeys.length === 0) {
          _this.syncScales.delete(syncKey);
        }
        return false;
      }
    });
  };
  ScalePool2.prototype.getSyncKey = function(sm) {
    var scale2 = sm.scale, scaleDef = sm.scaleDef;
    var field2 = scale2.field;
    var sync = get(scaleDef, ["sync"]);
    return sync === true ? field2 : sync === false ? void 0 : sync;
  };
  ScalePool2.prototype.getScaleMeta = function(key2) {
    return this.scales.get(key2);
  };
  return ScalePool2;
}();
var PaddingCal = function() {
  function PaddingCal2(top, right2, bottom, left2) {
    if (top === void 0) {
      top = 0;
    }
    if (right2 === void 0) {
      right2 = 0;
    }
    if (bottom === void 0) {
      bottom = 0;
    }
    if (left2 === void 0) {
      left2 = 0;
    }
    this.top = top;
    this.right = right2;
    this.bottom = bottom;
    this.left = left2;
  }
  PaddingCal2.instance = function(top, right2, bottom, left2) {
    if (top === void 0) {
      top = 0;
    }
    if (right2 === void 0) {
      right2 = 0;
    }
    if (bottom === void 0) {
      bottom = 0;
    }
    if (left2 === void 0) {
      left2 = 0;
    }
    return new PaddingCal2(top, right2, bottom, left2);
  };
  PaddingCal2.prototype.max = function(padding2) {
    var _a2 = __read(padding2, 4), top = _a2[0], right2 = _a2[1], bottom = _a2[2], left2 = _a2[3];
    this.top = Math.max(this.top, top);
    this.right = Math.max(this.right, right2);
    this.bottom = Math.max(this.bottom, bottom);
    this.left = Math.max(this.left, left2);
    return this;
  };
  PaddingCal2.prototype.shrink = function(padding2) {
    var _a2 = __read(padding2, 4), top = _a2[0], right2 = _a2[1], bottom = _a2[2], left2 = _a2[3];
    this.top += top;
    this.right += right2;
    this.bottom += bottom;
    this.left += left2;
    return this;
  };
  PaddingCal2.prototype.inc = function(bbox, direction2) {
    var width = bbox.width, height = bbox.height;
    switch (direction2) {
      case DIRECTION.TOP:
      case DIRECTION.TOP_LEFT:
      case DIRECTION.TOP_RIGHT:
        this.top += height;
        break;
      case DIRECTION.RIGHT:
      case DIRECTION.RIGHT_TOP:
      case DIRECTION.RIGHT_BOTTOM:
        this.right += width;
        break;
      case DIRECTION.BOTTOM:
      case DIRECTION.BOTTOM_LEFT:
      case DIRECTION.BOTTOM_RIGHT:
        this.bottom += height;
        break;
      case DIRECTION.LEFT:
      case DIRECTION.LEFT_TOP:
      case DIRECTION.LEFT_BOTTOM:
        this.left += width;
        break;
    }
    return this;
  };
  PaddingCal2.prototype.getPadding = function() {
    return [this.top, this.right, this.bottom, this.left];
  };
  PaddingCal2.prototype.clone = function() {
    return new (PaddingCal2.bind.apply(PaddingCal2, __spreadArray$1([void 0], __read(this.getPadding()), false)))();
  };
  return PaddingCal2;
}();
function calculatePadding(view) {
  var padding2 = view.padding;
  if (!isAutoPadding(padding2)) {
    return new (PaddingCal.bind.apply(PaddingCal, __spreadArray$1([void 0], __read(parsePadding(padding2)), false)))();
  }
  var viewBBox = view.viewBBox;
  var paddingCal = new PaddingCal();
  var axisComponents = [];
  var paddingComponents = [];
  var otherComponents = [];
  each$1(view.getComponents(), function(co) {
    var type4 = co.type;
    if (type4 === COMPONENT_TYPE.AXIS) {
      axisComponents.push(co);
    } else if ([COMPONENT_TYPE.LEGEND, COMPONENT_TYPE.SLIDER, COMPONENT_TYPE.SCROLLBAR].includes(type4)) {
      paddingComponents.push(co);
    } else if (type4 !== COMPONENT_TYPE.GRID && type4 !== COMPONENT_TYPE.TOOLTIP) {
      otherComponents.push(co);
    }
  });
  each$1(axisComponents, function(co) {
    var component2 = co.component;
    var bboxObject = component2.getLayoutBBox();
    var componentBBox = new BBox(bboxObject.x, bboxObject.y, bboxObject.width, bboxObject.height);
    var exceed = componentBBox.exceed(viewBBox);
    paddingCal.max(exceed);
  });
  each$1(paddingComponents, function(co) {
    var component2 = co.component, direction2 = co.direction;
    var bboxObject = component2.getLayoutBBox();
    var componentPadding = component2.get("padding");
    var componentBBox = new BBox(bboxObject.x, bboxObject.y, bboxObject.width, bboxObject.height).expand(componentPadding);
    paddingCal.inc(componentBBox, direction2);
  });
  each$1(otherComponents, function(co) {
    var component2 = co.component, direction2 = co.direction;
    var bboxObject = component2.getLayoutBBox();
    var componentBBox = new BBox(bboxObject.x, bboxObject.y, bboxObject.width, bboxObject.height);
    paddingCal.inc(componentBBox, direction2);
  });
  return paddingCal;
}
function defaultSyncViewPadding(chart, views, PC) {
  var syncPadding = PC.instance();
  views.forEach(function(v2) {
    v2.autoPadding = syncPadding.max(v2.autoPadding.getPadding());
  });
}
var View = function(_super) {
  __extends$3(View2, _super);
  function View2(props) {
    var _this = _super.call(this, { visible: props.visible }) || this;
    _this.views = [];
    _this.geometries = [];
    _this.controllers = [];
    _this.interactions = {};
    _this.limitInPlot = false;
    _this.options = {
      data: [],
      animate: true
    };
    _this.usedControllers = getComponentControllerNames();
    _this.scalePool = new ScalePool();
    _this.layoutFunc = defaultLayout;
    _this.isPreMouseInPlot = false;
    _this.isDataChanged = false;
    _this.isCoordinateChanged = false;
    _this.createdScaleKeys = /* @__PURE__ */ new Map();
    _this.onCanvasEvent = function(evt) {
      var name = evt.name;
      if (!name.includes(":")) {
        var e3 = _this.createViewEvent(evt);
        _this.doPlotEvent(e3);
        _this.emit(name, e3);
      }
    };
    _this.onDelegateEvents = function(evt) {
      var name = evt.name;
      if (!name.includes(":")) {
        return;
      }
      var e3 = _this.createViewEvent(evt);
      _this.emit(name, e3);
    };
    var _a2 = props.id, id2 = _a2 === void 0 ? uniqueId("view") : _a2, parent = props.parent, canvas = props.canvas, backgroundGroup = props.backgroundGroup, middleGroup = props.middleGroup, foregroundGroup = props.foregroundGroup, _b = props.region, region = _b === void 0 ? { start: { x: 0, y: 0 }, end: { x: 1, y: 1 } } : _b, padding2 = props.padding, appendPadding = props.appendPadding, theme2 = props.theme, options = props.options, limitInPlot2 = props.limitInPlot, syncViewPadding2 = props.syncViewPadding;
    _this.parent = parent;
    _this.canvas = canvas;
    _this.backgroundGroup = backgroundGroup;
    _this.middleGroup = middleGroup;
    _this.foregroundGroup = foregroundGroup;
    _this.region = region;
    _this.padding = padding2;
    _this.appendPadding = appendPadding;
    _this.options = __assign$4(__assign$4({}, _this.options), options);
    _this.limitInPlot = limitInPlot2;
    _this.id = id2;
    _this.syncViewPadding = syncViewPadding2;
    _this.themeObject = isObject(theme2) ? deepMix({}, getTheme("default"), createTheme(theme2)) : getTheme(theme2);
    _this.init();
    return _this;
  }
  View2.prototype.setLayout = function(layout2) {
    this.layoutFunc = layout2;
  };
  View2.prototype.init = function() {
    this.calculateViewBBox();
    this.initEvents();
    this.initComponentController();
    this.initOptions();
  };
  View2.prototype.render = function(isUpdate, payload) {
    if (isUpdate === void 0) {
      isUpdate = false;
    }
    this.emit(VIEW_LIFE_CIRCLE.BEFORE_RENDER, Event.fromData(this, VIEW_LIFE_CIRCLE.BEFORE_RENDER, payload));
    this.paint(isUpdate);
    this.emit(VIEW_LIFE_CIRCLE.AFTER_RENDER, Event.fromData(this, VIEW_LIFE_CIRCLE.AFTER_RENDER, payload));
    if (this.visible === false) {
      this.changeVisible(false);
    }
  };
  View2.prototype.clear = function() {
    var _this = this;
    this.emit(VIEW_LIFE_CIRCLE.BEFORE_CLEAR);
    this.filteredData = [];
    this.coordinateInstance = void 0;
    this.isDataChanged = false;
    this.isCoordinateChanged = false;
    var geometries = this.geometries;
    for (var i2 = 0; i2 < geometries.length; i2++) {
      geometries[i2].clear();
      geometries[i2].container.remove(true);
      geometries[i2].labelsContainer.remove(true);
    }
    this.geometries = [];
    var controllers = this.controllers;
    for (var i2 = 0; i2 < controllers.length; i2++) {
      if (controllers[i2].name === "annotation") {
        controllers[i2].clear(true);
      } else {
        controllers[i2].clear();
      }
    }
    this.createdScaleKeys.forEach(function(v2, k2) {
      _this.getRootView().scalePool.deleteScale(k2);
    });
    this.createdScaleKeys.clear();
    var views = this.views;
    for (var i2 = 0; i2 < views.length; i2++) {
      views[i2].clear();
    }
    this.emit(VIEW_LIFE_CIRCLE.AFTER_CLEAR);
  };
  View2.prototype.destroy = function() {
    this.emit(VIEW_LIFE_CIRCLE.BEFORE_DESTROY);
    var interactions = this.interactions;
    each$1(interactions, function(interaction2) {
      if (interaction2) {
        interaction2.destroy();
      }
    });
    this.clear();
    var controllers = this.controllers;
    for (var i2 = 0, len = controllers.length; i2 < len; i2++) {
      var controller = controllers[i2];
      controller.destroy();
    }
    this.backgroundGroup.remove(true);
    this.middleGroup.remove(true);
    this.foregroundGroup.remove(true);
    _super.prototype.destroy.call(this);
  };
  View2.prototype.changeVisible = function(visible) {
    _super.prototype.changeVisible.call(this, visible);
    var geometries = this.geometries;
    for (var i2 = 0, len = geometries.length; i2 < len; i2++) {
      var geometry2 = geometries[i2];
      geometry2.changeVisible(visible);
    }
    var controllers = this.controllers;
    for (var i2 = 0, len = controllers.length; i2 < len; i2++) {
      var controller = controllers[i2];
      controller.changeVisible(visible);
    }
    this.foregroundGroup.set("visible", visible);
    this.middleGroup.set("visible", visible);
    this.backgroundGroup.set("visible", visible);
    this.getCanvas().draw();
    return this;
  };
  View2.prototype.data = function(data2) {
    set(this.options, "data", data2);
    this.isDataChanged = true;
    return this;
  };
  View2.prototype.source = function(data2) {
    console.warn("This method will be removed at G2 V4.1. Please use chart.data() instead.");
    return this.data(data2);
  };
  View2.prototype.filter = function(field2, condition) {
    if (isFunction(condition)) {
      set(this.options, ["filters", field2], condition);
      return this;
    }
    if (!condition && get(this.options, ["filters", field2])) {
      delete this.options.filters[field2];
    }
    return this;
  };
  View2.prototype.axis = function(field2, axisOption) {
    if (isBoolean(field2)) {
      set(this.options, ["axes"], field2);
    } else {
      set(this.options, ["axes", field2], axisOption);
    }
    return this;
  };
  View2.prototype.legend = function(field2, legendOption) {
    if (isBoolean(field2)) {
      set(this.options, ["legends"], field2);
    } else if (isString(field2)) {
      set(this.options, ["legends", field2], legendOption);
      if (isPlainObject$1(legendOption) && (legendOption === null || legendOption === void 0 ? void 0 : legendOption.selected)) {
        set(this.options, ["filters", field2], function(name) {
          var _a2;
          return (_a2 = legendOption === null || legendOption === void 0 ? void 0 : legendOption.selected[name]) !== null && _a2 !== void 0 ? _a2 : true;
        });
      }
    } else {
      set(this.options, ["legends"], field2);
    }
    return this;
  };
  View2.prototype.scale = function(field2, scaleOption) {
    var _this = this;
    if (isString(field2)) {
      set(this.options, ["scales", field2], scaleOption);
    } else if (isObject(field2)) {
      each$1(field2, function(v2, k2) {
        set(_this.options, ["scales", k2], v2);
      });
    }
    return this;
  };
  View2.prototype.tooltip = function(cfg) {
    set(this.options, "tooltip", cfg);
    return this;
  };
  View2.prototype.annotation = function() {
    return this.getController("annotation");
  };
  View2.prototype.guide = function() {
    console.warn("This method will be removed at G2 V4.1. Please use chart.annotation() instead.");
    return this.annotation();
  };
  View2.prototype.coordinate = function(type4, coordinateCfg) {
    if (isString(type4)) {
      set(this.options, "coordinate", { type: type4, cfg: coordinateCfg });
    } else {
      set(this.options, "coordinate", type4);
    }
    this.coordinateController.update(this.options.coordinate);
    return this.coordinateController;
  };
  View2.prototype.coord = function(type4, coordinateCfg) {
    console.warn("This method will be removed at G2 V4.1. Please use chart.coordinate() instead.");
    return this.coordinate(type4, coordinateCfg);
  };
  View2.prototype.facet = function(type4, cfg) {
    if (this.facetInstance) {
      this.facetInstance.destroy();
    }
    var Ctor = getFacet(type4);
    if (!Ctor) {
      throw new Error("facet '".concat(type4, "' is not exist!"));
    }
    this.facetInstance = new Ctor(this, __assign$4(__assign$4({}, cfg), { type: type4 }));
    return this;
  };
  View2.prototype.animate = function(status) {
    set(this.options, "animate", status);
    return this;
  };
  View2.prototype.updateOptions = function(options) {
    this.clear();
    mix(this.options, options);
    this.views.forEach(function(view) {
      return view.destroy();
    });
    this.views = [];
    this.initOptions();
    this.coordinateBBox = this.viewBBox;
    return this;
  };
  View2.prototype.option = function(name, opt) {
    if (View2.prototype[name]) {
      throw new Error(`Can't use built in variable name "`.concat(name, '", please change another one.'));
    }
    set(this.options, name, opt);
    return this;
  };
  View2.prototype.theme = function(theme2) {
    this.themeObject = isObject(theme2) ? deepMix({}, this.themeObject, createTheme(theme2)) : getTheme(theme2);
    return this;
  };
  View2.prototype.interaction = function(name, cfg) {
    var existInteraction = this.interactions[name];
    if (existInteraction) {
      existInteraction.destroy();
    }
    var interaction2 = createInteraction(name, this, cfg);
    if (interaction2) {
      interaction2.init();
      this.interactions[name] = interaction2;
    }
    return this;
  };
  View2.prototype.removeInteraction = function(name) {
    var existInteraction = this.interactions[name];
    if (existInteraction) {
      existInteraction.destroy();
      this.interactions[name] = void 0;
    }
  };
  View2.prototype.changeData = function(data2) {
    this.isDataChanged = true;
    this.emit(VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, Event.fromData(this, VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, null));
    this.data(data2);
    this.paint(true);
    var views = this.views;
    for (var i2 = 0, len = views.length; i2 < len; i2++) {
      var view = views[i2];
      view.changeData(data2);
    }
    this.emit(VIEW_LIFE_CIRCLE.AFTER_CHANGE_DATA, Event.fromData(this, VIEW_LIFE_CIRCLE.AFTER_CHANGE_DATA, null));
  };
  View2.prototype.createView = function(cfg) {
    if (this.parent && this.parent.parent) {
      console.warn("The view nesting recursive feature will be removed at G2 V4.1. Please avoid to use it.");
    }
    var sharedOptions = {
      data: this.options.data,
      scales: clone$1(this.options.scales),
      axes: clone$1(this.options.axes),
      coordinate: clone$1(this.coordinateController.getOption()),
      tooltip: clone$1(this.options.tooltip),
      legends: clone$1(this.options.legends),
      animate: this.options.animate,
      visible: this.visible
    };
    var v2 = new View2(__assign$4(__assign$4({
      parent: this,
      canvas: this.canvas,
      backgroundGroup: this.backgroundGroup.addGroup({ zIndex: GROUP_Z_INDEX.BG }),
      middleGroup: this.middleGroup.addGroup({ zIndex: GROUP_Z_INDEX.MID }),
      foregroundGroup: this.foregroundGroup.addGroup({ zIndex: GROUP_Z_INDEX.FORE }),
      theme: this.themeObject,
      padding: this.padding
    }, cfg), { options: __assign$4(__assign$4({}, sharedOptions), get(cfg, "options", {})) }));
    this.views.push(v2);
    return v2;
  };
  View2.prototype.view = function(cfg) {
    console.warn("This method will be removed at G2 V4.1. Please use chart.createView() instead.");
    return this.createView(cfg);
  };
  View2.prototype.removeView = function(view) {
    var removedView = remove(this.views, function(v2) {
      return v2 === view;
    })[0];
    if (removedView) {
      removedView.destroy();
    }
    return removedView;
  };
  View2.prototype.getCoordinate = function() {
    return this.coordinateInstance;
  };
  View2.prototype.getTheme = function() {
    return this.themeObject;
  };
  View2.prototype.getXScale = function() {
    var g2 = this.geometries[0];
    return g2 ? g2.getXScale() : null;
  };
  View2.prototype.getYScales = function() {
    var tmpMap = {};
    var yScales = [];
    this.geometries.forEach(function(g2) {
      var yScale = g2.getYScale();
      var field2 = yScale.field;
      if (!tmpMap[field2]) {
        tmpMap[field2] = true;
        yScales.push(yScale);
      }
    });
    return yScales;
  };
  View2.prototype.getScalesByDim = function(dimType) {
    var geometries = this.geometries;
    var scales = {};
    for (var i2 = 0, len = geometries.length; i2 < len; i2++) {
      var geometry2 = geometries[i2];
      var scale2 = dimType === "x" ? geometry2.getXScale() : geometry2.getYScale();
      if (scale2 && !scales[scale2.field]) {
        scales[scale2.field] = scale2;
      }
    }
    return scales;
  };
  View2.prototype.getScale = function(field2, key2) {
    var defaultKey = key2 ? key2 : this.getScaleKey(field2);
    return this.getRootView().scalePool.getScale(defaultKey);
  };
  View2.prototype.getScaleByField = function(field2, key2) {
    return this.getScale(field2, key2);
  };
  View2.prototype.getOptions = function() {
    return this.options;
  };
  View2.prototype.getData = function() {
    return this.filteredData;
  };
  View2.prototype.getOriginalData = function() {
    return this.options.data;
  };
  View2.prototype.getPadding = function() {
    return this.autoPadding.getPadding();
  };
  View2.prototype.getGeometries = function() {
    return this.geometries;
  };
  View2.prototype.getElements = function() {
    return reduce(this.geometries, function(elements, geometry2) {
      return elements.concat(geometry2.getElements());
    }, []);
  };
  View2.prototype.getElementsBy = function(condition) {
    return this.getElements().filter(function(el) {
      return condition(el);
    });
  };
  View2.prototype.getLayer = function(layer) {
    return layer === LAYER.BG ? this.backgroundGroup : layer === LAYER.MID ? this.middleGroup : layer === LAYER.FORE ? this.foregroundGroup : this.foregroundGroup;
  };
  View2.prototype.isPointInPlot = function(point2) {
    return isPointInCoordinate(this.getCoordinate(), point2);
  };
  View2.prototype.getLegendAttributes = function() {
    return flatten(this.geometries.map(function(g2) {
      return g2.getGroupAttributes();
    }));
  };
  View2.prototype.getGroupScales = function() {
    var scales = this.geometries.map(function(g2) {
      return g2.getGroupScales();
    });
    return uniq$1(flatten(scales));
  };
  View2.prototype.getCanvas = function() {
    return this.getRootView().canvas;
  };
  View2.prototype.getRootView = function() {
    var v2 = this;
    while (true) {
      if (v2.parent) {
        v2 = v2.parent;
        continue;
      }
      break;
    }
    return v2;
  };
  View2.prototype.getXY = function(data2) {
    var coordinate2 = this.getCoordinate();
    var xScales = this.getScalesByDim("x");
    var yScales = this.getScalesByDim("y");
    var x2;
    var y2;
    each$1(data2, function(value2, key2) {
      if (xScales[key2]) {
        x2 = xScales[key2].scale(value2);
      }
      if (yScales[key2]) {
        y2 = yScales[key2].scale(value2);
      }
    });
    if (!isNil(x2) && !isNil(y2)) {
      return coordinate2.convert({ x: x2, y: y2 });
    }
  };
  View2.prototype.getController = function(name) {
    return find$1(this.controllers, function(c2) {
      return c2.name === name;
    });
  };
  View2.prototype.showTooltip = function(point2) {
    var tooltip2 = this.getController("tooltip");
    if (tooltip2) {
      tooltip2.showTooltip(point2);
    }
    return this;
  };
  View2.prototype.hideTooltip = function() {
    var tooltip2 = this.getController("tooltip");
    if (tooltip2) {
      tooltip2.hideTooltip();
    }
    return this;
  };
  View2.prototype.lockTooltip = function() {
    var tooltip2 = this.getController("tooltip");
    if (tooltip2) {
      tooltip2.lockTooltip();
    }
    return this;
  };
  View2.prototype.unlockTooltip = function() {
    var tooltip2 = this.getController("tooltip");
    if (tooltip2) {
      tooltip2.unlockTooltip();
    }
    return this;
  };
  View2.prototype.isTooltipLocked = function() {
    var tooltip2 = this.getController("tooltip");
    return tooltip2 && tooltip2.isTooltipLocked();
  };
  View2.prototype.getTooltipItems = function(point2) {
    var tooltip2 = this.getController("tooltip");
    return tooltip2 ? tooltip2.getTooltipItems(point2) : [];
  };
  View2.prototype.getSnapRecords = function(point2) {
    var geometries = this.geometries;
    var rst = [];
    for (var i2 = 0, len = geometries.length; i2 < len; i2++) {
      var geom = geometries[i2];
      var dataArray = geom.dataArray;
      geom.sort(dataArray);
      var record = void 0;
      for (var j2 = 0, dataLen = dataArray.length; j2 < dataLen; j2++) {
        var data2 = dataArray[j2];
        record = findDataByPoint(point2, data2, geom);
        if (record) {
          rst.push(record);
        }
      }
    }
    var views = this.views;
    for (var i2 = 0, len = views.length; i2 < len; i2++) {
      var view = views[i2];
      var snapRecords = view.getSnapRecords(point2);
      rst = rst.concat(snapRecords);
    }
    return rst;
  };
  View2.prototype.getComponents = function() {
    var components = [];
    var controllers = this.controllers;
    for (var i2 = 0, len = controllers.length; i2 < len; i2++) {
      var controller = controllers[i2];
      components = components.concat(controller.getComponents());
    }
    return components;
  };
  View2.prototype.filterData = function(data2) {
    var filters = this.options.filters;
    if (size(filters) === 0) {
      return data2;
    }
    return filter(data2, function(datum, idx) {
      var fields = Object.keys(filters);
      return fields.every(function(field2) {
        var condition = filters[field2];
        return condition(datum[field2], datum, idx);
      });
    });
  };
  View2.prototype.filterFieldData = function(field2, data2) {
    var filters = this.options.filters;
    var condition = get(filters, field2);
    if (isUndefined(condition)) {
      return data2;
    }
    return data2.filter(function(datum, idx) {
      return condition(datum[field2], datum, idx);
    });
  };
  View2.prototype.adjustCoordinate = function() {
    var _a2 = this.getCoordinate(), curStart = _a2.start, curEnd = _a2.end;
    var start = this.coordinateBBox.bl;
    var end = this.coordinateBBox.tr;
    if (isEqual$1(curStart, start) && isEqual$1(curEnd, end)) {
      this.isCoordinateChanged = false;
      return;
    }
    this.isCoordinateChanged = true;
    this.coordinateInstance = this.coordinateController.adjust(start, end);
  };
  View2.prototype.paint = function(isUpdate) {
    this.renderDataRecursive(isUpdate);
    this.syncScale();
    this.emit(VIEW_LIFE_CIRCLE.BEFORE_PAINT);
    this.renderPaddingRecursive(isUpdate);
    this.renderLayoutRecursive(isUpdate);
    this.renderBackgroundStyleShape();
    this.renderPaintRecursive(isUpdate);
    this.emit(VIEW_LIFE_CIRCLE.AFTER_PAINT);
    this.isDataChanged = false;
  };
  View2.prototype.renderBackgroundStyleShape = function() {
    if (this.parent) {
      return;
    }
    var background = get(this.themeObject, "background");
    if (background) {
      if (!this.backgroundStyleRectShape) {
        this.backgroundStyleRectShape = this.backgroundGroup.addShape("rect", {
          attrs: {},
          zIndex: -1,
          capture: false
        });
        this.backgroundStyleRectShape.toBack();
      }
      var _a2 = this.viewBBox, x2 = _a2.x, y2 = _a2.y, width = _a2.width, height = _a2.height;
      this.backgroundStyleRectShape.attr({
        fill: background,
        x: x2,
        y: y2,
        width,
        height
      });
    } else {
      if (this.backgroundStyleRectShape) {
        this.backgroundStyleRectShape.remove(true);
        this.backgroundStyleRectShape = void 0;
      }
    }
  };
  View2.prototype.renderPaddingRecursive = function(isUpdate) {
    this.calculateViewBBox();
    this.adjustCoordinate();
    this.initComponents(isUpdate);
    this.autoPadding = calculatePadding(this).shrink(parsePadding(this.appendPadding));
    this.coordinateBBox = this.viewBBox.shrink(this.autoPadding.getPadding());
    this.adjustCoordinate();
    var tooltipController = this.controllers.find(function(c2) {
      return c2.name === "tooltip";
    });
    tooltipController.update();
    var views = this.views;
    for (var i2 = 0, len = views.length; i2 < len; i2++) {
      var view = views[i2];
      view.renderPaddingRecursive(isUpdate);
    }
  };
  View2.prototype.renderLayoutRecursive = function(isUpdate) {
    var syncViewPaddingFn = this.syncViewPadding === true ? defaultSyncViewPadding : isFunction(this.syncViewPadding) ? this.syncViewPadding : void 0;
    if (syncViewPaddingFn) {
      syncViewPaddingFn(this, this.views, PaddingCal);
      this.views.forEach(function(v2) {
        v2.coordinateBBox = v2.viewBBox.shrink(v2.autoPadding.getPadding());
        v2.adjustCoordinate();
      });
    }
    this.doLayout();
    var views = this.views;
    for (var i2 = 0, len = views.length; i2 < len; i2++) {
      var view = views[i2];
      view.renderLayoutRecursive(isUpdate);
    }
  };
  View2.prototype.renderPaintRecursive = function(isUpdate) {
    var middleGroup = this.middleGroup;
    if (this.limitInPlot) {
      var _a2 = getCoordinateClipCfg(this.coordinateInstance), type4 = _a2.type, attrs = _a2.attrs;
      middleGroup.setClip({
        type: type4,
        attrs
      });
    } else {
      middleGroup.setClip(void 0);
    }
    this.paintGeometries(isUpdate);
    this.renderComponents(isUpdate);
    var views = this.views;
    for (var i2 = 0, len = views.length; i2 < len; i2++) {
      var view = views[i2];
      view.renderPaintRecursive(isUpdate);
    }
  };
  View2.prototype.createScale = function(field2, data2, scaleDef, key2) {
    var currentScaleDef = get(this.options.scales, [field2]);
    var mergedScaleDef = __assign$4(__assign$4({}, currentScaleDef), scaleDef);
    if (this.parent) {
      return this.parent.createScale(field2, data2, mergedScaleDef, key2);
    }
    return this.scalePool.createScale(field2, data2, mergedScaleDef, key2);
  };
  View2.prototype.renderDataRecursive = function(isUpdate) {
    this.doFilterData();
    this.createCoordinate();
    this.initGeometries(isUpdate);
    this.renderFacet(isUpdate);
    var views = this.views;
    for (var i2 = 0, len = views.length; i2 < len; i2++) {
      var view = views[i2];
      view.renderDataRecursive(isUpdate);
    }
  };
  View2.prototype.calculateViewBBox = function() {
    var x2;
    var y2;
    var width;
    var height;
    if (this.parent) {
      var bbox = this.parent.coordinateBBox;
      x2 = bbox.x;
      y2 = bbox.y;
      width = bbox.width;
      height = bbox.height;
    } else {
      x2 = 0;
      y2 = 0;
      width = this.canvas.get("width");
      height = this.canvas.get("height");
    }
    var _a2 = this.region, start = _a2.start, end = _a2.end;
    var viewBBox = new BBox(x2 + width * start.x, y2 + height * start.y, width * (end.x - start.x), height * (end.y - start.y));
    if (!this.viewBBox || !this.viewBBox.isEqual(viewBBox)) {
      this.viewBBox = new BBox(x2 + width * start.x, y2 + height * start.y, width * (end.x - start.x), height * (end.y - start.y));
    }
    this.coordinateBBox = this.viewBBox;
  };
  View2.prototype.initEvents = function() {
    this.foregroundGroup.on("*", this.onDelegateEvents);
    this.middleGroup.on("*", this.onDelegateEvents);
    this.backgroundGroup.on("*", this.onDelegateEvents);
    this.canvas.on("*", this.onCanvasEvent);
  };
  View2.prototype.initComponentController = function() {
    var usedControllers = this.usedControllers;
    for (var i2 = 0, len = usedControllers.length; i2 < len; i2++) {
      var controllerName = usedControllers[i2];
      var Ctor = getComponentController(controllerName);
      if (Ctor) {
        this.controllers.push(new Ctor(this));
      }
    }
  };
  View2.prototype.createViewEvent = function(evt) {
    var shape = evt.shape, name = evt.name;
    var data2 = shape ? shape.get("origin") : null;
    var e3 = new Event(this, evt, data2);
    e3.type = name;
    return e3;
  };
  View2.prototype.doPlotEvent = function(e3) {
    var type4 = e3.type, x2 = e3.x, y2 = e3.y;
    var point2 = { x: x2, y: y2 };
    var ALL_EVENTS = [
      "mousedown",
      "mouseup",
      "mousemove",
      "mouseleave",
      "mousewheel",
      "touchstart",
      "touchmove",
      "touchend",
      "touchcancel",
      "click",
      "dblclick",
      "contextmenu"
    ];
    if (ALL_EVENTS.includes(type4)) {
      var currentInPlot = this.isPointInPlot(point2);
      var newEvent = e3.clone();
      if (currentInPlot) {
        var TYPE = "plot:".concat(type4);
        newEvent.type = TYPE;
        this.emit(TYPE, newEvent);
        if (type4 === "mouseleave" || type4 === "touchend") {
          this.isPreMouseInPlot = false;
        }
      }
      if (type4 === "mousemove" || type4 === "touchmove") {
        if (this.isPreMouseInPlot && !currentInPlot) {
          if (type4 === "mousemove") {
            newEvent.type = PLOT_EVENTS.MOUSE_LEAVE;
            this.emit(PLOT_EVENTS.MOUSE_LEAVE, newEvent);
          }
          newEvent.type = PLOT_EVENTS.LEAVE;
          this.emit(PLOT_EVENTS.LEAVE, newEvent);
        } else if (!this.isPreMouseInPlot && currentInPlot) {
          if (type4 === "mousemove") {
            newEvent.type = PLOT_EVENTS.MOUSE_ENTER;
            this.emit(PLOT_EVENTS.MOUSE_ENTER, newEvent);
          }
          newEvent.type = PLOT_EVENTS.ENTER;
          this.emit(PLOT_EVENTS.ENTER, newEvent);
        }
        this.isPreMouseInPlot = currentInPlot;
      } else if (type4 === "mouseleave" || type4 === "touchend") {
        if (this.isPreMouseInPlot) {
          if (type4 === "mouseleave") {
            newEvent.type = PLOT_EVENTS.MOUSE_LEAVE;
            this.emit(PLOT_EVENTS.MOUSE_LEAVE, newEvent);
          }
          newEvent.type = PLOT_EVENTS.LEAVE;
          this.emit(PLOT_EVENTS.LEAVE, newEvent);
          this.isPreMouseInPlot = false;
        }
      }
    }
  };
  View2.prototype.doFilterData = function() {
    var data2 = this.options.data;
    this.filteredData = this.filterData(data2);
  };
  View2.prototype.initGeometries = function(isUpdate) {
    this.createOrUpdateScales();
    var coordinate2 = this.getCoordinate();
    var scaleDefs = get(this.options, "scales", {});
    var geometries = this.geometries;
    for (var i2 = 0, len = geometries.length; i2 < len; i2++) {
      var geometry2 = geometries[i2];
      geometry2.scales = this.getGeometryScales();
      var cfg = {
        coordinate: coordinate2,
        scaleDefs,
        data: this.filteredData,
        theme: this.themeObject,
        isDataChanged: this.isDataChanged,
        isCoordinateChanged: this.isCoordinateChanged
      };
      if (isUpdate) {
        geometry2.update(cfg);
      } else {
        geometry2.init(cfg);
      }
    }
    this.adjustScales();
  };
  View2.prototype.createOrUpdateScales = function() {
    var fields = this.getScaleFields();
    var groupedFields = this.getGroupedFields();
    var _a2 = this.getOptions(), data2 = _a2.data, _b = _a2.scales, scales = _b === void 0 ? {} : _b;
    var filteredData = this.filteredData;
    for (var i2 = 0, len = fields.length; i2 < len; i2++) {
      var field2 = fields[i2];
      var scaleDef = scales[field2];
      var key2 = this.getScaleKey(field2);
      this.createScale(
        field2,
        groupedFields.includes(field2) ? data2 : filteredData,
        scaleDef,
        key2
      );
      this.createdScaleKeys.set(key2, true);
    }
  };
  View2.prototype.syncScale = function() {
    this.getRootView().scalePool.sync(this.getCoordinate(), this.theme);
  };
  View2.prototype.getGeometryScales = function() {
    var fields = this.getScaleFields();
    var scales = {};
    for (var i2 = 0; i2 < fields.length; i2++) {
      var field2 = fields[i2];
      scales[field2] = this.getScaleByField(field2);
    }
    return scales;
  };
  View2.prototype.getScaleFields = function() {
    var fields = [];
    var tmpMap = /* @__PURE__ */ new Map();
    var geometries = this.geometries;
    for (var i2 = 0; i2 < geometries.length; i2++) {
      var geometry2 = geometries[i2];
      var geometryScales = geometry2.getScaleFields();
      uniq$1(geometryScales, fields, tmpMap);
    }
    return fields;
  };
  View2.prototype.getGroupedFields = function() {
    var fields = [];
    var tmpMap = /* @__PURE__ */ new Map();
    var geometries = this.geometries;
    for (var i2 = 0; i2 < geometries.length; i2++) {
      var geometry2 = geometries[i2];
      var groupFields = geometry2.getGroupFields();
      uniq$1(groupFields, fields, tmpMap);
    }
    return fields;
  };
  View2.prototype.adjustScales = function() {
    this.adjustCategoryScaleRange();
  };
  View2.prototype.adjustCategoryScaleRange = function() {
    var _this = this;
    var xyScales = __spreadArray$1([this.getXScale()], __read(this.getYScales()), false).filter(function(e3) {
      return !!e3;
    });
    var coordinate2 = this.getCoordinate();
    var scaleOptions = this.options.scales;
    each$1(xyScales, function(scale2) {
      var field2 = scale2.field, values2 = scale2.values, isCategory = scale2.isCategory, isIdentity = scale2.isIdentity;
      if (isCategory || isIdentity) {
        if (values2 && !get(scaleOptions, [field2, "range"])) {
          scale2.range = getDefaultCategoryScaleRange(scale2, coordinate2, _this.theme);
        }
      }
    });
  };
  View2.prototype.initComponents = function(isUpdate) {
    var controllers = this.controllers;
    for (var i2 = 0; i2 < controllers.length; i2++) {
      var controller = controllers[i2];
      if (isUpdate) {
        controller.update();
      } else {
        controller.clear();
        controller.render();
      }
    }
  };
  View2.prototype.doLayout = function() {
    this.layoutFunc(this);
  };
  View2.prototype.createCoordinate = function() {
    var start = this.coordinateBBox.bl;
    var end = this.coordinateBBox.tr;
    this.coordinateInstance = this.coordinateController.create(start, end);
  };
  View2.prototype.paintGeometries = function(isUpdate) {
    var doAnimation = this.options.animate;
    var coordinate2 = this.getCoordinate();
    var canvasRegion = {
      x: this.viewBBox.x,
      y: this.viewBBox.y,
      minX: this.viewBBox.minX,
      minY: this.viewBBox.minY,
      maxX: this.viewBBox.maxX,
      maxY: this.viewBBox.maxY,
      width: this.viewBBox.width,
      height: this.viewBBox.height
    };
    var geometries = this.geometries;
    for (var i2 = 0; i2 < geometries.length; i2++) {
      var geometry2 = geometries[i2];
      geometry2.coordinate = coordinate2;
      geometry2.canvasRegion = canvasRegion;
      if (!doAnimation) {
        geometry2.animate(false);
      }
      geometry2.paint(isUpdate);
    }
  };
  View2.prototype.renderComponents = function(isUpdate) {
    var components = this.getComponents();
    for (var i2 = 0; i2 < components.length; i2++) {
      var co = components[i2];
      co.component.render();
    }
  };
  View2.prototype.renderFacet = function(isUpdate) {
    if (this.facetInstance) {
      if (isUpdate) {
        this.facetInstance.update();
      } else {
        this.facetInstance.clear();
        this.facetInstance.init();
        this.facetInstance.render();
      }
    }
  };
  View2.prototype.initOptions = function() {
    var _this = this;
    var _a2 = this.options, _b = _a2.geometries, geometries = _b === void 0 ? [] : _b, _c = _a2.interactions, interactions = _c === void 0 ? [] : _c, _d = _a2.views, views = _d === void 0 ? [] : _d, _e = _a2.annotations, annotations = _e === void 0 ? [] : _e, coordinate2 = _a2.coordinate, events = _a2.events, facets = _a2.facets;
    if (this.coordinateController) {
      coordinate2 && this.coordinateController.update(coordinate2);
    } else {
      this.coordinateController = new CoordinateController(coordinate2);
    }
    for (var i2 = 0; i2 < geometries.length; i2++) {
      var geometryOption = geometries[i2];
      this.createGeometry(geometryOption);
    }
    for (var j2 = 0; j2 < interactions.length; j2++) {
      var interactionOption = interactions[j2];
      var type4 = interactionOption.type, cfg = interactionOption.cfg;
      this.interaction(type4, cfg);
    }
    for (var k2 = 0; k2 < views.length; k2++) {
      var viewOption = views[k2];
      this.createView(viewOption);
    }
    var annotationComponent = this.getController("annotation");
    for (var l2 = 0; l2 < annotations.length; l2++) {
      var annotationOption = annotations[l2];
      annotationComponent.annotation(annotationOption);
    }
    if (events) {
      each$1(events, function(eventCallback, eventName) {
        _this.on(eventName, eventCallback);
      });
    }
    if (facets) {
      each$1(facets, function(facet) {
        var type5 = facet.type, rest = __rest$3(facet, ["type"]);
        _this.facet(type5, rest);
      });
    }
  };
  View2.prototype.createGeometry = function(geometryOption) {
    var type4 = geometryOption.type, _a2 = geometryOption.cfg, cfg = _a2 === void 0 ? {} : _a2;
    if (this[type4]) {
      var geometry_1 = this[type4](cfg);
      each$1(geometryOption, function(v2, k2) {
        if (isFunction(geometry_1[k2])) {
          geometry_1[k2](v2);
        }
      });
    }
  };
  View2.prototype.getScaleKey = function(field2) {
    return "".concat(this.id, "-").concat(field2);
  };
  return View2;
}(Base$1);
function registerGeometry(name, Ctor) {
  View.prototype[name.toLowerCase()] = function(cfg) {
    if (cfg === void 0) {
      cfg = {};
    }
    var props = __assign$4({
      container: this.middleGroup.addGroup(),
      labelsContainer: this.foregroundGroup.addGroup()
    }, cfg);
    var geometry2 = new Ctor(props);
    this.geometries.push(geometry2);
    return geometry2;
  };
}
var Chart = function(_super) {
  __extends$3(Chart2, _super);
  function Chart2(props) {
    var _this = this;
    var container = props.container, width = props.width, height = props.height, _a2 = props.autoFit, autoFit = _a2 === void 0 ? false : _a2, padding2 = props.padding, appendPadding = props.appendPadding, _b = props.renderer, renderer = _b === void 0 ? "canvas" : _b, pixelRatio = props.pixelRatio, _c = props.localRefresh, localRefresh = _c === void 0 ? true : _c, _d = props.visible, visible = _d === void 0 ? true : _d, _e = props.supportCSSTransform, supportCSSTransform = _e === void 0 ? false : _e, _f = props.defaultInteractions, defaultInteractions = _f === void 0 ? ["tooltip", "legend-filter", "legend-active", "continuous-filter", "ellipsis-text", "axis-description"] : _f, options = props.options, limitInPlot2 = props.limitInPlot, theme2 = props.theme, syncViewPadding2 = props.syncViewPadding;
    var ele = isString(container) ? document.getElementById(container) : container;
    var wrapperElement = createDom$1('<div style="position:relative;"></div>');
    ele.appendChild(wrapperElement);
    var size2 = getChartSize(ele, autoFit, width, height);
    var G2 = getEngine(renderer);
    var canvas = new G2.Canvas(__assign$4({ container: wrapperElement, pixelRatio, localRefresh, supportCSSTransform }, size2));
    _this = _super.call(this, {
      parent: null,
      canvas,
      backgroundGroup: canvas.addGroup({ zIndex: GROUP_Z_INDEX.BG }),
      middleGroup: canvas.addGroup({ zIndex: GROUP_Z_INDEX.MID }),
      foregroundGroup: canvas.addGroup({ zIndex: GROUP_Z_INDEX.FORE }),
      padding: padding2,
      appendPadding,
      visible,
      options,
      limitInPlot: limitInPlot2,
      theme: theme2,
      syncViewPadding: syncViewPadding2
    }) || this;
    _this.onResize = debounce$1(function() {
      _this.forceFit();
    }, 300);
    _this.ele = ele;
    _this.canvas = canvas;
    _this.width = size2.width;
    _this.height = size2.height;
    _this.autoFit = autoFit;
    _this.localRefresh = localRefresh;
    _this.renderer = renderer;
    _this.wrapperElement = wrapperElement;
    _this.updateCanvasStyle();
    _this.bindAutoFit();
    _this.initDefaultInteractions(defaultInteractions);
    return _this;
  }
  Chart2.prototype.initDefaultInteractions = function(interactions) {
    var _this = this;
    each$1(interactions, function(interaction2) {
      _this.interaction(interaction2);
    });
  };
  Chart2.prototype.aria = function(ariaOption) {
    var ATTR = "aria-label";
    if (ariaOption === false) {
      this.ele.removeAttribute(ATTR);
    } else {
      this.ele.setAttribute(ATTR, ariaOption.label);
    }
  };
  Chart2.prototype.changeSize = function(width, height) {
    if (this.width === width && this.height === height) {
      return this;
    }
    this.emit(VIEW_LIFE_CIRCLE.BEFORE_CHANGE_SIZE);
    this.width = width;
    this.height = height;
    this.canvas.changeSize(width, height);
    this.render(true);
    this.emit(VIEW_LIFE_CIRCLE.AFTER_CHANGE_SIZE);
    return this;
  };
  Chart2.prototype.clear = function() {
    _super.prototype.clear.call(this);
    this.aria(false);
  };
  Chart2.prototype.destroy = function() {
    _super.prototype.destroy.call(this);
    this.unbindAutoFit();
    this.canvas.destroy();
    removeDom(this.wrapperElement);
    this.wrapperElement = null;
  };
  Chart2.prototype.changeVisible = function(visible) {
    _super.prototype.changeVisible.call(this, visible);
    this.wrapperElement.style.display = visible ? "" : "none";
    return this;
  };
  Chart2.prototype.forceFit = function() {
    if (!this.destroyed) {
      var _a2 = getChartSize(this.ele, true, this.width, this.height), width = _a2.width, height = _a2.height;
      this.changeSize(width, height);
    }
  };
  Chart2.prototype.updateCanvasStyle = function() {
    modifyCSS(this.canvas.get("el"), {
      display: "inline-block",
      verticalAlign: "middle"
    });
  };
  Chart2.prototype.bindAutoFit = function() {
    if (this.autoFit) {
      window.addEventListener("resize", this.onResize);
    }
  };
  Chart2.prototype.unbindAutoFit = function() {
    if (this.autoFit) {
      window.removeEventListener("resize", this.onResize);
    }
  };
  return Chart2;
}(View);
var Controller = function() {
  function Controller2(view) {
    this.visible = true;
    this.components = [];
    this.view = view;
  }
  Controller2.prototype.clear = function(includeOption) {
    each$1(this.components, function(co) {
      co.component.destroy();
    });
    this.components = [];
  };
  Controller2.prototype.destroy = function() {
    this.clear();
  };
  Controller2.prototype.getComponents = function() {
    return this.components;
  };
  Controller2.prototype.changeVisible = function(visible) {
    if (this.visible === visible) {
      return;
    }
    this.components.forEach(function(co) {
      if (visible) {
        co.component.show();
      } else {
        co.component.hide();
      }
    });
    this.visible = visible;
  };
  return Controller2;
}();
function uniq(items) {
  var uniqItems = [];
  var _loop_1 = function(index3) {
    var item = items[index3];
    var result = find$1(uniqItems, function(subItem) {
      return subItem.color === item.color && subItem.name === item.name && subItem.value === item.value && subItem.title === item.title;
    });
    if (!result) {
      uniqItems.push(item);
    }
  };
  for (var index2 = 0; index2 < items.length; index2++) {
    _loop_1(index2);
  }
  return uniqItems;
}
var Tooltip = function(_super) {
  __extends$3(Tooltip3, _super);
  function Tooltip3() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.isLocked = false;
    return _this;
  }
  Object.defineProperty(Tooltip3.prototype, "name", {
    get: function() {
      return "tooltip";
    },
    enumerable: false,
    configurable: true
  });
  Tooltip3.prototype.init = function() {
  };
  Tooltip3.prototype.isVisible = function() {
    var option = this.view.getOptions().tooltip;
    return option !== false;
  };
  Tooltip3.prototype.render = function() {
  };
  Tooltip3.prototype.showTooltip = function(point2) {
    this.point = point2;
    if (!this.isVisible()) {
      return;
    }
    var view = this.view;
    var items = this.getTooltipItems(point2);
    if (!items.length) {
      this.hideTooltip();
      return;
    }
    var title = this.getTitle(items);
    var dataPoint = {
      x: items[0].x,
      y: items[0].y
    };
    view.emit("tooltip:show", Event.fromData(view, "tooltip:show", __assign$4({ items, title }, point2)));
    var cfg = this.getTooltipCfg();
    var follow = cfg.follow, showMarkers = cfg.showMarkers, showCrosshairs = cfg.showCrosshairs, showContent = cfg.showContent, marker = cfg.marker;
    var lastItems = this.items;
    var lastTitle = this.title;
    if (!isEqual$1(lastTitle, title) || !isEqual$1(lastItems, items)) {
      view.emit("tooltip:change", Event.fromData(view, "tooltip:change", __assign$4({ items, title }, point2)));
      if (isFunction(showContent) ? showContent(items) : showContent) {
        if (!this.tooltip) {
          this.renderTooltip();
        }
        this.tooltip.update(mix({}, cfg, {
          items: this.getItemsAfterProcess(items),
          title
        }, follow ? point2 : {}));
        this.tooltip.show();
      }
      if (showMarkers) {
        this.renderTooltipMarkers(items, marker);
      }
    } else {
      if (this.tooltip && follow) {
        this.tooltip.update(point2);
        this.tooltip.show();
      }
      if (this.tooltipMarkersGroup) {
        this.tooltipMarkersGroup.show();
      }
    }
    this.items = items;
    this.title = title;
    if (showCrosshairs) {
      var isCrosshairsFollowCursor = get(cfg, ["crosshairs", "follow"], false);
      this.renderCrosshairs(isCrosshairsFollowCursor ? point2 : dataPoint, cfg);
    }
  };
  Tooltip3.prototype.hideTooltip = function() {
    var follow = this.getTooltipCfg().follow;
    if (!follow) {
      this.point = null;
      return;
    }
    var tooltipMarkersGroup = this.tooltipMarkersGroup;
    if (tooltipMarkersGroup) {
      tooltipMarkersGroup.hide();
    }
    var xCrosshair = this.xCrosshair;
    var yCrosshair = this.yCrosshair;
    if (xCrosshair) {
      xCrosshair.hide();
    }
    if (yCrosshair) {
      yCrosshair.hide();
    }
    var tooltip2 = this.tooltip;
    if (tooltip2) {
      tooltip2.hide();
    }
    this.view.emit("tooltip:hide", Event.fromData(this.view, "tooltip:hide", {}));
    this.point = null;
  };
  Tooltip3.prototype.lockTooltip = function() {
    this.isLocked = true;
    if (this.tooltip) {
      this.tooltip.setCapture(true);
    }
  };
  Tooltip3.prototype.unlockTooltip = function() {
    this.isLocked = false;
    var cfg = this.getTooltipCfg();
    if (this.tooltip) {
      this.tooltip.setCapture(cfg.capture);
    }
  };
  Tooltip3.prototype.isTooltipLocked = function() {
    return this.isLocked;
  };
  Tooltip3.prototype.clear = function() {
    var _a2 = this, tooltip2 = _a2.tooltip, xCrosshair = _a2.xCrosshair, yCrosshair = _a2.yCrosshair, tooltipMarkersGroup = _a2.tooltipMarkersGroup;
    if (tooltip2) {
      tooltip2.hide();
      tooltip2.clear();
    }
    if (xCrosshair) {
      xCrosshair.clear();
    }
    if (yCrosshair) {
      yCrosshair.clear();
    }
    if (tooltipMarkersGroup) {
      tooltipMarkersGroup.clear();
    }
    if (tooltip2 === null || tooltip2 === void 0 ? void 0 : tooltip2.get("customContent")) {
      this.tooltip.destroy();
      this.tooltip = null;
    }
    this.title = null;
    this.items = null;
  };
  Tooltip3.prototype.destroy = function() {
    if (this.tooltip) {
      this.tooltip.destroy();
    }
    if (this.xCrosshair) {
      this.xCrosshair.destroy();
    }
    if (this.yCrosshair) {
      this.yCrosshair.destroy();
    }
    if (this.guideGroup) {
      this.guideGroup.remove(true);
    }
    this.reset();
  };
  Tooltip3.prototype.reset = function() {
    this.items = null;
    this.title = null;
    this.tooltipMarkersGroup = null;
    this.tooltipCrosshairsGroup = null;
    this.xCrosshair = null;
    this.yCrosshair = null;
    this.tooltip = null;
    this.guideGroup = null;
    this.isLocked = false;
    this.point = null;
  };
  Tooltip3.prototype.changeVisible = function(visible) {
    if (this.visible === visible) {
      return;
    }
    var _a2 = this, tooltip2 = _a2.tooltip, tooltipMarkersGroup = _a2.tooltipMarkersGroup, xCrosshair = _a2.xCrosshair, yCrosshair = _a2.yCrosshair;
    if (visible) {
      if (tooltip2) {
        tooltip2.show();
      }
      if (tooltipMarkersGroup) {
        tooltipMarkersGroup.show();
      }
      if (xCrosshair) {
        xCrosshair.show();
      }
      if (yCrosshair) {
        yCrosshair.show();
      }
    } else {
      if (tooltip2) {
        tooltip2.hide();
      }
      if (tooltipMarkersGroup) {
        tooltipMarkersGroup.hide();
      }
      if (xCrosshair) {
        xCrosshair.hide();
      }
      if (yCrosshair) {
        yCrosshair.hide();
      }
    }
    this.visible = visible;
  };
  Tooltip3.prototype.getTooltipItems = function(point2) {
    var e_1, _a2, e_2, _b, e_3, _c;
    var items = this.findItemsFromView(this.view, point2);
    if (items.length) {
      items = flatten(items);
      try {
        for (var items_1 = __values(items), items_1_1 = items_1.next(); !items_1_1.done; items_1_1 = items_1.next()) {
          var itemArr = items_1_1.value;
          try {
            for (var itemArr_1 = (e_2 = void 0, __values(itemArr)), itemArr_1_1 = itemArr_1.next(); !itemArr_1_1.done; itemArr_1_1 = itemArr_1.next()) {
              var item = itemArr_1_1.value;
              var _d = item.mappingData, x2 = _d.x, y2 = _d.y;
              item.x = isArray$1(x2) ? x2[x2.length - 1] : x2;
              item.y = isArray$1(y2) ? y2[y2.length - 1] : y2;
            }
          } catch (e_2_1) {
            e_2 = { error: e_2_1 };
          } finally {
            try {
              if (itemArr_1_1 && !itemArr_1_1.done && (_b = itemArr_1.return))
                _b.call(itemArr_1);
            } finally {
              if (e_2)
                throw e_2.error;
            }
          }
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (items_1_1 && !items_1_1.done && (_a2 = items_1.return))
            _a2.call(items_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      var shared = this.getTooltipCfg().shared;
      if (shared === false && items.length > 1) {
        var snapItem = items[0];
        var min2 = Math.abs(point2.y - snapItem[0].y);
        try {
          for (var items_2 = __values(items), items_2_1 = items_2.next(); !items_2_1.done; items_2_1 = items_2.next()) {
            var aItem = items_2_1.value;
            var yDistance = Math.abs(point2.y - aItem[0].y);
            if (yDistance <= min2) {
              snapItem = aItem;
              min2 = yDistance;
            }
          }
        } catch (e_3_1) {
          e_3 = { error: e_3_1 };
        } finally {
          try {
            if (items_2_1 && !items_2_1.done && (_c = items_2.return))
              _c.call(items_2);
          } finally {
            if (e_3)
              throw e_3.error;
          }
        }
        items = [snapItem];
      }
      return uniq(flatten(items));
    }
    return [];
  };
  Tooltip3.prototype.layout = function() {
  };
  Tooltip3.prototype.update = function() {
    if (this.point) {
      this.showTooltip(this.point);
    }
    if (this.tooltip) {
      var canvas = this.view.getCanvas();
      this.tooltip.set("region", {
        start: { x: 0, y: 0 },
        end: { x: canvas.get("width"), y: canvas.get("height") }
      });
    }
  };
  Tooltip3.prototype.isCursorEntered = function(point2) {
    if (this.tooltip) {
      var el = this.tooltip.getContainer();
      var capture = this.tooltip.get("capture");
      if (el && capture) {
        var _a2 = el.getBoundingClientRect(), x2 = _a2.x, y2 = _a2.y, width = _a2.width, height = _a2.height;
        return new BBox(x2, y2, width, height).isPointIn(point2);
      }
    }
    return false;
  };
  Tooltip3.prototype.getTooltipCfg = function() {
    var view = this.view;
    var option = view.getOptions().tooltip;
    var processOption = this.processCustomContent(option);
    var theme2 = view.getTheme();
    var defaultCfg = get(theme2, ["components", "tooltip"], {});
    var enterable = get(processOption, "enterable", defaultCfg.enterable);
    return deepMix({}, defaultCfg, processOption, {
      capture: enterable || this.isLocked ? true : false
    });
  };
  Tooltip3.prototype.processCustomContent = function(option) {
    if (isBoolean(option) || !get(option, "customContent")) {
      return option;
    }
    var currentCustomContent = option.customContent;
    var customContent = function(title, items) {
      var content = currentCustomContent(title, items) || "";
      return isString(content) ? '<div class="g2-tooltip">' + content + "</div>" : content;
    };
    return __assign$4(__assign$4({}, option), { customContent });
  };
  Tooltip3.prototype.getTitle = function(items) {
    var title = items[0].title || items[0].name;
    this.title = title;
    return title;
  };
  Tooltip3.prototype.renderTooltip = function() {
    var canvas = this.view.getCanvas();
    var region = {
      start: { x: 0, y: 0 },
      end: { x: canvas.get("width"), y: canvas.get("height") }
    };
    var cfg = this.getTooltipCfg();
    var tooltip2 = new HtmlTooltip(__assign$4(__assign$4({ parent: canvas.get("el").parentNode, region }, cfg), { visible: false, crosshairs: null }));
    tooltip2.init();
    this.tooltip = tooltip2;
  };
  Tooltip3.prototype.renderTooltipMarkers = function(items, marker) {
    var e_4, _a2;
    var tooltipMarkersGroup = this.getTooltipMarkersGroup();
    var rootView = this.view.getRootView();
    var limitInPlot2 = rootView.limitInPlot;
    try {
      for (var items_3 = __values(items), items_3_1 = items_3.next(); !items_3_1.done; items_3_1 = items_3.next()) {
        var item = items_3_1.value;
        var x2 = item.x, y2 = item.y;
        if (limitInPlot2 || (tooltipMarkersGroup === null || tooltipMarkersGroup === void 0 ? void 0 : tooltipMarkersGroup.getClip())) {
          var _b = getCoordinateClipCfg(rootView.getCoordinate()), type4 = _b.type, attrs_1 = _b.attrs;
          tooltipMarkersGroup === null || tooltipMarkersGroup === void 0 ? void 0 : tooltipMarkersGroup.setClip({
            type: type4,
            attrs: attrs_1
          });
        } else {
          tooltipMarkersGroup === null || tooltipMarkersGroup === void 0 ? void 0 : tooltipMarkersGroup.setClip(void 0);
        }
        var theme2 = this.view.getTheme();
        var markerDefaultCfg = get(theme2, ["components", "tooltip", "marker"], {});
        var attrs = __assign$4(__assign$4({ fill: item.color, symbol: "circle", shadowColor: item.color }, isFunction(marker) ? __assign$4(__assign$4({}, markerDefaultCfg), marker(item)) : marker), { x: x2, y: y2 });
        tooltipMarkersGroup.addShape("marker", {
          attrs
        });
      }
    } catch (e_4_1) {
      e_4 = { error: e_4_1 };
    } finally {
      try {
        if (items_3_1 && !items_3_1.done && (_a2 = items_3.return))
          _a2.call(items_3);
      } finally {
        if (e_4)
          throw e_4.error;
      }
    }
  };
  Tooltip3.prototype.renderCrosshairs = function(point2, cfg) {
    var crosshairsType = get(cfg, ["crosshairs", "type"], "x");
    if (crosshairsType === "x") {
      if (this.yCrosshair) {
        this.yCrosshair.hide();
      }
      this.renderXCrosshairs(point2, cfg);
    } else if (crosshairsType === "y") {
      if (this.xCrosshair) {
        this.xCrosshair.hide();
      }
      this.renderYCrosshairs(point2, cfg);
    } else if (crosshairsType === "xy") {
      this.renderXCrosshairs(point2, cfg);
      this.renderYCrosshairs(point2, cfg);
    }
  };
  Tooltip3.prototype.renderXCrosshairs = function(point2, tooltipCfg) {
    var coordinate2 = this.getViewWithGeometry(this.view).getCoordinate();
    var start;
    var end;
    if (coordinate2.isRect) {
      if (coordinate2.isTransposed) {
        start = {
          x: coordinate2.start.x,
          y: point2.y
        };
        end = {
          x: coordinate2.end.x,
          y: point2.y
        };
      } else {
        start = {
          x: point2.x,
          y: coordinate2.end.y
        };
        end = {
          x: point2.x,
          y: coordinate2.start.y
        };
      }
    } else {
      var angle2 = getAngleByPoint(coordinate2, point2);
      var center2 = coordinate2.getCenter();
      var radius = coordinate2.getRadius();
      end = polarToCartesian(center2.x, center2.y, radius, angle2);
      start = center2;
    }
    var cfg = deepMix({
      start,
      end,
      container: this.getTooltipCrosshairsGroup()
    }, get(tooltipCfg, "crosshairs", {}), this.getCrosshairsText("x", point2, tooltipCfg));
    delete cfg.type;
    var xCrosshair = this.xCrosshair;
    if (xCrosshair) {
      xCrosshair.update(cfg);
    } else {
      xCrosshair = new LineCrosshair$1(cfg);
      xCrosshair.init();
    }
    xCrosshair.render();
    xCrosshair.show();
    this.xCrosshair = xCrosshair;
  };
  Tooltip3.prototype.renderYCrosshairs = function(point2, tooltipCfg) {
    var coordinate2 = this.getViewWithGeometry(this.view).getCoordinate();
    var cfg;
    var type4;
    if (coordinate2.isRect) {
      var start = void 0;
      var end = void 0;
      if (coordinate2.isTransposed) {
        start = {
          x: point2.x,
          y: coordinate2.end.y
        };
        end = {
          x: point2.x,
          y: coordinate2.start.y
        };
      } else {
        start = {
          x: coordinate2.start.x,
          y: point2.y
        };
        end = {
          x: coordinate2.end.x,
          y: point2.y
        };
      }
      cfg = {
        start,
        end
      };
      type4 = "Line";
    } else {
      cfg = {
        center: coordinate2.getCenter(),
        radius: getDistanceToCenter(coordinate2, point2),
        startAngle: coordinate2.startAngle,
        endAngle: coordinate2.endAngle
      };
      type4 = "Circle";
    }
    cfg = deepMix({
      container: this.getTooltipCrosshairsGroup()
    }, cfg, get(tooltipCfg, "crosshairs", {}), this.getCrosshairsText("y", point2, tooltipCfg));
    delete cfg.type;
    var yCrosshair = this.yCrosshair;
    if (yCrosshair) {
      if (coordinate2.isRect && yCrosshair.get("type") === "circle" || !coordinate2.isRect && yCrosshair.get("type") === "line") {
        yCrosshair = new Crosshair[type4](cfg);
        yCrosshair.init();
      } else {
        yCrosshair.update(cfg);
      }
    } else {
      yCrosshair = new Crosshair[type4](cfg);
      yCrosshair.init();
    }
    yCrosshair.render();
    yCrosshair.show();
    this.yCrosshair = yCrosshair;
  };
  Tooltip3.prototype.getCrosshairsText = function(type4, point2, tooltipCfg) {
    var textCfg = get(tooltipCfg, ["crosshairs", "text"]);
    var follow = get(tooltipCfg, ["crosshairs", "follow"]);
    var items = this.items;
    if (textCfg) {
      var view = this.getViewWithGeometry(this.view);
      var firstItem = items[0];
      var xScale = view.getXScale();
      var yScale = view.getYScales()[0];
      var xValue = void 0;
      var yValue = void 0;
      if (follow) {
        var invertPoint = this.view.getCoordinate().invert(point2);
        xValue = xScale.invert(invertPoint.x);
        yValue = yScale.invert(invertPoint.y);
      } else {
        xValue = firstItem.data[xScale.field];
        yValue = firstItem.data[yScale.field];
      }
      var content = type4 === "x" ? xValue : yValue;
      if (isFunction(textCfg)) {
        textCfg = textCfg(type4, content, items, point2);
      } else {
        textCfg.content = content;
      }
      return {
        text: textCfg
      };
    }
  };
  Tooltip3.prototype.getGuideGroup = function() {
    if (!this.guideGroup) {
      var foregroundGroup = this.view.foregroundGroup;
      this.guideGroup = foregroundGroup.addGroup({
        name: "tooltipGuide",
        capture: false
      });
    }
    return this.guideGroup;
  };
  Tooltip3.prototype.getTooltipMarkersGroup = function() {
    var tooltipMarkersGroup = this.tooltipMarkersGroup;
    if (tooltipMarkersGroup && !tooltipMarkersGroup.destroyed) {
      tooltipMarkersGroup.clear();
      tooltipMarkersGroup.show();
    } else {
      tooltipMarkersGroup = this.getGuideGroup().addGroup({
        name: "tooltipMarkersGroup"
      });
      tooltipMarkersGroup.toFront();
      this.tooltipMarkersGroup = tooltipMarkersGroup;
    }
    return tooltipMarkersGroup;
  };
  Tooltip3.prototype.getTooltipCrosshairsGroup = function() {
    var tooltipCrosshairsGroup = this.tooltipCrosshairsGroup;
    if (!tooltipCrosshairsGroup) {
      tooltipCrosshairsGroup = this.getGuideGroup().addGroup({
        name: "tooltipCrosshairsGroup",
        capture: false
      });
      tooltipCrosshairsGroup.toBack();
      this.tooltipCrosshairsGroup = tooltipCrosshairsGroup;
    }
    return tooltipCrosshairsGroup;
  };
  Tooltip3.prototype.findItemsFromView = function(view, point2) {
    var e_5, _a2;
    if (view.getOptions().tooltip === false) {
      return [];
    }
    var tooltipCfg = this.getTooltipCfg();
    var result = findItemsFromView(view, point2, tooltipCfg);
    try {
      for (var _b = __values(view.views), _c = _b.next(); !_c.done; _c = _b.next()) {
        var childView = _c.value;
        result = result.concat(this.findItemsFromView(childView, point2));
      }
    } catch (e_5_1) {
      e_5 = { error: e_5_1 };
    } finally {
      try {
        if (_c && !_c.done && (_a2 = _b.return))
          _a2.call(_b);
      } finally {
        if (e_5)
          throw e_5.error;
      }
    }
    return result;
  };
  Tooltip3.prototype.getViewWithGeometry = function(view) {
    var _this = this;
    if (view.geometries.length) {
      return view;
    }
    return find$1(view.views, function(childView) {
      return _this.getViewWithGeometry(childView);
    });
  };
  Tooltip3.prototype.getItemsAfterProcess = function(originalItems) {
    var customItems = this.getTooltipCfg().customItems;
    var fn2 = customItems ? customItems : function(v2) {
      return v2;
    };
    return fn2(originalItems);
  };
  return Tooltip3;
}(Controller);
var ANIMATIONS_MAP = {};
function getAnimation(type4) {
  return ANIMATIONS_MAP[type4.toLowerCase()];
}
function registerAnimation(type4, animation2) {
  ANIMATIONS_MAP[type4.toLowerCase()] = animation2;
}
var DEFAULT_ANIMATE_CFG = {
  appear: {
    duration: 450,
    easing: "easeQuadOut"
  },
  update: {
    duration: 400,
    easing: "easeQuadInOut"
  },
  enter: {
    duration: 400,
    easing: "easeQuadInOut"
  },
  leave: {
    duration: 350,
    easing: "easeQuadIn"
  }
};
var GEOMETRY_ANIMATE_CFG = {
  interval: function(coordinate2) {
    return {
      enter: {
        animation: coordinate2.isRect ? coordinate2.isTransposed ? "scale-in-x" : "scale-in-y" : "fade-in"
      },
      update: {
        animation: coordinate2.isPolar && coordinate2.isTransposed ? "sector-path-update" : null
      },
      leave: {
        animation: "fade-out"
      }
    };
  },
  line: {
    enter: {
      animation: "fade-in"
    },
    leave: {
      animation: "fade-out"
    }
  },
  path: {
    enter: {
      animation: "fade-in"
    },
    leave: {
      animation: "fade-out"
    }
  },
  point: {
    appear: {
      animation: "zoom-in"
    },
    enter: {
      animation: "zoom-in"
    },
    leave: {
      animation: "zoom-out"
    }
  },
  area: {
    enter: {
      animation: "fade-in"
    },
    leave: {
      animation: "fade-out"
    }
  },
  polygon: {
    enter: {
      animation: "fade-in"
    },
    leave: {
      animation: "fade-out"
    }
  },
  schema: {
    enter: {
      animation: "fade-in"
    },
    leave: {
      animation: "fade-out"
    }
  },
  edge: {
    enter: {
      animation: "fade-in"
    },
    leave: {
      animation: "fade-out"
    }
  },
  label: {
    appear: {
      animation: "fade-in",
      delay: 450
    },
    enter: {
      animation: "fade-in"
    },
    update: {
      animation: "position-update"
    },
    leave: {
      animation: "fade-out"
    }
  }
};
var GEOMETRY_GROUP_APPEAR_ANIMATION = {
  line: function() {
    return {
      animation: "wave-in"
    };
  },
  area: function() {
    return {
      animation: "wave-in"
    };
  },
  path: function() {
    return {
      animation: "fade-in"
    };
  },
  interval: function(coordinate2) {
    var animation2;
    if (coordinate2.isRect) {
      animation2 = coordinate2.isTransposed ? "grow-in-x" : "grow-in-y";
    } else {
      animation2 = "grow-in-xy";
      if (coordinate2.isPolar && coordinate2.isTransposed) {
        animation2 = "wave-in";
      }
    }
    return {
      animation: animation2
    };
  },
  schema: function(coordinate2) {
    var animation2;
    if (coordinate2.isRect) {
      animation2 = coordinate2.isTransposed ? "grow-in-x" : "grow-in-y";
    } else {
      animation2 = "grow-in-xy";
    }
    return {
      animation: animation2
    };
  },
  polygon: function() {
    return {
      animation: "fade-in",
      duration: 500
    };
  },
  edge: function() {
    return {
      animation: "fade-in"
    };
  }
};
function parseAnimateConfig(animateCfg, data2) {
  return {
    delay: isFunction(animateCfg.delay) ? animateCfg.delay(data2) : animateCfg.delay,
    easing: isFunction(animateCfg.easing) ? animateCfg.easing(data2) : animateCfg.easing,
    duration: isFunction(animateCfg.duration) ? animateCfg.duration(data2) : animateCfg.duration,
    callback: animateCfg.callback,
    repeat: animateCfg.repeat
  };
}
function getDefaultAnimateCfg(elementName, coordinate2, animateType) {
  var animateCfg = GEOMETRY_ANIMATE_CFG[elementName];
  if (animateCfg) {
    if (isFunction(animateCfg)) {
      animateCfg = animateCfg(coordinate2);
    }
    animateCfg = deepMix({}, DEFAULT_ANIMATE_CFG, animateCfg);
    if (animateType) {
      return animateCfg[animateType];
    }
  }
  return animateCfg;
}
function doAnimate(shape, animateCfg, cfg) {
  var data2 = get(shape.get("origin"), "data", FIELD_ORIGIN);
  var animation2 = animateCfg.animation;
  var parsedAnimateCfg = parseAnimateConfig(animateCfg, data2);
  if (animation2) {
    var animateFunction = getAnimation(animation2);
    if (animateFunction) {
      animateFunction(shape, parsedAnimateCfg, cfg);
    }
  } else {
    shape.animate(cfg.toAttrs, parsedAnimateCfg);
  }
}
function doGroupAppearAnimate(container, animateCfg, geometryType, coordinate2, minYPoint) {
  if (GEOMETRY_GROUP_APPEAR_ANIMATION[geometryType]) {
    var defaultCfg = GEOMETRY_GROUP_APPEAR_ANIMATION[geometryType](coordinate2);
    var animation2 = getAnimation(get(defaultCfg, "animation", ""));
    if (animation2) {
      var cfg = __assign$4(__assign$4(__assign$4({}, DEFAULT_ANIMATE_CFG.appear), defaultCfg), animateCfg);
      container.stopAnimate();
      animation2(container, cfg, {
        coordinate: coordinate2,
        minYPoint,
        toAttrs: null
      });
    }
  }
}
var BACKGROUND_SHAPE = "element-background";
var Element$1 = function(_super) {
  __extends$3(Element2, _super);
  function Element2(cfg) {
    var _this = _super.call(this, cfg) || this;
    _this.labelShape = [];
    _this.states = [];
    var shapeFactory = cfg.shapeFactory, container = cfg.container, offscreenGroup = cfg.offscreenGroup, elementIndex = cfg.elementIndex, _a2 = cfg.visible, visible = _a2 === void 0 ? true : _a2;
    _this.shapeFactory = shapeFactory;
    _this.container = container;
    _this.offscreenGroup = offscreenGroup;
    _this.visible = visible;
    _this.elementIndex = elementIndex;
    return _this;
  }
  Element2.prototype.draw = function(model, isUpdate) {
    if (isUpdate === void 0) {
      isUpdate = false;
    }
    this.model = model;
    this.data = model.data;
    this.shapeType = this.getShapeType(model);
    this.drawShape(model, isUpdate);
    if (this.visible === false) {
      this.changeVisible(false);
    }
  };
  Element2.prototype.update = function(model) {
    var _a2 = this, shapeFactory = _a2.shapeFactory, shape = _a2.shape;
    if (!shape) {
      return;
    }
    this.model = model;
    this.data = model.data;
    this.shapeType = this.getShapeType(model);
    this.setShapeInfo(shape, model);
    var offscreenGroup = this.getOffscreenGroup();
    var newShape = shapeFactory.drawShape(this.shapeType, model, offscreenGroup);
    newShape.cfg.data = this.data;
    newShape.cfg.origin = model;
    newShape.cfg.element = this;
    this.syncShapeStyle(shape, newShape, this.getStates(), this.getAnimateCfg("update"));
  };
  Element2.prototype.destroy = function() {
    var _a2 = this, shapeFactory = _a2.shapeFactory, shape = _a2.shape;
    if (shape) {
      var animateCfg = this.getAnimateCfg("leave");
      if (animateCfg) {
        doAnimate(shape, animateCfg, {
          coordinate: shapeFactory.coordinate,
          toAttrs: __assign$4({}, shape.attr())
        });
      } else {
        shape.remove(true);
      }
    }
    this.states = [];
    this.shapeFactory = void 0;
    this.container = void 0;
    this.shape = void 0;
    this.animate = void 0;
    this.geometry = void 0;
    this.labelShape = [];
    this.model = void 0;
    this.data = void 0;
    this.offscreenGroup = void 0;
    this.statesStyle = void 0;
    _super.prototype.destroy.call(this);
  };
  Element2.prototype.changeVisible = function(visible) {
    _super.prototype.changeVisible.call(this, visible);
    if (visible) {
      if (this.shape) {
        this.shape.show();
      }
      if (this.labelShape) {
        this.labelShape.forEach(function(label2) {
          label2.show();
        });
      }
    } else {
      if (this.shape) {
        this.shape.hide();
      }
      if (this.labelShape) {
        this.labelShape.forEach(function(label2) {
          label2.hide();
        });
      }
    }
  };
  Element2.prototype.setState = function(stateName, stateStatus) {
    var _a2 = this, states = _a2.states, shapeFactory = _a2.shapeFactory, model = _a2.model, shape = _a2.shape, shapeType = _a2.shapeType;
    var index2 = states.indexOf(stateName);
    if (stateStatus) {
      if (index2 > -1) {
        return;
      }
      states.push(stateName);
      if (stateName === "active" || stateName === "selected") {
        shape === null || shape === void 0 ? void 0 : shape.toFront();
      }
    } else {
      if (index2 === -1) {
        return;
      }
      states.splice(index2, 1);
      if (stateName === "active" || stateName === "selected") {
        var _b = this.geometry, sortZIndex = _b.sortZIndex, zIndexReversed = _b.zIndexReversed;
        var idx = zIndexReversed ? this.geometry.elements.length - this.elementIndex : this.elementIndex;
        sortZIndex ? shape.setZIndex(idx) : shape.set("zIndex", idx);
      }
    }
    var offscreenShape = shapeFactory.drawShape(shapeType, model, this.getOffscreenGroup());
    if (states.length) {
      this.syncShapeStyle(shape, offscreenShape, states, null);
    } else {
      this.syncShapeStyle(shape, offscreenShape, ["reset"], null);
    }
    offscreenShape.remove(true);
    var eventObject = {
      state: stateName,
      stateStatus,
      element: this,
      target: this.container
    };
    this.container.emit("statechange", eventObject);
    propagationDelegate(this.shape, "statechange", eventObject);
  };
  Element2.prototype.clearStates = function() {
    var _this = this;
    var states = this.states;
    each$1(states, function(state2) {
      _this.setState(state2, false);
    });
    this.states = [];
  };
  Element2.prototype.hasState = function(stateName) {
    return this.states.includes(stateName);
  };
  Element2.prototype.getStates = function() {
    return this.states;
  };
  Element2.prototype.getData = function() {
    return this.data;
  };
  Element2.prototype.getModel = function() {
    return this.model;
  };
  Element2.prototype.getBBox = function() {
    var _a2 = this, shape = _a2.shape, labelShape = _a2.labelShape;
    var bbox = {
      x: 0,
      y: 0,
      minX: 0,
      minY: 0,
      maxX: 0,
      maxY: 0,
      width: 0,
      height: 0
    };
    if (shape) {
      bbox = shape.getCanvasBBox();
    }
    if (labelShape) {
      labelShape.forEach(function(label2) {
        var labelBBox = label2.getCanvasBBox();
        bbox.x = Math.min(labelBBox.x, bbox.x);
        bbox.y = Math.min(labelBBox.y, bbox.y);
        bbox.minX = Math.min(labelBBox.minX, bbox.minX);
        bbox.minY = Math.min(labelBBox.minY, bbox.minY);
        bbox.maxX = Math.max(labelBBox.maxX, bbox.maxX);
        bbox.maxY = Math.max(labelBBox.maxY, bbox.maxY);
      });
    }
    bbox.width = bbox.maxX - bbox.minX;
    bbox.height = bbox.maxY - bbox.minY;
    return bbox;
  };
  Element2.prototype.getStatesStyle = function() {
    if (!this.statesStyle) {
      var _a2 = this, shapeType = _a2.shapeType, geometry2 = _a2.geometry, shapeFactory = _a2.shapeFactory;
      var stateOption = geometry2.stateOption;
      var defaultShapeType = shapeFactory.defaultShapeType;
      var stateTheme = shapeFactory.theme[shapeType] || shapeFactory.theme[defaultShapeType];
      this.statesStyle = deepMix({}, stateTheme, stateOption);
    }
    return this.statesStyle;
  };
  Element2.prototype.getStateStyle = function(stateName, shapeKey) {
    var statesStyle = this.getStatesStyle();
    var stateCfg = get(statesStyle, [stateName, "style"], {});
    var shapeStyle = stateCfg[shapeKey] || stateCfg;
    if (isFunction(shapeStyle)) {
      return shapeStyle(this);
    }
    return shapeStyle;
  };
  Element2.prototype.getAnimateCfg = function(animateType) {
    var _this = this;
    var animate = this.animate;
    if (animate) {
      var cfg_1 = animate[animateType];
      if (cfg_1) {
        return __assign$4(__assign$4({}, cfg_1), { callback: function() {
          var _a2;
          isFunction(cfg_1.callback) && cfg_1.callback();
          (_a2 = _this.geometry) === null || _a2 === void 0 ? void 0 : _a2.emit(GEOMETRY_LIFE_CIRCLE.AFTER_DRAW_ANIMATE);
        } });
      }
      return cfg_1;
    }
    return null;
  };
  Element2.prototype.drawShape = function(model, isUpdate) {
    var _a2;
    if (isUpdate === void 0) {
      isUpdate = false;
    }
    var _b = this, shapeFactory = _b.shapeFactory, container = _b.container, shapeType = _b.shapeType;
    this.shape = shapeFactory.drawShape(shapeType, model, container);
    if (this.shape) {
      this.setShapeInfo(this.shape, model);
      var name_1 = this.shape.cfg.name;
      if (!name_1) {
        this.shape.cfg.name = ["element", this.shapeFactory.geometryType];
      } else if (isString(name_1)) {
        this.shape.cfg.name = ["element", name_1];
      }
      var animateType = isUpdate ? "enter" : "appear";
      var animateCfg = this.getAnimateCfg(animateType);
      if (animateCfg) {
        (_a2 = this.geometry) === null || _a2 === void 0 ? void 0 : _a2.emit(GEOMETRY_LIFE_CIRCLE.BEFORE_DRAW_ANIMATE);
        doAnimate(this.shape, animateCfg, {
          coordinate: shapeFactory.coordinate,
          toAttrs: __assign$4({}, this.shape.attr())
        });
      }
    }
  };
  Element2.prototype.getOffscreenGroup = function() {
    if (!this.offscreenGroup) {
      var GroupCtor = this.container.getGroupBase();
      this.offscreenGroup = new GroupCtor({});
    }
    return this.offscreenGroup;
  };
  Element2.prototype.setShapeInfo = function(shape, data2) {
    var _this = this;
    shape.cfg.origin = data2;
    shape.cfg.element = this;
    if (shape.isGroup()) {
      var children = shape.get("children");
      children.forEach(function(child) {
        _this.setShapeInfo(child, data2);
      });
    }
  };
  Element2.prototype.syncShapeStyle = function(sourceShape, targetShape, states, animateCfg, index2) {
    var _this = this;
    var _a2;
    if (states === void 0) {
      states = [];
    }
    if (index2 === void 0) {
      index2 = 0;
    }
    if (!sourceShape || !targetShape) {
      return;
    }
    var clip = sourceShape.get("clipShape");
    var newClip = targetShape.get("clipShape");
    this.syncShapeStyle(clip, newClip, states, animateCfg);
    if (sourceShape.isGroup()) {
      var children = sourceShape.get("children");
      var newChildren = targetShape.get("children");
      for (var i2 = 0; i2 < children.length; i2++) {
        this.syncShapeStyle(children[i2], newChildren[i2], states, animateCfg, index2 + i2);
      }
    } else {
      if (!isEmpty(states) && !isEqual$1(states, ["reset"])) {
        var name_2 = sourceShape.get("name");
        if (isArray$1(name_2)) {
          name_2 = name_2[1];
        }
        each$1(states, function(state2) {
          if (targetShape.get("name") !== BACKGROUND_SHAPE) {
            var style2 = _this.getStateStyle(state2, name_2 || index2);
            targetShape.attr(style2);
          }
        });
      }
      var newAttrs = getReplaceAttrs(sourceShape, targetShape);
      if (this.animate) {
        if (animateCfg) {
          (_a2 = this.geometry) === null || _a2 === void 0 ? void 0 : _a2.emit(GEOMETRY_LIFE_CIRCLE.BEFORE_DRAW_ANIMATE);
          doAnimate(sourceShape, animateCfg, {
            coordinate: this.shapeFactory.coordinate,
            toAttrs: newAttrs,
            shapeModel: this.model
          });
        } else if (!isEmpty(states)) {
          sourceShape.stopAnimate();
          sourceShape.animate(newAttrs, {
            duration: 300
          });
        } else {
          sourceShape.attr(newAttrs);
        }
      } else {
        sourceShape.attr(newAttrs);
      }
    }
  };
  Element2.prototype.getShapeType = function(model) {
    var shape = get(model, "shape");
    return isArray$1(shape) ? shape[0] : shape;
  };
  return Element2;
}(Base$1);
var GEOMETRY_LABELS_MAP = {};
var GEOMETRY_LABELS_LAYOUT_MAP = {};
function getGeometryLabel(type4) {
  return GEOMETRY_LABELS_MAP[type4.toLowerCase()];
}
function registerGeometryLabel(type4, ctor) {
  GEOMETRY_LABELS_MAP[type4.toLowerCase()] = ctor;
}
function getGeometryLabelLayout(type4) {
  return GEOMETRY_LABELS_LAYOUT_MAP[type4.toLowerCase()];
}
function registerGeometryLabelLayout(type4, layoutFn) {
  GEOMETRY_LABELS_LAYOUT_MAP[type4.toLowerCase()] = layoutFn;
}
var ShapeFactoryBase = {
  coordinate: null,
  defaultShapeType: null,
  theme: null,
  getShapePoints: function(shapeType, shapePoint) {
    var shape = this.getShape(shapeType);
    if (shape.getPoints) {
      return shape.getPoints(shapePoint);
    }
    return this.getDefaultPoints(shapePoint);
  },
  getShape: function(shapeType) {
    var shape = this[shapeType] || this[this.defaultShapeType];
    shape.coordinate = this.coordinate;
    return shape;
  },
  getDefaultPoints: function() {
    return [];
  },
  getDefaultStyle: function(geometryTheme) {
    return get(geometryTheme, [this.defaultShapeType, "default", "style"], {});
  },
  getMarker: function(shapeType, markerCfg) {
    var shape = this.getShape(shapeType);
    if (!shape.getMarker) {
      var defaultShapeType = this.defaultShapeType;
      shape = this.getShape(defaultShapeType);
    }
    var theme2 = this.theme;
    var shapeStyle = get(theme2, [shapeType, "default"], {});
    var markerStyle = shape.getMarker(markerCfg);
    return deepMix({}, shapeStyle, markerStyle);
  },
  drawShape: function(shapeType, cfg, container) {
    var shape = this.getShape(shapeType);
    return shape.draw(cfg, container);
  }
};
var ShapeBase$4 = {
  coordinate: null,
  parsePath: function(path2) {
    var coordinate2 = this.coordinate;
    var parsedPath = parsePathString(path2);
    if (coordinate2.isPolar) {
      parsedPath = convertPolarPath(coordinate2, parsedPath);
    } else {
      parsedPath = convertNormalPath(coordinate2, parsedPath);
    }
    return parsedPath;
  },
  parsePoint: function(point2) {
    var coordinate2 = this.coordinate;
    return coordinate2.convert(point2);
  },
  parsePoints: function(points2) {
    var coordinate2 = this.coordinate;
    return points2.map(function(point2) {
      return coordinate2.convert(point2);
    });
  },
  draw: function(cfg, container) {
  }
};
var ShapeFactoryMap = {};
function registerShapeFactory(factoryName, cfg) {
  var className = upperFirst(factoryName);
  var geomObj = __assign$4(__assign$4(__assign$4({}, ShapeFactoryBase), cfg), { geometryType: factoryName });
  ShapeFactoryMap[className] = geomObj;
  return geomObj;
}
function registerShape(factoryName, shapeType, cfg) {
  var className = upperFirst(factoryName);
  var factory = ShapeFactoryMap[className];
  var shapeObj = __assign$4(__assign$4({}, ShapeBase$4), cfg);
  factory[shapeType] = shapeObj;
  return shapeObj;
}
function getShapeFactory(factoryName) {
  var className = upperFirst(factoryName);
  return ShapeFactoryMap[className];
}
function group(data2, fields, appendConditions) {
  var e_1, _a2;
  if (appendConditions === void 0) {
    appendConditions = {};
  }
  if (!fields) {
    return [data2];
  }
  var groups = groupToMap(data2, fields);
  var array4 = [];
  if (fields.length === 1 && appendConditions[fields[0]]) {
    var values2 = appendConditions[fields[0]];
    try {
      for (var values_1 = __values(values2), values_1_1 = values_1.next(); !values_1_1.done; values_1_1 = values_1.next()) {
        var value2 = values_1_1.value;
        var arr = groups["_".concat(value2)];
        if (arr) {
          array4.push(arr);
        }
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (values_1_1 && !values_1_1.done && (_a2 = values_1.return))
          _a2.call(values_1);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
  } else {
    for (var k2 in groups) {
      if (groups.hasOwnProperty(k2)) {
        var eachGroup = groups[k2];
        array4.push(eachGroup);
      }
    }
  }
  return array4;
}
function isModelChange(currentModel, preModel) {
  return some(["color", "shape", "size", "x", "y", "isInCircle", "data", "style", "defaultStyle", "points", "mappingData"], function(key2) {
    return !isEqual$1(currentModel[key2], preModel[key2]);
  });
}
function parseFields(field2) {
  if (isArray$1(field2)) {
    return field2;
  }
  return field2.split("*");
}
function diff(keyItem, keys2) {
  var added = [];
  var updated = [];
  var removed = [];
  var keyIncluded = /* @__PURE__ */ new Map();
  for (var i2 = 0; i2 < keys2.length; i2++) {
    var key2 = keys2[i2];
    if (keyItem[key2])
      updated.push(key2);
    else
      added.push(key2);
    keyIncluded.set(key2, true);
  }
  Object.keys(keyItem).forEach(function(key3) {
    if (!keyIncluded.has(key3))
      removed.push(key3);
  });
  return {
    added,
    updated,
    removed
  };
}
var Geometry = function(_super) {
  __extends$3(Geometry2, _super);
  function Geometry2(cfg) {
    var _this = _super.call(this, cfg) || this;
    _this.type = "base";
    _this.attributes = {};
    _this.elements = [];
    _this.elementsMap = {};
    _this.animateOption = true;
    _this.attributeOption = {};
    _this.lastElementsMap = {};
    _this.generatePoints = false;
    _this.beforeMappingData = null;
    _this.adjusts = {};
    _this.idFields = [];
    _this.hasSorted = false;
    _this.isCoordinateChanged = false;
    var container = cfg.container, labelsContainer = cfg.labelsContainer, coordinate2 = cfg.coordinate, data2 = cfg.data, _a2 = cfg.sortable, sortable = _a2 === void 0 ? false : _a2, _b = cfg.visible, visible = _b === void 0 ? true : _b, theme2 = cfg.theme, _c = cfg.scales, scales = _c === void 0 ? {} : _c, _d = cfg.scaleDefs, scaleDefs = _d === void 0 ? {} : _d, intervalPadding = cfg.intervalPadding, dodgePadding = cfg.dodgePadding, maxColumnWidth = cfg.maxColumnWidth, minColumnWidth = cfg.minColumnWidth, columnWidthRatio = cfg.columnWidthRatio, roseWidthRatio = cfg.roseWidthRatio, multiplePieWidthRatio = cfg.multiplePieWidthRatio, zIndexReversed = cfg.zIndexReversed, sortZIndex = cfg.sortZIndex, useDeferredLabel = cfg.useDeferredLabel;
    _this.container = container;
    _this.labelsContainer = labelsContainer;
    _this.coordinate = coordinate2;
    _this.data = data2;
    _this.sortable = sortable;
    _this.visible = visible;
    _this.userTheme = theme2;
    _this.scales = scales;
    _this.scaleDefs = scaleDefs;
    _this.intervalPadding = intervalPadding;
    _this.dodgePadding = dodgePadding;
    _this.maxColumnWidth = maxColumnWidth;
    _this.minColumnWidth = minColumnWidth;
    _this.columnWidthRatio = columnWidthRatio;
    _this.roseWidthRatio = roseWidthRatio;
    _this.multiplePieWidthRatio = multiplePieWidthRatio;
    _this.zIndexReversed = zIndexReversed;
    _this.sortZIndex = sortZIndex;
    _this.useDeferredLabel = useDeferredLabel ? typeof useDeferredLabel === "number" ? useDeferredLabel : Infinity : null;
    return _this;
  }
  Geometry2.prototype.position = function(cfg) {
    var positionCfg = cfg;
    if (!isPlainObject$1(cfg)) {
      positionCfg = {
        fields: parseFields(cfg)
      };
    }
    var fields = get(positionCfg, "fields");
    if (fields.length === 1) {
      fields.unshift("1");
      set(positionCfg, "fields", fields);
    }
    set(this.attributeOption, "position", positionCfg);
    return this;
  };
  Geometry2.prototype.color = function(field2, cfg) {
    this.createAttrOption("color", field2, cfg);
    return this;
  };
  Geometry2.prototype.shape = function(field2, cfg) {
    this.createAttrOption("shape", field2, cfg);
    return this;
  };
  Geometry2.prototype.size = function(field2, cfg) {
    this.createAttrOption("size", field2, cfg);
    return this;
  };
  Geometry2.prototype.adjust = function(adjustCfg2) {
    var adjusts = adjustCfg2;
    if (isString(adjustCfg2) || isPlainObject$1(adjustCfg2)) {
      adjusts = [adjustCfg2];
    }
    each$1(adjusts, function(adjust2, index2) {
      if (!isObject(adjust2)) {
        adjusts[index2] = { type: adjust2 };
      }
    });
    this.adjustOption = adjusts;
    return this;
  };
  Geometry2.prototype.style = function(field2, styleFunc) {
    if (isString(field2)) {
      var fields = parseFields(field2);
      this.styleOption = {
        fields,
        callback: styleFunc
      };
    } else {
      var _a2 = field2, fields = _a2.fields, callback = _a2.callback, cfg = _a2.cfg;
      if (fields || callback || cfg) {
        this.styleOption = field2;
      } else {
        this.styleOption = {
          cfg: field2
        };
      }
    }
    return this;
  };
  Geometry2.prototype.tooltip = function(field2, cfg) {
    if (isString(field2)) {
      var fields = parseFields(field2);
      this.tooltipOption = {
        fields,
        callback: cfg
      };
    } else {
      this.tooltipOption = field2;
    }
    return this;
  };
  Geometry2.prototype.animate = function(cfg) {
    this.animateOption = cfg;
    return this;
  };
  Geometry2.prototype.label = function(field2, secondParam, thirdParam) {
    if (isString(field2)) {
      var labelOption = {};
      var fields = parseFields(field2);
      labelOption.fields = fields;
      if (isFunction(secondParam)) {
        labelOption.callback = secondParam;
      } else if (isPlainObject$1(secondParam)) {
        labelOption.cfg = secondParam;
      }
      if (thirdParam) {
        labelOption.cfg = thirdParam;
      }
      this.labelOption = labelOption;
    } else {
      this.labelOption = field2;
    }
    return this;
  };
  Geometry2.prototype.state = function(cfg) {
    this.stateOption = cfg;
    return this;
  };
  Geometry2.prototype.customInfo = function(cfg) {
    this.customOption = cfg;
    return this;
  };
  Geometry2.prototype.init = function(cfg) {
    if (cfg === void 0) {
      cfg = {};
    }
    this.setCfg(cfg);
    this.initAttributes();
    this.processData(this.data);
    this.adjustScale();
  };
  Geometry2.prototype.update = function(cfg) {
    if (cfg === void 0) {
      cfg = {};
    }
    var data2 = cfg.data, isDataChanged = cfg.isDataChanged, isCoordinateChanged = cfg.isCoordinateChanged;
    var _a2 = this, attributeOption = _a2.attributeOption, lastAttributeOption = _a2.lastAttributeOption;
    if (!isEqual$1(attributeOption, lastAttributeOption)) {
      this.init(cfg);
    } else if (data2 && (isDataChanged || !isEqual$1(data2, this.data))) {
      this.setCfg(cfg);
      this.initAttributes();
      this.processData(data2);
    } else {
      this.setCfg(cfg);
    }
    this.adjustScale();
    this.isCoordinateChanged = isCoordinateChanged;
  };
  Geometry2.prototype.paint = function(isUpdate) {
    var _this = this;
    if (isUpdate === void 0) {
      isUpdate = false;
    }
    if (this.animateOption) {
      this.animateOption = deepMix({}, getDefaultAnimateCfg(this.type, this.coordinate), this.animateOption);
    }
    this.defaultSize = void 0;
    this.elementsMap = {};
    this.elements = [];
    var offscreenGroup = this.getOffscreenGroup();
    offscreenGroup.clear();
    var beforeMappingData = this.beforeMappingData;
    var dataArray = this.beforeMapping(beforeMappingData);
    this.dataArray = new Array(dataArray.length);
    for (var i2 = 0; i2 < dataArray.length; i2++) {
      var data2 = dataArray[i2];
      this.dataArray[i2] = this.mapping(data2);
    }
    this.updateElements(this.dataArray, isUpdate);
    this.lastElementsMap = this.elementsMap;
    if (this.canDoGroupAnimation(isUpdate)) {
      var container = this.container;
      var type4 = this.type;
      var coordinate2 = this.coordinate;
      var animateCfg = get(this.animateOption, "appear");
      var yScale = this.getYScale();
      var yMinPoint = coordinate2.convert({
        x: 0,
        y: yScale.scale(this.getYMinValue())
      });
      doGroupAppearAnimate(container, animateCfg, type4, coordinate2, yMinPoint);
    }
    if (this.labelOption) {
      var deferred = this.useDeferredLabel;
      var callback = function() {
        return _this.renderLabels(flatten(_this.dataArray), isUpdate);
      }.bind(this);
      if (typeof deferred === "number") {
        var timeout2 = typeof deferred === "number" && deferred !== Infinity ? deferred : 0;
        if (!window.requestIdleCallback) {
          setTimeout(callback, timeout2);
        } else {
          var options = timeout2 && timeout2 !== Infinity ? { timeout: timeout2 } : void 0;
          window.requestIdleCallback(callback, options);
        }
      } else {
        callback();
      }
    }
    this.lastAttributeOption = __assign$4({}, this.attributeOption);
    if (this.visible === false) {
      this.changeVisible(false);
    }
  };
  Geometry2.prototype.clear = function() {
    var _a2 = this, container = _a2.container, geometryLabel = _a2.geometryLabel, offscreenGroup = _a2.offscreenGroup;
    if (container) {
      container.clear();
    }
    if (geometryLabel) {
      geometryLabel.clear();
    }
    if (offscreenGroup) {
      offscreenGroup.clear();
    }
    this.scaleDefs = void 0;
    this.attributes = {};
    this.scales = {};
    this.elementsMap = {};
    this.lastElementsMap = {};
    this.elements = [];
    this.adjusts = {};
    this.dataArray = null;
    this.beforeMappingData = null;
    this.lastAttributeOption = void 0;
    this.defaultSize = void 0;
    this.idFields = [];
    this.groupScales = void 0;
    this.hasSorted = false;
    this.isCoordinateChanged = false;
  };
  Geometry2.prototype.destroy = function() {
    this.clear();
    var container = this.container;
    container.remove(true);
    if (this.offscreenGroup) {
      this.offscreenGroup.remove(true);
      this.offscreenGroup = null;
    }
    if (this.geometryLabel) {
      this.geometryLabel.destroy();
      this.geometryLabel = null;
    }
    this.theme = void 0;
    this.shapeFactory = void 0;
    _super.prototype.destroy.call(this);
  };
  Geometry2.prototype.getGroupScales = function() {
    return this.groupScales;
  };
  Geometry2.prototype.getAttribute = function(name) {
    return this.attributes[name];
  };
  Geometry2.prototype.getXScale = function() {
    return this.getAttribute("position").scales[0];
  };
  Geometry2.prototype.getYScale = function() {
    return this.getAttribute("position").scales[1];
  };
  Geometry2.prototype.getGroupAttributes = function() {
    var rst = [];
    each$1(this.attributes, function(attr) {
      if (GROUP_ATTRS.includes(attr.type)) {
        rst.push(attr);
      }
    });
    return rst;
  };
  Geometry2.prototype.getDefaultValue = function(attrName) {
    var value2;
    var attr = this.getAttribute(attrName);
    if (attr && isEmpty(attr.scales)) {
      value2 = attr.values[0];
    }
    return value2;
  };
  Geometry2.prototype.getAttributeValues = function(attr, obj) {
    var params = [];
    var scales = attr.scales;
    for (var index2 = 0, length_1 = scales.length; index2 < length_1; index2++) {
      var scale2 = scales[index2];
      var field2 = scale2.field;
      if (scale2.isIdentity) {
        params.push(scale2.values);
      } else {
        params.push(obj[field2]);
      }
    }
    return attr.mapping.apply(attr, __spreadArray$1([], __read(params), false));
  };
  Geometry2.prototype.getAdjust = function(adjustType) {
    return this.adjusts[adjustType];
  };
  Geometry2.prototype.getCoordinate = function() {
    return this.coordinate;
  };
  Geometry2.prototype.getData = function() {
    return this.data;
  };
  Geometry2.prototype.getShapeMarker = function(shapeName, cfg) {
    var shapeFactory = this.getShapeFactory();
    return shapeFactory.getMarker(shapeName, cfg);
  };
  Geometry2.prototype.getElementsBy = function(condition) {
    return this.elements.filter(function(element) {
      return condition(element);
    });
  };
  Geometry2.prototype.getElements = function() {
    return this.elements;
  };
  Geometry2.prototype.getElementId = function(data2) {
    data2 = isArray$1(data2) ? data2[0] : data2;
    var originData = data2[FIELD_ORIGIN];
    if (this.idFields.length) {
      var elementId = originData[this.idFields[0]];
      for (var index2 = 1; index2 < this.idFields.length; index2++) {
        elementId += "-" + originData[this.idFields[index2]];
      }
      return elementId;
    }
    var type4 = this.type;
    var xScale = this.getXScale();
    var yScale = this.getYScale();
    var xField = xScale.field || "x";
    var yField = yScale.field || "y";
    var yVal = originData[yField];
    var xVal;
    if (xScale.type === "identity") {
      xVal = xScale.values[0];
    } else {
      xVal = originData[xField];
    }
    var id2;
    if (type4 === "interval" || type4 === "schema") {
      id2 = "".concat(xVal);
    } else if (type4 === "line" || type4 === "area" || type4 === "path") {
      id2 = type4;
    } else {
      id2 = "".concat(xVal, "-").concat(yVal);
    }
    var groupScales = this.groupScales;
    for (var index2 = 0, length_2 = groupScales.length; index2 < length_2; index2++) {
      var groupScale = groupScales[index2];
      var field2 = groupScale.field;
      id2 = "".concat(id2, "-").concat(originData[field2]);
    }
    var dodgeAdjust = this.getAdjust("dodge");
    if (dodgeAdjust) {
      var dodgeBy = dodgeAdjust.dodgeBy;
      if (dodgeBy) {
        id2 = "".concat(id2, "-").concat(originData[dodgeBy]);
      }
    }
    if (this.getAdjust("jitter")) {
      id2 = "".concat(id2, "-").concat(data2.x, "-").concat(data2.y);
    }
    return id2;
  };
  Geometry2.prototype.getScaleFields = function() {
    var fields = [];
    var tmpMap = /* @__PURE__ */ new Map();
    var _a2 = this, attributeOption = _a2.attributeOption, labelOption = _a2.labelOption, tooltipOption = _a2.tooltipOption;
    for (var attributeType in attributeOption) {
      if (attributeOption.hasOwnProperty(attributeType)) {
        var eachOpt = attributeOption[attributeType];
        if (eachOpt.fields) {
          uniq$1(eachOpt.fields, fields, tmpMap);
        } else if (eachOpt.values) {
          uniq$1(eachOpt.values, fields, tmpMap);
        }
      }
    }
    if (labelOption && labelOption.fields) {
      uniq$1(labelOption.fields, fields, tmpMap);
    }
    if (isObject(tooltipOption) && tooltipOption.fields) {
      uniq$1(tooltipOption.fields, fields, tmpMap);
    }
    return fields;
  };
  Geometry2.prototype.changeVisible = function(visible) {
    _super.prototype.changeVisible.call(this, visible);
    var elements = this.elements;
    for (var index2 = 0, length_3 = elements.length; index2 < length_3; index2++) {
      var element = elements[index2];
      element.changeVisible(visible);
    }
    if (visible) {
      if (this.container) {
        this.container.show();
      }
      if (this.labelsContainer) {
        this.labelsContainer.show();
      }
    } else {
      if (this.container) {
        this.container.hide();
      }
      if (this.labelsContainer) {
        this.labelsContainer.hide();
      }
    }
  };
  Geometry2.prototype.getFields = function() {
    var uniqMap = /* @__PURE__ */ new Map();
    var fields = [];
    Object.values(this.attributeOption).forEach(function(cfg) {
      var fs = (cfg === null || cfg === void 0 ? void 0 : cfg.fields) || [];
      fs.forEach(function(f2) {
        if (!uniqMap.has(f2)) {
          fields.push(f2);
        }
        uniqMap.set(f2, true);
      });
    }, []);
    return fields;
  };
  Geometry2.prototype.getGroupFields = function() {
    var groupFields = [];
    var tmpMap = /* @__PURE__ */ new Map();
    for (var index2 = 0, length_4 = GROUP_ATTRS.length; index2 < length_4; index2++) {
      var attributeName = GROUP_ATTRS[index2];
      var cfg = this.attributeOption[attributeName];
      if (cfg && cfg.fields) {
        uniq$1(cfg.fields, groupFields, tmpMap);
      }
    }
    return groupFields;
  };
  Geometry2.prototype.getXYFields = function() {
    var _a2 = __read(this.attributeOption.position.fields, 2), x2 = _a2[0], y2 = _a2[1];
    return [x2, y2];
  };
  Geometry2.prototype.getXField = function() {
    return get(this.getXYFields(), [0]);
  };
  Geometry2.prototype.getYField = function() {
    return get(this.getXYFields(), [1]);
  };
  Geometry2.prototype.getShapes = function() {
    return this.elements.map(function(element) {
      return element.shape;
    });
  };
  Geometry2.prototype.getOffscreenGroup = function() {
    if (!this.offscreenGroup) {
      var GroupCtor = this.container.getGroupBase();
      this.offscreenGroup = new GroupCtor({});
    }
    return this.offscreenGroup;
  };
  Geometry2.prototype.sort = function(mappingArray) {
    if (!this.hasSorted) {
      var xScale_1 = this.getXScale();
      var xField_1 = xScale_1.field;
      for (var index2 = 0; index2 < mappingArray.length; index2++) {
        var itemArr = mappingArray[index2];
        itemArr.sort(function(obj1, obj2) {
          return xScale_1.translate(obj1[FIELD_ORIGIN][xField_1]) - xScale_1.translate(obj2[FIELD_ORIGIN][xField_1]);
        });
      }
    }
    this.hasSorted = true;
  };
  Geometry2.prototype.adjustScale = function() {
    var yScale = this.getYScale();
    if (yScale && this.getAdjust("stack")) {
      this.updateStackRange(yScale, this.beforeMappingData);
    }
  };
  Geometry2.prototype.getShapeFactory = function() {
    var shapeType = this.shapeType;
    if (!getShapeFactory(shapeType)) {
      return;
    }
    if (!this.shapeFactory) {
      this.shapeFactory = clone$1(getShapeFactory(shapeType));
    }
    this.shapeFactory.coordinate = this.coordinate;
    this.shapeFactory.theme = this.theme.geometries[shapeType] || {};
    return this.shapeFactory;
  };
  Geometry2.prototype.createShapePointsCfg = function(obj) {
    var xScale = this.getXScale();
    var yScale = this.getYScale();
    var x2 = this.normalizeValues(obj[xScale.field], xScale);
    var y2;
    if (yScale) {
      y2 = this.normalizeValues(obj[yScale.field], yScale);
    } else {
      y2 = obj.y ? obj.y : 0.1;
    }
    return {
      x: x2,
      y: y2,
      y0: yScale ? yScale.scale(this.getYMinValue()) : void 0
    };
  };
  Geometry2.prototype.createElement = function(mappingDatum, index2, isUpdate) {
    if (isUpdate === void 0) {
      isUpdate = false;
    }
    var container = this.container;
    var shapeCfg = this.getDrawCfg(mappingDatum);
    var shapeFactory = this.getShapeFactory();
    var element = new Element$1({
      shapeFactory,
      container,
      offscreenGroup: this.getOffscreenGroup(),
      elementIndex: index2
    });
    element.animate = this.animateOption;
    element.geometry = this;
    element.draw(shapeCfg, isUpdate);
    return element;
  };
  Geometry2.prototype.getDrawCfg = function(mappingDatum) {
    var originData = mappingDatum[FIELD_ORIGIN];
    var cfg = {
      mappingData: mappingDatum,
      data: originData,
      x: mappingDatum.x,
      y: mappingDatum.y,
      color: mappingDatum.color,
      size: mappingDatum.size,
      isInCircle: this.coordinate.isPolar,
      customInfo: this.customOption
    };
    var shapeName = mappingDatum.shape;
    if (!shapeName && this.getShapeFactory()) {
      shapeName = this.getShapeFactory().defaultShapeType;
    }
    cfg.shape = shapeName;
    var theme2 = this.theme.geometries[this.shapeType];
    cfg.defaultStyle = get(theme2, [shapeName, "default"], {}).style;
    if (!cfg.defaultStyle && this.getShapeFactory()) {
      cfg.defaultStyle = this.getShapeFactory().getDefaultStyle(theme2);
    }
    var styleOption = this.styleOption;
    if (styleOption) {
      cfg.style = this.getStyleCfg(styleOption, originData);
    }
    if (this.generatePoints) {
      cfg.points = mappingDatum.points;
      cfg.nextPoints = mappingDatum.nextPoints;
    }
    return cfg;
  };
  Geometry2.prototype.updateElements = function(mappingDataArray, isUpdate) {
    var e_1, _a2, e_2, _b, e_3, _c;
    if (isUpdate === void 0) {
      isUpdate = false;
    }
    var keyDatum = /* @__PURE__ */ new Map();
    var keys2 = [];
    var keyIndex = /* @__PURE__ */ new Map();
    var index2 = 0;
    for (var i2 = 0; i2 < mappingDataArray.length; i2++) {
      var mappingData = mappingDataArray[i2];
      for (var j2 = 0; j2 < mappingData.length; j2++) {
        var mappingDatum = mappingData[j2];
        var key2 = this.getElementId(mappingDatum);
        var finalKey = keyDatum.has(key2) ? "".concat(key2, "-").concat(i2, "-").concat(j2) : key2;
        keys2.push(finalKey);
        keyDatum.set(finalKey, mappingDatum);
        keyIndex.set(finalKey, index2);
        index2++;
      }
    }
    this.elements = new Array(index2);
    var _d = diff(this.lastElementsMap, keys2), added = _d.added, updated = _d.updated, removed = _d.removed;
    try {
      for (var added_1 = __values(added), added_1_1 = added_1.next(); !added_1_1.done; added_1_1 = added_1.next()) {
        var key2 = added_1_1.value;
        var mappingDatum = keyDatum.get(key2);
        var i2 = keyIndex.get(key2);
        var element = this.createElement(mappingDatum, i2, isUpdate);
        this.elements[i2] = element;
        this.elementsMap[key2] = element;
        if (element.shape) {
          element.shape.set("zIndex", this.zIndexReversed ? this.elements.length - i2 : i2);
        }
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (added_1_1 && !added_1_1.done && (_a2 = added_1.return))
          _a2.call(added_1);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
    try {
      for (var updated_1 = __values(updated), updated_1_1 = updated_1.next(); !updated_1_1.done; updated_1_1 = updated_1.next()) {
        var key2 = updated_1_1.value;
        var element = this.lastElementsMap[key2];
        var mappingDatum = keyDatum.get(key2);
        var currentShapeCfg = this.getDrawCfg(mappingDatum);
        var preShapeCfg = element.getModel();
        var i2 = keyIndex.get(key2);
        if (this.isCoordinateChanged || isModelChange(currentShapeCfg, preShapeCfg)) {
          element.animate = this.animateOption;
          element.update(currentShapeCfg);
        }
        this.elements[i2] = element;
        this.elementsMap[key2] = element;
        if (element.shape) {
          element.shape.set("zIndex", this.zIndexReversed ? this.elements.length - i2 : i2);
        }
      }
    } catch (e_2_1) {
      e_2 = { error: e_2_1 };
    } finally {
      try {
        if (updated_1_1 && !updated_1_1.done && (_b = updated_1.return))
          _b.call(updated_1);
      } finally {
        if (e_2)
          throw e_2.error;
      }
    }
    if (this.container) {
      this.container.sort();
    }
    try {
      for (var removed_1 = __values(removed), removed_1_1 = removed_1.next(); !removed_1_1.done; removed_1_1 = removed_1.next()) {
        var key2 = removed_1_1.value;
        var element = this.lastElementsMap[key2];
        element.animate = this.animateOption;
        element.destroy();
      }
    } catch (e_3_1) {
      e_3 = { error: e_3_1 };
    } finally {
      try {
        if (removed_1_1 && !removed_1_1.done && (_c = removed_1.return))
          _c.call(removed_1);
      } finally {
        if (e_3)
          throw e_3.error;
      }
    }
  };
  Geometry2.prototype.getLabelType = function() {
    var _a2 = this, labelOption = _a2.labelOption, coordinate2 = _a2.coordinate, type4 = _a2.type;
    var coordinateType = coordinate2.type, isTransposed = coordinate2.isTransposed;
    var labelType = get(labelOption, ["cfg", "type"]);
    if (!labelType) {
      if (coordinateType === "polar") {
        labelType = isTransposed ? "pie" : "polar";
      } else if (coordinateType === "theta") {
        labelType = "pie";
      } else if (type4 === "interval" || type4 === "polygon") {
        labelType = "interval";
      } else {
        labelType = "base";
      }
    }
    return labelType;
  };
  Geometry2.prototype.getYMinValue = function() {
    var yScale = this.getYScale();
    var min2 = yScale.min, max2 = yScale.max;
    var value2;
    if (min2 >= 0) {
      value2 = min2;
    } else if (max2 <= 0) {
      value2 = max2;
    } else {
      value2 = 0;
    }
    return value2;
  };
  Geometry2.prototype.createAttrOption = function(attrName, field2, cfg) {
    if (isNil(field2) || isObject(field2)) {
      if (isObject(field2) && isEqual$1(Object.keys(field2), ["values"])) {
        set(this.attributeOption, attrName, {
          fields: field2.values
        });
      } else {
        set(this.attributeOption, attrName, field2);
      }
    } else {
      var attrCfg = {};
      if (isNumber$1(field2)) {
        attrCfg.values = [field2];
      } else {
        attrCfg.fields = parseFields(field2);
      }
      if (cfg) {
        if (isFunction(cfg)) {
          attrCfg.callback = cfg;
        } else {
          attrCfg.values = cfg;
        }
      }
      set(this.attributeOption, attrName, attrCfg);
    }
  };
  Geometry2.prototype.initAttributes = function() {
    var _this = this;
    var _a2 = this, attributes2 = _a2.attributes, attributeOption = _a2.attributeOption, theme2 = _a2.theme, shapeType = _a2.shapeType;
    this.groupScales = [];
    var tmpMap = {};
    var _loop_1 = function(attrType2) {
      if (attributeOption.hasOwnProperty(attrType2)) {
        var option = attributeOption[attrType2];
        if (!option) {
          return { value: void 0 };
        }
        var attrCfg = __assign$4({}, option);
        var callback = attrCfg.callback, values2 = attrCfg.values, _b = attrCfg.fields, fields = _b === void 0 ? [] : _b;
        var scales = fields.map(function(field2) {
          var scale2 = _this.scales[field2];
          if (!tmpMap[field2] && GROUP_ATTRS.includes(attrType2)) {
            var inferedScaleType = inferScaleType(scale2, get(_this.scaleDefs, field2), attrType2, _this.type);
            if (inferedScaleType === "cat") {
              _this.groupScales.push(scale2);
              tmpMap[field2] = true;
            }
          }
          return scale2;
        });
        attrCfg.scales = scales;
        if (attrType2 !== "position" && scales.length === 1 && scales[0].type === "identity") {
          attrCfg.values = scales[0].values;
        } else if (!callback && !values2) {
          if (attrType2 === "size") {
            attrCfg.values = theme2.sizes;
          } else if (attrType2 === "shape") {
            attrCfg.values = theme2.shapes[shapeType] || [];
          } else if (attrType2 === "color") {
            if (scales.length) {
              attrCfg.values = scales[0].values.length <= 10 ? theme2.colors10 : theme2.colors20;
            } else {
              attrCfg.values = theme2.colors10;
            }
          }
        }
        var AttributeCtor = getAttribute(attrType2);
        attributes2[attrType2] = new AttributeCtor(attrCfg);
      }
    };
    for (var attrType in attributeOption) {
      var state_1 = _loop_1(attrType);
      if (typeof state_1 === "object")
        return state_1.value;
    }
  };
  Geometry2.prototype.processData = function(data2) {
    var e_4, _a2;
    this.hasSorted = false;
    var scales = this.getAttribute("position").scales;
    var categoryScales = scales.filter(function(scale3) {
      return scale3.isCategory;
    });
    var groupedArray = this.groupData(data2);
    var beforeAdjust = [];
    for (var i2 = 0, len = groupedArray.length; i2 < len; i2++) {
      var subData = groupedArray[i2];
      var arr = [];
      for (var j2 = 0, subLen = subData.length; j2 < subLen; j2++) {
        var originData = subData[j2];
        var item = {};
        for (var k2 in originData) {
          item[k2] = originData[k2];
        }
        item[FIELD_ORIGIN] = originData;
        try {
          for (var categoryScales_1 = (e_4 = void 0, __values(categoryScales)), categoryScales_1_1 = categoryScales_1.next(); !categoryScales_1_1.done; categoryScales_1_1 = categoryScales_1.next()) {
            var scale2 = categoryScales_1_1.value;
            var field2 = scale2.field;
            item[field2] = scale2.translate(item[field2]);
          }
        } catch (e_4_1) {
          e_4 = { error: e_4_1 };
        } finally {
          try {
            if (categoryScales_1_1 && !categoryScales_1_1.done && (_a2 = categoryScales_1.return))
              _a2.call(categoryScales_1);
          } finally {
            if (e_4)
              throw e_4.error;
          }
        }
        arr.push(item);
      }
      beforeAdjust.push(arr);
    }
    var dataArray = this.adjustData(beforeAdjust);
    this.beforeMappingData = dataArray;
    return dataArray;
  };
  Geometry2.prototype.adjustData = function(dataArray) {
    var adjustOption = this.adjustOption;
    var _a2 = this, intervalPadding = _a2.intervalPadding, dodgePadding = _a2.dodgePadding, theme2 = _a2.theme;
    var maxColumnWidth = this.maxColumnWidth || theme2.maxColumnWidth;
    var minColumnWidth = this.minColumnWidth || theme2.minColumnWidth;
    var columnWidthRatio = this.columnWidthRatio || theme2.columnWidthRatio;
    var result = dataArray;
    if (adjustOption) {
      var xScale_2 = this.getXScale();
      var yScale = this.getYScale();
      var xField = xScale_2.field;
      var yField = yScale ? yScale.field : null;
      var xDimensionLength = getXDimensionLength(this.coordinate);
      var groupNum = xScale_2.values.length;
      var sizeAttr = this.getAttribute("size");
      var defaultSize = void 0;
      if (sizeAttr) {
        defaultSize = sizeAttr.values[0];
      }
      for (var i2 = 0, len = adjustOption.length; i2 < len; i2++) {
        var adjust2 = adjustOption[i2];
        var adjustCfg2 = __assign$4({ xField, yField, intervalPadding, dodgePadding, xDimensionLength, groupNum, defaultSize, maxColumnWidth, minColumnWidth, columnWidthRatio }, adjust2);
        var type4 = adjust2.type;
        if (type4 === "dodge") {
          var adjustNames = [];
          if (xScale_2.isCategory || xScale_2.type === "identity") {
            adjustNames.push("x");
          } else if (!yScale) {
            adjustNames.push("y");
          } else {
            throw new Error("dodge is not support linear attribute, please use category attribute!");
          }
          adjustCfg2.adjustNames = adjustNames;
          adjustCfg2.dodgeRatio = columnWidthRatio;
        } else if (type4 === "stack") {
          var coordinate2 = this.coordinate;
          if (!yScale) {
            adjustCfg2.height = coordinate2.getHeight();
            var size2 = this.getDefaultValue("size") || 3;
            adjustCfg2.size = size2;
          }
          if (!coordinate2.isTransposed && isNil(adjustCfg2.reverseOrder)) {
            adjustCfg2.reverseOrder = true;
          }
        }
        var adjustCtor = getAdjust(type4);
        adjustCfg2.dimValuesMap = {};
        if (xScale_2 && xScale_2.values) {
          adjustCfg2.dimValuesMap[xScale_2.field] = xScale_2.values.map(function(v2) {
            return xScale_2.translate(v2);
          });
        }
        var adjustInstance = new adjustCtor(adjustCfg2);
        result = adjustInstance.process(result);
        this.adjusts[type4] = adjustInstance;
      }
    }
    return result;
  };
  Geometry2.prototype.groupData = function(data2) {
    var groupScales = this.getGroupScales();
    var scaleDefs = this.scaleDefs;
    var appendConditions = {};
    var groupFields = [];
    for (var index2 = 0; index2 < groupScales.length; index2++) {
      var scale2 = groupScales[index2];
      var field2 = scale2.field;
      groupFields.push(field2);
      if (get(scaleDefs, [field2, "values"])) {
        appendConditions[field2] = scaleDefs[field2].values;
      }
    }
    return group(data2, groupFields, appendConditions);
  };
  Geometry2.prototype.updateStackRange = function(scale2, dataArray) {
    var mergeArray = flatten(dataArray);
    var field2 = scale2.field;
    var min2 = scale2.min;
    var max2 = scale2.max;
    for (var index2 = 0; index2 < mergeArray.length; index2++) {
      var obj = mergeArray[index2];
      var tmpMin = Math.min.apply(null, obj[field2]);
      var tmpMax = Math.max.apply(null, obj[field2]);
      if (tmpMin < min2) {
        min2 = tmpMin;
      }
      if (tmpMax > max2) {
        max2 = tmpMax;
      }
    }
    var scaleDefs = this.scaleDefs;
    var cfg = {};
    if (min2 < scale2.min && !get(scaleDefs, [field2, "min"])) {
      cfg.min = min2;
    }
    if (max2 > scale2.max && !get(scaleDefs, [field2, "max"])) {
      cfg.max = max2;
    }
    scale2.change(cfg);
  };
  Geometry2.prototype.beforeMapping = function(beforeMappingData) {
    var source = beforeMappingData;
    if (this.sortable) {
      this.sort(source);
    }
    if (this.generatePoints) {
      for (var index2 = 0, length_5 = source.length; index2 < length_5; index2++) {
        var currentData = source[index2];
        this.generateShapePoints(currentData);
        var nextData = source[index2 + 1];
        if (nextData) {
          this.generateShapePoints(nextData);
          currentData[0].nextPoints = nextData[0].points;
        }
      }
    }
    return source;
  };
  Geometry2.prototype.generateShapePoints = function(data2) {
    var shapeFactory = this.getShapeFactory();
    var shapeAttr = this.getAttribute("shape");
    for (var index2 = 0; index2 < data2.length; index2++) {
      var obj = data2[index2];
      var cfg = this.createShapePointsCfg(obj);
      var shape = shapeAttr ? this.getAttributeValues(shapeAttr, obj) : null;
      var points2 = shapeFactory.getShapePoints(shape, cfg);
      obj.points = points2;
    }
  };
  Geometry2.prototype.normalizeValues = function(values2, scale2) {
    var rst = [];
    if (isArray$1(values2)) {
      for (var index2 = 0; index2 < values2.length; index2++) {
        var value2 = values2[index2];
        rst.push(scale2.scale(value2));
      }
    } else {
      rst = scale2.scale(values2);
    }
    return rst;
  };
  Geometry2.prototype.mapping = function(data2) {
    var attributes2 = this.attributes;
    var mappingData = [];
    for (var index2 = 0; index2 < data2.length; index2++) {
      var record = data2[index2];
      var newRecord = {
        _origin: record[FIELD_ORIGIN],
        points: record.points,
        nextPoints: record.nextPoints
      };
      for (var k2 in attributes2) {
        if (attributes2.hasOwnProperty(k2)) {
          var attr = attributes2[k2];
          var names2 = attr.names;
          var values2 = this.getAttributeValues(attr, record);
          if (names2.length > 1) {
            for (var j2 = 0; j2 < values2.length; j2 += 1) {
              var val = values2[j2];
              var name_1 = names2[j2];
              newRecord[name_1] = isArray$1(val) && val.length === 1 ? val[0] : val;
            }
          } else {
            newRecord[names2[0]] = values2.length === 1 ? values2[0] : values2;
          }
        }
      }
      this.convertPoint(newRecord);
      mappingData.push(newRecord);
    }
    return mappingData;
  };
  Geometry2.prototype.convertPoint = function(mappingRecord) {
    var x2 = mappingRecord.x, y2 = mappingRecord.y;
    var rstX;
    var rstY;
    var obj;
    var coordinate2 = this.coordinate;
    if (isArray$1(x2) && isArray$1(y2)) {
      rstX = [];
      rstY = [];
      for (var i2 = 0, j2 = 0, xLen = x2.length, yLen = y2.length; i2 < xLen && j2 < yLen; i2 += 1, j2 += 1) {
        obj = coordinate2.convert({
          x: x2[i2],
          y: y2[j2]
        });
        rstX.push(obj.x);
        rstY.push(obj.y);
      }
    } else if (isArray$1(y2)) {
      rstY = [];
      for (var index2 = 0; index2 < y2.length; index2++) {
        var yVal = y2[index2];
        obj = coordinate2.convert({
          x: x2,
          y: yVal
        });
        if (rstX && rstX !== obj.x) {
          if (!isArray$1(rstX)) {
            rstX = [rstX];
          }
          rstX.push(obj.x);
        } else {
          rstX = obj.x;
        }
        rstY.push(obj.y);
      }
    } else if (isArray$1(x2)) {
      rstX = [];
      for (var index2 = 0; index2 < x2.length; index2++) {
        var xVal = x2[index2];
        obj = coordinate2.convert({
          x: xVal,
          y: y2
        });
        if (rstY && rstY !== obj.y) {
          if (!isArray$1(rstY)) {
            rstY = [rstY];
          }
          rstY.push(obj.y);
        } else {
          rstY = obj.y;
        }
        rstX.push(obj.x);
      }
    } else {
      var point2 = coordinate2.convert({
        x: x2,
        y: y2
      });
      rstX = point2.x;
      rstY = point2.y;
    }
    mappingRecord.x = rstX;
    mappingRecord.y = rstY;
  };
  Geometry2.prototype.getStyleCfg = function(styleOption, originData) {
    var _a2 = styleOption.fields, fields = _a2 === void 0 ? [] : _a2, callback = styleOption.callback, cfg = styleOption.cfg;
    if (cfg) {
      return cfg;
    }
    var params = fields.map(function(field2) {
      return originData[field2];
    });
    return callback.apply(void 0, __spreadArray$1([], __read(params), false));
  };
  Geometry2.prototype.setCfg = function(cfg) {
    var _this = this;
    var coordinate2 = cfg.coordinate, data2 = cfg.data, theme2 = cfg.theme, scaleDefs = cfg.scaleDefs;
    if (coordinate2) {
      this.coordinate = coordinate2;
    }
    if (data2) {
      this.data = data2;
    }
    if (scaleDefs) {
      this.scaleDefs = scaleDefs;
      this.idFields = [];
      each$1(scaleDefs, function(scaleDef, field2) {
        if (scaleDef && scaleDef.key) {
          _this.idFields.push(field2);
        }
      });
    }
    if (theme2) {
      this.theme = this.userTheme ? deepMix({}, theme2, this.userTheme) : theme2;
    }
  };
  Geometry2.prototype.renderLabels = function(mappingArray, isUpdate) {
    if (isUpdate === void 0) {
      isUpdate = false;
    }
    return __awaiter(this, void 0, void 0, function() {
      var geometryLabel, labelType, GeometryLabelsCtor, labelsMap, elementLabels, _a2, _b, _c, element, labels;
      var e_5, _d;
      var _this = this;
      return __generator(this, function(_e) {
        switch (_e.label) {
          case 0:
            geometryLabel = this.geometryLabel;
            this.emit(GEOMETRY_LIFE_CIRCLE.BEFORE_RENDER_LABEL);
            if (!geometryLabel) {
              labelType = this.getLabelType();
              GeometryLabelsCtor = getGeometryLabel(labelType);
              geometryLabel = new GeometryLabelsCtor(this);
              this.geometryLabel = geometryLabel;
            }
            return [4, geometryLabel.render(mappingArray, isUpdate)];
          case 1:
            _e.sent();
            labelsMap = geometryLabel.labelsRenderer.shapesMap;
            elementLabels = /* @__PURE__ */ new Map();
            each$1(labelsMap, function(labelGroup, labelGroupId) {
              var labelChildren = labelGroup.getChildren() || [];
              for (var j2 = 0; j2 < labelChildren.length; j2++) {
                var labelShape = labelChildren[j2];
                var element2 = _this.elementsMap[labelShape.get("elementId") || labelGroupId.split(" ")[0]];
                if (element2) {
                  labelShape.cfg.name = ["element", "label"];
                  labelShape.cfg.element = element2;
                  var labels2 = elementLabels.get(element2) || /* @__PURE__ */ new Set();
                  labels2.add(labelGroup);
                  elementLabels.set(element2, labels2);
                }
              }
            });
            try {
              for (_a2 = __values(elementLabels.entries()), _b = _a2.next(); !_b.done; _b = _a2.next()) {
                _c = __read(_b.value, 2), element = _c[0], labels = _c[1];
                element.labelShape = __spreadArray$1([], __read(labels), false);
              }
            } catch (e_5_1) {
              e_5 = { error: e_5_1 };
            } finally {
              try {
                if (_b && !_b.done && (_d = _a2.return))
                  _d.call(_a2);
              } finally {
                if (e_5)
                  throw e_5.error;
              }
            }
            this.emit(GEOMETRY_LIFE_CIRCLE.AFTER_RENDER_LABEL);
            return [2];
        }
      });
    });
  };
  Geometry2.prototype.canDoGroupAnimation = function(isUpdate) {
    return !isUpdate && this.animateOption && (get(this.animateOption, "appear") === void 0 || get(this.animateOption, "appear") && get(this.animateOption, ["appear", "animation"]) === void 0);
  };
  return Geometry2;
}(Base$1);
var transform$4 = transform$6;
function translate(element, x2, y2) {
  var matrix = transform$4(element.getMatrix(), [["t", x2, y2]]);
  element.setMatrix(matrix);
}
function getRotateMatrix(element, rotateRadian) {
  var _a2 = element.attr(), x2 = _a2.x, y2 = _a2.y;
  var matrix = transform$4(element.getMatrix(), [
    ["t", -x2, -y2],
    ["r", rotateRadian],
    ["t", x2, y2]
  ]);
  return matrix;
}
function rotate(element, rotateRadian) {
  var matrix = getRotateMatrix(element, rotateRadian);
  element.setMatrix(matrix);
}
function zoom(element, ratio) {
  var bbox = element.getBBox();
  var x2 = (bbox.minX + bbox.maxX) / 2;
  var y2 = (bbox.minY + bbox.maxY) / 2;
  element.applyToMatrix([x2, y2, 1]);
  var matrix = transform$4(element.getMatrix(), [
    ["t", -x2, -y2],
    ["s", ratio, ratio],
    ["t", x2, y2]
  ]);
  element.setMatrix(matrix);
}
function findLabelTextShape(label2) {
  return label2.find(function(el) {
    return el.get("type") === "text";
  });
}
function getLabelBackgroundInfo(labelGroup, labelItem, padding2) {
  if (padding2 === void 0) {
    padding2 = [0, 0, 0, 0];
  }
  var content = labelGroup && labelGroup.getChildren()[0];
  if (content) {
    var labelShape = content.clone();
    if (labelItem === null || labelItem === void 0 ? void 0 : labelItem.rotate) {
      rotate(labelShape, -labelItem.rotate);
    }
    var _a2 = labelShape.getCanvasBBox(), x2 = _a2.x, y2 = _a2.y, width = _a2.width, height = _a2.height;
    labelShape.destroy();
    var boxPadding = padding2;
    if (isNil(boxPadding)) {
      boxPadding = [2, 2, 2, 2];
    } else if (isNumber$1(boxPadding)) {
      boxPadding = new Array(4).fill(boxPadding);
    }
    return {
      x: x2 - boxPadding[3],
      y: y2 - boxPadding[0],
      width: width + boxPadding[1] + boxPadding[3],
      height: height + boxPadding[0] + boxPadding[2],
      rotation: (labelItem === null || labelItem === void 0 ? void 0 : labelItem.rotate) || 0
    };
  }
  return { x: 0, y: 0, width: 0, height: 0, rotation: 0 };
}
function getOverlapArea$2(a2, b10, margin) {
  if (margin === void 0) {
    margin = 0;
  }
  var xOverlap = Math.max(0, Math.min(a2.x + a2.width + margin, b10.x + b10.width + margin) - Math.max(a2.x - margin, b10.x - margin));
  var yOverlap = Math.max(0, Math.min(a2.y + a2.height + margin, b10.y + b10.height + margin) - Math.max(a2.y - margin, b10.y - margin));
  return xOverlap * yOverlap;
}
function checkShapeOverlap$2(cur, dones) {
  var box2 = cur.getBBox();
  return some(dones, function(done) {
    var target = done.getBBox();
    return getOverlapArea$2(box2, target, 2) > 0;
  });
}
function updateLabel(fromShape, toShape, cfg) {
  var data2 = cfg.data, origin = cfg.origin, animateCfg = cfg.animateCfg, coordinate2 = cfg.coordinate;
  var updateAnimateCfg = get(animateCfg, "update");
  fromShape.set("data", data2);
  fromShape.set("origin", origin);
  fromShape.set("animateCfg", animateCfg);
  fromShape.set("coordinate", coordinate2);
  fromShape.set("visible", toShape.get("visible"));
  (fromShape.getChildren() || []).forEach(function(fromChild, idx) {
    var toChild = toShape.getChildByIndex(idx);
    if (!toChild) {
      fromShape.removeChild(fromChild);
      fromChild.remove(true);
    } else {
      fromChild.set("data", data2);
      fromChild.set("origin", origin);
      fromChild.set("animateCfg", animateCfg);
      fromChild.set("coordinate", coordinate2);
      var newAttrs = getReplaceAttrs(fromChild, toChild);
      if (updateAnimateCfg) {
        doAnimate(fromChild, updateAnimateCfg, {
          toAttrs: newAttrs,
          coordinate: coordinate2
        });
      } else {
        fromChild.attr(newAttrs);
      }
      if (toChild.isGroup()) {
        updateLabel(fromChild, toChild, cfg);
      }
    }
  });
  each$1(toShape.getChildren(), function(child, idx) {
    if (idx >= fromShape.getCount()) {
      if (!child.destroyed) {
        fromShape.add(child);
      }
    }
  });
}
var Labels = function() {
  function Labels2(cfg) {
    this.shapesMap = {};
    var layout2 = cfg.layout, container = cfg.container;
    this.layout = layout2;
    this.container = container;
  }
  Labels2.prototype.render = function(items, shapes, isUpdate) {
    if (isUpdate === void 0) {
      isUpdate = false;
    }
    return __awaiter(this, void 0, void 0, function() {
      var shapesMap, offscreenGroup, items_1, items_1_1, item, lastShapesMap;
      var e_1, _a2;
      var _this = this;
      return __generator(this, function(_b) {
        switch (_b.label) {
          case 0:
            shapesMap = {};
            offscreenGroup = this.createOffscreenGroup();
            if (!items.length)
              return [3, 2];
            try {
              for (items_1 = __values(items), items_1_1 = items_1.next(); !items_1_1.done; items_1_1 = items_1.next()) {
                item = items_1_1.value;
                if (item) {
                  shapesMap[item.id] = this.renderLabel(item, offscreenGroup);
                }
              }
            } catch (e_1_1) {
              e_1 = { error: e_1_1 };
            } finally {
              try {
                if (items_1_1 && !items_1_1.done && (_a2 = items_1.return))
                  _a2.call(items_1);
              } finally {
                if (e_1)
                  throw e_1.error;
              }
            }
            return [4, this.doLayout(items, shapes, shapesMap)];
          case 1:
            _b.sent();
            this.renderLabelLine(items, shapesMap);
            this.renderLabelBackground(items, shapesMap);
            this.adjustLabel(items, shapesMap);
            _b.label = 2;
          case 2:
            lastShapesMap = this.shapesMap;
            each$1(shapesMap, function(shape, id2) {
              if (shape.destroyed) {
                delete shapesMap[id2];
              } else {
                if (lastShapesMap[id2]) {
                  var data2 = shape.get("data");
                  var origin_1 = shape.get("origin");
                  var coordinate2 = shape.get("coordinate");
                  var currentAnimateCfg = shape.get("animateCfg");
                  var currentShape = lastShapesMap[id2];
                  updateLabel(currentShape, shapesMap[id2], {
                    data: data2,
                    origin: origin_1,
                    animateCfg: currentAnimateCfg,
                    coordinate: coordinate2
                  });
                  shapesMap[id2] = currentShape;
                } else {
                  if (_this.container.destroyed)
                    return;
                  _this.container.add(shape);
                  var animateCfg = get(shape.get("animateCfg"), isUpdate ? "enter" : "appear");
                  if (animateCfg) {
                    doAnimate(shape, animateCfg, {
                      toAttrs: __assign$4({}, shape.attr()),
                      coordinate: shape.get("coordinate")
                    });
                  }
                }
                delete lastShapesMap[id2];
              }
            });
            each$1(lastShapesMap, function(deleteShape) {
              var animateCfg = get(deleteShape.get("animateCfg"), "leave");
              if (animateCfg) {
                doAnimate(deleteShape, animateCfg, {
                  toAttrs: null,
                  coordinate: deleteShape.get("coordinate")
                });
              } else {
                deleteShape.remove(true);
              }
            });
            this.shapesMap = shapesMap;
            offscreenGroup.destroy();
            return [2];
        }
      });
    });
  };
  Labels2.prototype.clear = function() {
    this.container.clear();
    this.shapesMap = {};
  };
  Labels2.prototype.destroy = function() {
    this.container.destroy();
    this.shapesMap = null;
  };
  Labels2.prototype.renderLabel = function(cfg, container) {
    var id2 = cfg.id, elementId = cfg.elementId, data2 = cfg.data, mappingData = cfg.mappingData, coordinate2 = cfg.coordinate, animate = cfg.animate, content = cfg.content, capture = cfg.capture;
    var shapeAppendCfg = {
      id: id2,
      elementId,
      capture,
      data: data2,
      origin: __assign$4(__assign$4({}, mappingData), { data: mappingData[FIELD_ORIGIN] }),
      coordinate: coordinate2
    };
    var labelGroup = container.addGroup(__assign$4({
      name: "label",
      animateCfg: this.animate === false || animate === null || animate === false ? false : deepMix({}, this.animate, animate)
    }, shapeAppendCfg));
    var labelShape;
    if (content.isGroup && content.isGroup() || content.isShape && content.isShape()) {
      var _a2 = content.getCanvasBBox(), width = _a2.width, height = _a2.height;
      var textAlign = get(cfg, "textAlign", "left");
      var x2 = cfg.x;
      var y2 = cfg.y - height / 2;
      if (textAlign === "center") {
        x2 = x2 - width / 2;
      } else if (textAlign === "right" || textAlign === "end") {
        x2 = x2 - width;
      }
      translate(content, x2, y2);
      labelShape = content;
      labelGroup.add(content);
    } else {
      var fill = get(cfg, ["style", "fill"]);
      labelShape = labelGroup.addShape("text", __assign$4({ attrs: __assign$4(__assign$4({ x: cfg.x, y: cfg.y, textAlign: cfg.textAlign, textBaseline: get(cfg, "textBaseline", "middle"), text: cfg.content }, cfg.style), { fill: isNull(fill) ? cfg.color : fill }) }, shapeAppendCfg));
    }
    if (cfg.rotate) {
      rotate(labelShape, cfg.rotate);
    }
    return labelGroup;
  };
  Labels2.prototype.doLayout = function(items, shapes, shapesMap) {
    return __awaiter(this, void 0, void 0, function() {
      var layouts;
      var _this = this;
      return __generator(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            if (!this.layout)
              return [3, 2];
            layouts = isArray$1(this.layout) ? this.layout : [this.layout];
            return [4, Promise.all(layouts.map(function(layout2) {
              var layoutFn = getGeometryLabelLayout(get(layout2, "type", ""));
              if (!layoutFn)
                return;
              var labelShapes = [];
              var geometryShapes = [];
              each$1(shapesMap, function(labelShape, id2) {
                labelShapes.push(labelShape);
                geometryShapes.push(shapes[labelShape.get("elementId")]);
              });
              return layoutFn(items, labelShapes, geometryShapes, _this.region, layout2.cfg);
            }))];
          case 1:
            _a2.sent();
            _a2.label = 2;
          case 2:
            return [2];
        }
      });
    });
  };
  Labels2.prototype.renderLabelLine = function(labelItems, shapesMap) {
    each$1(labelItems, function(labelItem) {
      var coordinate2 = get(labelItem, "coordinate");
      if (!labelItem || !coordinate2) {
        return;
      }
      var center2 = coordinate2.getCenter();
      var radius = coordinate2.getRadius();
      if (!labelItem.labelLine) {
        return;
      }
      var labelLineCfg = get(labelItem, "labelLine", {});
      var id2 = labelItem.id;
      var path2 = labelLineCfg.path;
      if (!path2) {
        var start = polarToCartesian(center2.x, center2.y, radius, labelItem.angle);
        path2 = [
          ["M", start.x, start.y],
          ["L", labelItem.x, labelItem.y]
        ];
      }
      var labelGroup = shapesMap[id2];
      if (!labelGroup.destroyed) {
        labelGroup.addShape("path", {
          capture: false,
          attrs: __assign$4({ path: path2, stroke: labelItem.color ? labelItem.color : get(labelItem, ["style", "fill"], "#000"), fill: null }, labelLineCfg.style),
          id: id2,
          origin: labelItem.mappingData,
          data: labelItem.data,
          coordinate: labelItem.coordinate
        });
      }
    });
  };
  Labels2.prototype.renderLabelBackground = function(labelItems, shapesMap) {
    each$1(labelItems, function(labelItem) {
      var coordinate2 = get(labelItem, "coordinate");
      var background = get(labelItem, "background");
      if (!background || !coordinate2) {
        return;
      }
      var id2 = labelItem.id;
      var labelGroup = shapesMap[id2];
      if (!labelGroup.destroyed) {
        var labelContentShape = labelGroup.getChildren()[0];
        if (labelContentShape) {
          var _a2 = getLabelBackgroundInfo(labelGroup, labelItem, background.padding), rotation = _a2.rotation, box2 = __rest$3(_a2, ["rotation"]);
          var backgroundShape = labelGroup.addShape("rect", {
            attrs: __assign$4(__assign$4({}, box2), background.style || {}),
            id: id2,
            origin: labelItem.mappingData,
            data: labelItem.data,
            coordinate: labelItem.coordinate
          });
          backgroundShape.setZIndex(-1);
          if (rotation) {
            var matrix = labelContentShape.getMatrix();
            backgroundShape.setMatrix(matrix);
          }
        }
      }
    });
  };
  Labels2.prototype.createOffscreenGroup = function() {
    var container = this.container;
    var GroupClass = container.getGroupBase();
    var newGroup = new GroupClass({});
    return newGroup;
  };
  Labels2.prototype.adjustLabel = function(items, shapesMap) {
    each$1(items, function(item) {
      if (item) {
        var id2 = item.id;
        var labelGroup = shapesMap[id2];
        if (!labelGroup.destroyed) {
          var labelShapes = labelGroup.findAll(function(ele) {
            return ele.get("type") !== "path";
          });
          each$1(labelShapes, function(labelShape) {
            if (labelShape) {
              if (item.offsetX) {
                labelShape.attr("x", labelShape.attr("x") + item.offsetX);
              }
              if (item.offsetY) {
                labelShape.attr("y", labelShape.attr("y") + item.offsetY);
              }
            }
          });
        }
      }
    });
  };
  return Labels2;
}();
function avg(arr) {
  var sum = 0;
  each$1(arr, function(value2) {
    sum += value2;
  });
  return sum / arr.length;
}
var GeometryLabel = function() {
  function GeometryLabel2(geometry2) {
    this.geometry = geometry2;
  }
  GeometryLabel2.prototype.getLabelItems = function(mapppingArray) {
    var _this = this;
    var items = [];
    var labelCfgs = this.getLabelCfgs(mapppingArray);
    each$1(mapppingArray, function(mappingData, index2) {
      var labelCfg = labelCfgs[index2];
      if (!labelCfg || isNil(mappingData.x) || isNil(mappingData.y)) {
        items.push(null);
        return;
      }
      var labelContent = !isArray$1(labelCfg.content) ? [labelCfg.content] : labelCfg.content;
      labelCfg.content = labelContent;
      var total = labelContent.length;
      each$1(labelContent, function(content, subIndex) {
        if (isNil(content) || content === "") {
          items.push(null);
          return;
        }
        var item = __assign$4(__assign$4({}, labelCfg), _this.getLabelPoint(labelCfg, mappingData, subIndex));
        if (!item.textAlign) {
          item.textAlign = _this.getLabelAlign(item, subIndex, total);
        }
        if (item.offset <= 0) {
          item.labelLine = null;
        }
        items.push(item);
      });
    });
    return items;
  };
  GeometryLabel2.prototype.render = function(mappingArray, isUpdate) {
    if (isUpdate === void 0) {
      isUpdate = false;
    }
    return __awaiter(this, void 0, void 0, function() {
      var labelItems, labelsRenderer, shapes;
      return __generator(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            labelItems = this.getLabelItems(mappingArray);
            labelsRenderer = this.getLabelsRenderer();
            shapes = this.getGeometryShapes();
            return [4, labelsRenderer.render(labelItems, shapes, isUpdate)];
          case 1:
            _a2.sent();
            return [2];
        }
      });
    });
  };
  GeometryLabel2.prototype.clear = function() {
    var labelsRenderer = this.labelsRenderer;
    if (labelsRenderer) {
      labelsRenderer.clear();
    }
  };
  GeometryLabel2.prototype.destroy = function() {
    var labelsRenderer = this.labelsRenderer;
    if (labelsRenderer) {
      labelsRenderer.destroy();
    }
    this.labelsRenderer = null;
  };
  GeometryLabel2.prototype.getCoordinate = function() {
    return this.geometry.coordinate;
  };
  GeometryLabel2.prototype.getDefaultLabelCfg = function(offset3, position) {
    var geometry2 = this.geometry;
    var type4 = geometry2.type, theme2 = geometry2.theme;
    if (type4 === "polygon" || type4 === "interval" && position === "middle" || offset3 < 0 && !["line", "point", "path"].includes(type4)) {
      return get(theme2, "innerLabels", {});
    }
    return get(theme2, "labels", {});
  };
  GeometryLabel2.prototype.getThemedLabelCfg = function(labelCfg) {
    var geometry2 = this.geometry;
    var defaultLabelCfg = this.getDefaultLabelCfg();
    var type4 = geometry2.type, theme2 = geometry2.theme;
    var themedLabelCfg;
    if (type4 === "polygon" || labelCfg.offset < 0 && !["line", "point", "path"].includes(type4)) {
      themedLabelCfg = deepMix({}, defaultLabelCfg, theme2.innerLabels, labelCfg);
    } else {
      themedLabelCfg = deepMix({}, defaultLabelCfg, theme2.labels, labelCfg);
    }
    return themedLabelCfg;
  };
  GeometryLabel2.prototype.setLabelPosition = function(labelPointCfg, mappingData, index2, position) {
  };
  GeometryLabel2.prototype.getLabelOffset = function(offset3) {
    var coordinate2 = this.getCoordinate();
    var vector = this.getOffsetVector(offset3);
    return coordinate2.isTransposed ? vector[0] : vector[1];
  };
  GeometryLabel2.prototype.getLabelOffsetPoint = function(labelCfg, index2, total) {
    var offset3 = labelCfg.offset;
    var coordinate2 = this.getCoordinate();
    var transposed = coordinate2.isTransposed;
    var dim = transposed ? "x" : "y";
    var factor = transposed ? 1 : -1;
    var offsetPoint = {
      x: 0,
      y: 0
    };
    if (index2 > 0 || total === 1) {
      offsetPoint[dim] = offset3 * factor;
    } else {
      offsetPoint[dim] = offset3 * factor * -1;
    }
    return offsetPoint;
  };
  GeometryLabel2.prototype.getLabelPoint = function(labelCfg, mappingData, index2) {
    var coordinate2 = this.getCoordinate();
    var total = labelCfg.content.length;
    function getDimValue(value2, idx, isAvg) {
      if (isAvg === void 0) {
        isAvg = false;
      }
      var v2 = value2;
      if (isArray$1(v2)) {
        if (labelCfg.content.length === 1) {
          if (isAvg) {
            v2 = avg(v2);
          } else {
            if (v2.length <= 2) {
              v2 = v2[value2.length - 1];
            } else {
              v2 = avg(v2);
            }
          }
        } else {
          v2 = v2[idx];
        }
      }
      return v2;
    }
    var label2 = {
      content: labelCfg.content[index2],
      x: 0,
      y: 0,
      start: { x: 0, y: 0 },
      color: "#fff"
    };
    var shape = isArray$1(mappingData.shape) ? mappingData.shape[0] : mappingData.shape;
    var isFunnel = shape === "funnel" || shape === "pyramid";
    if (this.geometry.type === "polygon") {
      var centroid = getPolygonCentroid(mappingData.x, mappingData.y);
      label2.x = centroid[0];
      label2.y = centroid[1];
    } else if (this.geometry.type === "interval" && !isFunnel) {
      label2.x = getDimValue(mappingData.x, index2, true);
      label2.y = getDimValue(mappingData.y, index2);
    } else {
      label2.x = getDimValue(mappingData.x, index2);
      label2.y = getDimValue(mappingData.y, index2);
    }
    if (isFunnel) {
      var nextPoints = get(mappingData, "nextPoints");
      var points2 = get(mappingData, "points");
      if (nextPoints) {
        var point1 = coordinate2.convert(points2[1]);
        var point2 = coordinate2.convert(nextPoints[1]);
        label2.x = (point1.x + point2.x) / 2;
        label2.y = (point1.y + point2.y) / 2;
      } else if (shape === "pyramid") {
        var point1 = coordinate2.convert(points2[1]);
        var point2 = coordinate2.convert(points2[2]);
        label2.x = (point1.x + point2.x) / 2;
        label2.y = (point1.y + point2.y) / 2;
      }
    }
    if (labelCfg.position) {
      this.setLabelPosition(label2, mappingData, index2, labelCfg.position);
    }
    var offsetPoint = this.getLabelOffsetPoint(labelCfg, index2, total);
    label2.start = { x: label2.x, y: label2.y };
    label2.x += offsetPoint.x;
    label2.y += offsetPoint.y;
    label2.color = mappingData.color;
    return label2;
  };
  GeometryLabel2.prototype.getLabelAlign = function(item, index2, total) {
    var align = "center";
    var coordinate2 = this.getCoordinate();
    if (coordinate2.isTransposed) {
      var offset3 = item.offset;
      if (offset3 < 0) {
        align = "right";
      } else if (offset3 === 0) {
        align = "center";
      } else {
        align = "left";
      }
      if (total > 1 && index2 === 0) {
        if (align === "right") {
          align = "left";
        } else if (align === "left") {
          align = "right";
        }
      }
    }
    return align;
  };
  GeometryLabel2.prototype.getLabelId = function(mappingData) {
    var geometry2 = this.geometry;
    var type4 = geometry2.type;
    var xScale = geometry2.getXScale();
    var yScale = geometry2.getYScale();
    var origin = mappingData[FIELD_ORIGIN];
    var labelId = geometry2.getElementId(mappingData);
    if (type4 === "line" || type4 === "area") {
      labelId += " ".concat(origin[xScale.field]);
    } else if (type4 === "path") {
      labelId += " ".concat(origin[xScale.field], "-").concat(origin[yScale.field]);
    }
    return labelId;
  };
  GeometryLabel2.prototype.getLabelsRenderer = function() {
    var _a2 = this.geometry, labelsContainer = _a2.labelsContainer, labelOption = _a2.labelOption, canvasRegion = _a2.canvasRegion, animateOption = _a2.animateOption;
    var coordinate2 = this.geometry.coordinate;
    var labelsRenderer = this.labelsRenderer;
    if (!labelsRenderer) {
      labelsRenderer = new Labels({
        container: labelsContainer,
        layout: get(labelOption, ["cfg", "layout"], {
          type: this.defaultLayout
        })
      });
      this.labelsRenderer = labelsRenderer;
    }
    labelsRenderer.region = canvasRegion;
    labelsRenderer.animate = animateOption ? getDefaultAnimateCfg("label", coordinate2) : false;
    return labelsRenderer;
  };
  GeometryLabel2.prototype.getLabelCfgs = function(mapppingArray) {
    var _this = this;
    var geometry2 = this.geometry;
    var labelOption = geometry2.labelOption, scales = geometry2.scales, coordinate2 = geometry2.coordinate;
    var _a2 = labelOption, fields = _a2.fields, callback = _a2.callback, cfg = _a2.cfg;
    var labelScales = fields.map(function(field2) {
      return scales[field2];
    });
    var labelCfgs = [];
    each$1(mapppingArray, function(mappingData, index2) {
      var origin = mappingData[FIELD_ORIGIN];
      var originText = _this.getLabelText(origin, labelScales);
      var callbackCfg;
      if (callback) {
        var originValues = fields.map(function(field2) {
          return origin[field2];
        });
        callbackCfg = callback.apply(void 0, __spreadArray$1([], __read(originValues), false));
        if (isNil(callbackCfg)) {
          labelCfgs.push(null);
          return;
        }
      }
      var labelCfg = __assign$4(__assign$4({
        id: _this.getLabelId(mappingData),
        elementId: _this.geometry.getElementId(mappingData),
        data: origin,
        mappingData,
        coordinate: coordinate2
      }, cfg), callbackCfg);
      if (isFunction(labelCfg.position)) {
        labelCfg.position = labelCfg.position(origin, mappingData, index2);
      }
      var offset3 = _this.getLabelOffset(labelCfg.offset || 0);
      var defaultLabelCfg = _this.getDefaultLabelCfg(offset3, labelCfg.position);
      labelCfg = deepMix({}, defaultLabelCfg, labelCfg);
      labelCfg.offset = _this.getLabelOffset(labelCfg.offset || 0);
      var content = labelCfg.content;
      if (isFunction(content)) {
        labelCfg.content = content(origin, mappingData, index2);
      } else if (isUndefined(content)) {
        labelCfg.content = originText[0];
      }
      labelCfgs.push(labelCfg);
    });
    return labelCfgs;
  };
  GeometryLabel2.prototype.getLabelText = function(origin, scales) {
    var labelTexts = [];
    each$1(scales, function(scale2) {
      var value2 = origin[scale2.field];
      if (isArray$1(value2)) {
        value2 = value2.map(function(subVal) {
          return scale2.getText(subVal);
        });
      } else {
        value2 = scale2.getText(value2);
      }
      if (isNil(value2) || value2 === "") {
        labelTexts.push(null);
      } else {
        labelTexts.push(value2);
      }
    });
    return labelTexts;
  };
  GeometryLabel2.prototype.getOffsetVector = function(offset3) {
    if (offset3 === void 0) {
      offset3 = 0;
    }
    var coordinate2 = this.getCoordinate();
    var actualOffset = 0;
    if (isNumber$1(offset3)) {
      actualOffset = offset3;
    }
    return coordinate2.isTransposed ? coordinate2.applyMatrix(actualOffset, 0) : coordinate2.applyMatrix(0, actualOffset);
  };
  GeometryLabel2.prototype.getGeometryShapes = function() {
    var geometry2 = this.geometry;
    var shapes = {};
    each$1(geometry2.elementsMap, function(element, id2) {
      shapes[id2] = element.shape;
    });
    each$1(geometry2.getOffscreenGroup().getChildren(), function(child) {
      var id2 = geometry2.getElementId(child.get("origin").mappingData);
      shapes[id2] = child;
    });
    return shapes;
  };
  return GeometryLabel2;
}();
function getMappingValue(attr, value2, def) {
  if (!attr) {
    return def;
  }
  var r2;
  if (attr.callback && attr.callback.length > 1) {
    var restArgs = Array(attr.callback.length - 1).fill("");
    r2 = attr.mapping.apply(attr, __spreadArray$1([value2], __read(restArgs), false)).join("");
  } else {
    r2 = attr.mapping(value2).join("");
  }
  return r2 || def;
}
var MarkerSymbols = {
  hexagon: function(x2, y2, r2) {
    var diffX = r2 / 2 * Math.sqrt(3);
    return [
      ["M", x2, y2 - r2],
      ["L", x2 + diffX, y2 - r2 / 2],
      ["L", x2 + diffX, y2 + r2 / 2],
      ["L", x2, y2 + r2],
      ["L", x2 - diffX, y2 + r2 / 2],
      ["L", x2 - diffX, y2 - r2 / 2],
      ["Z"]
    ];
  },
  bowtie: function(x2, y2, r2) {
    var diffY = r2 - 1.5;
    return [["M", x2 - r2, y2 - diffY], ["L", x2 + r2, y2 + diffY], ["L", x2 + r2, y2 - diffY], ["L", x2 - r2, y2 + diffY], ["Z"]];
  },
  cross: function(x2, y2, r2) {
    return [
      ["M", x2 - r2, y2 - r2],
      ["L", x2 + r2, y2 + r2],
      ["M", x2 + r2, y2 - r2],
      ["L", x2 - r2, y2 + r2]
    ];
  },
  tick: function(x2, y2, r2) {
    return [
      ["M", x2 - r2 / 2, y2 - r2],
      ["L", x2 + r2 / 2, y2 - r2],
      ["M", x2, y2 - r2],
      ["L", x2, y2 + r2],
      ["M", x2 - r2 / 2, y2 + r2],
      ["L", x2 + r2 / 2, y2 + r2]
    ];
  },
  plus: function(x2, y2, r2) {
    return [
      ["M", x2 - r2, y2],
      ["L", x2 + r2, y2],
      ["M", x2, y2 - r2],
      ["L", x2, y2 + r2]
    ];
  },
  hyphen: function(x2, y2, r2) {
    return [
      ["M", x2 - r2, y2],
      ["L", x2 + r2, y2]
    ];
  },
  line: function(x2, y2, r2) {
    return [
      ["M", x2, y2 - r2],
      ["L", x2, y2 + r2]
    ];
  }
};
var STROKES_SYMBOLS = ["line", "cross", "tick", "plus", "hyphen"];
function handleUserMarkerStyle(markerStyle, style2) {
  if (isFunction(style2)) {
    return style2(markerStyle);
  }
  return deepMix({}, markerStyle, style2);
}
function adpatorMarkerStyle(marker, color2) {
  var symbol = marker.symbol;
  if (isString(symbol) && STROKES_SYMBOLS.indexOf(symbol) !== -1) {
    var markerStyle = get(marker, "style", {});
    var lineWidth = get(markerStyle, "lineWidth", 1);
    var stroke = markerStyle.stroke || markerStyle.fill || color2;
    marker.style = deepMix({}, marker.style, { lineWidth, stroke, fill: null });
  }
}
function setMarkerSymbol(marker) {
  var symbol = marker.symbol;
  if (isString(symbol) && MarkerSymbols[symbol]) {
    marker.symbol = MarkerSymbols[symbol];
  }
}
function getLegendLayout(direction2) {
  return direction2.startsWith(DIRECTION.LEFT) || direction2.startsWith(DIRECTION.RIGHT) ? "vertical" : "horizontal";
}
function getLegendItems(view, geometry2, attr, themeMarker, userMarker) {
  var scale2 = attr.getScale(attr.type);
  if (scale2.isCategory) {
    var field_1 = scale2.field;
    var colorAttr_1 = geometry2.getAttribute("color");
    var shapeAttr_1 = geometry2.getAttribute("shape");
    var defaultColor_1 = view.getTheme().defaultColor;
    var isInPolar_1 = geometry2.coordinate.isPolar;
    return scale2.getTicks().map(function(tick, index2) {
      var _a2;
      var text2 = tick.text, scaleValue = tick.value;
      var name = text2;
      var value2 = scale2.invert(scaleValue);
      var unchecked = view.filterFieldData(field_1, [(_a2 = {}, _a2[field_1] = value2, _a2)]).length === 0;
      each$1(view.views, function(subView) {
        var _a3;
        if (!subView.filterFieldData(field_1, [(_a3 = {}, _a3[field_1] = value2, _a3)]).length) {
          unchecked = true;
        }
      });
      var color2 = getMappingValue(colorAttr_1, value2, defaultColor_1);
      var shape = getMappingValue(shapeAttr_1, value2, "point");
      var marker = geometry2.getShapeMarker(shape, {
        color: color2,
        isInPolar: isInPolar_1
      });
      var markerCfg = userMarker;
      if (isFunction(markerCfg)) {
        markerCfg = markerCfg(name, index2, __assign$4({ name, value: value2 }, deepMix({}, themeMarker, marker)));
      }
      marker = deepMix({}, themeMarker, marker, omit(__assign$4({}, markerCfg), ["style"]));
      adpatorMarkerStyle(marker, color2);
      if (markerCfg && markerCfg.style) {
        marker.style = handleUserMarkerStyle(marker.style, markerCfg.style);
      }
      setMarkerSymbol(marker);
      return { id: value2, name, value: value2, marker, unchecked };
    });
  }
  return [];
}
function getCustomLegendItems(themeMarker, userMarker, customItems) {
  return customItems.map(function(item, index2) {
    var markerCfg = userMarker;
    if (isFunction(markerCfg)) {
      markerCfg = markerCfg(item.name, index2, deepMix({}, themeMarker, item));
    }
    var itemMarker = isFunction(item.marker) ? item.marker(item.name, index2, deepMix({}, themeMarker, item)) : item.marker;
    var marker = deepMix({}, themeMarker, markerCfg, itemMarker);
    setMarkerSymbol(marker);
    item.marker = marker;
    return item;
  });
}
function getLegendThemeCfg(theme2, direction2) {
  var legendTheme = get(theme2, ["components", "legend"], {});
  return deepMix({}, get(legendTheme, ["common"], {}), deepMix({}, get(legendTheme, [direction2], {})));
}
function isValueEmpty(value2) {
  if (value2) {
    return false;
  }
  return value2 === null || value2 === void 0 || isNaN(value2);
}
function isYNil(point2) {
  if (isArray$1(point2)) {
    return isValueEmpty(point2[1].y);
  }
  var value2 = point2.y;
  return isArray$1(value2) ? isValueEmpty(value2[0]) : isValueEmpty(value2);
}
function getPathPoints(points2, connectNulls, showSinglePoint) {
  if (connectNulls === void 0) {
    connectNulls = false;
  }
  if (showSinglePoint === void 0) {
    showSinglePoint = true;
  }
  if (!points2.length || points2.length === 1 && !showSinglePoint) {
    return [];
  }
  if (connectNulls) {
    var filtered = [];
    for (var i2 = 0, len = points2.length; i2 < len; i2++) {
      var point2 = points2[i2];
      if (!isYNil(point2)) {
        filtered.push(point2);
      }
    }
    return [filtered];
  }
  var result = [];
  var tmp = [];
  for (var i2 = 0, len = points2.length; i2 < len; i2++) {
    var point2 = points2[i2];
    if (isYNil(point2)) {
      if (tmp.length) {
        if (!(tmp.length === 1 && !showSinglePoint)) {
          result.push(tmp);
        }
        tmp = [];
      }
    } else {
      tmp.push(point2);
    }
  }
  if (tmp.length) {
    result.push(tmp);
  }
  return result;
}
function getViolinPath(points2) {
  var path2 = [];
  for (var i2 = 0; i2 < points2.length; i2++) {
    var point2 = points2[i2];
    if (point2) {
      var action = i2 === 0 ? "M" : "L";
      path2.push([action, point2.x, point2.y]);
    }
  }
  var first = points2[0];
  if (first) {
    path2.push(["L", first.x, first.y]);
    path2.push(["z"]);
  }
  return path2;
}
function getSmoothViolinPath(points2) {
  var half = points2.length / 2;
  var leftPoints = [];
  var rightPoints = [];
  for (var i2 = 0; i2 < points2.length; i2++) {
    if (i2 < half) {
      leftPoints.push(points2[i2]);
    } else {
      rightPoints.push(points2[i2]);
    }
  }
  var leftPath = getSplinePath$1(leftPoints, false);
  var rightPath = getSplinePath$1(rightPoints, false);
  if (rightPoints.length) {
    leftPath.push(["L", rightPoints[0].x, rightPoints[0].y]);
  }
  rightPath.shift();
  var path2 = leftPath.concat(rightPath);
  if (leftPoints.length) {
    path2.push(["L", leftPoints[0].x, leftPoints[0].y]);
  }
  path2.push(["z"]);
  return path2;
}
function getStyle(cfg, isStroke, isFill, sizeName) {
  if (sizeName === void 0) {
    sizeName = "";
  }
  var _a2 = cfg.style, style2 = _a2 === void 0 ? {} : _a2, defaultStyle = cfg.defaultStyle, color2 = cfg.color, size2 = cfg.size;
  var attrs = __assign$4(__assign$4({}, defaultStyle), style2);
  if (color2) {
    if (isStroke) {
      if (!style2.stroke) {
        attrs.stroke = color2;
      }
    }
    if (isFill) {
      if (!style2.fill) {
        attrs.fill = color2;
      }
    }
  }
  if (sizeName && isNil(style2[sizeName]) && !isNil(size2)) {
    attrs[sizeName] = size2;
  }
  return attrs;
}
function getBackgroundRectStyle(cfg) {
  return deepMix({}, {
    fill: "#CCD6EC",
    fillOpacity: 0.3
  }, get(cfg, ["background", "style"]));
}
function splitPoints(obj) {
  var x2 = obj.x;
  var y2 = isArray$1(obj.y) ? obj.y : [obj.y];
  return y2.map(function(eachY, index2) {
    return {
      x: isArray$1(x2) ? x2[index2] : x2,
      y: eachY
    };
  });
}
var LineSymbols = {
  line: function(x2, y2, r2) {
    return [
      ["M", x2 - r2, y2],
      ["L", x2 + r2, y2]
    ];
  },
  dot: function(x2, y2, r2) {
    return [
      ["M", x2 - r2, y2],
      ["L", x2 + r2, y2]
    ];
  },
  dash: function(x2, y2, r2) {
    return [
      ["M", x2 - r2, y2],
      ["L", x2 + r2, y2]
    ];
  },
  smooth: function(x2, y2, r2) {
    return [
      ["M", x2 - r2, y2],
      ["A", r2 / 2, r2 / 2, 0, 1, 1, x2, y2],
      ["A", r2 / 2, r2 / 2, 0, 1, 0, x2 + r2, y2]
    ];
  },
  hv: function(x2, y2, r2) {
    return [
      ["M", x2 - r2 - 1, y2 - 2.5],
      ["L", x2, y2 - 2.5],
      ["L", x2, y2 + 2.5],
      ["L", x2 + r2 + 1, y2 + 2.5]
    ];
  },
  vh: function(x2, y2, r2) {
    return [
      ["M", x2 - r2 - 1, y2 + 2.5],
      ["L", x2, y2 + 2.5],
      ["L", x2, y2 - 2.5],
      ["L", x2 + r2 + 1, y2 - 2.5]
    ];
  },
  hvh: function(x2, y2, r2) {
    return [
      ["M", x2 - (r2 + 1), y2 + 2.5],
      ["L", x2 - r2 / 2, y2 + 2.5],
      ["L", x2 - r2 / 2, y2 - 2.5],
      ["L", x2 + r2 / 2, y2 - 2.5],
      ["L", x2 + r2 / 2, y2 + 2.5],
      ["L", x2 + r2 + 1, y2 + 2.5]
    ];
  },
  vhv: function(x2, y2) {
    return [
      ["M", x2 - 5, y2 + 2.5],
      ["L", x2 - 5, y2],
      ["L", x2, y2],
      ["L", x2, y2 - 3],
      ["L", x2, y2 + 3],
      ["L", x2 + 6.5, y2 + 3]
    ];
  }
};
function getLineMarker(markerCfg, shapeType) {
  var color2 = markerCfg.color;
  return {
    symbol: LineSymbols[shapeType],
    style: {
      lineWidth: 2,
      r: 6,
      stroke: color2
    }
  };
}
function getShapeAttrs$1(cfg, smooth, constraint) {
  var isStack = cfg.isStack, connectNulls = cfg.connectNulls, isInCircle = cfg.isInCircle, showSinglePoint = cfg.showSinglePoint;
  var shapeAttrs = getStyle(cfg, true, false, "lineWidth");
  var points2 = getPathPoints(cfg.points, connectNulls, showSinglePoint);
  var path2 = [];
  for (var i2 = 0, len = points2.length; i2 < len; i2++) {
    var eachLinePoints = points2[i2];
    path2 = path2.concat(getPath$3(eachLinePoints, isInCircle, isStack, smooth, constraint, shapeAttrs));
  }
  shapeAttrs.path = path2;
  return shapeAttrs;
}
function getSinglePath(points2, isInCircle, smooth, constraint, style2) {
  if (points2.length === 1) {
    return [
      ["M", points2[0].x, points2[0].y - style2.lineWidth / 2],
      ["L", points2[0].x, points2[0].y],
      ["L", points2[0].x, points2[0].y + style2.lineWidth / 2]
    ];
  }
  var path2;
  if (!smooth) {
    path2 = getLinePath(points2, false);
    if (isInCircle) {
      path2.push(["Z"]);
    }
  } else {
    if (isInCircle && points2.length) {
      points2.push({ x: points2[0].x, y: points2[0].y });
    }
    path2 = getSplinePath$1(points2, false, constraint);
  }
  return path2;
}
function getRangePath(points2, isInCircle, isStack, smooth, constraint, style2) {
  var topPoints = [];
  var bottomPoints = [];
  each$1(points2, function(point2) {
    var result = splitPoints(point2);
    topPoints.push(result[1]);
    bottomPoints.push(result[0]);
  });
  var topPath = getSinglePath(topPoints, isInCircle, smooth, constraint, style2);
  var bottomPath = getSinglePath(bottomPoints, isInCircle, smooth, constraint, style2);
  if (isStack) {
    return topPath;
  }
  return topPath.concat(bottomPath);
}
function getPath$3(points2, isInCircle, isStack, smooth, constraint, style2) {
  if (points2.length) {
    var first = points2[0];
    return isArray$1(first.y) ? getRangePath(points2, isInCircle, isStack, smooth, constraint, style2) : getSinglePath(points2, isInCircle, smooth, constraint, style2);
  }
  return [];
}
registerShapeFactory("line", {
  defaultShapeType: "line"
});
each$1(["line", "dot", "dash", "smooth"], function(shapeType) {
  registerShape("line", shapeType, {
    draw: function(cfg, container) {
      var smooth = shapeType === "smooth";
      var constraint;
      if (smooth) {
        var _a2 = this.coordinate, start = _a2.start, end = _a2.end;
        constraint = [
          [start.x, end.y],
          [end.x, start.y]
        ];
      }
      var attrs = getShapeAttrs$1(cfg, smooth, constraint);
      var shape = container.addShape({
        type: "path",
        attrs,
        name: "line",
        capture: !smooth
      });
      return shape;
    },
    getMarker: function(markerCfg) {
      return getLineMarker(markerCfg, shapeType);
    }
  });
});
var Util = {
  getLegendItems,
  translate,
  rotate,
  zoom,
  transform: transform$4,
  getAngle: getAngle$1,
  getSectorPath,
  polarToCartesian,
  getDelegationObject,
  getTooltipItems,
  getMappingValue,
  getPath: getPath$3,
  getPathPoints
};
var WHITE_COLORS = {
  100: "#000",
  95: "#0D0D0D",
  85: "#262626",
  65: "#595959",
  45: "#8C8C8C",
  25: "#BFBFBF",
  15: "#D9D9D9",
  6: "#F0F0F0"
};
var BLACK_COLORS = {
  100: "#FFFFFF",
  95: "#F2F2F2",
  85: "#D9D9D9",
  65: "#A6A6A6",
  45: "#737373",
  25: "#404040",
  15: "#262626",
  6: "#0F0F0F"
};
var QUALITATIVE_10 = [
  "#5B8FF9",
  "#5AD8A6",
  "#5D7092",
  "#F6BD16",
  "#E86452",
  "#6DC8EC",
  "#945FB9",
  "#FF9845",
  "#1E9493",
  "#FF99C3"
];
var QUALITATIVE_20 = [
  "#5B8FF9",
  "#CDDDFD",
  "#5AD8A6",
  "#CDF3E4",
  "#5D7092",
  "#CED4DE",
  "#F6BD16",
  "#FCEBB9",
  "#E86452",
  "#F8D0CB",
  "#6DC8EC",
  "#D3EEF9",
  "#945FB9",
  "#DECFEA",
  "#FF9845",
  "#FFE0C7",
  "#1E9493",
  "#BBDEDE",
  "#FF99C3",
  "#FFE0ED"
];
var SINGLE_SEQUENCE = [
  "#B8E1FF",
  "#9AC5FF",
  "#7DAAFF",
  "#5B8FF9",
  "#3D76DD",
  "#085EC0",
  "#0047A5",
  "#00318A",
  "#001D70"
];
var createDarkStyleSheet = function(cfg) {
  if (cfg === void 0) {
    cfg = {};
  }
  var _a2 = cfg.paletteQualitative10, paletteQualitative10 = _a2 === void 0 ? QUALITATIVE_10 : _a2, _b = cfg.paletteQualitative20, paletteQualitative20 = _b === void 0 ? QUALITATIVE_20 : _b;
  var _c = cfg.brandColor, brandColor = _c === void 0 ? paletteQualitative10[0] : _c;
  var token2 = {
    backgroundColor: "#141414",
    brandColor,
    subColor: "rgba(255,255,255,0.05)",
    paletteQualitative10,
    paletteQualitative20,
    paletteSemanticRed: "#F4664A",
    paletteSemanticGreen: "#30BF78",
    paletteSemanticYellow: "#FAAD14",
    paletteSequence: SINGLE_SEQUENCE,
    fontFamily: '"Segoe UI", Roboto, "Helvetica Neue", Arial,\n    "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol",\n    "Noto Color Emoji"',
    axisLineBorderColor: BLACK_COLORS[25],
    axisLineBorder: 1,
    axisLineDash: null,
    axisTitleTextFillColor: BLACK_COLORS[65],
    axisTitleTextFontSize: 12,
    axisTitleTextLineHeight: 12,
    axisTitleTextFontWeight: "normal",
    axisTitleSpacing: 12,
    axisDescriptionIconFillColor: WHITE_COLORS[85],
    axisTickLineBorderColor: BLACK_COLORS[25],
    axisTickLineLength: 4,
    axisTickLineBorder: 1,
    axisSubTickLineBorderColor: BLACK_COLORS[15],
    axisSubTickLineLength: 2,
    axisSubTickLineBorder: 1,
    axisLabelFillColor: BLACK_COLORS[45],
    axisLabelFontSize: 12,
    axisLabelLineHeight: 12,
    axisLabelFontWeight: "normal",
    axisLabelOffset: 8,
    axisGridBorderColor: BLACK_COLORS[15],
    axisGridBorder: 1,
    axisGridLineDash: null,
    legendTitleTextFillColor: BLACK_COLORS[45],
    legendTitleTextFontSize: 12,
    legendTitleTextLineHeight: 21,
    legendTitleTextFontWeight: "normal",
    legendMarkerColor: QUALITATIVE_10[0],
    legendMarkerSpacing: 8,
    legendMarkerSize: 4,
    legendCircleMarkerSize: 4,
    legendSquareMarkerSize: 4,
    legendLineMarkerSize: 5,
    legendItemNameFillColor: BLACK_COLORS[65],
    legendItemNameFontSize: 12,
    legendItemNameLineHeight: 12,
    legendItemNameFontWeight: "normal",
    legendItemSpacing: 24,
    legendItemMarginBottom: 12,
    legendSpacing: 16,
    legendPadding: [8, 8, 8, 8],
    legendHorizontalPadding: [8, 0, 8, 0],
    legendVerticalPadding: [0, 8, 0, 8],
    legendPageNavigatorMarkerSize: 12,
    legendPageNavigatorMarkerInactiveFillColor: BLACK_COLORS[45],
    legendPageNavigatorMarkerInactiveFillOpacity: 0.45,
    legendPageNavigatorMarkerFillColor: BLACK_COLORS[45],
    legendPageNavigatorMarkerFillOpacity: 1,
    legendPageNavigatorTextFillColor: BLACK_COLORS[65],
    legendPageNavigatorTextFontSize: 12,
    sliderRailFillColor: BLACK_COLORS[15],
    sliderRailBorder: 0,
    sliderRailBorderColor: null,
    sliderRailWidth: 100,
    sliderRailHeight: 12,
    sliderLabelTextFillColor: BLACK_COLORS[45],
    sliderLabelTextFontSize: 12,
    sliderLabelTextLineHeight: 12,
    sliderLabelTextFontWeight: "normal",
    sliderHandlerFillColor: WHITE_COLORS[6],
    sliderHandlerWidth: 10,
    sliderHandlerHeight: 14,
    sliderHandlerBorder: 1,
    sliderHandlerBorderColor: WHITE_COLORS[25],
    annotationArcBorderColor: BLACK_COLORS[15],
    annotationArcBorder: 1,
    annotationLineBorderColor: BLACK_COLORS[25],
    annotationLineBorder: 1,
    annotationLineDash: null,
    annotationTextFillColor: BLACK_COLORS[65],
    annotationTextFontSize: 12,
    annotationTextLineHeight: 12,
    annotationTextFontWeight: "normal",
    annotationTextBorderColor: null,
    annotationTextBorder: 0,
    annotationRegionFillColor: BLACK_COLORS[100],
    annotationRegionFillOpacity: 0.06,
    annotationRegionBorder: 0,
    annotationRegionBorderColor: null,
    annotationDataMarkerLineLength: 16,
    tooltipCrosshairsBorderColor: BLACK_COLORS[25],
    tooltipCrosshairsBorder: 1,
    tooltipCrosshairsLineDash: null,
    tooltipContainerFillColor: "#1f1f1f",
    tooltipContainerFillOpacity: 0.95,
    tooltipContainerShadow: "0px 2px 4px rgba(0,0,0,.5)",
    tooltipContainerBorderRadius: 3,
    tooltipTextFillColor: BLACK_COLORS[65],
    tooltipTextFontSize: 12,
    tooltipTextLineHeight: 12,
    tooltipTextFontWeight: "bold",
    labelFillColor: BLACK_COLORS[65],
    labelFillColorDark: "#2c3542",
    labelFillColorLight: "#ffffff",
    labelFontSize: 12,
    labelLineHeight: 12,
    labelFontWeight: "normal",
    labelBorderColor: null,
    labelBorder: 0,
    innerLabelFillColor: WHITE_COLORS[100],
    innerLabelFontSize: 12,
    innerLabelLineHeight: 12,
    innerLabelFontWeight: "normal",
    innerLabelBorderColor: null,
    innerLabelBorder: 0,
    overflowLabelFillColor: BLACK_COLORS[65],
    overflowLabelFillColorDark: "#2c3542",
    overflowLabelFillColorLight: "#ffffff",
    overflowLabelFontSize: 12,
    overflowLabelLineHeight: 12,
    overflowLabelFontWeight: "normal",
    overflowLabelBorderColor: WHITE_COLORS[100],
    overflowLabelBorder: 1,
    labelLineBorder: 1,
    labelLineBorderColor: BLACK_COLORS[25],
    cSliderRailHieght: 16,
    cSliderBackgroundFillColor: "#416180",
    cSliderBackgroundFillOpacity: 0.05,
    cSliderForegroundFillColor: "#5B8FF9",
    cSliderForegroundFillOpacity: 0.15,
    cSliderHandlerHeight: 24,
    cSliderHandlerWidth: 10,
    cSliderHandlerFillColor: "#F7F7F7",
    cSliderHandlerFillOpacity: 1,
    cSliderHandlerHighlightFillColor: "#FFF",
    cSliderHandlerBorderColor: "#BFBFBF",
    cSliderHandlerBorder: 1,
    cSliderHandlerBorderRadius: 2,
    cSliderTextFillColor: "#fff",
    cSliderTextFillOpacity: 0.45,
    cSliderTextFontSize: 12,
    cSliderTextLineHeight: 12,
    cSliderTextFontWeight: "normal",
    cSliderTextBorderColor: null,
    cSliderTextBorder: 0,
    scrollbarTrackFillColor: "rgba(255,255,255,0.65)",
    scrollbarThumbFillColor: "rgba(0,0,0,0.35)",
    scrollbarThumbHighlightFillColor: "rgba(0,0,0,0.45)",
    pointFillColor: QUALITATIVE_10[0],
    pointFillOpacity: 0.95,
    pointSize: 4,
    pointBorder: 1,
    pointBorderColor: WHITE_COLORS[100],
    pointBorderOpacity: 1,
    pointActiveBorderColor: BLACK_COLORS[100],
    pointSelectedBorder: 2,
    pointSelectedBorderColor: BLACK_COLORS[100],
    pointInactiveFillOpacity: 0.3,
    pointInactiveBorderOpacity: 0.3,
    hollowPointSize: 4,
    hollowPointBorder: 1,
    hollowPointBorderColor: QUALITATIVE_10[0],
    hollowPointBorderOpacity: 0.95,
    hollowPointFillColor: WHITE_COLORS[100],
    hollowPointActiveBorder: 1,
    hollowPointActiveBorderColor: BLACK_COLORS[100],
    hollowPointActiveBorderOpacity: 1,
    hollowPointSelectedBorder: 2,
    hollowPointSelectedBorderColor: BLACK_COLORS[100],
    hollowPointSelectedBorderOpacity: 1,
    hollowPointInactiveBorderOpacity: 0.3,
    lineBorder: 2,
    lineBorderColor: QUALITATIVE_10[0],
    lineBorderOpacity: 1,
    lineActiveBorder: 3,
    lineSelectedBorder: 3,
    lineInactiveBorderOpacity: 0.3,
    areaFillColor: QUALITATIVE_10[0],
    areaFillOpacity: 0.25,
    areaActiveFillColor: QUALITATIVE_10[0],
    areaActiveFillOpacity: 0.5,
    areaSelectedFillColor: QUALITATIVE_10[0],
    areaSelectedFillOpacity: 0.5,
    areaInactiveFillOpacity: 0.3,
    hollowAreaBorderColor: QUALITATIVE_10[0],
    hollowAreaBorder: 2,
    hollowAreaBorderOpacity: 1,
    hollowAreaActiveBorder: 3,
    hollowAreaActiveBorderColor: BLACK_COLORS[100],
    hollowAreaSelectedBorder: 3,
    hollowAreaSelectedBorderColor: BLACK_COLORS[100],
    hollowAreaInactiveBorderOpacity: 0.3,
    intervalFillColor: QUALITATIVE_10[0],
    intervalFillOpacity: 0.95,
    intervalActiveBorder: 1,
    intervalActiveBorderColor: BLACK_COLORS[100],
    intervalActiveBorderOpacity: 1,
    intervalSelectedBorder: 2,
    intervalSelectedBorderColor: BLACK_COLORS[100],
    intervalSelectedBorderOpacity: 1,
    intervalInactiveBorderOpacity: 0.3,
    intervalInactiveFillOpacity: 0.3,
    hollowIntervalBorder: 2,
    hollowIntervalBorderColor: QUALITATIVE_10[0],
    hollowIntervalBorderOpacity: 1,
    hollowIntervalFillColor: WHITE_COLORS[100],
    hollowIntervalActiveBorder: 2,
    hollowIntervalActiveBorderColor: BLACK_COLORS[100],
    hollowIntervalSelectedBorder: 3,
    hollowIntervalSelectedBorderColor: BLACK_COLORS[100],
    hollowIntervalSelectedBorderOpacity: 1,
    hollowIntervalInactiveBorderOpacity: 0.3
  };
  return __assign$4(__assign$4({}, token2), cfg);
};
var antvDark = createDarkStyleSheet();
function getPixelRatio$1() {
  return window ? window.devicePixelRatio : 1;
}
function distance$1(x1, y1, x2, y2) {
  var dx = x1 - x2;
  var dy = y1 - y2;
  return Math.sqrt(dx * dx + dy * dy);
}
function inBox(minX, minY, width, height, x2, y2) {
  return x2 >= minX && x2 <= minX + width && y2 >= minY && y2 <= minY + height;
}
function intersectRect(box1, box2) {
  return !(box2.minX > box1.maxX || box2.maxX < box1.minX || box2.minY > box1.maxY || box2.maxY < box1.minY);
}
function mergeRegion(region1, region2) {
  if (!region1 || !region2) {
    return region1 || region2;
  }
  return {
    minX: Math.min(region1.minX, region2.minX),
    minY: Math.min(region1.minY, region2.minY),
    maxX: Math.max(region1.maxX, region2.maxX),
    maxY: Math.max(region1.maxY, region2.maxY)
  };
}
function isSamePoint(point1, point2) {
  return point1[0] === point2[0] && point1[1] === point2[1];
}
var regexLG$1 = /^l\s*\(\s*([\d.]+)\s*\)\s*(.*)/i;
var regexRG$1 = /^r\s*\(\s*([\d.]+)\s*,\s*([\d.]+)\s*,\s*([\d.]+)\s*\)\s*(.*)/i;
var regexPR$1 = /^p\s*\(\s*([axyn])\s*\)\s*(.*)/i;
var regexColorStop$1 = /[\d.]+:(#[^\s]+|[^\)]+\))/gi;
function addStop$1(steps, gradient2) {
  var arr = steps.match(regexColorStop$1);
  each$1(arr, function(item) {
    var itemArr = item.split(":");
    gradient2.addColorStop(itemArr[0], itemArr[1]);
  });
}
function parseLineGradient$1(context2, element, gradientStr) {
  var arr = regexLG$1.exec(gradientStr);
  var angle2 = parseFloat(arr[1]) % 360 * (Math.PI / 180);
  var steps = arr[2];
  var box2 = element.getBBox();
  var start;
  var end;
  if (angle2 >= 0 && angle2 < 1 / 2 * Math.PI) {
    start = {
      x: box2.minX,
      y: box2.minY
    };
    end = {
      x: box2.maxX,
      y: box2.maxY
    };
  } else if (1 / 2 * Math.PI <= angle2 && angle2 < Math.PI) {
    start = {
      x: box2.maxX,
      y: box2.minY
    };
    end = {
      x: box2.minX,
      y: box2.maxY
    };
  } else if (Math.PI <= angle2 && angle2 < 3 / 2 * Math.PI) {
    start = {
      x: box2.maxX,
      y: box2.maxY
    };
    end = {
      x: box2.minX,
      y: box2.minY
    };
  } else {
    start = {
      x: box2.minX,
      y: box2.maxY
    };
    end = {
      x: box2.maxX,
      y: box2.minY
    };
  }
  var tanTheta = Math.tan(angle2);
  var tanTheta2 = tanTheta * tanTheta;
  var x2 = (end.x - start.x + tanTheta * (end.y - start.y)) / (tanTheta2 + 1) + start.x;
  var y2 = tanTheta * (end.x - start.x + tanTheta * (end.y - start.y)) / (tanTheta2 + 1) + start.y;
  var gradient2 = context2.createLinearGradient(start.x, start.y, x2, y2);
  addStop$1(steps, gradient2);
  return gradient2;
}
function parseRadialGradient$1(context2, element, gradientStr) {
  var arr = regexRG$1.exec(gradientStr);
  var fx = parseFloat(arr[1]);
  var fy = parseFloat(arr[2]);
  var fr = parseFloat(arr[3]);
  var steps = arr[4];
  if (fr === 0) {
    var colors = steps.match(regexColorStop$1);
    return colors[colors.length - 1].split(":")[1];
  }
  var box2 = element.getBBox();
  var width = box2.maxX - box2.minX;
  var height = box2.maxY - box2.minY;
  var r2 = Math.sqrt(width * width + height * height) / 2;
  var gradient2 = context2.createRadialGradient(box2.minX + width * fx, box2.minY + height * fy, 0, box2.minX + width / 2, box2.minY + height / 2, fr * r2);
  addStop$1(steps, gradient2);
  return gradient2;
}
function parsePattern(context2, element, patternStr) {
  if (element.get("patternSource") && element.get("patternSource") === patternStr) {
    return element.get("pattern");
  }
  var pattern4;
  var img;
  var arr = regexPR$1.exec(patternStr);
  var repeat = arr[1];
  var source = arr[2];
  function onload() {
    pattern4 = context2.createPattern(img, repeat);
    element.set("pattern", pattern4);
    element.set("patternSource", patternStr);
  }
  switch (repeat) {
    case "a":
      repeat = "repeat";
      break;
    case "x":
      repeat = "repeat-x";
      break;
    case "y":
      repeat = "repeat-y";
      break;
    case "n":
      repeat = "no-repeat";
      break;
    default:
      repeat = "no-repeat";
  }
  img = new Image();
  if (!source.match(/^data:/i)) {
    img.crossOrigin = "Anonymous";
  }
  img.src = source;
  if (img.complete) {
    onload();
  } else {
    img.onload = onload;
    img.src = img.src;
  }
  return pattern4;
}
function parseStyle(context2, element, color2) {
  var bbox = element.getBBox();
  if (isNaN(bbox.x) || isNaN(bbox.y) || isNaN(bbox.width) || isNaN(bbox.height)) {
    return color2;
  }
  if (isString(color2)) {
    if (color2[1] === "(" || color2[2] === "(") {
      if (color2[0] === "l") {
        return parseLineGradient$1(context2, element, color2);
      }
      if (color2[0] === "r") {
        return parseRadialGradient$1(context2, element, color2);
      }
      if (color2[0] === "p") {
        return parsePattern(context2, element, color2);
      }
    }
    return color2;
  }
  if (color2 instanceof CanvasPattern) {
    return color2;
  }
}
function parseRadius$2(radius) {
  var r1 = 0;
  var r2 = 0;
  var r3 = 0;
  var r4 = 0;
  if (isArray$1(radius)) {
    if (radius.length === 1) {
      r1 = r2 = r3 = r4 = radius[0];
    } else if (radius.length === 2) {
      r1 = r3 = radius[0];
      r2 = r4 = radius[1];
    } else if (radius.length === 3) {
      r1 = radius[0];
      r2 = r4 = radius[1];
      r3 = radius[2];
    } else {
      r1 = radius[0];
      r2 = radius[1];
      r3 = radius[2];
      r4 = radius[3];
    }
  } else {
    r1 = r2 = r3 = r4 = radius;
  }
  return [r1, r2, r3, r4];
}
function vMag(v2) {
  return Math.sqrt(v2[0] * v2[0] + v2[1] * v2[1]);
}
function vRatio(u2, v2) {
  return vMag(u2) * vMag(v2) ? (u2[0] * v2[0] + u2[1] * v2[1]) / (vMag(u2) * vMag(v2)) : 1;
}
function vAngle(u2, v2) {
  return (u2[0] * v2[1] < u2[1] * v2[0] ? -1 : 1) * Math.acos(vRatio(u2, v2));
}
function getArcParams(startPoint, params) {
  var rx = params[1];
  var ry = params[2];
  var xRotation = mod$1(toRadian(params[3]), Math.PI * 2);
  var arcFlag = params[4];
  var sweepFlag = params[5];
  var x1 = startPoint[0];
  var y1 = startPoint[1];
  var x2 = params[6];
  var y2 = params[7];
  var xp = Math.cos(xRotation) * (x1 - x2) / 2 + Math.sin(xRotation) * (y1 - y2) / 2;
  var yp = -1 * Math.sin(xRotation) * (x1 - x2) / 2 + Math.cos(xRotation) * (y1 - y2) / 2;
  var lambda = xp * xp / (rx * rx) + yp * yp / (ry * ry);
  if (lambda > 1) {
    rx *= Math.sqrt(lambda);
    ry *= Math.sqrt(lambda);
  }
  var diff2 = rx * rx * (yp * yp) + ry * ry * (xp * xp);
  var f2 = diff2 ? Math.sqrt((rx * rx * (ry * ry) - diff2) / diff2) : 1;
  if (arcFlag === sweepFlag) {
    f2 *= -1;
  }
  if (isNaN(f2)) {
    f2 = 0;
  }
  var cxp = ry ? f2 * rx * yp / ry : 0;
  var cyp = rx ? f2 * -ry * xp / rx : 0;
  var cx = (x1 + x2) / 2 + Math.cos(xRotation) * cxp - Math.sin(xRotation) * cyp;
  var cy = (y1 + y2) / 2 + Math.sin(xRotation) * cxp + Math.cos(xRotation) * cyp;
  var u2 = [(xp - cxp) / rx, (yp - cyp) / ry];
  var v2 = [(-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry];
  var theta = vAngle([1, 0], u2);
  var dTheta = vAngle(u2, v2);
  if (vRatio(u2, v2) <= -1) {
    dTheta = Math.PI;
  }
  if (vRatio(u2, v2) >= 1) {
    dTheta = 0;
  }
  if (sweepFlag === 0 && dTheta > 0) {
    dTheta = dTheta - 2 * Math.PI;
  }
  if (sweepFlag === 1 && dTheta < 0) {
    dTheta = dTheta + 2 * Math.PI;
  }
  return {
    cx,
    cy,
    rx: isSamePoint(startPoint, [x2, y2]) ? 0 : rx,
    ry: isSamePoint(startPoint, [x2, y2]) ? 0 : ry,
    startAngle: theta,
    endAngle: theta + dTheta,
    xRotation,
    arcFlag,
    sweepFlag
  };
}
var sin = Math.sin, cos = Math.cos, atan2 = Math.atan2, PI = Math.PI;
function _addDefaultArrow(shape, attrs, x1, y1, x2, y2, isStart) {
  var stroke = attrs.stroke, lineWidth = attrs.lineWidth;
  var x3 = x1 - x2;
  var y3 = y1 - y2;
  var rad = atan2(y3, x3);
  var arrowShape = new Path$4({
    type: "path",
    canvas: shape.get("canvas"),
    isArrowShape: true,
    attrs: {
      path: "M" + 10 * cos(PI / 6) + "," + 10 * sin(PI / 6) + " L0,0 L" + 10 * cos(PI / 6) + ",-" + 10 * sin(PI / 6),
      stroke,
      lineWidth
    }
  });
  arrowShape.translate(x2, y2);
  arrowShape.rotateAtPoint(x2, y2, rad);
  shape.set(isStart ? "startArrowShape" : "endArrowShape", arrowShape);
}
function _addCustomizedArrow(shape, attrs, x1, y1, x2, y2, isStart) {
  var startArrow = attrs.startArrow, endArrow = attrs.endArrow, stroke = attrs.stroke, lineWidth = attrs.lineWidth;
  var arrowAttrs = isStart ? startArrow : endArrow;
  var d2 = arrowAttrs.d, arrowFill = arrowAttrs.fill, arrowStroke = arrowAttrs.stroke, arrowLineWidth = arrowAttrs.lineWidth, restAttrs = __rest$3(arrowAttrs, ["d", "fill", "stroke", "lineWidth"]);
  var x3 = x1 - x2;
  var y3 = y1 - y2;
  var rad = atan2(y3, x3);
  if (d2) {
    x2 = x2 - cos(rad) * d2;
    y2 = y2 - sin(rad) * d2;
  }
  var arrowShape = new Path$4({
    type: "path",
    canvas: shape.get("canvas"),
    isArrowShape: true,
    attrs: __assign$4(__assign$4({}, restAttrs), {
      stroke: arrowStroke || stroke,
      lineWidth: arrowLineWidth || lineWidth,
      fill: arrowFill
    })
  });
  arrowShape.translate(x2, y2);
  arrowShape.rotateAtPoint(x2, y2, rad);
  shape.set(isStart ? "startArrowShape" : "endArrowShape", arrowShape);
}
function getShortenOffset(x1, y1, x2, y2, d2) {
  var rad = atan2(y2 - y1, x2 - x1);
  return {
    dx: cos(rad) * d2,
    dy: sin(rad) * d2
  };
}
function addStartArrow(shape, attrs, x1, y1, x2, y2) {
  if (typeof attrs.startArrow === "object") {
    _addCustomizedArrow(shape, attrs, x1, y1, x2, y2, true);
  } else if (attrs.startArrow) {
    _addDefaultArrow(shape, attrs, x1, y1, x2, y2, true);
  } else {
    shape.set("startArrowShape", null);
  }
}
function addEndArrow(shape, attrs, x1, y1, x2, y2) {
  if (typeof attrs.endArrow === "object") {
    _addCustomizedArrow(shape, attrs, x1, y1, x2, y2, false);
  } else if (attrs.endArrow) {
    _addDefaultArrow(shape, attrs, x1, y1, x2, y2, false);
  } else {
    shape.set("startArrowShape", null);
  }
}
var SHAPE_ATTRS_MAP = {
  fill: "fillStyle",
  stroke: "strokeStyle",
  opacity: "globalAlpha"
};
function applyAttrsToContext(context2, element) {
  var attrs = element.attr();
  for (var k2 in attrs) {
    var v2 = attrs[k2];
    var name_1 = SHAPE_ATTRS_MAP[k2] ? SHAPE_ATTRS_MAP[k2] : k2;
    if (name_1 === "matrix" && v2) {
      context2.transform(v2[0], v2[1], v2[3], v2[4], v2[6], v2[7]);
    } else if (name_1 === "lineDash" && context2.setLineDash) {
      isArray$1(v2) && context2.setLineDash(v2);
    } else {
      if (name_1 === "strokeStyle" || name_1 === "fillStyle") {
        v2 = parseStyle(context2, element, v2);
      } else if (name_1 === "globalAlpha") {
        v2 = v2 * context2.globalAlpha;
      }
      context2[name_1] = v2;
    }
  }
}
function drawChildren$1(context2, children, region) {
  for (var i2 = 0; i2 < children.length; i2++) {
    var child = children[i2];
    if (child.cfg.visible) {
      child.draw(context2, region);
    } else {
      child.skipDraw();
    }
  }
}
function checkRefresh(canvas, children, region) {
  var refreshElements = canvas.get("refreshElements");
  each$1(refreshElements, function(el) {
    if (el !== canvas) {
      var parent_1 = el.cfg.parent;
      while (parent_1 && parent_1 !== canvas && !parent_1.cfg.refresh) {
        parent_1.cfg.refresh = true;
        parent_1 = parent_1.cfg.parent;
      }
    }
  });
  if (refreshElements[0] === canvas) {
    setChildrenRefresh(children);
  } else {
    checkChildrenRefresh(children, region);
  }
}
function checkChildrenRefresh(children, region) {
  for (var i2 = 0; i2 < children.length; i2++) {
    var child = children[i2];
    if (child.cfg.visible) {
      if (child.cfg.hasChanged) {
        child.cfg.refresh = true;
        if (child.isGroup()) {
          setChildrenRefresh(child.cfg.children);
        }
      } else if (child.cfg.refresh) {
        if (child.isGroup()) {
          checkChildrenRefresh(child.cfg.children, region);
        }
      } else {
        var refresh = checkElementRefresh(child, region);
        child.cfg.refresh = refresh;
        if (refresh && child.isGroup()) {
          checkChildrenRefresh(child.cfg.children, region);
        }
      }
    }
  }
}
function clearChanged(elements) {
  for (var i2 = 0; i2 < elements.length; i2++) {
    var el = elements[i2];
    el.cfg.hasChanged = false;
    if (el.isGroup() && !el.destroyed) {
      clearChanged(el.cfg.children);
    }
  }
}
function setChildrenRefresh(children, region) {
  for (var i2 = 0; i2 < children.length; i2++) {
    var child = children[i2];
    child.cfg.refresh = true;
    if (child.isGroup()) {
      setChildrenRefresh(child.get("children"));
    }
  }
}
function checkElementRefresh(shape, region) {
  var bbox = shape.cfg.cacheCanvasBBox;
  var isAllow = shape.cfg.isInView && bbox && intersectRect(bbox, region);
  return isAllow;
}
function drawPath(shape, context2, attrs, arcParamsCache) {
  var path2 = attrs.path, startArrow = attrs.startArrow, endArrow = attrs.endArrow;
  if (!path2) {
    return;
  }
  var currentPoint = [0, 0];
  var startMovePoint = [0, 0];
  var distance2 = {
    dx: 0,
    dy: 0
  };
  context2.beginPath();
  for (var i2 = 0; i2 < path2.length; i2++) {
    var params = path2[i2];
    var command = params[0];
    if (i2 === 0 && startArrow && startArrow.d) {
      var tangent = shape.getStartTangent();
      distance2 = getShortenOffset(tangent[0][0], tangent[0][1], tangent[1][0], tangent[1][1], startArrow.d);
    } else if (i2 === path2.length - 2 && path2[i2 + 1][0] === "Z" && endArrow && endArrow.d) {
      var lastPath = path2[i2 + 1];
      if (lastPath[0] === "Z") {
        var tangent = shape.getEndTangent();
        distance2 = getShortenOffset(tangent[0][0], tangent[0][1], tangent[1][0], tangent[1][1], endArrow.d);
      }
    } else if (i2 === path2.length - 1 && endArrow && endArrow.d) {
      if (path2[0] !== "Z") {
        var tangent = shape.getEndTangent();
        distance2 = getShortenOffset(tangent[0][0], tangent[0][1], tangent[1][0], tangent[1][1], endArrow.d);
      }
    }
    var dx = distance2.dx, dy = distance2.dy;
    switch (command) {
      case "M":
        context2.moveTo(params[1] - dx, params[2] - dy);
        startMovePoint = [params[1], params[2]];
        break;
      case "L":
        context2.lineTo(params[1] - dx, params[2] - dy);
        break;
      case "Q":
        context2.quadraticCurveTo(params[1], params[2], params[3] - dx, params[4] - dy);
        break;
      case "C":
        context2.bezierCurveTo(params[1], params[2], params[3], params[4], params[5] - dx, params[6] - dy);
        break;
      case "A": {
        var arcParams = void 0;
        if (arcParamsCache) {
          arcParams = arcParamsCache[i2];
          if (!arcParams) {
            arcParams = getArcParams(currentPoint, params);
            arcParamsCache[i2] = arcParams;
          }
        } else {
          arcParams = getArcParams(currentPoint, params);
        }
        var cx = arcParams.cx, cy = arcParams.cy, rx = arcParams.rx, ry = arcParams.ry, startAngle = arcParams.startAngle, endAngle = arcParams.endAngle, xRotation = arcParams.xRotation, sweepFlag = arcParams.sweepFlag;
        if (context2.ellipse) {
          context2.ellipse(cx, cy, rx, ry, xRotation, startAngle, endAngle, 1 - sweepFlag);
        } else {
          var r2 = rx > ry ? rx : ry;
          var scaleX = rx > ry ? 1 : rx / ry;
          var scaleY = rx > ry ? ry / rx : 1;
          context2.translate(cx, cy);
          context2.rotate(xRotation);
          context2.scale(scaleX, scaleY);
          context2.arc(0, 0, r2, startAngle, endAngle, 1 - sweepFlag);
          context2.scale(1 / scaleX, 1 / scaleY);
          context2.rotate(-xRotation);
          context2.translate(-cx, -cy);
        }
        break;
      }
      case "Z":
        context2.closePath();
        break;
    }
    if (command === "Z") {
      currentPoint = startMovePoint;
    } else {
      var len = params.length;
      currentPoint = [params[len - 2], params[len - 1]];
    }
  }
}
function refreshElement$1(element, changeType) {
  var canvas = element.get("canvas");
  if (canvas) {
    if (changeType === "remove") {
      element._cacheCanvasBBox = element.get("cacheCanvasBBox");
    }
    if (!element.get("hasChanged")) {
      element.set("hasChanged", true);
      if (!(element.cfg.parent && element.cfg.parent.get("hasChanged"))) {
        canvas.refreshElement(element, changeType, canvas);
        if (canvas.get("autoDraw")) {
          canvas.draw();
        }
      }
    }
  }
}
function getRefreshRegion(element) {
  var region;
  if (!element.destroyed) {
    var cacheBox = element.get("cacheCanvasBBox");
    var validCache = cacheBox && !!(cacheBox.width && cacheBox.height);
    var bbox = element.getCanvasBBox();
    var validBBox = bbox && !!(bbox.width && bbox.height);
    if (validCache && validBBox) {
      region = mergeRegion(cacheBox, bbox);
    } else if (validCache) {
      region = cacheBox;
    } else if (validBBox) {
      region = bbox;
    }
  } else {
    region = element["_cacheCanvasBBox"];
  }
  return region;
}
function getMergedRegion(elements) {
  if (!elements.length) {
    return null;
  }
  var minXArr = [];
  var minYArr = [];
  var maxXArr = [];
  var maxYArr = [];
  each$1(elements, function(el) {
    var region = getRefreshRegion(el);
    if (region) {
      minXArr.push(region.minX);
      minYArr.push(region.minY);
      maxXArr.push(region.maxX);
      maxYArr.push(region.maxY);
    }
  });
  return {
    minX: min$2(minXArr),
    minY: min$2(minYArr),
    maxX: max$2(maxXArr),
    maxY: max$2(maxYArr)
  };
}
function mergeView(region, viewRegion) {
  if (!region || !viewRegion) {
    return null;
  }
  if (!intersectRect(region, viewRegion)) {
    return null;
  }
  return {
    minX: Math.max(region.minX, viewRegion.minX),
    minY: Math.max(region.minY, viewRegion.minY),
    maxX: Math.min(region.maxX, viewRegion.maxX),
    maxY: Math.min(region.maxY, viewRegion.maxY)
  };
}
var Group$1 = function(_super) {
  __extends$3(Group4, _super);
  function Group4() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Group4.prototype.onCanvasChange = function(changeType) {
    refreshElement$1(this, changeType);
  };
  Group4.prototype.getShapeBase = function() {
    return Shape$1;
  };
  Group4.prototype.getGroupBase = function() {
    return Group4;
  };
  Group4.prototype._applyClip = function(context2, clip) {
    if (clip) {
      context2.save();
      applyAttrsToContext(context2, clip);
      clip.createPath(context2);
      context2.restore();
      context2.clip();
      clip._afterDraw();
    }
  };
  Group4.prototype.cacheCanvasBBox = function() {
    var children = this.cfg.children;
    var xArr = [];
    var yArr = [];
    each$1(children, function(child) {
      var bbox2 = child.cfg.cacheCanvasBBox;
      if (bbox2 && child.cfg.isInView) {
        xArr.push(bbox2.minX, bbox2.maxX);
        yArr.push(bbox2.minY, bbox2.maxY);
      }
    });
    var bbox = null;
    if (xArr.length) {
      var minX = min$2(xArr);
      var maxX = max$2(xArr);
      var minY = min$2(yArr);
      var maxY2 = max$2(yArr);
      bbox = {
        minX,
        minY,
        x: minX,
        y: minY,
        maxX,
        maxY: maxY2,
        width: maxX - minX,
        height: maxY2 - minY
      };
      var canvas = this.cfg.canvas;
      if (canvas) {
        var viewRange = canvas.getViewRange();
        this.set("isInView", intersectRect(bbox, viewRange));
      }
    } else {
      this.set("isInView", false);
    }
    this.set("cacheCanvasBBox", bbox);
  };
  Group4.prototype.draw = function(context2, region) {
    var children = this.cfg.children;
    var allowDraw = region ? this.cfg.refresh : true;
    if (children.length && allowDraw) {
      context2.save();
      applyAttrsToContext(context2, this);
      this._applyClip(context2, this.getClip());
      drawChildren$1(context2, children, region);
      context2.restore();
      this.cacheCanvasBBox();
    }
    this.cfg.refresh = null;
    this.set("hasChanged", false);
  };
  Group4.prototype.skipDraw = function() {
    this.set("cacheCanvasBBox", null);
    this.set("hasChanged", false);
  };
  return Group4;
}(AbstractGroup);
var ShapeBase$2 = function(_super) {
  __extends$3(ShapeBase2, _super);
  function ShapeBase2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  ShapeBase2.prototype.getDefaultAttrs = function() {
    var attrs = _super.prototype.getDefaultAttrs.call(this);
    return __assign$4(__assign$4({}, attrs), { lineWidth: 1, lineAppendWidth: 0, strokeOpacity: 1, fillOpacity: 1 });
  };
  ShapeBase2.prototype.getShapeBase = function() {
    return Shape$1;
  };
  ShapeBase2.prototype.getGroupBase = function() {
    return Group$1;
  };
  ShapeBase2.prototype.onCanvasChange = function(changeType) {
    refreshElement$1(this, changeType);
  };
  ShapeBase2.prototype.calculateBBox = function() {
    var type4 = this.get("type");
    var lineWidth = this.getHitLineWidth();
    var bboxMethod = getMethod(type4);
    var box2 = bboxMethod(this);
    var halfLineWidth = lineWidth / 2;
    var minX = box2.x - halfLineWidth;
    var minY = box2.y - halfLineWidth;
    var maxX = box2.x + box2.width + halfLineWidth;
    var maxY2 = box2.y + box2.height + halfLineWidth;
    return {
      x: minX,
      minX,
      y: minY,
      minY,
      width: box2.width + lineWidth,
      height: box2.height + lineWidth,
      maxX,
      maxY: maxY2
    };
  };
  ShapeBase2.prototype.isFill = function() {
    return !!this.attrs["fill"] || this.isClipShape();
  };
  ShapeBase2.prototype.isStroke = function() {
    return !!this.attrs["stroke"];
  };
  ShapeBase2.prototype._applyClip = function(context2, clip) {
    if (clip) {
      context2.save();
      applyAttrsToContext(context2, clip);
      clip.createPath(context2);
      context2.restore();
      context2.clip();
      clip._afterDraw();
    }
  };
  ShapeBase2.prototype.draw = function(context2, region) {
    var clip = this.cfg.clipShape;
    if (region) {
      if (this.cfg.refresh === false) {
        this.set("hasChanged", false);
        return;
      }
      var bbox = this.getCanvasBBox();
      if (!intersectRect(region, bbox)) {
        this.set("hasChanged", false);
        if (this.cfg.isInView) {
          this._afterDraw();
        }
        return;
      }
    }
    context2.save();
    applyAttrsToContext(context2, this);
    this._applyClip(context2, clip);
    this.drawPath(context2);
    context2.restore();
    this._afterDraw();
  };
  ShapeBase2.prototype.getCanvasViewBox = function() {
    var canvas = this.cfg.canvas;
    if (canvas) {
      return canvas.getViewRange();
    }
    return null;
  };
  ShapeBase2.prototype.cacheCanvasBBox = function() {
    var canvasBBox = this.getCanvasViewBox();
    if (canvasBBox) {
      var bbox = this.getCanvasBBox();
      var isInView = intersectRect(bbox, canvasBBox);
      this.set("isInView", isInView);
      if (isInView) {
        this.set("cacheCanvasBBox", bbox);
      } else {
        this.set("cacheCanvasBBox", null);
      }
    }
  };
  ShapeBase2.prototype._afterDraw = function() {
    this.cacheCanvasBBox();
    this.set("hasChanged", false);
    this.set("refresh", null);
  };
  ShapeBase2.prototype.skipDraw = function() {
    this.set("cacheCanvasBBox", null);
    this.set("isInView", null);
    this.set("hasChanged", false);
  };
  ShapeBase2.prototype.drawPath = function(context2) {
    this.createPath(context2);
    this.strokeAndFill(context2);
    this.afterDrawPath(context2);
  };
  ShapeBase2.prototype.fill = function(context2) {
    context2.fill();
  };
  ShapeBase2.prototype.stroke = function(context2) {
    context2.stroke();
  };
  ShapeBase2.prototype.strokeAndFill = function(context2) {
    var _a2 = this.attrs, lineWidth = _a2.lineWidth, opacity = _a2.opacity, strokeOpacity = _a2.strokeOpacity, fillOpacity = _a2.fillOpacity;
    if (this.isFill()) {
      if (!isNil(fillOpacity) && fillOpacity !== 1) {
        context2.globalAlpha = fillOpacity;
        this.fill(context2);
        context2.globalAlpha = opacity;
      } else {
        this.fill(context2);
      }
    }
    if (this.isStroke()) {
      if (lineWidth > 0) {
        if (!isNil(strokeOpacity) && strokeOpacity !== 1) {
          context2.globalAlpha = strokeOpacity;
        }
        this.stroke(context2);
      }
    }
    this.afterDrawPath(context2);
  };
  ShapeBase2.prototype.createPath = function(context2) {
  };
  ShapeBase2.prototype.afterDrawPath = function(context2) {
  };
  ShapeBase2.prototype.isInShape = function(refX, refY) {
    var isStroke = this.isStroke();
    var isFill = this.isFill();
    var lineWidth = this.getHitLineWidth();
    return this.isInStrokeOrPath(refX, refY, isStroke, isFill, lineWidth);
  };
  ShapeBase2.prototype.isInStrokeOrPath = function(x2, y2, isStroke, isFill, lineWidth) {
    return false;
  };
  ShapeBase2.prototype.getHitLineWidth = function() {
    if (!this.isStroke()) {
      return 0;
    }
    var attrs = this.attrs;
    return attrs["lineWidth"] + attrs["lineAppendWidth"];
  };
  return ShapeBase2;
}(AbstractShape);
var ShapeBase$3 = ShapeBase$2;
var Circle$3 = function(_super) {
  __extends$3(Circle2, _super);
  function Circle2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Circle2.prototype.getDefaultAttrs = function() {
    var attrs = _super.prototype.getDefaultAttrs.call(this);
    return __assign$4(__assign$4({}, attrs), { x: 0, y: 0, r: 0 });
  };
  Circle2.prototype.isInStrokeOrPath = function(x2, y2, isStroke, isFill, lineWidth) {
    var attrs = this.attr();
    var cx = attrs.x;
    var cy = attrs.y;
    var r2 = attrs.r;
    var halfLineWidth = lineWidth / 2;
    var absDistance = distance$1(cx, cy, x2, y2);
    if (isFill && isStroke) {
      return absDistance <= r2 + halfLineWidth;
    }
    if (isFill) {
      return absDistance <= r2;
    }
    if (isStroke) {
      return absDistance >= r2 - halfLineWidth && absDistance <= r2 + halfLineWidth;
    }
    return false;
  };
  Circle2.prototype.createPath = function(context2) {
    var attrs = this.attr();
    var cx = attrs.x;
    var cy = attrs.y;
    var r2 = attrs.r;
    context2.beginPath();
    context2.arc(cx, cy, r2, 0, Math.PI * 2, false);
    context2.closePath();
  };
  return Circle2;
}(ShapeBase$3);
var Circle$4 = Circle$3;
function ellipseDistance(squareX, squareY, rx, ry) {
  return squareX / (rx * rx) + squareY / (ry * ry);
}
var Ellipse$2 = function(_super) {
  __extends$3(Ellipse2, _super);
  function Ellipse2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Ellipse2.prototype.getDefaultAttrs = function() {
    var attrs = _super.prototype.getDefaultAttrs.call(this);
    return __assign$4(__assign$4({}, attrs), { x: 0, y: 0, rx: 0, ry: 0 });
  };
  Ellipse2.prototype.isInStrokeOrPath = function(x2, y2, isStroke, isFill, lineWidth) {
    var attrs = this.attr();
    var halfLineWith = lineWidth / 2;
    var cx = attrs.x;
    var cy = attrs.y;
    var rx = attrs.rx, ry = attrs.ry;
    var squareX = (x2 - cx) * (x2 - cx);
    var squareY = (y2 - cy) * (y2 - cy);
    if (isFill && isStroke) {
      return ellipseDistance(squareX, squareY, rx + halfLineWith, ry + halfLineWith) <= 1;
    }
    if (isFill) {
      return ellipseDistance(squareX, squareY, rx, ry) <= 1;
    }
    if (isStroke) {
      return ellipseDistance(squareX, squareY, rx - halfLineWith, ry - halfLineWith) >= 1 && ellipseDistance(squareX, squareY, rx + halfLineWith, ry + halfLineWith) <= 1;
    }
    return false;
  };
  Ellipse2.prototype.createPath = function(context2) {
    var attrs = this.attr();
    var cx = attrs.x;
    var cy = attrs.y;
    var rx = attrs.rx;
    var ry = attrs.ry;
    context2.beginPath();
    if (context2.ellipse) {
      context2.ellipse(cx, cy, rx, ry, 0, 0, Math.PI * 2, false);
    } else {
      var r2 = rx > ry ? rx : ry;
      var scaleX = rx > ry ? 1 : rx / ry;
      var scaleY = rx > ry ? ry / rx : 1;
      context2.save();
      context2.translate(cx, cy);
      context2.scale(scaleX, scaleY);
      context2.arc(0, 0, r2, 0, Math.PI * 2);
      context2.restore();
      context2.closePath();
    }
  };
  return Ellipse2;
}(ShapeBase$3);
var Ellipse$3 = Ellipse$2;
function isCanvas(dom) {
  return dom instanceof HTMLElement && isString(dom.nodeName) && dom.nodeName.toUpperCase() === "CANVAS";
}
var ImageShape = function(_super) {
  __extends$3(ImageShape2, _super);
  function ImageShape2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  ImageShape2.prototype.getDefaultAttrs = function() {
    var attrs = _super.prototype.getDefaultAttrs.call(this);
    return __assign$4(__assign$4({}, attrs), { x: 0, y: 0, width: 0, height: 0 });
  };
  ImageShape2.prototype.initAttrs = function(attrs) {
    this._setImage(attrs.img);
  };
  ImageShape2.prototype.isStroke = function() {
    return false;
  };
  ImageShape2.prototype.isOnlyHitBox = function() {
    return true;
  };
  ImageShape2.prototype._afterLoading = function() {
    if (this.get("toDraw") === true) {
      var canvas = this.get("canvas");
      if (canvas) {
        canvas.draw();
      } else {
        this.createPath(this.get("context"));
      }
    }
  };
  ImageShape2.prototype._setImage = function(img) {
    var _this = this;
    var attrs = this.attrs;
    if (isString(img)) {
      var image_1 = new Image();
      image_1.onload = function() {
        if (_this.destroyed) {
          return false;
        }
        _this.attr("img", image_1);
        _this.set("loading", false);
        _this._afterLoading();
        var callback = _this.get("callback");
        if (callback) {
          callback.call(_this);
        }
      };
      image_1.crossOrigin = "Anonymous";
      image_1.src = img;
      this.set("loading", true);
    } else if (img instanceof Image) {
      if (!attrs.width) {
        attrs.width = img.width;
      }
      if (!attrs.height) {
        attrs.height = img.height;
      }
    } else if (isCanvas(img)) {
      if (!attrs.width) {
        attrs.width = Number(img.getAttribute("width"));
      }
      if (!attrs.height) {
        attrs.height, Number(img.getAttribute("height"));
      }
    }
  };
  ImageShape2.prototype.onAttrChange = function(name, value2, originValue) {
    _super.prototype.onAttrChange.call(this, name, value2, originValue);
    if (name === "img") {
      this._setImage(value2);
    }
  };
  ImageShape2.prototype.createPath = function(context2) {
    if (this.get("loading")) {
      this.set("toDraw", true);
      this.set("context", context2);
      return;
    }
    var attrs = this.attr();
    var x2 = attrs.x, y2 = attrs.y, width = attrs.width, height = attrs.height, sx = attrs.sx, sy = attrs.sy, swidth = attrs.swidth, sheight = attrs.sheight;
    var img = attrs.img;
    if (img instanceof Image || isCanvas(img)) {
      if (!isNil(sx) && !isNil(sy) && !isNil(swidth) && !isNil(sheight)) {
        context2.drawImage(img, sx, sy, swidth, sheight, x2, y2, width, height);
      } else {
        context2.drawImage(img, x2, y2, width, height);
      }
    }
  };
  return ImageShape2;
}(ShapeBase$3);
var ImageShape$1 = ImageShape;
function inLine(x1, y1, x2, y2, lineWidth, x3, y3) {
  var minX = Math.min(x1, x2);
  var maxX = Math.max(x1, x2);
  var minY = Math.min(y1, y2);
  var maxY2 = Math.max(y1, y2);
  var halfWidth = lineWidth / 2;
  if (!(x3 >= minX - halfWidth && x3 <= maxX + halfWidth && y3 >= minY - halfWidth && y3 <= maxY2 + halfWidth)) {
    return false;
  }
  return LineUtil.pointToLine(x1, y1, x2, y2, x3, y3) <= lineWidth / 2;
}
var Line$5 = function(_super) {
  __extends$3(Line2, _super);
  function Line2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Line2.prototype.getDefaultAttrs = function() {
    var attrs = _super.prototype.getDefaultAttrs.call(this);
    return __assign$4(__assign$4({}, attrs), { x1: 0, y1: 0, x2: 0, y2: 0, startArrow: false, endArrow: false });
  };
  Line2.prototype.initAttrs = function(attrs) {
    this.setArrow();
  };
  Line2.prototype.onAttrChange = function(name, value2, originValue) {
    _super.prototype.onAttrChange.call(this, name, value2, originValue);
    this.setArrow();
  };
  Line2.prototype.setArrow = function() {
    var attrs = this.attr();
    var x1 = attrs.x1, y1 = attrs.y1, x2 = attrs.x2, y2 = attrs.y2, startArrow = attrs.startArrow, endArrow = attrs.endArrow;
    if (startArrow) {
      addStartArrow(this, attrs, x2, y2, x1, y1);
    }
    if (endArrow) {
      addEndArrow(this, attrs, x1, y1, x2, y2);
    }
  };
  Line2.prototype.isInStrokeOrPath = function(x2, y2, isStroke, isFill, lineWidth) {
    if (!isStroke || !lineWidth) {
      return false;
    }
    var _a2 = this.attr(), x1 = _a2.x1, y1 = _a2.y1, x22 = _a2.x2, y22 = _a2.y2;
    return inLine(x1, y1, x22, y22, lineWidth, x2, y2);
  };
  Line2.prototype.createPath = function(context2) {
    var attrs = this.attr();
    var x1 = attrs.x1, y1 = attrs.y1, x2 = attrs.x2, y2 = attrs.y2, startArrow = attrs.startArrow, endArrow = attrs.endArrow;
    var startArrowDistance = {
      dx: 0,
      dy: 0
    };
    var endArrowDistance = {
      dx: 0,
      dy: 0
    };
    if (startArrow && startArrow.d) {
      startArrowDistance = getShortenOffset(x1, y1, x2, y2, attrs.startArrow.d);
    }
    if (endArrow && endArrow.d) {
      endArrowDistance = getShortenOffset(x1, y1, x2, y2, attrs.endArrow.d);
    }
    context2.beginPath();
    context2.moveTo(x1 + startArrowDistance.dx, y1 + startArrowDistance.dy);
    context2.lineTo(x2 - endArrowDistance.dx, y2 - endArrowDistance.dy);
  };
  Line2.prototype.afterDrawPath = function(context2) {
    var startArrowShape = this.get("startArrowShape");
    var endArrowShape = this.get("endArrowShape");
    if (startArrowShape) {
      startArrowShape.draw(context2);
    }
    if (endArrowShape) {
      endArrowShape.draw(context2);
    }
  };
  Line2.prototype.getTotalLength = function() {
    var _a2 = this.attr(), x1 = _a2.x1, y1 = _a2.y1, x2 = _a2.x2, y2 = _a2.y2;
    return LineUtil.length(x1, y1, x2, y2);
  };
  Line2.prototype.getPoint = function(ratio) {
    var _a2 = this.attr(), x1 = _a2.x1, y1 = _a2.y1, x2 = _a2.x2, y2 = _a2.y2;
    return LineUtil.pointAt(x1, y1, x2, y2, ratio);
  };
  return Line2;
}(ShapeBase$3);
var Line$6 = Line$5;
var Symbols$1 = {
  circle: function(x2, y2, r2) {
    return [
      ["M", x2 - r2, y2],
      ["A", r2, r2, 0, 1, 0, x2 + r2, y2],
      ["A", r2, r2, 0, 1, 0, x2 - r2, y2]
    ];
  },
  square: function(x2, y2, r2) {
    return [["M", x2 - r2, y2 - r2], ["L", x2 + r2, y2 - r2], ["L", x2 + r2, y2 + r2], ["L", x2 - r2, y2 + r2], ["Z"]];
  },
  diamond: function(x2, y2, r2) {
    return [["M", x2 - r2, y2], ["L", x2, y2 - r2], ["L", x2 + r2, y2], ["L", x2, y2 + r2], ["Z"]];
  },
  triangle: function(x2, y2, r2) {
    var diffY = r2 * Math.sin(1 / 3 * Math.PI);
    return [["M", x2 - r2, y2 + diffY], ["L", x2, y2 - diffY], ["L", x2 + r2, y2 + diffY], ["Z"]];
  },
  "triangle-down": function(x2, y2, r2) {
    var diffY = r2 * Math.sin(1 / 3 * Math.PI);
    return [["M", x2 - r2, y2 - diffY], ["L", x2 + r2, y2 - diffY], ["L", x2, y2 + diffY], ["Z"]];
  }
};
var Marker$2 = function(_super) {
  __extends$3(Marker2, _super);
  function Marker2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Marker2.prototype.initAttrs = function(attrs) {
    this._resetParamsCache();
  };
  Marker2.prototype._resetParamsCache = function() {
    this.set("paramsCache", {});
  };
  Marker2.prototype.onAttrChange = function(name, value2, originValue) {
    _super.prototype.onAttrChange.call(this, name, value2, originValue);
    if (["symbol", "x", "y", "r", "radius"].indexOf(name) !== -1) {
      this._resetParamsCache();
    }
  };
  Marker2.prototype.isOnlyHitBox = function() {
    return true;
  };
  Marker2.prototype._getR = function(attrs) {
    return isNil(attrs.r) ? attrs.radius : attrs.r;
  };
  Marker2.prototype._getPath = function() {
    var attrs = this.attr();
    var x2 = attrs.x, y2 = attrs.y;
    var symbol = attrs.symbol || "circle";
    var r2 = this._getR(attrs);
    var method4;
    var path2;
    if (isFunction(symbol)) {
      method4 = symbol;
      path2 = method4(x2, y2, r2);
      path2 = pathToAbsolute(path2);
    } else {
      method4 = Marker2.Symbols[symbol];
      if (!method4) {
        console.warn(symbol + " marker is not supported.");
        return null;
      }
      path2 = method4(x2, y2, r2);
    }
    return path2;
  };
  Marker2.prototype.createPath = function(context2) {
    var path2 = this._getPath();
    var paramsCache = this.get("paramsCache");
    drawPath(this, context2, { path: path2 }, paramsCache);
  };
  Marker2.Symbols = Symbols$1;
  return Marker2;
}(ShapeBase$3);
var Marker$3 = Marker$2;
function isPointInPath(shape, x2, y2) {
  var ctx2 = getOffScreenContext();
  shape.createPath(ctx2);
  return ctx2.isPointInPath(x2, y2);
}
var tolerance = 1e-6;
function dcmp(x2) {
  if (Math.abs(x2) < tolerance) {
    return 0;
  }
  return x2 < 0 ? -1 : 1;
}
function onSegment(p1, p2, q2) {
  if ((q2[0] - p1[0]) * (p2[1] - p1[1]) === (p2[0] - p1[0]) * (q2[1] - p1[1]) && Math.min(p1[0], p2[0]) <= q2[0] && q2[0] <= Math.max(p1[0], p2[0]) && Math.min(p1[1], p2[1]) <= q2[1] && q2[1] <= Math.max(p1[1], p2[1])) {
    return true;
  }
  return false;
}
function isInPolygon(points2, x2, y2) {
  var isHit = false;
  var n2 = points2.length;
  if (n2 <= 2) {
    return false;
  }
  for (var i2 = 0; i2 < n2; i2++) {
    var p1 = points2[i2];
    var p2 = points2[(i2 + 1) % n2];
    if (onSegment(p1, p2, [x2, y2])) {
      return true;
    }
    if (dcmp(p1[1] - y2) > 0 !== dcmp(p2[1] - y2) > 0 && dcmp(x2 - (y2 - p1[1]) * (p1[0] - p2[0]) / (p1[1] - p2[1]) - p1[0]) < 0) {
      isHit = !isHit;
    }
  }
  return isHit;
}
function arc(cx, cy, r2, startAngle, endAngle, lineWidth, x2, y2) {
  var angle2 = (Math.atan2(y2 - cy, x2 - cx) + Math.PI * 2) % (Math.PI * 2);
  if (angle2 < startAngle || angle2 > endAngle) {
    return false;
  }
  var point2 = {
    x: cx + r2 * Math.cos(angle2),
    y: cy + r2 * Math.sin(angle2)
  };
  return distance$1(point2.x, point2.y, x2, y2) <= lineWidth / 2;
}
var transform$3 = transform$6;
function hasArc(path2) {
  var hasArc2 = false;
  var count2 = path2.length;
  for (var i2 = 0; i2 < count2; i2++) {
    var params = path2[i2];
    var cmd = params[0];
    if (cmd === "C" || cmd === "A" || cmd === "Q") {
      hasArc2 = true;
      break;
    }
  }
  return hasArc2;
}
function isPointInStroke(segments, lineWidth, x2, y2, length2) {
  var isHit = false;
  var halfWidth = lineWidth / 2;
  for (var i2 = 0; i2 < segments.length; i2++) {
    var segment = segments[i2];
    var currentPoint = segment.currentPoint, params = segment.params, prePoint = segment.prePoint, box2 = segment.box;
    if (box2 && !inBox(box2.x - halfWidth, box2.y - halfWidth, box2.width + lineWidth, box2.height + lineWidth, x2, y2)) {
      continue;
    }
    switch (segment.command) {
      case "L":
      case "Z":
        isHit = inLine(prePoint[0], prePoint[1], currentPoint[0], currentPoint[1], lineWidth, x2, y2);
        break;
      case "Q":
        var qDistance = QuadUtil.pointDistance(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4], x2, y2);
        isHit = qDistance <= lineWidth / 2;
        break;
      case "C":
        var cDistance = CubicUtil.pointDistance(
          prePoint[0],
          prePoint[1],
          params[1],
          params[2],
          params[3],
          params[4],
          params[5],
          params[6],
          x2,
          y2,
          length2
        );
        isHit = cDistance <= lineWidth / 2;
        break;
      case "A":
        var arcParams = segment.arcParams;
        var cx = arcParams.cx, cy = arcParams.cy, rx = arcParams.rx, ry = arcParams.ry, startAngle = arcParams.startAngle, endAngle = arcParams.endAngle, xRotation = arcParams.xRotation;
        var p2 = [x2, y2, 1];
        var r2 = rx > ry ? rx : ry;
        var scaleX = rx > ry ? 1 : rx / ry;
        var scaleY = rx > ry ? ry / rx : 1;
        var m2 = transform$3(null, [
          ["t", -cx, -cy],
          ["r", -xRotation],
          ["s", 1 / scaleX, 1 / scaleY]
        ]);
        transformMat3$1(p2, p2, m2);
        isHit = arc(0, 0, r2, startAngle, endAngle, lineWidth, p2[0], p2[1]);
        break;
    }
    if (isHit) {
      break;
    }
  }
  return isHit;
}
function extractPolygons(path2) {
  var count2 = path2.length;
  var polygons = [];
  var polylines = [];
  var points2 = [];
  for (var i2 = 0; i2 < count2; i2++) {
    var params = path2[i2];
    var cmd = params[0];
    if (cmd === "M") {
      if (points2.length) {
        polylines.push(points2);
        points2 = [];
      }
      points2.push([params[1], params[2]]);
    } else if (cmd === "Z") {
      if (points2.length) {
        polygons.push(points2);
        points2 = [];
      }
    } else {
      points2.push([params[1], params[2]]);
    }
  }
  if (points2.length > 0) {
    polylines.push(points2);
  }
  return {
    polygons,
    polylines
  };
}
var PathUtil = __assign$4({ hasArc, extractPolygons, isPointInStroke }, PathUtil$1);
function isInPolygons(polygons, x2, y2) {
  var isHit = false;
  for (var i2 = 0; i2 < polygons.length; i2++) {
    var points2 = polygons[i2];
    isHit = isInPolygon(points2, x2, y2);
    if (isHit) {
      break;
    }
  }
  return isHit;
}
var Path$3 = function(_super) {
  __extends$3(Path2, _super);
  function Path2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Path2.prototype.getDefaultAttrs = function() {
    var attrs = _super.prototype.getDefaultAttrs.call(this);
    return __assign$4(__assign$4({}, attrs), { startArrow: false, endArrow: false });
  };
  Path2.prototype.initAttrs = function(attrs) {
    this._setPathArr(attrs.path);
    this.setArrow();
  };
  Path2.prototype.onAttrChange = function(name, value2, originValue) {
    _super.prototype.onAttrChange.call(this, name, value2, originValue);
    if (name === "path") {
      this._setPathArr(value2);
    }
    this.setArrow();
  };
  Path2.prototype._setPathArr = function(path2) {
    this.attrs.path = pathToAbsolute(path2);
    var hasArc2 = PathUtil.hasArc(path2);
    this.set("hasArc", hasArc2);
    this.set("paramsCache", {});
    this.set("segments", null);
    this.set("curve", null);
    this.set("tCache", null);
    this.set("totalLength", null);
  };
  Path2.prototype.getSegments = function() {
    var segments = this.get("segements");
    if (!segments) {
      segments = getSegments(this.attr("path"));
      this.set("segments", segments);
    }
    return segments;
  };
  Path2.prototype.setArrow = function() {
    var attrs = this.attr();
    var startArrow = attrs.startArrow, endArrow = attrs.endArrow;
    if (startArrow) {
      var tangent = this.getStartTangent();
      addStartArrow(this, attrs, tangent[0][0], tangent[0][1], tangent[1][0], tangent[1][1]);
    }
    if (endArrow) {
      var tangent = this.getEndTangent();
      addEndArrow(this, attrs, tangent[0][0], tangent[0][1], tangent[1][0], tangent[1][1]);
    }
  };
  Path2.prototype.isInStrokeOrPath = function(x2, y2, isStroke, isFill, lineWidth) {
    var segments = this.getSegments();
    var hasArc2 = this.get("hasArc");
    var isHit = false;
    if (isStroke) {
      var length_1 = this.getTotalLength();
      isHit = PathUtil.isPointInStroke(segments, lineWidth, x2, y2, length_1);
    }
    if (!isHit && isFill) {
      if (hasArc2) {
        isHit = isPointInPath(this, x2, y2);
      } else {
        var path2 = this.attr("path");
        var extractResutl = PathUtil.extractPolygons(path2);
        isHit = isInPolygons(extractResutl.polygons, x2, y2) || isInPolygons(extractResutl.polylines, x2, y2);
      }
    }
    return isHit;
  };
  Path2.prototype.createPath = function(context2) {
    var attrs = this.attr();
    var paramsCache = this.get("paramsCache");
    drawPath(this, context2, attrs, paramsCache);
  };
  Path2.prototype.afterDrawPath = function(context2) {
    var startArrowShape = this.get("startArrowShape");
    var endArrowShape = this.get("endArrowShape");
    if (startArrowShape) {
      startArrowShape.draw(context2);
    }
    if (endArrowShape) {
      endArrowShape.draw(context2);
    }
  };
  Path2.prototype.getTotalLength = function() {
    var totalLength = this.get("totalLength");
    if (!isNil(totalLength)) {
      return totalLength;
    }
    this._calculateCurve();
    this._setTcache();
    return this.get("totalLength");
  };
  Path2.prototype.getPoint = function(ratio) {
    var tCache = this.get("tCache");
    if (!tCache) {
      this._calculateCurve();
      this._setTcache();
      tCache = this.get("tCache");
    }
    var subt;
    var index2;
    var curve = this.get("curve");
    if (!tCache || tCache.length === 0) {
      if (curve) {
        return {
          x: curve[0][1],
          y: curve[0][2]
        };
      }
      return null;
    }
    each$1(tCache, function(v2, i2) {
      if (ratio >= v2[0] && ratio <= v2[1]) {
        subt = (ratio - v2[0]) / (v2[1] - v2[0]);
        index2 = i2;
      }
    });
    var seg = curve[index2];
    if (isNil(seg) || isNil(index2)) {
      return null;
    }
    var l2 = seg.length;
    var nextSeg = curve[index2 + 1];
    return CubicUtil.pointAt(seg[l2 - 2], seg[l2 - 1], nextSeg[1], nextSeg[2], nextSeg[3], nextSeg[4], nextSeg[5], nextSeg[6], subt);
  };
  Path2.prototype._calculateCurve = function() {
    var path2 = this.attr().path;
    this.set("curve", PathUtil.pathToCurve(path2));
  };
  Path2.prototype._setTcache = function() {
    var totalLength = 0;
    var tempLength = 0;
    var tCache = [];
    var segmentT;
    var segmentL;
    var segmentN;
    var l2;
    var curve = this.get("curve");
    if (!curve) {
      return;
    }
    each$1(curve, function(segment, i2) {
      segmentN = curve[i2 + 1];
      l2 = segment.length;
      if (segmentN) {
        totalLength += CubicUtil.length(segment[l2 - 2], segment[l2 - 1], segmentN[1], segmentN[2], segmentN[3], segmentN[4], segmentN[5], segmentN[6]) || 0;
      }
    });
    this.set("totalLength", totalLength);
    if (totalLength === 0) {
      this.set("tCache", []);
      return;
    }
    each$1(curve, function(segment, i2) {
      segmentN = curve[i2 + 1];
      l2 = segment.length;
      if (segmentN) {
        segmentT = [];
        segmentT[0] = tempLength / totalLength;
        segmentL = CubicUtil.length(segment[l2 - 2], segment[l2 - 1], segmentN[1], segmentN[2], segmentN[3], segmentN[4], segmentN[5], segmentN[6]);
        tempLength += segmentL || 0;
        segmentT[1] = tempLength / totalLength;
        tCache.push(segmentT);
      }
    });
    this.set("tCache", tCache);
  };
  Path2.prototype.getStartTangent = function() {
    var segments = this.getSegments();
    var result;
    if (segments.length > 1) {
      var startPoint = segments[0].currentPoint;
      var endPoint = segments[1].currentPoint;
      var tangent = segments[1].startTangent;
      result = [];
      if (tangent) {
        result.push([startPoint[0] - tangent[0], startPoint[1] - tangent[1]]);
        result.push([startPoint[0], startPoint[1]]);
      } else {
        result.push([endPoint[0], endPoint[1]]);
        result.push([startPoint[0], startPoint[1]]);
      }
    }
    return result;
  };
  Path2.prototype.getEndTangent = function() {
    var segments = this.getSegments();
    var length2 = segments.length;
    var result;
    if (length2 > 1) {
      var startPoint = segments[length2 - 2].currentPoint;
      var endPoint = segments[length2 - 1].currentPoint;
      var tangent = segments[length2 - 1].endTangent;
      result = [];
      if (tangent) {
        result.push([endPoint[0] - tangent[0], endPoint[1] - tangent[1]]);
        result.push([endPoint[0], endPoint[1]]);
      } else {
        result.push([startPoint[0], startPoint[1]]);
        result.push([endPoint[0], endPoint[1]]);
      }
    }
    return result;
  };
  return Path2;
}(ShapeBase$3);
var Path$4 = Path$3;
function inPolyline(points2, lineWidth, x2, y2, isClose) {
  var count2 = points2.length;
  if (count2 < 2) {
    return false;
  }
  for (var i2 = 0; i2 < count2 - 1; i2++) {
    var x1 = points2[i2][0];
    var y1 = points2[i2][1];
    var x22 = points2[i2 + 1][0];
    var y22 = points2[i2 + 1][1];
    if (inLine(x1, y1, x22, y22, lineWidth, x2, y2)) {
      return true;
    }
  }
  if (isClose) {
    var first = points2[0];
    var last2 = points2[count2 - 1];
    if (inLine(first[0], first[1], last2[0], last2[1], lineWidth, x2, y2)) {
      return true;
    }
  }
  return false;
}
var Polygon$3 = function(_super) {
  __extends$3(Polygon2, _super);
  function Polygon2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Polygon2.prototype.isInStrokeOrPath = function(x2, y2, isStroke, isFill, lineWidth) {
    var points2 = this.attr().points;
    var isHit = false;
    if (isStroke) {
      isHit = inPolyline(points2, lineWidth, x2, y2, true);
    }
    if (!isHit && isFill) {
      isHit = isInPolygon(points2, x2, y2);
    }
    return isHit;
  };
  Polygon2.prototype.createPath = function(context2) {
    var attrs = this.attr();
    var points2 = attrs.points;
    if (points2.length < 2) {
      return;
    }
    context2.beginPath();
    for (var i2 = 0; i2 < points2.length; i2++) {
      var point2 = points2[i2];
      if (i2 === 0) {
        context2.moveTo(point2[0], point2[1]);
      } else {
        context2.lineTo(point2[0], point2[1]);
      }
    }
    context2.closePath();
  };
  return Polygon2;
}(ShapeBase$3);
var Polygon$4 = Polygon$3;
var PolyLine = function(_super) {
  __extends$3(PolyLine2, _super);
  function PolyLine2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  PolyLine2.prototype.getDefaultAttrs = function() {
    var attrs = _super.prototype.getDefaultAttrs.call(this);
    return __assign$4(__assign$4({}, attrs), { startArrow: false, endArrow: false });
  };
  PolyLine2.prototype.initAttrs = function(attrs) {
    this.setArrow();
  };
  PolyLine2.prototype.onAttrChange = function(name, value2, originValue) {
    _super.prototype.onAttrChange.call(this, name, value2, originValue);
    this.setArrow();
    if (["points"].indexOf(name) !== -1) {
      this._resetCache();
    }
  };
  PolyLine2.prototype._resetCache = function() {
    this.set("totalLength", null);
    this.set("tCache", null);
  };
  PolyLine2.prototype.setArrow = function() {
    var attrs = this.attr();
    var _a2 = this.attrs, points2 = _a2.points, startArrow = _a2.startArrow, endArrow = _a2.endArrow;
    var length2 = points2.length;
    var x1 = points2[0][0];
    var y1 = points2[0][1];
    var x2 = points2[length2 - 1][0];
    var y2 = points2[length2 - 1][1];
    if (startArrow) {
      addStartArrow(this, attrs, points2[1][0], points2[1][1], x1, y1);
    }
    if (endArrow) {
      addEndArrow(this, attrs, points2[length2 - 2][0], points2[length2 - 2][1], x2, y2);
    }
  };
  PolyLine2.prototype.isFill = function() {
    return false;
  };
  PolyLine2.prototype.isInStrokeOrPath = function(x2, y2, isStroke, isFill, lineWidth) {
    if (!isStroke || !lineWidth) {
      return false;
    }
    var points2 = this.attr().points;
    return inPolyline(points2, lineWidth, x2, y2, false);
  };
  PolyLine2.prototype.isStroke = function() {
    return true;
  };
  PolyLine2.prototype.createPath = function(context2) {
    var _a2 = this.attr(), points2 = _a2.points, startArrow = _a2.startArrow, endArrow = _a2.endArrow;
    var length2 = points2.length;
    if (points2.length < 2) {
      return;
    }
    var x1 = points2[0][0];
    var y1 = points2[0][1];
    var x2 = points2[length2 - 1][0];
    var y2 = points2[length2 - 1][1];
    if (startArrow && startArrow.d) {
      var distance2 = getShortenOffset(x1, y1, points2[1][0], points2[1][1], startArrow.d);
      x1 += distance2.dx;
      y1 += distance2.dy;
    }
    if (endArrow && endArrow.d) {
      var distance2 = getShortenOffset(points2[length2 - 2][0], points2[length2 - 2][1], x2, y2, endArrow.d);
      x2 -= distance2.dx;
      y2 -= distance2.dy;
    }
    context2.beginPath();
    context2.moveTo(x1, y1);
    for (var i2 = 0; i2 < length2 - 1; i2++) {
      var point2 = points2[i2];
      context2.lineTo(point2[0], point2[1]);
    }
    context2.lineTo(x2, y2);
  };
  PolyLine2.prototype.afterDrawPath = function(context2) {
    var startArrowShape = this.get("startArrowShape");
    var endArrowShape = this.get("endArrowShape");
    if (startArrowShape) {
      startArrowShape.draw(context2);
    }
    if (endArrowShape) {
      endArrowShape.draw(context2);
    }
  };
  PolyLine2.prototype.getTotalLength = function() {
    var points2 = this.attr().points;
    var totalLength = this.get("totalLength");
    if (!isNil(totalLength)) {
      return totalLength;
    }
    this.set("totalLength", PolylineUtil.length(points2));
    return this.get("totalLength");
  };
  PolyLine2.prototype.getPoint = function(ratio) {
    var points2 = this.attr().points;
    var tCache = this.get("tCache");
    if (!tCache) {
      this._setTcache();
      tCache = this.get("tCache");
    }
    var subt;
    var index2;
    each$1(tCache, function(v2, i2) {
      if (ratio >= v2[0] && ratio <= v2[1]) {
        subt = (ratio - v2[0]) / (v2[1] - v2[0]);
        index2 = i2;
      }
    });
    return LineUtil.pointAt(points2[index2][0], points2[index2][1], points2[index2 + 1][0], points2[index2 + 1][1], subt);
  };
  PolyLine2.prototype._setTcache = function() {
    var points2 = this.attr().points;
    if (!points2 || points2.length === 0) {
      return;
    }
    var totalLength = this.getTotalLength();
    if (totalLength <= 0) {
      return;
    }
    var tempLength = 0;
    var tCache = [];
    var segmentT;
    var segmentL;
    each$1(points2, function(p2, i2) {
      if (points2[i2 + 1]) {
        segmentT = [];
        segmentT[0] = tempLength / totalLength;
        segmentL = LineUtil.length(p2[0], p2[1], points2[i2 + 1][0], points2[i2 + 1][1]);
        tempLength += segmentL;
        segmentT[1] = tempLength / totalLength;
        tCache.push(segmentT);
      }
    });
    this.set("tCache", tCache);
  };
  PolyLine2.prototype.getStartTangent = function() {
    var points2 = this.attr().points;
    var result = [];
    result.push([points2[1][0], points2[1][1]]);
    result.push([points2[0][0], points2[0][1]]);
    return result;
  };
  PolyLine2.prototype.getEndTangent = function() {
    var points2 = this.attr().points;
    var l2 = points2.length - 1;
    var result = [];
    result.push([points2[l2 - 1][0], points2[l2 - 1][1]]);
    result.push([points2[l2][0], points2[l2][1]]);
    return result;
  };
  return PolyLine2;
}(ShapeBase$3);
var PolyLine$1 = PolyLine;
function inRect(minX, minY, width, height, lineWidth, x2, y2) {
  var halfWidth = lineWidth / 2;
  return inBox(minX - halfWidth, minY - halfWidth, width, lineWidth, x2, y2) || inBox(minX + width - halfWidth, minY - halfWidth, lineWidth, height, x2, y2) || inBox(minX + halfWidth, minY + height - halfWidth, width, lineWidth, x2, y2) || inBox(minX - halfWidth, minY + halfWidth, lineWidth, height, x2, y2);
}
function rectWithRadius(minX, minY, width, height, radius, lineWidth, x2, y2) {
  return inLine(minX + radius, minY, minX + width - radius, minY, lineWidth, x2, y2) || inLine(minX + width, minY + radius, minX + width, minY + height - radius, lineWidth, x2, y2) || inLine(minX + width - radius, minY + height, minX + radius, minY + height, lineWidth, x2, y2) || inLine(minX, minY + height - radius, minX, minY + radius, lineWidth, x2, y2) || arc(minX + width - radius, minY + radius, radius, 1.5 * Math.PI, 2 * Math.PI, lineWidth, x2, y2) || arc(minX + width - radius, minY + height - radius, radius, 0, 0.5 * Math.PI, lineWidth, x2, y2) || arc(minX + radius, minY + height - radius, radius, 0.5 * Math.PI, Math.PI, lineWidth, x2, y2) || arc(minX + radius, minY + radius, radius, Math.PI, 1.5 * Math.PI, lineWidth, x2, y2);
}
var Rect$3 = function(_super) {
  __extends$3(Rect2, _super);
  function Rect2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Rect2.prototype.getDefaultAttrs = function() {
    var attrs = _super.prototype.getDefaultAttrs.call(this);
    return __assign$4(__assign$4({}, attrs), { x: 0, y: 0, width: 0, height: 0, radius: 0 });
  };
  Rect2.prototype.isInStrokeOrPath = function(x2, y2, isStroke, isFill, lineWidth) {
    var attrs = this.attr();
    var minX = attrs.x;
    var minY = attrs.y;
    var width = attrs.width;
    var height = attrs.height;
    var radius = attrs.radius;
    if (!radius) {
      var halfWidth = lineWidth / 2;
      if (isFill && isStroke) {
        return inBox(minX - halfWidth, minY - halfWidth, width + halfWidth, height + halfWidth, x2, y2);
      }
      if (isFill) {
        return inBox(minX, minY, width, height, x2, y2);
      }
      if (isStroke) {
        return inRect(minX, minY, width, height, lineWidth, x2, y2);
      }
    } else {
      var isHit = false;
      if (isStroke) {
        isHit = rectWithRadius(minX, minY, width, height, radius, lineWidth, x2, y2);
      }
      if (!isHit && isFill) {
        isHit = isPointInPath(this, x2, y2);
      }
      return isHit;
    }
  };
  Rect2.prototype.createPath = function(context2) {
    var attrs = this.attr();
    var x2 = attrs.x;
    var y2 = attrs.y;
    var width = attrs.width;
    var height = attrs.height;
    var radius = attrs.radius;
    context2.beginPath();
    if (radius === 0) {
      context2.rect(x2, y2, width, height);
    } else {
      var _a2 = parseRadius$2(radius), r1 = _a2[0], r2 = _a2[1], r3 = _a2[2], r4 = _a2[3];
      context2.moveTo(x2 + r1, y2);
      context2.lineTo(x2 + width - r2, y2);
      r2 !== 0 && context2.arc(x2 + width - r2, y2 + r2, r2, -Math.PI / 2, 0);
      context2.lineTo(x2 + width, y2 + height - r3);
      r3 !== 0 && context2.arc(x2 + width - r3, y2 + height - r3, r3, 0, Math.PI / 2);
      context2.lineTo(x2 + r4, y2 + height);
      r4 !== 0 && context2.arc(x2 + r4, y2 + height - r4, r4, Math.PI / 2, Math.PI);
      context2.lineTo(x2, y2 + r1);
      r1 !== 0 && context2.arc(x2 + r1, y2 + r1, r1, Math.PI, Math.PI * 1.5);
      context2.closePath();
    }
  };
  return Rect2;
}(ShapeBase$3);
var Rect$4 = Rect$3;
var Text$2 = function(_super) {
  __extends$3(Text2, _super);
  function Text2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Text2.prototype.getDefaultAttrs = function() {
    var attrs = _super.prototype.getDefaultAttrs.call(this);
    return __assign$4(__assign$4({}, attrs), { x: 0, y: 0, text: null, fontSize: 12, fontFamily: "sans-serif", fontStyle: "normal", fontWeight: "normal", fontVariant: "normal", textAlign: "start", textBaseline: "bottom" });
  };
  Text2.prototype.isOnlyHitBox = function() {
    return true;
  };
  Text2.prototype.initAttrs = function(attrs) {
    this._assembleFont();
    if (attrs.text) {
      this._setText(attrs.text);
    }
  };
  Text2.prototype._assembleFont = function() {
    var attrs = this.attrs;
    attrs.font = assembleFont(attrs);
  };
  Text2.prototype._setText = function(text2) {
    var textArr = null;
    if (isString(text2) && text2.indexOf("\n") !== -1) {
      textArr = text2.split("\n");
    }
    this.set("textArr", textArr);
  };
  Text2.prototype.onAttrChange = function(name, value2, originValue) {
    _super.prototype.onAttrChange.call(this, name, value2, originValue);
    if (name.startsWith("font")) {
      this._assembleFont();
    }
    if (name === "text") {
      this._setText(value2);
    }
  };
  Text2.prototype._getSpaceingY = function() {
    var attrs = this.attrs;
    var lineHeight = attrs.lineHeight;
    var fontSize = attrs.fontSize * 1;
    return lineHeight ? lineHeight - fontSize : fontSize * 0.14;
  };
  Text2.prototype._drawTextArr = function(context2, textArr, isFill) {
    var attrs = this.attrs;
    var textBaseline = attrs.textBaseline;
    var x2 = attrs.x;
    var y2 = attrs.y;
    var fontSize = attrs.fontSize * 1;
    var spaceingY = this._getSpaceingY();
    var height = getTextHeight(attrs.text, attrs.fontSize, attrs.lineHeight);
    var subY;
    each$1(textArr, function(subText, index2) {
      subY = y2 + index2 * (spaceingY + fontSize) - height + fontSize;
      if (textBaseline === "middle")
        subY += height - fontSize - (height - fontSize) / 2;
      if (textBaseline === "top")
        subY += height - fontSize;
      if (!isNil(subText)) {
        if (isFill) {
          context2.fillText(subText, x2, subY);
        } else {
          context2.strokeText(subText, x2, subY);
        }
      }
    });
  };
  Text2.prototype._drawText = function(context2, isFill) {
    var attrs = this.attr();
    var x2 = attrs.x;
    var y2 = attrs.y;
    var textArr = this.get("textArr");
    if (textArr) {
      this._drawTextArr(context2, textArr, isFill);
    } else {
      var text2 = attrs.text;
      if (!isNil(text2)) {
        if (isFill) {
          context2.fillText(text2, x2, y2);
        } else {
          context2.strokeText(text2, x2, y2);
        }
      }
    }
  };
  Text2.prototype.strokeAndFill = function(context2) {
    var _a2 = this.attrs, lineWidth = _a2.lineWidth, opacity = _a2.opacity, strokeOpacity = _a2.strokeOpacity, fillOpacity = _a2.fillOpacity;
    if (this.isStroke()) {
      if (lineWidth > 0) {
        if (!isNil(strokeOpacity) && strokeOpacity !== 1) {
          context2.globalAlpha = opacity;
        }
        this.stroke(context2);
      }
    }
    if (this.isFill()) {
      if (!isNil(fillOpacity) && fillOpacity !== 1) {
        context2.globalAlpha = fillOpacity;
        this.fill(context2);
        context2.globalAlpha = opacity;
      } else {
        this.fill(context2);
      }
    }
    this.afterDrawPath(context2);
  };
  Text2.prototype.fill = function(context2) {
    this._drawText(context2, true);
  };
  Text2.prototype.stroke = function(context2) {
    this._drawText(context2, false);
  };
  return Text2;
}(ShapeBase$3);
var Text$3 = Text$2;
function invertFromMatrix(v2, matrix) {
  if (matrix) {
    var invertMatrix = invert(matrix);
    return multiplyVec2$1(invertMatrix, v2);
  }
  return v2;
}
function getRefXY(element, x2, y2) {
  var totalMatrix = element.getTotalMatrix();
  if (totalMatrix) {
    var _a2 = invertFromMatrix([x2, y2, 1], totalMatrix), refX = _a2[0], refY = _a2[1];
    return [refX, refY];
  }
  return [x2, y2];
}
function preTest(element, x2, y2) {
  if (element.isCanvas && element.isCanvas()) {
    return true;
  }
  if (!isAllowCapture(element) || element.cfg.isInView === false) {
    return false;
  }
  if (element.cfg.clipShape) {
    var _a2 = getRefXY(element, x2, y2), refX = _a2[0], refY = _a2[1];
    if (element.isClipped(refX, refY)) {
      return false;
    }
  }
  var bbox = element.cfg.cacheCanvasBBox || element.getCanvasBBox();
  if (!(x2 >= bbox.minX && x2 <= bbox.maxX && y2 >= bbox.minY && y2 <= bbox.maxY)) {
    return false;
  }
  return true;
}
function getShape(container, x2, y2) {
  if (!preTest(container, x2, y2)) {
    return null;
  }
  var shape = null;
  var children = container.getChildren();
  var count2 = children.length;
  for (var i2 = count2 - 1; i2 >= 0; i2--) {
    var child = children[i2];
    if (child.isGroup()) {
      shape = getShape(child, x2, y2);
    } else if (preTest(child, x2, y2)) {
      var curShape = child;
      var _a2 = getRefXY(child, x2, y2), refX = _a2[0], refY = _a2[1];
      if (curShape.isInShape(refX, refY)) {
        shape = child;
      }
    }
    if (shape) {
      break;
    }
  }
  return shape;
}
var Canvas$1 = function(_super) {
  __extends$3(Canvas2, _super);
  function Canvas2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Canvas2.prototype.getDefaultCfg = function() {
    var cfg = _super.prototype.getDefaultCfg.call(this);
    cfg["renderer"] = "canvas";
    cfg["autoDraw"] = true;
    cfg["localRefresh"] = true;
    cfg["refreshElements"] = [];
    cfg["clipView"] = true;
    cfg["quickHit"] = false;
    return cfg;
  };
  Canvas2.prototype.onCanvasChange = function(changeType) {
    if (changeType === "attr" || changeType === "sort" || changeType === "changeSize") {
      this.set("refreshElements", [this]);
      this.draw();
    }
  };
  Canvas2.prototype.getShapeBase = function() {
    return Shape$1;
  };
  Canvas2.prototype.getGroupBase = function() {
    return Group$1;
  };
  Canvas2.prototype.getPixelRatio = function() {
    var pixelRatio = this.get("pixelRatio") || getPixelRatio$1();
    return pixelRatio >= 1 ? Math.ceil(pixelRatio) : 1;
  };
  Canvas2.prototype.getViewRange = function() {
    return {
      minX: 0,
      minY: 0,
      maxX: this.cfg.width,
      maxY: this.cfg.height
    };
  };
  Canvas2.prototype.createDom = function() {
    var element = document.createElement("canvas");
    var context2 = element.getContext("2d");
    this.set("context", context2);
    return element;
  };
  Canvas2.prototype.setDOMSize = function(width, height) {
    _super.prototype.setDOMSize.call(this, width, height);
    var context2 = this.get("context");
    var el = this.get("el");
    var pixelRatio = this.getPixelRatio();
    el.width = pixelRatio * width;
    el.height = pixelRatio * height;
    if (pixelRatio > 1) {
      context2.scale(pixelRatio, pixelRatio);
    }
  };
  Canvas2.prototype.clear = function() {
    _super.prototype.clear.call(this);
    this._clearFrame();
    var context2 = this.get("context");
    var element = this.get("el");
    context2.clearRect(0, 0, element.width, element.height);
  };
  Canvas2.prototype.getShape = function(x2, y2) {
    var shape;
    if (this.get("quickHit")) {
      shape = getShape(this, x2, y2);
    } else {
      shape = _super.prototype.getShape.call(this, x2, y2, null);
    }
    return shape;
  };
  Canvas2.prototype._getRefreshRegion = function() {
    var elements = this.get("refreshElements");
    var viewRegion = this.getViewRange();
    var region;
    if (elements.length && elements[0] === this) {
      region = viewRegion;
    } else {
      region = getMergedRegion(elements);
      if (region) {
        region.minX = Math.floor(region.minX);
        region.minY = Math.floor(region.minY);
        region.maxX = Math.ceil(region.maxX);
        region.maxY = Math.ceil(region.maxY);
        region.maxY += 1;
        var clipView = this.get("clipView");
        if (clipView) {
          region = mergeView(region, viewRegion);
        }
      }
    }
    return region;
  };
  Canvas2.prototype.refreshElement = function(element) {
    var refreshElements = this.get("refreshElements");
    refreshElements.push(element);
  };
  Canvas2.prototype._clearFrame = function() {
    var drawFrame = this.get("drawFrame");
    if (drawFrame) {
      cancelAnimationFrame$1(drawFrame);
      this.set("drawFrame", null);
      this.set("refreshElements", []);
    }
  };
  Canvas2.prototype.draw = function() {
    var drawFrame = this.get("drawFrame");
    if (this.get("autoDraw") && drawFrame) {
      return;
    }
    this._startDraw();
  };
  Canvas2.prototype._drawAll = function() {
    var context2 = this.get("context");
    var element = this.get("el");
    var children = this.getChildren();
    context2.clearRect(0, 0, element.width, element.height);
    applyAttrsToContext(context2, this);
    drawChildren$1(context2, children);
    this.set("refreshElements", []);
  };
  Canvas2.prototype._drawRegion = function() {
    var context2 = this.get("context");
    var refreshElements = this.get("refreshElements");
    var children = this.getChildren();
    var region = this._getRefreshRegion();
    if (region) {
      context2.clearRect(region.minX, region.minY, region.maxX - region.minX, region.maxY - region.minY);
      context2.save();
      context2.beginPath();
      context2.rect(region.minX, region.minY, region.maxX - region.minX, region.maxY - region.minY);
      context2.clip();
      applyAttrsToContext(context2, this);
      checkRefresh(this, children, region);
      drawChildren$1(context2, children, region);
      context2.restore();
    } else if (refreshElements.length) {
      clearChanged(refreshElements);
    }
    each$1(refreshElements, function(element) {
      if (element.get("hasChanged")) {
        element.set("hasChanged", false);
      }
    });
    this.set("refreshElements", []);
  };
  Canvas2.prototype._startDraw = function() {
    var _this = this;
    var drawFrame = this.get("drawFrame");
    if (!drawFrame) {
      drawFrame = requestAnimationFrame$1(function() {
        if (_this.get("localRefresh")) {
          _this._drawRegion();
        } else {
          _this._drawAll();
        }
        _this.set("drawFrame", null);
      });
      this.set("drawFrame", drawFrame);
    }
  };
  Canvas2.prototype.skipDraw = function() {
  };
  Canvas2.prototype.removeDom = function() {
    var el = this.get("el");
    el.width = 0;
    el.height = 0;
    el.parentNode.removeChild(el);
  };
  return Canvas2;
}(Canvas$2);
var version$2 = "0.5.12";
var CanvasEngine = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Shape: Shape$1,
  version: version$2,
  Canvas: Canvas$1,
  Group: Group$1,
  getArcParams,
  Event: GraphEvent,
  Base,
  AbstractCanvas: Canvas$2,
  AbstractGroup,
  AbstractShape,
  getBBoxMethod: getMethod,
  registerBBox: register,
  getTextHeight,
  assembleFont,
  isAllowCapture,
  multiplyVec2: multiplyVec2$1,
  invert,
  getOffScreenContext,
  registerEasing,
  PathUtil: PathUtil$1
}, Symbol.toStringTag, { value: "Module" }));
var SHAPE_TO_TAGS = {
  rect: "path",
  circle: "circle",
  line: "line",
  path: "path",
  marker: "path",
  text: "text",
  polyline: "polyline",
  polygon: "polygon",
  image: "image",
  ellipse: "ellipse",
  dom: "foreignObject"
};
var SVG_ATTR_MAP = {
  opacity: "opacity",
  fillStyle: "fill",
  fill: "fill",
  fillOpacity: "fill-opacity",
  strokeStyle: "stroke",
  strokeOpacity: "stroke-opacity",
  stroke: "stroke",
  x: "x",
  y: "y",
  r: "r",
  rx: "rx",
  ry: "ry",
  width: "width",
  height: "height",
  x1: "x1",
  x2: "x2",
  y1: "y1",
  y2: "y2",
  lineCap: "stroke-linecap",
  lineJoin: "stroke-linejoin",
  lineWidth: "stroke-width",
  lineDash: "stroke-dasharray",
  lineDashOffset: "stroke-dashoffset",
  miterLimit: "stroke-miterlimit",
  font: "font",
  fontSize: "font-size",
  fontStyle: "font-style",
  fontVariant: "font-variant",
  fontWeight: "font-weight",
  fontFamily: "font-family",
  startArrow: "marker-start",
  endArrow: "marker-end",
  path: "d",
  class: "class",
  id: "id",
  style: "style",
  preserveAspectRatio: "preserveAspectRatio"
};
function createSVGElement(type4) {
  return document.createElementNS("http://www.w3.org/2000/svg", type4);
}
function createDom(shape) {
  var type4 = SHAPE_TO_TAGS[shape.type];
  var parent = shape.getParent();
  if (!type4) {
    throw new Error("the type " + shape.type + " is not supported by svg");
  }
  var element = createSVGElement(type4);
  if (shape.get("id")) {
    element.id = shape.get("id");
  }
  shape.set("el", element);
  shape.set("attrs", {});
  if (parent) {
    var parentNode = parent.get("el");
    if (parentNode) {
      parentNode.appendChild(element);
    } else {
      parentNode = parent.createDom();
      parent.set("el", parentNode);
      parentNode.appendChild(element);
    }
  }
  return element;
}
function sortDom(element, sorter) {
  var el = element.get("el");
  var childList = toArray(el.children).sort(sorter);
  var fragment = document.createDocumentFragment();
  childList.forEach(function(child) {
    fragment.appendChild(child);
  });
  el.appendChild(fragment);
}
function moveTo(element, targetIndex) {
  var parentNode = element.parentNode;
  var siblings2 = Array.from(parentNode.childNodes).filter(
    function(node) {
      return node.nodeType === 1 && node.nodeName.toLowerCase() !== "defs";
    }
  );
  var target = siblings2[targetIndex];
  var currentIndex = siblings2.indexOf(element);
  if (target) {
    if (currentIndex > targetIndex) {
      parentNode.insertBefore(element, target);
    } else if (currentIndex < targetIndex) {
      var targetNext = siblings2[targetIndex + 1];
      if (targetNext) {
        parentNode.insertBefore(element, targetNext);
      } else {
        parentNode.appendChild(element);
      }
    }
  } else {
    parentNode.appendChild(element);
  }
}
function setShadow(model, context2) {
  var el = model.cfg.el;
  var attrs = model.attr();
  var cfg = {
    dx: attrs.shadowOffsetX,
    dy: attrs.shadowOffsetY,
    blur: attrs.shadowBlur,
    color: attrs.shadowColor
  };
  if (!cfg.dx && !cfg.dy && !cfg.blur && !cfg.color) {
    el.removeAttribute("filter");
  } else {
    var id2 = context2.find("filter", cfg);
    if (!id2) {
      id2 = context2.addShadow(cfg);
    }
    el.setAttribute("filter", "url(#" + id2 + ")");
  }
}
function setTransform(model) {
  var matrix = model.attr().matrix;
  if (matrix) {
    var el = model.cfg.el;
    var transform2 = [];
    for (var i2 = 0; i2 < 9; i2 += 3) {
      transform2.push(matrix[i2] + "," + matrix[i2 + 1]);
    }
    transform2 = transform2.join(",");
    if (transform2.indexOf("NaN") === -1) {
      el.setAttribute("transform", "matrix(" + transform2 + ")");
    } else {
      console.warn("invalid matrix:", matrix);
    }
  }
}
function setClip(model, context2) {
  var clip = model.getClip();
  var el = model.get("el");
  if (!clip) {
    el.removeAttribute("clip-path");
  } else if (clip && !el.hasAttribute("clip-path")) {
    createDom(clip);
    clip.createPath(context2);
    var id2 = context2.addClip(clip);
    el.setAttribute("clip-path", "url(#" + id2 + ")");
  }
}
function drawChildren(context2, children) {
  children.forEach(function(child) {
    child.draw(context2);
  });
}
function refreshElement(element, changeType) {
  var canvas = element.get("canvas");
  if (canvas && canvas.get("autoDraw")) {
    var context2 = canvas.get("context");
    var parent_1 = element.getParent();
    var parentChildren = parent_1 ? parent_1.getChildren() : [canvas];
    var el = element.get("el");
    if (changeType === "remove") {
      var isClipShape = element.get("isClipShape");
      if (isClipShape) {
        var clipPathEl = el && el.parentNode;
        var defsEl = clipPathEl && clipPathEl.parentNode;
        if (clipPathEl && defsEl) {
          defsEl.removeChild(clipPathEl);
        }
      } else if (el && el.parentNode) {
        el.parentNode.removeChild(el);
      }
    } else if (changeType === "show") {
      el.setAttribute("visibility", "visible");
    } else if (changeType === "hide") {
      el.setAttribute("visibility", "hidden");
    } else if (changeType === "zIndex") {
      moveTo(el, parentChildren.indexOf(element));
    } else if (changeType === "sort") {
      var children_1 = element.get("children");
      if (children_1 && children_1.length) {
        sortDom(element, function(a2, b10) {
          return children_1.indexOf(a2) - children_1.indexOf(b10) ? 1 : 0;
        });
      }
    } else if (changeType === "clear") {
      if (el) {
        el.innerHTML = "";
      }
    } else if (changeType === "matrix") {
      setTransform(element);
    } else if (changeType === "clip") {
      setClip(element, context2);
    } else if (changeType === "attr")
      ;
    else if (changeType === "add") {
      element.draw(context2);
    }
  }
}
var Group = function(_super) {
  __extends$3(Group4, _super);
  function Group4() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Group4.prototype.isEntityGroup = function() {
    return true;
  };
  Group4.prototype.createDom = function() {
    var element = createSVGElement("g");
    this.set("el", element);
    var parent = this.getParent();
    if (parent) {
      var parentNode = parent.get("el");
      if (parentNode) {
        parentNode.appendChild(element);
      } else {
        parentNode = parent.createDom();
        parent.set("el", parentNode);
        parentNode.appendChild(element);
      }
    }
    return element;
  };
  Group4.prototype.afterAttrsChange = function(targetAttrs) {
    _super.prototype.afterAttrsChange.call(this, targetAttrs);
    var canvas = this.get("canvas");
    if (canvas && canvas.get("autoDraw")) {
      var context2 = canvas.get("context");
      this.createPath(context2, targetAttrs);
    }
  };
  Group4.prototype.onCanvasChange = function(changeType) {
    refreshElement(this, changeType);
  };
  Group4.prototype.getShapeBase = function() {
    return Shape;
  };
  Group4.prototype.getGroupBase = function() {
    return Group4;
  };
  Group4.prototype.draw = function(context2) {
    var children = this.getChildren();
    var el = this.get("el");
    if (this.get("destroyed")) {
      if (el) {
        el.parentNode.removeChild(el);
      }
    } else {
      if (!el) {
        this.createDom();
      }
      setClip(this, context2);
      this.createPath(context2);
      if (children.length) {
        drawChildren(context2, children);
      }
    }
  };
  Group4.prototype.createPath = function(context2, targetAttrs) {
    var attrs = this.attr();
    var el = this.get("el");
    each$1(targetAttrs || attrs, function(value2, attr) {
      if (SVG_ATTR_MAP[attr]) {
        el.setAttribute(SVG_ATTR_MAP[attr], value2);
      }
    });
    setTransform(this);
  };
  return Group4;
}(AbstractGroup);
var ShapeBase = function(_super) {
  __extends$3(ShapeBase2, _super);
  function ShapeBase2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "svg";
    _this.canFill = false;
    _this.canStroke = false;
    return _this;
  }
  ShapeBase2.prototype.getDefaultAttrs = function() {
    var attrs = _super.prototype.getDefaultAttrs.call(this);
    return __assign$4(__assign$4({}, attrs), { lineWidth: 1, lineAppendWidth: 0, strokeOpacity: 1, fillOpacity: 1 });
  };
  ShapeBase2.prototype.afterAttrsChange = function(targetAttrs) {
    _super.prototype.afterAttrsChange.call(this, targetAttrs);
    var canvas = this.get("canvas");
    if (canvas && canvas.get("autoDraw")) {
      var context2 = canvas.get("context");
      this.draw(context2, targetAttrs);
    }
  };
  ShapeBase2.prototype.getShapeBase = function() {
    return Shape;
  };
  ShapeBase2.prototype.getGroupBase = function() {
    return Group;
  };
  ShapeBase2.prototype.onCanvasChange = function(changeType) {
    refreshElement(this, changeType);
  };
  ShapeBase2.prototype.calculateBBox = function() {
    var el = this.get("el");
    var bbox = null;
    if (el) {
      bbox = el.getBBox();
    } else {
      var bboxMethod = getMethod(this.get("type"));
      if (bboxMethod) {
        bbox = bboxMethod(this);
      }
    }
    if (bbox) {
      var x2 = bbox.x, y2 = bbox.y, width = bbox.width, height = bbox.height;
      var lineWidth = this.getHitLineWidth();
      var halfWidth = lineWidth / 2;
      var minX = x2 - halfWidth;
      var minY = y2 - halfWidth;
      var maxX = x2 + width + halfWidth;
      var maxY2 = y2 + height + halfWidth;
      return {
        x: minX,
        y: minY,
        minX,
        minY,
        maxX,
        maxY: maxY2,
        width: width + lineWidth,
        height: height + lineWidth
      };
    }
    return {
      x: 0,
      y: 0,
      minX: 0,
      minY: 0,
      maxX: 0,
      maxY: 0,
      width: 0,
      height: 0
    };
  };
  ShapeBase2.prototype.isFill = function() {
    var _a2 = this.attr(), fill = _a2.fill, fillStyle = _a2.fillStyle;
    return (fill || fillStyle || this.isClipShape()) && this.canFill;
  };
  ShapeBase2.prototype.isStroke = function() {
    var _a2 = this.attr(), stroke = _a2.stroke, strokeStyle = _a2.strokeStyle;
    return (stroke || strokeStyle) && this.canStroke;
  };
  ShapeBase2.prototype.draw = function(context2, targetAttrs) {
    var el = this.get("el");
    if (this.get("destroyed")) {
      if (el) {
        el.parentNode.removeChild(el);
      }
    } else {
      if (!el) {
        createDom(this);
      }
      setClip(this, context2);
      this.createPath(context2, targetAttrs);
      this.shadow(context2, targetAttrs);
      this.strokeAndFill(context2, targetAttrs);
      this.transform(targetAttrs);
    }
  };
  ShapeBase2.prototype.createPath = function(context2, targetAttrs) {
  };
  ShapeBase2.prototype.strokeAndFill = function(context2, targetAttrs) {
    var attrs = targetAttrs || this.attr();
    var fill = attrs.fill, fillStyle = attrs.fillStyle, stroke = attrs.stroke, strokeStyle = attrs.strokeStyle, fillOpacity = attrs.fillOpacity, strokeOpacity = attrs.strokeOpacity, lineWidth = attrs.lineWidth;
    var el = this.get("el");
    if (this.canFill) {
      if (!targetAttrs) {
        this._setColor(context2, "fill", fill || fillStyle);
      } else if ("fill" in attrs) {
        this._setColor(context2, "fill", fill);
      } else if ("fillStyle" in attrs) {
        this._setColor(context2, "fill", fillStyle);
      }
      if (fillOpacity) {
        el.setAttribute(SVG_ATTR_MAP["fillOpacity"], fillOpacity);
      }
    }
    if (this.canStroke && lineWidth > 0) {
      if (!targetAttrs) {
        this._setColor(context2, "stroke", stroke || strokeStyle);
      } else if ("stroke" in attrs) {
        this._setColor(context2, "stroke", stroke);
      } else if ("strokeStyle" in attrs) {
        this._setColor(context2, "stroke", strokeStyle);
      }
      if (strokeOpacity) {
        el.setAttribute(SVG_ATTR_MAP["strokeOpacity"], strokeOpacity);
      }
      if (lineWidth) {
        el.setAttribute(SVG_ATTR_MAP["lineWidth"], lineWidth);
      }
    }
  };
  ShapeBase2.prototype._setColor = function(context2, attr, value2) {
    var el = this.get("el");
    if (!value2) {
      el.setAttribute(SVG_ATTR_MAP[attr], "none");
      return;
    }
    value2 = value2.trim();
    if (/^[r,R,L,l]{1}[\s]*\(/.test(value2)) {
      var id2 = context2.find("gradient", value2);
      if (!id2) {
        id2 = context2.addGradient(value2);
      }
      el.setAttribute(SVG_ATTR_MAP[attr], "url(#" + id2 + ")");
    } else if (/^[p,P]{1}[\s]*\(/.test(value2)) {
      var id2 = context2.find("pattern", value2);
      if (!id2) {
        id2 = context2.addPattern(value2);
      }
      el.setAttribute(SVG_ATTR_MAP[attr], "url(#" + id2 + ")");
    } else {
      el.setAttribute(SVG_ATTR_MAP[attr], value2);
    }
  };
  ShapeBase2.prototype.shadow = function(context2, targetAttrs) {
    var attrs = this.attr();
    var _a2 = targetAttrs || attrs, shadowOffsetX = _a2.shadowOffsetX, shadowOffsetY = _a2.shadowOffsetY, shadowBlur = _a2.shadowBlur, shadowColor = _a2.shadowColor;
    if (shadowOffsetX || shadowOffsetY || shadowBlur || shadowColor) {
      setShadow(this, context2);
    }
  };
  ShapeBase2.prototype.transform = function(targetAttrs) {
    var attrs = this.attr();
    var matrix = (targetAttrs || attrs).matrix;
    if (matrix) {
      setTransform(this);
    }
  };
  ShapeBase2.prototype.isInShape = function(refX, refY) {
    return this.isPointInPath(refX, refY);
  };
  ShapeBase2.prototype.isPointInPath = function(refX, refY) {
    var el = this.get("el");
    var canvas = this.get("canvas");
    var bbox = canvas.get("el").getBoundingClientRect();
    var clientX = refX + bbox.left;
    var clientY = refY + bbox.top;
    var element = document.elementFromPoint(clientX, clientY);
    if (element && element.isEqualNode(el)) {
      return true;
    }
    return false;
  };
  ShapeBase2.prototype.getHitLineWidth = function() {
    var _a2 = this.attrs, lineWidth = _a2.lineWidth, lineAppendWidth = _a2.lineAppendWidth;
    if (this.isStroke()) {
      return lineWidth + lineAppendWidth;
    }
    return 0;
  };
  return ShapeBase2;
}(AbstractShape);
var ShapeBase$1 = ShapeBase;
var Circle$1 = function(_super) {
  __extends$3(Circle2, _super);
  function Circle2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "circle";
    _this.canFill = true;
    _this.canStroke = true;
    return _this;
  }
  Circle2.prototype.getDefaultAttrs = function() {
    var attrs = _super.prototype.getDefaultAttrs.call(this);
    return __assign$4(__assign$4({}, attrs), { x: 0, y: 0, r: 0 });
  };
  Circle2.prototype.createPath = function(context2, targetAttrs) {
    var attrs = this.attr();
    var el = this.get("el");
    each$1(targetAttrs || attrs, function(value2, attr) {
      if (attr === "x" || attr === "y") {
        el.setAttribute("c" + attr, value2);
      } else if (SVG_ATTR_MAP[attr]) {
        el.setAttribute(SVG_ATTR_MAP[attr], value2);
      }
    });
  };
  return Circle2;
}(ShapeBase$1);
var Circle$2 = Circle$1;
var Dom = function(_super) {
  __extends$3(Dom2, _super);
  function Dom2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "dom";
    _this.canFill = false;
    _this.canStroke = false;
    return _this;
  }
  Dom2.prototype.createPath = function(context2, targetAttrs) {
    var attrs = this.attr();
    var el = this.get("el");
    each$1(targetAttrs || attrs, function(value2, attr) {
      if (SVG_ATTR_MAP[attr]) {
        el.setAttribute(SVG_ATTR_MAP[attr], value2);
      }
    });
    if (typeof attrs["html"] === "function") {
      var element = attrs["html"].call(this, attrs);
      if (element instanceof Element || element instanceof HTMLDocument) {
        var children = el.childNodes;
        for (var i2 = children.length - 1; i2 >= 0; i2--) {
          el.removeChild(children[i2]);
        }
        el.appendChild(element);
      } else {
        el.innerHTML = element;
      }
    } else {
      el.innerHTML = attrs["html"];
    }
  };
  return Dom2;
}(ShapeBase$1);
var Dom$1 = Dom;
var Ellipse = function(_super) {
  __extends$3(Ellipse2, _super);
  function Ellipse2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "ellipse";
    _this.canFill = true;
    _this.canStroke = true;
    return _this;
  }
  Ellipse2.prototype.getDefaultAttrs = function() {
    var attrs = _super.prototype.getDefaultAttrs.call(this);
    return __assign$4(__assign$4({}, attrs), { x: 0, y: 0, rx: 0, ry: 0 });
  };
  Ellipse2.prototype.createPath = function(context2, targetAttrs) {
    var attrs = this.attr();
    var el = this.get("el");
    each$1(targetAttrs || attrs, function(value2, attr) {
      if (attr === "x" || attr === "y") {
        el.setAttribute("c" + attr, value2);
      } else if (SVG_ATTR_MAP[attr]) {
        el.setAttribute(SVG_ATTR_MAP[attr], value2);
      }
    });
  };
  return Ellipse2;
}(ShapeBase$1);
var Ellipse$1 = Ellipse;
var Image$1 = function(_super) {
  __extends$3(Image3, _super);
  function Image3() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "image";
    _this.canFill = false;
    _this.canStroke = false;
    return _this;
  }
  Image3.prototype.getDefaultAttrs = function() {
    var attrs = _super.prototype.getDefaultAttrs.call(this);
    return __assign$4(__assign$4({}, attrs), { x: 0, y: 0, width: 0, height: 0 });
  };
  Image3.prototype.createPath = function(context2, targetAttrs) {
    var _this = this;
    var attrs = this.attr();
    var el = this.get("el");
    each$1(targetAttrs || attrs, function(value2, attr) {
      if (attr === "img") {
        _this._setImage(attrs.img);
      } else if (SVG_ATTR_MAP[attr]) {
        el.setAttribute(SVG_ATTR_MAP[attr], value2);
      }
    });
  };
  Image3.prototype.setAttr = function(name, value2) {
    this.attrs[name] = value2;
    if (name === "img") {
      this._setImage(value2);
    }
  };
  Image3.prototype._setImage = function(img) {
    var attrs = this.attr();
    var el = this.get("el");
    if (isString(img)) {
      el.setAttribute("href", img);
    } else if (img instanceof window.Image) {
      if (!attrs.width) {
        el.setAttribute("width", img.width);
        this.attr("width", img.width);
      }
      if (!attrs.height) {
        el.setAttribute("height", img.height);
        this.attr("height", img.height);
      }
      el.setAttribute("href", img.src);
    } else if (img instanceof HTMLElement && isString(img.nodeName) && img.nodeName.toUpperCase() === "CANVAS") {
      el.setAttribute("href", img.toDataURL());
    } else if (img instanceof ImageData) {
      var canvas = document.createElement("canvas");
      canvas.setAttribute("width", "" + img.width);
      canvas.setAttribute("height", "" + img.height);
      canvas.getContext("2d").putImageData(img, 0, 0);
      if (!attrs.width) {
        el.setAttribute("width", "" + img.width);
        this.attr("width", img.width);
      }
      if (!attrs.height) {
        el.setAttribute("height", "" + img.height);
        this.attr("height", img.height);
      }
      el.setAttribute("href", canvas.toDataURL());
    }
  };
  return Image3;
}(ShapeBase$1);
var Image$2 = Image$1;
var Line$3 = function(_super) {
  __extends$3(Line2, _super);
  function Line2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "line";
    _this.canFill = false;
    _this.canStroke = true;
    return _this;
  }
  Line2.prototype.getDefaultAttrs = function() {
    var attrs = _super.prototype.getDefaultAttrs.call(this);
    return __assign$4(__assign$4({}, attrs), { x1: 0, y1: 0, x2: 0, y2: 0, startArrow: false, endArrow: false });
  };
  Line2.prototype.createPath = function(context2, targetAttrs) {
    var attrs = this.attr();
    var el = this.get("el");
    each$1(targetAttrs || attrs, function(value2, attr) {
      if (attr === "startArrow" || attr === "endArrow") {
        if (value2) {
          var id2 = isObject(value2) ? context2.addArrow(attrs, SVG_ATTR_MAP[attr]) : context2.getDefaultArrow(attrs, SVG_ATTR_MAP[attr]);
          el.setAttribute(SVG_ATTR_MAP[attr], "url(#" + id2 + ")");
        } else {
          el.removeAttribute(SVG_ATTR_MAP[attr]);
        }
      } else if (SVG_ATTR_MAP[attr]) {
        el.setAttribute(SVG_ATTR_MAP[attr], value2);
      }
    });
  };
  Line2.prototype.getTotalLength = function() {
    var _a2 = this.attr(), x1 = _a2.x1, y1 = _a2.y1, x2 = _a2.x2, y2 = _a2.y2;
    return LineUtil.length(x1, y1, x2, y2);
  };
  Line2.prototype.getPoint = function(ratio) {
    var _a2 = this.attr(), x1 = _a2.x1, y1 = _a2.y1, x2 = _a2.x2, y2 = _a2.y2;
    return LineUtil.pointAt(x1, y1, x2, y2, ratio);
  };
  return Line2;
}(ShapeBase$1);
var Line$4 = Line$3;
var Symbols = {
  circle: function(x2, y2, r2) {
    return [
      ["M", x2, y2],
      ["m", -r2, 0],
      ["a", r2, r2, 0, 1, 0, r2 * 2, 0],
      ["a", r2, r2, 0, 1, 0, -r2 * 2, 0]
    ];
  },
  square: function(x2, y2, r2) {
    return [["M", x2 - r2, y2 - r2], ["L", x2 + r2, y2 - r2], ["L", x2 + r2, y2 + r2], ["L", x2 - r2, y2 + r2], ["Z"]];
  },
  diamond: function(x2, y2, r2) {
    return [["M", x2 - r2, y2], ["L", x2, y2 - r2], ["L", x2 + r2, y2], ["L", x2, y2 + r2], ["Z"]];
  },
  triangle: function(x2, y2, r2) {
    var diffY = r2 * Math.sin(1 / 3 * Math.PI);
    return [["M", x2 - r2, y2 + diffY], ["L", x2, y2 - diffY], ["L", x2 + r2, y2 + diffY], ["z"]];
  },
  triangleDown: function(x2, y2, r2) {
    var diffY = r2 * Math.sin(1 / 3 * Math.PI);
    return [["M", x2 - r2, y2 - diffY], ["L", x2 + r2, y2 - diffY], ["L", x2, y2 + diffY], ["Z"]];
  }
};
var symbolsFactory = {
  get: function(type4) {
    return Symbols[type4];
  },
  register: function(type4, func) {
    Symbols[type4] = func;
  },
  remove: function(type4) {
    delete Symbols[type4];
  },
  getAll: function() {
    return Symbols;
  }
};
var Marker = function(_super) {
  __extends$3(Marker2, _super);
  function Marker2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "marker";
    _this.canFill = true;
    _this.canStroke = true;
    return _this;
  }
  Marker2.prototype.createPath = function(context2) {
    var el = this.get("el");
    el.setAttribute("d", this._assembleMarker());
  };
  Marker2.prototype._assembleMarker = function() {
    var d2 = this._getPath();
    if (isArray$1(d2)) {
      return d2.map(function(path2) {
        return path2.join(" ");
      }).join("");
    }
    return d2;
  };
  Marker2.prototype._getPath = function() {
    var attrs = this.attr();
    var x2 = attrs.x, y2 = attrs.y;
    var r2 = attrs.r || attrs.radius;
    var symbol = attrs.symbol || "circle";
    var method4;
    if (isFunction(symbol)) {
      method4 = symbol;
    } else {
      method4 = symbolsFactory.get(symbol);
    }
    if (!method4) {
      console.warn(method4 + " symbol is not exist.");
      return null;
    }
    return method4(x2, y2, r2);
  };
  Marker2.symbolsFactory = symbolsFactory;
  return Marker2;
}(ShapeBase$1);
var Marker$1 = Marker;
var Path$1 = function(_super) {
  __extends$3(Path2, _super);
  function Path2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "path";
    _this.canFill = true;
    _this.canStroke = true;
    return _this;
  }
  Path2.prototype.getDefaultAttrs = function() {
    var attrs = _super.prototype.getDefaultAttrs.call(this);
    return __assign$4(__assign$4({}, attrs), { startArrow: false, endArrow: false });
  };
  Path2.prototype.createPath = function(context2, targetAttrs) {
    var _this = this;
    var attrs = this.attr();
    var el = this.get("el");
    each$1(targetAttrs || attrs, function(value2, attr) {
      if (attr === "path" && isArray$1(value2)) {
        el.setAttribute("d", _this._formatPath(value2));
      } else if (attr === "startArrow" || attr === "endArrow") {
        if (value2) {
          var id2 = isObject(value2) ? context2.addArrow(attrs, SVG_ATTR_MAP[attr]) : context2.getDefaultArrow(attrs, SVG_ATTR_MAP[attr]);
          el.setAttribute(SVG_ATTR_MAP[attr], "url(#" + id2 + ")");
        } else {
          el.removeAttribute(SVG_ATTR_MAP[attr]);
        }
      } else if (SVG_ATTR_MAP[attr]) {
        el.setAttribute(SVG_ATTR_MAP[attr], value2);
      }
    });
  };
  Path2.prototype._formatPath = function(value2) {
    var newValue = value2.map(function(path2) {
      return path2.join(" ");
    }).join("");
    if (~newValue.indexOf("NaN")) {
      return "";
    }
    return newValue;
  };
  Path2.prototype.getTotalLength = function() {
    var el = this.get("el");
    return el ? el.getTotalLength() : null;
  };
  Path2.prototype.getPoint = function(ratio) {
    var el = this.get("el");
    var totalLength = this.getTotalLength();
    if (totalLength === 0) {
      return null;
    }
    var point2 = el ? el.getPointAtLength(ratio * totalLength) : null;
    return point2 ? {
      x: point2.x,
      y: point2.y
    } : null;
  };
  return Path2;
}(ShapeBase$1);
var Path$2 = Path$1;
var Polygon$1 = function(_super) {
  __extends$3(Polygon2, _super);
  function Polygon2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "polygon";
    _this.canFill = true;
    _this.canStroke = true;
    return _this;
  }
  Polygon2.prototype.createPath = function(context2, targetAttrs) {
    var attrs = this.attr();
    var el = this.get("el");
    each$1(targetAttrs || attrs, function(value2, attr) {
      if (attr === "points" && isArray$1(value2) && value2.length >= 2) {
        el.setAttribute("points", value2.map(function(point2) {
          return point2[0] + "," + point2[1];
        }).join(" "));
      } else if (SVG_ATTR_MAP[attr]) {
        el.setAttribute(SVG_ATTR_MAP[attr], value2);
      }
    });
  };
  return Polygon2;
}(ShapeBase$1);
var Polygon$2 = Polygon$1;
var Polyline = function(_super) {
  __extends$3(Polyline2, _super);
  function Polyline2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "polyline";
    _this.canFill = true;
    _this.canStroke = true;
    return _this;
  }
  Polyline2.prototype.getDefaultAttrs = function() {
    var attrs = _super.prototype.getDefaultAttrs.call(this);
    return __assign$4(__assign$4({}, attrs), { startArrow: false, endArrow: false });
  };
  Polyline2.prototype.onAttrChange = function(name, value2, originValue) {
    _super.prototype.onAttrChange.call(this, name, value2, originValue);
    if (["points"].indexOf(name) !== -1) {
      this._resetCache();
    }
  };
  Polyline2.prototype._resetCache = function() {
    this.set("totalLength", null);
    this.set("tCache", null);
  };
  Polyline2.prototype.createPath = function(context2, targetAttrs) {
    var attrs = this.attr();
    var el = this.get("el");
    each$1(targetAttrs || attrs, function(value2, attr) {
      if (attr === "points" && isArray$1(value2) && value2.length >= 2) {
        el.setAttribute("points", value2.map(function(point2) {
          return point2[0] + "," + point2[1];
        }).join(" "));
      } else if (SVG_ATTR_MAP[attr]) {
        el.setAttribute(SVG_ATTR_MAP[attr], value2);
      }
    });
  };
  Polyline2.prototype.getTotalLength = function() {
    var points2 = this.attr().points;
    var totalLength = this.get("totalLength");
    if (!isNil(totalLength)) {
      return totalLength;
    }
    this.set("totalLength", PolylineUtil.length(points2));
    return this.get("totalLength");
  };
  Polyline2.prototype.getPoint = function(ratio) {
    var points2 = this.attr().points;
    var tCache = this.get("tCache");
    if (!tCache) {
      this._setTcache();
      tCache = this.get("tCache");
    }
    var subt;
    var index2;
    each$1(tCache, function(v2, i2) {
      if (ratio >= v2[0] && ratio <= v2[1]) {
        subt = (ratio - v2[0]) / (v2[1] - v2[0]);
        index2 = i2;
      }
    });
    return LineUtil.pointAt(points2[index2][0], points2[index2][1], points2[index2 + 1][0], points2[index2 + 1][1], subt);
  };
  Polyline2.prototype._setTcache = function() {
    var points2 = this.attr().points;
    if (!points2 || points2.length === 0) {
      return;
    }
    var totalLength = this.getTotalLength();
    if (totalLength <= 0) {
      return;
    }
    var tempLength = 0;
    var tCache = [];
    var segmentT;
    var segmentL;
    each$1(points2, function(p2, i2) {
      if (points2[i2 + 1]) {
        segmentT = [];
        segmentT[0] = tempLength / totalLength;
        segmentL = LineUtil.length(p2[0], p2[1], points2[i2 + 1][0], points2[i2 + 1][1]);
        tempLength += segmentL;
        segmentT[1] = tempLength / totalLength;
        tCache.push(segmentT);
      }
    });
    this.set("tCache", tCache);
  };
  Polyline2.prototype.getStartTangent = function() {
    var points2 = this.attr().points;
    var result = [];
    result.push([points2[1][0], points2[1][1]]);
    result.push([points2[0][0], points2[0][1]]);
    return result;
  };
  Polyline2.prototype.getEndTangent = function() {
    var points2 = this.attr().points;
    var l2 = points2.length - 1;
    var result = [];
    result.push([points2[l2 - 1][0], points2[l2 - 1][1]]);
    result.push([points2[l2][0], points2[l2][1]]);
    return result;
  };
  return Polyline2;
}(ShapeBase$1);
var Polyline$1 = Polyline;
function parseRadius$1(radius) {
  var r1 = 0;
  var r2 = 0;
  var r3 = 0;
  var r4 = 0;
  if (isArray$1(radius)) {
    if (radius.length === 1) {
      r1 = r2 = r3 = r4 = radius[0];
    } else if (radius.length === 2) {
      r1 = r3 = radius[0];
      r2 = r4 = radius[1];
    } else if (radius.length === 3) {
      r1 = radius[0];
      r2 = r4 = radius[1];
      r3 = radius[2];
    } else {
      r1 = radius[0];
      r2 = radius[1];
      r3 = radius[2];
      r4 = radius[3];
    }
  } else {
    r1 = r2 = r3 = r4 = radius;
  }
  return {
    r1,
    r2,
    r3,
    r4
  };
}
var Rect$1 = function(_super) {
  __extends$3(Rect2, _super);
  function Rect2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "rect";
    _this.canFill = true;
    _this.canStroke = true;
    return _this;
  }
  Rect2.prototype.getDefaultAttrs = function() {
    var attrs = _super.prototype.getDefaultAttrs.call(this);
    return __assign$4(__assign$4({}, attrs), { x: 0, y: 0, width: 0, height: 0, radius: 0 });
  };
  Rect2.prototype.createPath = function(context2, targetAttrs) {
    var _this = this;
    var attrs = this.attr();
    var el = this.get("el");
    var completed = false;
    var pathRelatedAttrs = ["x", "y", "width", "height", "radius"];
    each$1(targetAttrs || attrs, function(value2, attr) {
      if (pathRelatedAttrs.indexOf(attr) !== -1 && !completed) {
        el.setAttribute("d", _this._assembleRect(attrs));
        completed = true;
      } else if (pathRelatedAttrs.indexOf(attr) === -1 && SVG_ATTR_MAP[attr]) {
        el.setAttribute(SVG_ATTR_MAP[attr], value2);
      }
    });
  };
  Rect2.prototype._assembleRect = function(attrs) {
    var x2 = attrs.x;
    var y2 = attrs.y;
    var w2 = attrs.width;
    var h2 = attrs.height;
    var radius = attrs.radius;
    if (!radius) {
      return "M " + x2 + "," + y2 + " l " + w2 + ",0 l 0," + h2 + " l" + -w2 + " 0 z";
    }
    var r2 = parseRadius$1(radius);
    if (isArray$1(radius)) {
      if (radius.length === 1) {
        r2.r1 = r2.r2 = r2.r3 = r2.r4 = radius[0];
      } else if (radius.length === 2) {
        r2.r1 = r2.r3 = radius[0];
        r2.r2 = r2.r4 = radius[1];
      } else if (radius.length === 3) {
        r2.r1 = radius[0];
        r2.r2 = r2.r4 = radius[1];
        r2.r3 = radius[2];
      } else {
        r2.r1 = radius[0];
        r2.r2 = radius[1];
        r2.r3 = radius[2];
        r2.r4 = radius[3];
      }
    } else {
      r2.r1 = r2.r2 = r2.r3 = r2.r4 = radius;
    }
    var d2 = [
      ["M " + (x2 + r2.r1) + "," + y2],
      ["l " + (w2 - r2.r1 - r2.r2) + ",0"],
      ["a " + r2.r2 + "," + r2.r2 + ",0,0,1," + r2.r2 + "," + r2.r2],
      ["l 0," + (h2 - r2.r2 - r2.r3)],
      ["a " + r2.r3 + "," + r2.r3 + ",0,0,1," + -r2.r3 + "," + r2.r3],
      ["l " + (r2.r3 + r2.r4 - w2) + ",0"],
      ["a " + r2.r4 + "," + r2.r4 + ",0,0,1," + -r2.r4 + "," + -r2.r4],
      ["l 0," + (r2.r4 + r2.r1 - h2)],
      ["a " + r2.r1 + "," + r2.r1 + ",0,0,1," + r2.r1 + "," + -r2.r1],
      ["z"]
    ];
    return d2.join(" ");
  };
  return Rect2;
}(ShapeBase$1);
var Rect$2 = Rect$1;
var LETTER_SPACING = 0.3;
var BASELINE_MAP = {
  top: "before-edge",
  middle: "central",
  bottom: "after-edge",
  alphabetic: "baseline",
  hanging: "hanging"
};
var BASELINE_MAP_FOR_FIREFOX = {
  top: "text-before-edge",
  middle: "central",
  bottom: "text-after-edge",
  alphabetic: "alphabetic",
  hanging: "hanging"
};
var ANCHOR_MAP = {
  left: "left",
  start: "left",
  center: "middle",
  right: "end",
  end: "end"
};
var Text = function(_super) {
  __extends$3(Text2, _super);
  function Text2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "text";
    _this.canFill = true;
    _this.canStroke = true;
    return _this;
  }
  Text2.prototype.getDefaultAttrs = function() {
    var attrs = _super.prototype.getDefaultAttrs.call(this);
    return __assign$4(__assign$4({}, attrs), { x: 0, y: 0, text: null, fontSize: 12, fontFamily: "sans-serif", fontStyle: "normal", fontWeight: "normal", fontVariant: "normal", textAlign: "start", textBaseline: "bottom" });
  };
  Text2.prototype.createPath = function(context2, targetAttrs) {
    var _this = this;
    var attrs = this.attr();
    var el = this.get("el");
    this._setFont();
    each$1(targetAttrs || attrs, function(value2, attr) {
      if (attr === "text") {
        _this._setText("" + value2);
      } else if (attr === "matrix" && value2) {
        setTransform(_this);
      } else if (SVG_ATTR_MAP[attr]) {
        el.setAttribute(SVG_ATTR_MAP[attr], value2);
      }
    });
    el.setAttribute("paint-order", "stroke");
    el.setAttribute("style", "stroke-linecap:butt; stroke-linejoin:miter;");
  };
  Text2.prototype._setFont = function() {
    var el = this.get("el");
    var _a2 = this.attr(), textBaseline = _a2.textBaseline, textAlign = _a2.textAlign;
    var browser2 = detect();
    if (browser2 && browser2.name === "firefox") {
      el.setAttribute("dominant-baseline", BASELINE_MAP_FOR_FIREFOX[textBaseline] || "alphabetic");
    } else {
      el.setAttribute("alignment-baseline", BASELINE_MAP[textBaseline] || "baseline");
    }
    el.setAttribute("text-anchor", ANCHOR_MAP[textAlign] || "left");
  };
  Text2.prototype._setText = function(text2) {
    var el = this.get("el");
    var _a2 = this.attr(), x2 = _a2.x, _b = _a2.textBaseline, baseline = _b === void 0 ? "bottom" : _b;
    if (!text2) {
      el.innerHTML = "";
    } else if (~text2.indexOf("\n")) {
      var textArr = text2.split("\n");
      var textLen_1 = textArr.length - 1;
      var arr_1 = "";
      each$1(textArr, function(segment, i2) {
        if (i2 === 0) {
          if (baseline === "alphabetic") {
            arr_1 += '<tspan x="' + x2 + '" dy="' + -textLen_1 + 'em">' + segment + "</tspan>";
          } else if (baseline === "top") {
            arr_1 += '<tspan x="' + x2 + '" dy="0.9em">' + segment + "</tspan>";
          } else if (baseline === "middle") {
            arr_1 += '<tspan x="' + x2 + '" dy="' + -(textLen_1 - 1) / 2 + 'em">' + segment + "</tspan>";
          } else if (baseline === "bottom") {
            arr_1 += '<tspan x="' + x2 + '" dy="-' + (textLen_1 + LETTER_SPACING) + 'em">' + segment + "</tspan>";
          } else if (baseline === "hanging") {
            arr_1 += '<tspan x="' + x2 + '" dy="' + (-(textLen_1 - 1) - LETTER_SPACING) + 'em">' + segment + "</tspan>";
          }
        } else {
          arr_1 += '<tspan x="' + x2 + '" dy="1em">' + segment + "</tspan>";
        }
      });
      el.innerHTML = arr_1;
    } else {
      el.innerHTML = text2;
    }
  };
  return Text2;
}(ShapeBase$1);
var Text$1 = Text;
var regexLG = /^l\s*\(\s*([\d.]+)\s*\)\s*(.*)/i;
var regexRG = /^r\s*\(\s*([\d.]+)\s*,\s*([\d.]+)\s*,\s*([\d.]+)\s*\)\s*(.*)/i;
var regexColorStop = /[\d.]+:(#[^\s]+|[^)]+\))/gi;
function addStop(steps) {
  var arr = steps.match(regexColorStop);
  if (!arr) {
    return "";
  }
  var stops = "";
  arr.sort(function(a2, b10) {
    a2 = a2.split(":");
    b10 = b10.split(":");
    return Number(a2[0]) - Number(b10[0]);
  });
  each$1(arr, function(item) {
    item = item.split(":");
    stops += '<stop offset="' + item[0] + '" stop-color="' + item[1] + '"></stop>';
  });
  return stops;
}
function parseLineGradient(color2, el) {
  var arr = regexLG.exec(color2);
  var angle2 = mod$1(toRadian(parseFloat(arr[1])), Math.PI * 2);
  var steps = arr[2];
  var start;
  var end;
  if (angle2 >= 0 && angle2 < 0.5 * Math.PI) {
    start = {
      x: 0,
      y: 0
    };
    end = {
      x: 1,
      y: 1
    };
  } else if (0.5 * Math.PI <= angle2 && angle2 < Math.PI) {
    start = {
      x: 1,
      y: 0
    };
    end = {
      x: 0,
      y: 1
    };
  } else if (Math.PI <= angle2 && angle2 < 1.5 * Math.PI) {
    start = {
      x: 1,
      y: 1
    };
    end = {
      x: 0,
      y: 0
    };
  } else {
    start = {
      x: 0,
      y: 1
    };
    end = {
      x: 1,
      y: 0
    };
  }
  var tanTheta = Math.tan(angle2);
  var tanTheta2 = tanTheta * tanTheta;
  var x2 = (end.x - start.x + tanTheta * (end.y - start.y)) / (tanTheta2 + 1) + start.x;
  var y2 = tanTheta * (end.x - start.x + tanTheta * (end.y - start.y)) / (tanTheta2 + 1) + start.y;
  el.setAttribute("x1", start.x);
  el.setAttribute("y1", start.y);
  el.setAttribute("x2", x2);
  el.setAttribute("y2", y2);
  el.innerHTML = addStop(steps);
}
function parseRadialGradient(color2, self2) {
  var arr = regexRG.exec(color2);
  var cx = parseFloat(arr[1]);
  var cy = parseFloat(arr[2]);
  var r2 = parseFloat(arr[3]);
  var steps = arr[4];
  self2.setAttribute("cx", cx);
  self2.setAttribute("cy", cy);
  self2.setAttribute("r", r2);
  self2.innerHTML = addStop(steps);
}
var Gradient = function() {
  function Gradient2(cfg) {
    this.cfg = {};
    var el = null;
    var id2 = uniqueId("gradient_");
    if (cfg.toLowerCase()[0] === "l") {
      el = createSVGElement("linearGradient");
      parseLineGradient(cfg, el);
    } else {
      el = createSVGElement("radialGradient");
      parseRadialGradient(cfg, el);
    }
    el.setAttribute("id", id2);
    this.el = el;
    this.id = id2;
    this.cfg = cfg;
    return this;
  }
  Gradient2.prototype.match = function(type4, attr) {
    return this.cfg === attr;
  };
  return Gradient2;
}();
var ATTR_MAP = {
  shadowColor: "color",
  shadowOpacity: "opacity",
  shadowBlur: "blur",
  shadowOffsetX: "dx",
  shadowOffsetY: "dy"
};
var SHADOW_DIMENSION = {
  x: "-40%",
  y: "-40%",
  width: "200%",
  height: "200%"
};
var Shadow = function() {
  function Shadow2(cfg) {
    this.type = "filter";
    this.cfg = {};
    this.type = "filter";
    var el = createSVGElement("filter");
    each$1(SHADOW_DIMENSION, function(v2, k2) {
      el.setAttribute(k2, v2);
    });
    this.el = el;
    this.id = uniqueId("filter_");
    this.el.id = this.id;
    this.cfg = cfg;
    this._parseShadow(cfg, el);
    return this;
  }
  Shadow2.prototype.match = function(type4, cfg) {
    if (this.type !== type4) {
      return false;
    }
    var flag = true;
    var config = this.cfg;
    each$1(Object.keys(config), function(attr) {
      if (config[attr] !== cfg[attr]) {
        flag = false;
        return false;
      }
    });
    return flag;
  };
  Shadow2.prototype.update = function(name, value2) {
    var config = this.cfg;
    config[ATTR_MAP[name]] = value2;
    this._parseShadow(config, this.el);
    return this;
  };
  Shadow2.prototype._parseShadow = function(config, el) {
    var child = '<feDropShadow\n      dx="' + (config.dx || 0) + '"\n      dy="' + (config.dy || 0) + '"\n      stdDeviation="' + (config.blur ? config.blur / 10 : 0) + '"\n      flood-color="' + (config.color ? config.color : "#000") + '"\n      flood-opacity="' + (config.opacity ? config.opacity : 1) + '"\n      />';
    el.innerHTML = child;
  };
  return Shadow2;
}();
var Arrow = function() {
  function Arrow2(attrs, type4) {
    this.cfg = {};
    var el = createSVGElement("marker");
    var id2 = uniqueId("marker_");
    el.setAttribute("id", id2);
    var shape = createSVGElement("path");
    shape.setAttribute("stroke", attrs.stroke || "none");
    shape.setAttribute("fill", attrs.fill || "none");
    el.appendChild(shape);
    el.setAttribute("overflow", "visible");
    el.setAttribute("orient", "auto-start-reverse");
    this.el = el;
    this.child = shape;
    this.id = id2;
    var cfg = attrs[type4 === "marker-start" ? "startArrow" : "endArrow"];
    this.stroke = attrs.stroke || "#000";
    if (cfg === true) {
      this._setDefaultPath(type4, shape);
    } else {
      this.cfg = cfg;
      this._setMarker(attrs.lineWidth, shape);
    }
    return this;
  }
  Arrow2.prototype.match = function() {
    return false;
  };
  Arrow2.prototype._setDefaultPath = function(type4, el) {
    var parent = this.el;
    el.setAttribute("d", "M0,0 L" + 10 * Math.cos(Math.PI / 6) + ",5 L0,10");
    parent.setAttribute("refX", "" + 10 * Math.cos(Math.PI / 6));
    parent.setAttribute("refY", "" + 5);
  };
  Arrow2.prototype._setMarker = function(r2, el) {
    var parent = this.el;
    var path2 = this.cfg.path;
    var d2 = this.cfg.d;
    if (isArray$1(path2)) {
      path2 = path2.map(function(segment) {
        return segment.join(" ");
      }).join("");
    }
    el.setAttribute("d", path2);
    parent.appendChild(el);
    if (d2) {
      parent.setAttribute("refX", "" + d2 / r2);
    }
  };
  Arrow2.prototype.update = function(fill) {
    var child = this.child;
    if (child.attr) {
      child.attr("fill", fill);
    } else {
      child.setAttribute("fill", fill);
    }
  };
  return Arrow2;
}();
var Clip = function() {
  function Clip2(cfg) {
    this.type = "clip";
    this.cfg = {};
    var el = createSVGElement("clipPath");
    this.el = el;
    this.id = uniqueId("clip_");
    el.id = this.id;
    var shapeEl = cfg.cfg.el;
    el.appendChild(shapeEl);
    this.cfg = cfg;
    return this;
  }
  Clip2.prototype.match = function() {
    return false;
  };
  Clip2.prototype.remove = function() {
    var el = this.el;
    el.parentNode.removeChild(el);
  };
  return Clip2;
}();
var regexPR = /^p\s*\(\s*([axyn])\s*\)\s*(.*)/i;
var Pattern = function() {
  function Pattern2(cfg) {
    this.cfg = {};
    var el = createSVGElement("pattern");
    el.setAttribute("patternUnits", "userSpaceOnUse");
    var child = createSVGElement("image");
    el.appendChild(child);
    var id2 = uniqueId("pattern_");
    el.id = id2;
    this.el = el;
    this.id = id2;
    this.cfg = cfg;
    var arr = regexPR.exec(cfg);
    var source = arr[2];
    child.setAttribute("href", source);
    var img = new Image();
    if (!source.match(/^data:/i)) {
      img.crossOrigin = "Anonymous";
    }
    img.src = source;
    function onload() {
      el.setAttribute("width", "" + img.width);
      el.setAttribute("height", "" + img.height);
    }
    if (img.complete) {
      onload();
    } else {
      img.onload = onload;
      img.src = img.src;
    }
    return this;
  }
  Pattern2.prototype.match = function(type4, attr) {
    return this.cfg === attr;
  };
  return Pattern2;
}();
var Defs = function() {
  function Defs2(canvas) {
    var el = createSVGElement("defs");
    var id2 = uniqueId("defs_");
    el.id = id2;
    canvas.appendChild(el);
    this.children = [];
    this.defaultArrow = {};
    this.el = el;
    this.canvas = canvas;
  }
  Defs2.prototype.find = function(type4, attr) {
    var children = this.children;
    var result = null;
    for (var i2 = 0; i2 < children.length; i2++) {
      if (children[i2].match(type4, attr)) {
        result = children[i2].id;
        break;
      }
    }
    return result;
  };
  Defs2.prototype.findById = function(id2) {
    var children = this.children;
    var flag = null;
    for (var i2 = 0; i2 < children.length; i2++) {
      if (children[i2].id === id2) {
        flag = children[i2];
        break;
      }
    }
    return flag;
  };
  Defs2.prototype.add = function(item) {
    this.children.push(item);
    item.canvas = this.canvas;
    item.parent = this;
  };
  Defs2.prototype.getDefaultArrow = function(attrs, name) {
    var stroke = attrs.stroke || attrs.strokeStyle;
    if (this.defaultArrow[stroke]) {
      return this.defaultArrow[stroke].id;
    }
    var arrow = new Arrow(attrs, name);
    this.defaultArrow[stroke] = arrow;
    this.el.appendChild(arrow.el);
    this.add(arrow);
    return arrow.id;
  };
  Defs2.prototype.addGradient = function(cfg) {
    var gradient2 = new Gradient(cfg);
    this.el.appendChild(gradient2.el);
    this.add(gradient2);
    return gradient2.id;
  };
  Defs2.prototype.addArrow = function(attrs, name) {
    var arrow = new Arrow(attrs, name);
    this.el.appendChild(arrow.el);
    this.add(arrow);
    return arrow.id;
  };
  Defs2.prototype.addShadow = function(cfg) {
    var shadow = new Shadow(cfg);
    this.el.appendChild(shadow.el);
    this.add(shadow);
    return shadow.id;
  };
  Defs2.prototype.addPattern = function(cfg) {
    var pattern4 = new Pattern(cfg);
    this.el.appendChild(pattern4.el);
    this.add(pattern4);
    return pattern4.id;
  };
  Defs2.prototype.addClip = function(cfg) {
    var clip = new Clip(cfg);
    this.el.appendChild(clip.el);
    this.add(clip);
    return clip.id;
  };
  return Defs2;
}();
var Canvas = function(_super) {
  __extends$3(Canvas2, _super);
  function Canvas2(cfg) {
    return _super.call(this, __assign$4(__assign$4({}, cfg), {
      autoDraw: true,
      renderer: "svg"
    })) || this;
  }
  Canvas2.prototype.getShapeBase = function() {
    return Shape;
  };
  Canvas2.prototype.getGroupBase = function() {
    return Group;
  };
  Canvas2.prototype.getShape = function(x2, y2, ev) {
    var target = ev.target || ev.srcElement;
    if (!SHAPE_TO_TAGS[target.tagName]) {
      var parent_1 = target.parentNode;
      while (parent_1 && !SHAPE_TO_TAGS[parent_1.tagName]) {
        parent_1 = parent_1.parentNode;
      }
      target = parent_1;
    }
    return this.find(function(child) {
      return child.get("el") === target;
    });
  };
  Canvas2.prototype.createDom = function() {
    var element = createSVGElement("svg");
    var context2 = new Defs(element);
    element.setAttribute("width", "" + this.get("width"));
    element.setAttribute("height", "" + this.get("height"));
    this.set("context", context2);
    return element;
  };
  Canvas2.prototype.onCanvasChange = function(changeType) {
    var context2 = this.get("context");
    var el = this.get("el");
    if (changeType === "sort") {
      var children_1 = this.get("children");
      if (children_1 && children_1.length) {
        sortDom(this, function(a2, b10) {
          return children_1.indexOf(a2) - children_1.indexOf(b10) ? 1 : 0;
        });
      }
    } else if (changeType === "clear") {
      if (el) {
        el.innerHTML = "";
        var defsEl = context2.el;
        defsEl.innerHTML = "";
        el.appendChild(defsEl);
      }
    } else if (changeType === "matrix") {
      setTransform(this);
    } else if (changeType === "clip") {
      setClip(this, context2);
    } else if (changeType === "changeSize") {
      el.setAttribute("width", "" + this.get("width"));
      el.setAttribute("height", "" + this.get("height"));
    }
  };
  Canvas2.prototype.draw = function() {
    var context2 = this.get("context");
    var children = this.getChildren();
    setClip(this, context2);
    if (children.length) {
      drawChildren(context2, children);
    }
  };
  return Canvas2;
}(Canvas$2);
var version$1 = "0.5.6";
var SVGEngine = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Shape,
  version: version$1,
  Canvas,
  Group,
  Event: GraphEvent,
  Base,
  AbstractCanvas: Canvas$2,
  AbstractGroup,
  AbstractShape,
  getBBoxMethod: getMethod,
  registerBBox: register,
  getTextHeight,
  assembleFont,
  isAllowCapture,
  multiplyVec2: multiplyVec2$1,
  invert,
  getOffScreenContext,
  registerEasing,
  PathUtil: PathUtil$1
}, Symbol.toStringTag, { value: "Module" }));
var Path = function(_super) {
  __extends$3(Path2, _super);
  function Path2(cfg) {
    var _this = _super.call(this, cfg) || this;
    _this.type = "path";
    _this.shapeType = "line";
    var _a2 = cfg.connectNulls, connectNulls = _a2 === void 0 ? false : _a2, _b = cfg.showSinglePoint, showSinglePoint = _b === void 0 ? true : _b;
    _this.connectNulls = connectNulls;
    _this.showSinglePoint = showSinglePoint;
    return _this;
  }
  Path2.prototype.updateElements = function(mappingDataArray, isUpdate) {
    var e_1, _a2, e_2, _b, e_3, _c;
    if (isUpdate === void 0) {
      isUpdate = false;
    }
    var keyData = /* @__PURE__ */ new Map();
    var keyIndex = /* @__PURE__ */ new Map();
    var keys2 = [];
    var index2 = 0;
    for (var i2 = 0; i2 < mappingDataArray.length; i2++) {
      var mappingData = mappingDataArray[i2];
      var key2 = this.getElementId(mappingData);
      keys2.push(key2);
      keyData.set(key2, mappingData);
      keyIndex.set(key2, index2);
      index2++;
    }
    this.elements = new Array(index2);
    var _d = diff(this.lastElementsMap, keys2), added = _d.added, updated = _d.updated, removed = _d.removed;
    try {
      for (var added_1 = __values(added), added_1_1 = added_1.next(); !added_1_1.done; added_1_1 = added_1.next()) {
        var key2 = added_1_1.value;
        var mappingData = keyData.get(key2);
        var shapeFactory = this.getShapeFactory();
        var shapeCfg = this.getShapeInfo(mappingData);
        var i2 = keyIndex.get(key2);
        var element = new Element$1({
          shapeFactory,
          container: this.container,
          offscreenGroup: this.getOffscreenGroup(),
          elementIndex: i2
        });
        element.geometry = this;
        element.animate = this.animateOption;
        element.draw(shapeCfg, isUpdate);
        this.elementsMap[key2] = element;
        this.elements[i2] = element;
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (added_1_1 && !added_1_1.done && (_a2 = added_1.return))
          _a2.call(added_1);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
    try {
      for (var updated_1 = __values(updated), updated_1_1 = updated_1.next(); !updated_1_1.done; updated_1_1 = updated_1.next()) {
        var key2 = updated_1_1.value;
        var mappingData = keyData.get(key2);
        var element = this.lastElementsMap[key2];
        var i2 = keyIndex.get(key2);
        var shapeCfg = this.getShapeInfo(mappingData);
        var preShapeCfg = element.getModel();
        if (this.isCoordinateChanged || isModelChange(preShapeCfg, shapeCfg)) {
          element.animate = this.animateOption;
          element.update(shapeCfg);
        }
        this.elementsMap[key2] = element;
        this.elements[i2] = element;
      }
    } catch (e_2_1) {
      e_2 = { error: e_2_1 };
    } finally {
      try {
        if (updated_1_1 && !updated_1_1.done && (_b = updated_1.return))
          _b.call(updated_1);
      } finally {
        if (e_2)
          throw e_2.error;
      }
    }
    try {
      for (var removed_1 = __values(removed), removed_1_1 = removed_1.next(); !removed_1_1.done; removed_1_1 = removed_1.next()) {
        var key2 = removed_1_1.value;
        var element = this.lastElementsMap[key2];
        element.animate = this.animateOption;
        element.destroy();
      }
    } catch (e_3_1) {
      e_3 = { error: e_3_1 };
    } finally {
      try {
        if (removed_1_1 && !removed_1_1.done && (_c = removed_1.return))
          _c.call(removed_1);
      } finally {
        if (e_3)
          throw e_3.error;
      }
    }
  };
  Path2.prototype.getPointsAndData = function(mappingData) {
    var points2 = [];
    var data2 = [];
    for (var i2 = 0, len = mappingData.length; i2 < len; i2++) {
      var obj = mappingData[i2];
      points2.push({
        x: obj.x,
        y: obj.y
      });
      data2.push(obj[FIELD_ORIGIN]);
    }
    return {
      points: points2,
      data: data2
    };
  };
  Path2.prototype.getShapeInfo = function(mappingData) {
    var shapeCfg = this.getDrawCfg(mappingData[0]);
    var _a2 = this.getPointsAndData(mappingData), points2 = _a2.points, data2 = _a2.data;
    shapeCfg.mappingData = mappingData;
    shapeCfg.data = data2;
    shapeCfg.isStack = !!this.getAdjust("stack");
    shapeCfg.points = points2;
    shapeCfg.connectNulls = this.connectNulls;
    shapeCfg.showSinglePoint = this.showSinglePoint;
    return shapeCfg;
  };
  return Path2;
}(Geometry);
function getPath$2(points2, isInCircle, smooth, registeredShape, constraint) {
  var path2 = [];
  if (points2.length) {
    var topLinePoints_1 = [];
    var bottomLinePoints_1 = [];
    for (var i2 = 0, len = points2.length; i2 < len; i2++) {
      var point2 = points2[i2];
      topLinePoints_1.push(point2[1]);
      bottomLinePoints_1.push(point2[0]);
    }
    bottomLinePoints_1 = bottomLinePoints_1.reverse();
    each$1([topLinePoints_1, bottomLinePoints_1], function(pointsData, index2) {
      var subPath = [];
      var parsedPoints = registeredShape.parsePoints(pointsData);
      var p1 = parsedPoints[0];
      if (topLinePoints_1.length === 1 && bottomLinePoints_1.length === 1) {
        subPath = index2 === 0 ? [
          ["M", p1.x - 0.5, p1.y],
          ["L", p1.x + 0.5, p1.y]
        ] : [
          ["L", p1.x + 0.5, p1.y],
          ["L", p1.x - 0.5, p1.y]
        ];
      } else {
        if (isInCircle) {
          parsedPoints.push({ x: p1.x, y: p1.y });
        }
        if (smooth) {
          subPath = getSplinePath$1(parsedPoints, false, constraint);
        } else {
          subPath = getLinePath(parsedPoints, false);
        }
        if (index2 > 0) {
          subPath[0][0] = "L";
        }
      }
      path2 = path2.concat(subPath);
    });
    path2.push(["Z"]);
  }
  return path2;
}
function getShapeAttrs(cfg, isStroke, smooth, registeredShape, constraint) {
  var attrs = getStyle(cfg, isStroke, !isStroke, "lineWidth");
  var connectNulls = cfg.connectNulls, isInCircle = cfg.isInCircle, points2 = cfg.points, showSinglePoint = cfg.showSinglePoint;
  var pathPoints = getPathPoints(points2, connectNulls, showSinglePoint);
  var path2 = [];
  for (var i2 = 0, len = pathPoints.length; i2 < len; i2++) {
    var eachPoints = pathPoints[i2];
    path2 = path2.concat(getPath$2(eachPoints, isInCircle, smooth, registeredShape, constraint));
  }
  attrs.path = path2;
  return attrs;
}
function getConstraint(coordinate2) {
  var start = coordinate2.start, end = coordinate2.end;
  return [
    [start.x, end.y],
    [end.x, start.y]
  ];
}
registerShapeFactory("area", {
  defaultShapeType: "area",
  getDefaultPoints: function(pointInfo) {
    var x2 = pointInfo.x, y0 = pointInfo.y0;
    var y2 = isArray$1(pointInfo.y) ? pointInfo.y : [y0, pointInfo.y];
    return y2.map(function(yItem) {
      return {
        x: x2,
        y: yItem
      };
    });
  }
});
registerShape("area", "area", {
  draw: function(cfg, container) {
    var attrs = getShapeAttrs(cfg, false, false, this);
    var shape = container.addShape({
      type: "path",
      attrs,
      name: "area"
    });
    return shape;
  },
  getMarker: function(markerCfg) {
    var color2 = markerCfg.color;
    return {
      symbol: function(x2, y2, r2) {
        if (r2 === void 0) {
          r2 = 5.5;
        }
        return [["M", x2 - r2, y2 - 4], ["L", x2 + r2, y2 - 4], ["L", x2 + r2, y2 + 4], ["L", x2 - r2, y2 + 4], ["Z"]];
      },
      style: {
        r: 5,
        fill: color2,
        fillOpacity: 1
      }
    };
  }
});
var Area$1 = function(_super) {
  __extends$3(Area2, _super);
  function Area2(cfg) {
    var _this = _super.call(this, cfg) || this;
    _this.type = "area";
    _this.shapeType = "area";
    _this.generatePoints = true;
    _this.startOnZero = true;
    var _a2 = cfg.startOnZero, startOnZero = _a2 === void 0 ? true : _a2, _b = cfg.sortable, sortable = _b === void 0 ? false : _b, _c = cfg.showSinglePoint, showSinglePoint = _c === void 0 ? false : _c;
    _this.startOnZero = startOnZero;
    _this.sortable = sortable;
    _this.showSinglePoint = showSinglePoint;
    return _this;
  }
  Area2.prototype.getPointsAndData = function(mappingData) {
    var points2 = [];
    var data2 = [];
    for (var i2 = 0, len = mappingData.length; i2 < len; i2++) {
      var obj = mappingData[i2];
      points2.push(obj.points);
      data2.push(obj[FIELD_ORIGIN]);
    }
    return {
      points: points2,
      data: data2
    };
  };
  Area2.prototype.getYMinValue = function() {
    if (this.startOnZero) {
      return _super.prototype.getYMinValue.call(this);
    }
    var yScale = this.getYScale();
    return yScale.min;
  };
  return Area2;
}(Path);
registerShapeFactory("edge", {
  defaultShapeType: "line",
  getDefaultPoints: function(pointInfo) {
    return splitPoints(pointInfo);
  }
});
registerShape("edge", "line", {
  draw: function(cfg, container) {
    var style2 = getStyle(cfg, true, false, "lineWidth");
    var path2 = getLinePath(this.parsePoints(cfg.points), this.coordinate.isPolar);
    return container.addShape("path", {
      attrs: __assign$4(__assign$4({}, style2), { path: path2 })
    });
  },
  getMarker: function(markerCfg) {
    return {
      symbol: "circle",
      style: {
        r: 4.5,
        fill: markerCfg.color
      }
    };
  }
});
var Edge = function(_super) {
  __extends$3(Edge2, _super);
  function Edge2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "edge";
    _this.shapeType = "edge";
    _this.generatePoints = true;
    return _this;
  }
  return Edge2;
}(Geometry);
var Heatmap = function(_super) {
  __extends$3(Heatmap2, _super);
  function Heatmap2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "heatmap";
    _this.paletteCache = {};
    return _this;
  }
  Heatmap2.prototype.updateElements = function(mappingDataArray, isUpdate) {
    for (var i2 = 0; i2 < mappingDataArray.length; i2++) {
      var mappingData = mappingDataArray[i2];
      var range3 = this.prepareRange(mappingData);
      var radius = this.prepareSize();
      var blur_1 = get(this.styleOption, ["cfg", "shadowBlur"]);
      if (!isNumber$1(blur_1)) {
        blur_1 = radius / 2;
      }
      this.prepareGreyScaleBlurredCircle(radius, blur_1);
      this.drawWithRange(mappingData, range3, radius, blur_1);
    }
  };
  Heatmap2.prototype.color = function(field2, cfg) {
    this.createAttrOption("color", field2, typeof cfg !== "function" ? cfg : "");
    return this;
  };
  Heatmap2.prototype.clear = function() {
    _super.prototype.clear.call(this);
    this.clearShadowCanvasCtx();
    this.paletteCache = {};
  };
  Heatmap2.prototype.prepareRange = function(data2) {
    var colorAttr = this.getAttribute("color");
    var colorField = colorAttr.getFields()[0];
    var min2 = Infinity;
    var max2 = -Infinity;
    data2.forEach(function(row) {
      var value2 = row[FIELD_ORIGIN][colorField];
      if (value2 > max2) {
        max2 = value2;
      }
      if (value2 < min2) {
        min2 = value2;
      }
    });
    if (min2 === max2) {
      min2 = max2 - 1;
    }
    return [min2, max2];
  };
  Heatmap2.prototype.prepareSize = function() {
    var radius = this.getDefaultValue("size");
    if (!isNumber$1(radius)) {
      radius = this.getDefaultSize();
    }
    return radius;
  };
  Heatmap2.prototype.prepareGreyScaleBlurredCircle = function(radius, blur) {
    var grayScaleBlurredCanvas = this.getGrayScaleBlurredCanvas();
    var r2 = radius + blur;
    var ctx2 = grayScaleBlurredCanvas.getContext("2d");
    grayScaleBlurredCanvas.width = grayScaleBlurredCanvas.height = r2 * 2;
    ctx2.clearRect(0, 0, grayScaleBlurredCanvas.width, grayScaleBlurredCanvas.height);
    ctx2.shadowOffsetX = ctx2.shadowOffsetY = r2 * 2;
    ctx2.shadowBlur = blur;
    ctx2.shadowColor = "black";
    ctx2.beginPath();
    ctx2.arc(-r2, -r2, radius, 0, Math.PI * 2, true);
    ctx2.closePath();
    ctx2.fill();
  };
  Heatmap2.prototype.drawWithRange = function(data2, range3, radius, blur) {
    var e_1, _a2;
    var _b = this.coordinate, start = _b.start, end = _b.end;
    var width = this.coordinate.getWidth();
    var height = this.coordinate.getHeight();
    var colorAttr = this.getAttribute("color");
    var valueField = colorAttr.getFields()[0];
    this.clearShadowCanvasCtx();
    var ctx2 = this.getShadowCanvasCtx();
    if (range3) {
      data2 = data2.filter(function(row) {
        return row[FIELD_ORIGIN][valueField] <= range3[1] && row[FIELD_ORIGIN][valueField] >= range3[0];
      });
    }
    var scale2 = this.scales[valueField];
    try {
      for (var data_1 = __values(data2), data_1_1 = data_1.next(); !data_1_1.done; data_1_1 = data_1.next()) {
        var obj = data_1_1.value;
        var _c = this.getDrawCfg(obj), x2 = _c.x, y2 = _c.y;
        var alpha = scale2.scale(obj[FIELD_ORIGIN][valueField]);
        this.drawGrayScaleBlurredCircle(x2 - start.x, y2 - end.y, radius + blur, alpha, ctx2);
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (data_1_1 && !data_1_1.done && (_a2 = data_1.return))
          _a2.call(data_1);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
    var colored = ctx2.getImageData(0, 0, width, height);
    this.clearShadowCanvasCtx();
    this.colorize(colored);
    ctx2.putImageData(colored, 0, 0);
    var imageShape = this.getImageShape();
    imageShape.attr("x", start.x);
    imageShape.attr("y", end.y);
    imageShape.attr("width", width);
    imageShape.attr("height", height);
    imageShape.attr("img", ctx2.canvas);
    imageShape.set("origin", this.getShapeInfo(data2));
  };
  Heatmap2.prototype.getDefaultSize = function() {
    var position = this.getAttribute("position");
    var coordinate2 = this.coordinate;
    return Math.min(coordinate2.getWidth() / (position.scales[0].ticks.length * 4), coordinate2.getHeight() / (position.scales[1].ticks.length * 4));
  };
  Heatmap2.prototype.clearShadowCanvasCtx = function() {
    var ctx2 = this.getShadowCanvasCtx();
    ctx2.clearRect(0, 0, ctx2.canvas.width, ctx2.canvas.height);
  };
  Heatmap2.prototype.getShadowCanvasCtx = function() {
    var canvas = this.shadowCanvas;
    if (!canvas) {
      canvas = document.createElement("canvas");
      this.shadowCanvas = canvas;
    }
    canvas.width = this.coordinate.getWidth();
    canvas.height = this.coordinate.getHeight();
    return canvas.getContext("2d");
  };
  Heatmap2.prototype.getGrayScaleBlurredCanvas = function() {
    if (!this.grayScaleBlurredCanvas) {
      this.grayScaleBlurredCanvas = document.createElement("canvas");
    }
    return this.grayScaleBlurredCanvas;
  };
  Heatmap2.prototype.drawGrayScaleBlurredCircle = function(x2, y2, r2, alpha, ctx2) {
    var grayScaleBlurredCanvas = this.getGrayScaleBlurredCanvas();
    ctx2.globalAlpha = alpha;
    ctx2.drawImage(grayScaleBlurredCanvas, x2 - r2, y2 - r2);
  };
  Heatmap2.prototype.colorize = function(img) {
    var colorAttr = this.getAttribute("color");
    var pixels = img.data;
    var paletteCache = this.paletteCache;
    for (var i2 = 3; i2 < pixels.length; i2 += 4) {
      var alpha = pixels[i2];
      if (isNumber$1(alpha)) {
        var palette = paletteCache[alpha] ? paletteCache[alpha] : colorUtil.rgb2arr(colorAttr.gradient(alpha / 256));
        pixels[i2 - 3] = palette[0];
        pixels[i2 - 2] = palette[1];
        pixels[i2 - 1] = palette[2];
        pixels[i2] = alpha;
      }
    }
  };
  Heatmap2.prototype.getImageShape = function() {
    var imageShape = this.imageShape;
    if (imageShape) {
      return imageShape;
    }
    var container = this.container;
    imageShape = container.addShape({
      type: "image",
      attrs: {}
    });
    this.imageShape = imageShape;
    return imageShape;
  };
  Heatmap2.prototype.getShapeInfo = function(mappingData) {
    var shapeCfg = this.getDrawCfg(mappingData[0]);
    var data2 = mappingData.map(function(obj) {
      return obj[FIELD_ORIGIN];
    });
    return __assign$4(__assign$4({}, shapeCfg), { mappingData, data: data2 });
  };
  return Heatmap2;
}(Geometry);
function getRectPoints$1(pointInfo) {
  var _a2, _b;
  var x2 = pointInfo.x, y2 = pointInfo.y, y0 = pointInfo.y0, size2 = pointInfo.size;
  var yMin;
  var yMax;
  if (isArray$1(y2)) {
    _a2 = __read(y2, 2), yMin = _a2[0], yMax = _a2[1];
  } else {
    yMin = y0;
    yMax = y2;
  }
  var xMin;
  var xMax;
  if (isArray$1(x2)) {
    _b = __read(x2, 2), xMin = _b[0], xMax = _b[1];
  } else {
    xMin = x2 - size2 / 2;
    xMax = x2 + size2 / 2;
  }
  var points2 = [
    { x: xMin, y: yMin },
    { x: xMin, y: yMax }
  ];
  points2.push({ x: xMax, y: yMax }, { x: xMax, y: yMin });
  return points2;
}
function getRectPath$1(points2, isClosed) {
  if (isClosed === void 0) {
    isClosed = true;
  }
  var path2 = [];
  var firstPoint = points2[0];
  path2.push(["M", firstPoint.x, firstPoint.y]);
  for (var i2 = 1, len = points2.length; i2 < len; i2++) {
    path2.push(["L", points2[i2].x, points2[i2].y]);
  }
  if (isClosed) {
    path2.push(["L", firstPoint.x, firstPoint.y]);
    path2.push(["z"]);
  }
  return path2;
}
function parseRadius(radius, minLength) {
  var r1 = 0;
  var r2 = 0;
  var r3 = 0;
  var r4 = 0;
  if (isArray$1(radius)) {
    if (radius.length === 1) {
      r1 = r2 = r3 = r4 = radius[0];
    } else if (radius.length === 2) {
      r1 = r3 = radius[0];
      r2 = r4 = radius[1];
    } else if (radius.length === 3) {
      r1 = radius[0];
      r2 = r4 = radius[1];
      r3 = radius[2];
    } else {
      r1 = radius[0];
      r2 = radius[1];
      r3 = radius[2];
      r4 = radius[3];
    }
  } else {
    r1 = r2 = r3 = r4 = radius;
  }
  if (r1 + r2 > minLength) {
    r1 = r1 ? minLength / (1 + r2 / r1) : 0;
    r2 = minLength - r1;
  }
  if (r3 + r4 > minLength) {
    r3 = r3 ? minLength / (1 + r4 / r3) : 0;
    r4 = minLength - r3;
  }
  return [r1 || 0, r2 || 0, r3 || 0, r4 || 0];
}
function getBackgroundRectPath(cfg, points2, coordinate2) {
  var path2 = [];
  if (coordinate2.isRect) {
    var p0 = coordinate2.isTransposed ? { x: coordinate2.start.x, y: points2[0].y } : { x: points2[0].x, y: coordinate2.start.y };
    var p1 = coordinate2.isTransposed ? { x: coordinate2.end.x, y: points2[2].y } : { x: points2[3].x, y: coordinate2.end.y };
    var radius = get(cfg, ["background", "style", "radius"]);
    if (radius) {
      var width = coordinate2.isTransposed ? Math.abs(points2[0].y - points2[2].y) : points2[2].x - points2[1].x;
      var height = coordinate2.isTransposed ? coordinate2.getWidth() : coordinate2.getHeight();
      var _a2 = __read(parseRadius(radius, Math.min(width, height)), 4), r1 = _a2[0], r2 = _a2[1], r3 = _a2[2], r4 = _a2[3];
      var isReflectYTransposed_1 = coordinate2.isTransposed && coordinate2.isReflect("y");
      var bump = isReflectYTransposed_1 ? 0 : 1;
      var opposite = function(r5) {
        return isReflectYTransposed_1 ? -r5 : r5;
      };
      path2.push(["M", p0.x, p1.y + opposite(r1)]);
      r1 !== 0 && path2.push(["A", r1, r1, 0, 0, bump, p0.x + r1, p1.y]);
      path2.push(["L", p1.x - r2, p1.y]);
      r2 !== 0 && path2.push(["A", r2, r2, 0, 0, bump, p1.x, p1.y + opposite(r2)]);
      path2.push(["L", p1.x, p0.y - opposite(r3)]);
      r3 !== 0 && path2.push(["A", r3, r3, 0, 0, bump, p1.x - r3, p0.y]);
      path2.push(["L", p0.x + r4, p0.y]);
      r4 !== 0 && path2.push(["A", r4, r4, 0, 0, bump, p0.x, p0.y - opposite(r4)]);
    } else {
      path2.push(["M", p0.x, p0.y]);
      path2.push(["L", p1.x, p0.y]);
      path2.push(["L", p1.x, p1.y]);
      path2.push(["L", p0.x, p1.y]);
      path2.push(["L", p0.x, p0.y]);
    }
    path2.push(["z"]);
  }
  if (coordinate2.isPolar) {
    var center2 = coordinate2.getCenter();
    var _b = getAngle$1(cfg, coordinate2), startAngle = _b.startAngle, endAngle = _b.endAngle;
    if (coordinate2.type !== "theta" && !coordinate2.isTransposed) {
      path2 = getSectorPath(center2.x, center2.y, coordinate2.getRadius(), startAngle, endAngle);
    } else {
      var pow = function(v2) {
        return Math.pow(v2, 2);
      };
      var r1 = Math.sqrt(pow(center2.x - points2[0].x) + pow(center2.y - points2[0].y));
      var r2 = Math.sqrt(pow(center2.x - points2[2].x) + pow(center2.y - points2[2].y));
      path2 = getSectorPath(center2.x, center2.y, r1, coordinate2.startAngle, coordinate2.endAngle, r2);
    }
  }
  return path2;
}
function getIntervalRectPath(points2, lineCap, coor) {
  var width = coor.getWidth();
  var height = coor.getHeight();
  var isRect = coor.type === "rect";
  var path2 = [];
  var r2 = (points2[2].x - points2[1].x) / 2;
  var ry = coor.isTransposed ? r2 * height / width : r2 * width / height;
  if (lineCap === "round") {
    if (isRect) {
      path2.push(["M", points2[0].x, points2[0].y + ry]);
      path2.push(["L", points2[1].x, points2[1].y - ry]);
      path2.push(["A", r2, r2, 0, 0, 1, points2[2].x, points2[2].y - ry]);
      path2.push(["L", points2[3].x, points2[3].y + ry]);
      path2.push(["A", r2, r2, 0, 0, 1, points2[0].x, points2[0].y + ry]);
    } else {
      path2.push(["M", points2[0].x, points2[0].y]);
      path2.push(["L", points2[1].x, points2[1].y]);
      path2.push(["A", r2, r2, 0, 0, 1, points2[2].x, points2[2].y]);
      path2.push(["L", points2[3].x, points2[3].y]);
      path2.push(["A", r2, r2, 0, 0, 1, points2[0].x, points2[0].y]);
    }
    path2.push(["z"]);
  } else {
    path2 = getRectPath$1(points2);
  }
  return path2;
}
function getFunnelPath(points2, nextPoints, isPyramid) {
  var path2 = [];
  if (!isNil(nextPoints)) {
    path2.push(["M", points2[0].x, points2[0].y], ["L", points2[1].x, points2[1].y], ["L", nextPoints[1].x, nextPoints[1].y], ["L", nextPoints[0].x, nextPoints[0].y], ["Z"]);
  } else if (isPyramid) {
    path2.push(["M", points2[0].x, points2[0].y], ["L", points2[1].x, points2[1].y], ["L", (points2[2].x + points2[3].x) / 2, (points2[2].y + points2[3].y) / 2], ["Z"]);
  } else {
    path2.push(["M", points2[0].x, points2[0].y], ["L", points2[1].x, points2[1].y], ["L", points2[2].x, points2[2].y], ["L", points2[3].x, points2[3].y], ["Z"]);
  }
  return path2;
}
function swap$1(p0, p1) {
  return [p1, p0];
}
function getRectWithCornerRadius(points2, coordinate2, radius) {
  var _a2, _b, _c, _d, _e, _f, _g;
  var _h = __read(__spreadArray$1([], __read(points2), false), 4), p0 = _h[0], p1 = _h[1], p2 = _h[2], p3 = _h[3];
  var _j = __read(typeof radius === "number" ? Array(4).fill(radius) : radius, 4), r1 = _j[0], r2 = _j[1], r3 = _j[2], r4 = _j[3];
  if (coordinate2.isTransposed) {
    _a2 = __read(swap$1(p1, p3), 2), p1 = _a2[0], p3 = _a2[1];
  }
  if (coordinate2.isReflect("y")) {
    _b = __read(swap$1(p0, p1), 2), p0 = _b[0], p1 = _b[1];
    _c = __read(swap$1(p2, p3), 2), p2 = _c[0], p3 = _c[1];
  }
  if (coordinate2.isReflect("x")) {
    _d = __read(swap$1(p0, p3), 2), p0 = _d[0], p3 = _d[1];
    _e = __read(swap$1(p1, p2), 2), p1 = _e[0], p2 = _e[1];
  }
  var path2 = [];
  var abs = function(v2) {
    return Math.abs(v2);
  };
  _f = __read(parseRadius([r1, r2, r3, r4], Math.min(abs(p3.x - p0.x), abs(p1.y - p0.y))).map(function(d2) {
    return abs(d2);
  }), 4), r1 = _f[0], r2 = _f[1], r3 = _f[2], r4 = _f[3];
  if (coordinate2.isTransposed) {
    _g = __read([r4, r1, r2, r3], 4), r1 = _g[0], r2 = _g[1], r3 = _g[2], r4 = _g[3];
  }
  if (p0.y < p1.y) {
    path2.push(["M", p3.x, p3.y + r3]);
    r3 !== 0 && path2.push(["A", r3, r3, 0, 0, 0, p3.x - r3, p3.y]);
    path2.push(["L", p0.x + r4, p0.y]);
    r4 !== 0 && path2.push(["A", r4, r4, 0, 0, 0, p0.x, p0.y + r4]);
    path2.push(["L", p1.x, p1.y - r1]);
    r1 !== 0 && path2.push(["A", r1, r1, 0, 0, 0, p1.x + r1, p1.y]);
    path2.push(["L", p2.x - r2, p2.y]);
    r2 !== 0 && path2.push(["A", r2, r2, 0, 0, 0, p2.x, p2.y - r2]);
    path2.push(["L", p3.x, p3.y + r3]);
    path2.push(["z"]);
  } else if (p3.x < p0.x) {
    path2.push(["M", p2.x + r2, p2.y]);
    r2 !== 0 && path2.push(["A", r2, r2, 0, 0, 0, p2.x, p2.y + r2]);
    path2.push(["L", p3.x, p3.y - r3]);
    r3 !== 0 && path2.push(["A", r3, r3, 0, 0, 0, p3.x + r3, p3.y]);
    path2.push(["L", p0.x - r4, p0.y]);
    r4 !== 0 && path2.push(["A", r4, r4, 0, 0, 0, p0.x, p0.y - r4]);
    path2.push(["L", p1.x, p1.y + r1]);
    r1 !== 0 && path2.push(["A", r1, r1, 0, 0, 0, p1.x - r1, p1.y]);
    path2.push(["L", p2.x + r2, p2.y]);
    path2.push(["z"]);
  } else {
    path2.push(["M", p1.x, p1.y + r1]);
    r1 !== 0 && path2.push(["A", r1, r1, 0, 0, 1, p1.x + r1, p1.y]);
    path2.push(["L", p2.x - r2, p2.y]);
    r2 !== 0 && path2.push(["A", r2, r2, 0, 0, 1, p2.x, p2.y + r2]);
    path2.push(["L", p3.x, p3.y - r3]);
    r3 !== 0 && path2.push(["A", r3, r3, 0, 0, 1, p3.x - r3, p3.y]);
    path2.push(["L", p0.x + r4, p0.y]);
    r4 !== 0 && path2.push(["A", r4, r4, 0, 0, 1, p0.x, p0.y - r4]);
    path2.push(["L", p1.x, p1.y + r1]);
    path2.push(["z"]);
  }
  return path2;
}
registerShapeFactory("interval", {
  defaultShapeType: "rect",
  getDefaultPoints: function(pointInfo) {
    return getRectPoints$1(pointInfo);
  }
});
registerShape("interval", "rect", {
  draw: function(cfg, container) {
    var style2 = getStyle(cfg, false, true);
    var group2 = container;
    var backgroundCfg = cfg === null || cfg === void 0 ? void 0 : cfg.background;
    if (backgroundCfg) {
      group2 = container.addGroup({
        name: "interval-group"
      });
      var backgroundStyle = getBackgroundRectStyle(cfg);
      var backgroundPath = getBackgroundRectPath(cfg, this.parsePoints(cfg.points), this.coordinate);
      group2.addShape("path", {
        attrs: __assign$4(__assign$4({}, backgroundStyle), { path: backgroundPath }),
        zIndex: -1,
        name: BACKGROUND_SHAPE
      });
    }
    var path2;
    if (style2.radius && this.coordinate.isRect) {
      path2 = getRectWithCornerRadius(this.parsePoints(cfg.points), this.coordinate, style2.radius);
    } else {
      path2 = this.parsePath(getIntervalRectPath(cfg.points, style2.lineCap, this.coordinate));
    }
    var shape = group2.addShape("path", {
      attrs: __assign$4(__assign$4({}, style2), { path: path2 }),
      name: "interval"
    });
    return backgroundCfg ? group2 : shape;
  },
  getMarker: function(markerCfg) {
    var color2 = markerCfg.color, isInPolar = markerCfg.isInPolar;
    if (isInPolar) {
      return {
        symbol: "circle",
        style: {
          r: 4.5,
          fill: color2
        }
      };
    }
    return {
      symbol: "square",
      style: {
        r: 4,
        fill: color2
      }
    };
  }
});
function findMinDistance(arr, scale2) {
  var count2 = arr.length;
  var sourceArr = arr;
  if (isString(sourceArr[0])) {
    sourceArr = arr.map(function(v2) {
      return scale2.translate(v2);
    });
  }
  var distance2 = sourceArr[1] - sourceArr[0];
  for (var i2 = 2; i2 < count2; i2++) {
    var tmp = sourceArr[i2] - sourceArr[i2 - 1];
    if (distance2 > tmp) {
      distance2 = tmp;
    }
  }
  return distance2;
}
function getDodgeCount(dataArray, dodgeBy) {
  if (dodgeBy) {
    var mergeData = flatten(dataArray);
    var values2 = valuesOfKey(mergeData, dodgeBy);
    return values2.length;
  }
  return dataArray.length;
}
function getDefaultSize(geometry2) {
  var theme2 = geometry2.theme;
  var coordinate2 = geometry2.coordinate;
  var xScale = geometry2.getXScale();
  var xValues = xScale.values;
  var dataArray = geometry2.beforeMappingData;
  var count2 = xValues.length;
  var xDimensionLength = getXDimensionLength(geometry2.coordinate);
  var intervalPadding = geometry2.intervalPadding, dodgePadding = geometry2.dodgePadding;
  var maxColumnWidth = geometry2.maxColumnWidth || theme2.maxColumnWidth;
  var minColumnWidth = geometry2.minColumnWidth || theme2.minColumnWidth;
  var columnWidthRatio = geometry2.columnWidthRatio || theme2.columnWidthRatio;
  var multiplePieWidthRatio = geometry2.multiplePieWidthRatio || theme2.multiplePieWidthRatio;
  var roseWidthRatio = geometry2.roseWidthRatio || theme2.roseWidthRatio;
  if (xScale.isLinear && xValues.length > 1) {
    xValues.sort();
    var interval2 = findMinDistance(xValues, xScale);
    count2 = (xScale.max - xScale.min) / interval2;
    if (xValues.length > count2) {
      count2 = xValues.length;
    }
  }
  var range3 = xScale.range;
  var normalizedSize = 1 / count2;
  var wr = 1;
  if (coordinate2.isPolar) {
    if (coordinate2.isTransposed && count2 > 1) {
      wr = multiplePieWidthRatio;
    } else {
      wr = roseWidthRatio;
    }
  } else {
    if (xScale.isLinear) {
      normalizedSize *= range3[1] - range3[0];
    }
    wr = columnWidthRatio;
  }
  if (!isNil(intervalPadding) && intervalPadding >= 0) {
    var normalizedIntervalPadding = intervalPadding / xDimensionLength;
    normalizedSize = (1 - (count2 - 1) * normalizedIntervalPadding) / count2;
  } else {
    normalizedSize *= wr;
  }
  if (geometry2.getAdjust("dodge")) {
    var dodgeAdjust = geometry2.getAdjust("dodge");
    var dodgeBy = dodgeAdjust.dodgeBy;
    var dodgeCount = getDodgeCount(dataArray, dodgeBy);
    if (!isNil(dodgePadding) && dodgePadding >= 0) {
      var normalizedDodgePadding = dodgePadding / xDimensionLength;
      normalizedSize = (normalizedSize - normalizedDodgePadding * (dodgeCount - 1)) / dodgeCount;
    } else if (!isNil(intervalPadding) && intervalPadding >= 0) {
      normalizedSize *= wr;
      normalizedSize = normalizedSize / dodgeCount;
    } else {
      normalizedSize = normalizedSize / dodgeCount;
    }
    normalizedSize = normalizedSize >= 0 ? normalizedSize : 0;
  }
  if (!isNil(maxColumnWidth) && maxColumnWidth >= 0) {
    var normalizedMaxColumnWidth = maxColumnWidth / xDimensionLength;
    if (normalizedSize > normalizedMaxColumnWidth) {
      normalizedSize = normalizedMaxColumnWidth;
    }
  }
  if (!isNil(minColumnWidth) && minColumnWidth >= 0) {
    var normalizedMinColumnWidth = minColumnWidth / xDimensionLength;
    if (normalizedSize < normalizedMinColumnWidth) {
      normalizedSize = normalizedMinColumnWidth;
    }
  }
  return normalizedSize;
}
var Interval = function(_super) {
  __extends$3(Interval2, _super);
  function Interval2(cfg) {
    var _this = _super.call(this, cfg) || this;
    _this.type = "interval";
    _this.shapeType = "interval";
    _this.generatePoints = true;
    var background = cfg.background;
    _this.background = background;
    return _this;
  }
  Interval2.prototype.createShapePointsCfg = function(obj) {
    var cfg = _super.prototype.createShapePointsCfg.call(this, obj);
    var size2;
    var sizeAttr = this.getAttribute("size");
    if (sizeAttr) {
      size2 = this.getAttributeValues(sizeAttr, obj)[0];
      var coordinate2 = this.coordinate;
      var coordinateWidth = getXDimensionLength(coordinate2);
      size2 = size2 / coordinateWidth;
    } else {
      if (!this.defaultSize) {
        this.defaultSize = getDefaultSize(this);
      }
      size2 = this.defaultSize;
    }
    cfg.size = size2;
    return cfg;
  };
  Interval2.prototype.adjustScale = function() {
    _super.prototype.adjustScale.call(this);
    var yScale = this.getYScale();
    if (this.coordinate.type === "theta") {
      yScale.change({
        nice: false,
        min: 0,
        max: getMaxScale(yScale)
      });
    } else {
      var scaleDefs = this.scaleDefs;
      var field2 = yScale.field, min2 = yScale.min, max2 = yScale.max, type4 = yScale.type;
      if (type4 !== "time") {
        if (min2 > 0 && !get(scaleDefs, [field2, "min"])) {
          yScale.change({
            min: 0
          });
        }
        if (max2 <= 0 && !get(scaleDefs, [field2, "max"])) {
          yScale.change({
            max: 0
          });
        }
      }
    }
  };
  Interval2.prototype.getDrawCfg = function(mappingData) {
    var shapeCfg = _super.prototype.getDrawCfg.call(this, mappingData);
    shapeCfg.background = this.background;
    return shapeCfg;
  };
  return Interval2;
}(Geometry);
var Line$2 = function(_super) {
  __extends$3(Line2, _super);
  function Line2(cfg) {
    var _this = _super.call(this, cfg) || this;
    _this.type = "line";
    var _a2 = cfg.sortable, sortable = _a2 === void 0 ? false : _a2;
    _this.sortable = sortable;
    return _this;
  }
  return Line2;
}(Path);
var SHAPES = ["circle", "square", "bowtie", "diamond", "hexagon", "triangle", "triangle-down"];
var HOLLOW_SHAPES = ["cross", "tick", "plus", "hyphen", "line"];
function drawPoints(shape, cfg, container, shapeName, isStroke) {
  var e_1, _a2;
  var style2 = getStyle(cfg, isStroke, !isStroke, "r");
  var points2 = shape.parsePoints(cfg.points);
  var pointPosition = points2[0];
  if (cfg.isStack) {
    pointPosition = points2[1];
  } else if (points2.length > 1) {
    var group2 = container.addGroup();
    try {
      for (var points_1 = __values(points2), points_1_1 = points_1.next(); !points_1_1.done; points_1_1 = points_1.next()) {
        var point2 = points_1_1.value;
        group2.addShape({
          type: "marker",
          attrs: __assign$4(__assign$4(__assign$4({}, style2), { symbol: MarkerSymbols[shapeName] || shapeName }), point2)
        });
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (points_1_1 && !points_1_1.done && (_a2 = points_1.return))
          _a2.call(points_1);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
    return group2;
  }
  return container.addShape({
    type: "marker",
    attrs: __assign$4(__assign$4(__assign$4({}, style2), { symbol: MarkerSymbols[shapeName] || shapeName }), pointPosition)
  });
}
registerShapeFactory("point", {
  defaultShapeType: "hollow-circle",
  getDefaultPoints: function(pointInfo) {
    return splitPoints(pointInfo);
  }
});
each$1(SHAPES, function(shapeName) {
  registerShape("point", "hollow-".concat(shapeName), {
    draw: function(cfg, container) {
      return drawPoints(this, cfg, container, shapeName, true);
    },
    getMarker: function(markerCfg) {
      var color2 = markerCfg.color;
      return {
        symbol: MarkerSymbols[shapeName] || shapeName,
        style: {
          r: 4.5,
          stroke: color2,
          fill: null
        }
      };
    }
  });
});
var Point = function(_super) {
  __extends$3(Point2, _super);
  function Point2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "point";
    _this.shapeType = "point";
    _this.generatePoints = true;
    return _this;
  }
  Point2.prototype.getDrawCfg = function(mappingDatum) {
    var shapeCfg = _super.prototype.getDrawCfg.call(this, mappingDatum);
    return __assign$4(__assign$4({}, shapeCfg), { isStack: !!this.getAdjust("stack") });
  };
  return Point2;
}(Geometry);
function getPath$1(points2) {
  var flag = points2[0];
  var i2 = 1;
  var path2 = [["M", flag.x, flag.y]];
  while (i2 < points2.length) {
    var c2 = points2[i2];
    if (c2.x !== points2[i2 - 1].x || c2.y !== points2[i2 - 1].y) {
      path2.push(["L", c2.x, c2.y]);
      if (c2.x === flag.x && c2.y === flag.y && i2 < points2.length - 1) {
        flag = points2[i2 + 1];
        path2.push(["Z"]);
        path2.push(["M", flag.x, flag.y]);
        i2++;
      }
    }
    i2++;
  }
  if (!isEqual$1(last(path2), flag)) {
    path2.push(["L", flag.x, flag.y]);
  }
  path2.push(["Z"]);
  return path2;
}
registerShapeFactory("polygon", {
  defaultShapeType: "polygon",
  getDefaultPoints: function(pointInfo) {
    var points2 = [];
    each$1(pointInfo.x, function(subX, index2) {
      var subY = pointInfo.y[index2];
      points2.push({
        x: subX,
        y: subY
      });
    });
    return points2;
  }
});
registerShape("polygon", "polygon", {
  draw: function(cfg, container) {
    if (!isEmpty(cfg.points)) {
      var shapeAttrs = getStyle(cfg, true, true);
      var path2 = this.parsePath(getPath$1(cfg.points));
      return container.addShape("path", {
        attrs: __assign$4(__assign$4({}, shapeAttrs), { path: path2 }),
        name: "polygon"
      });
    }
  },
  getMarker: function(markerCfg) {
    var color2 = markerCfg.color;
    return {
      symbol: "square",
      style: {
        r: 4,
        fill: color2
      }
    };
  }
});
var Polygon = function(_super) {
  __extends$3(Polygon2, _super);
  function Polygon2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "polygon";
    _this.shapeType = "polygon";
    _this.generatePoints = true;
    return _this;
  }
  Polygon2.prototype.createShapePointsCfg = function(obj) {
    var cfg = _super.prototype.createShapePointsCfg.call(this, obj);
    var x2 = cfg.x;
    var y2 = cfg.y;
    var temp;
    if (!(isArray$1(x2) && isArray$1(y2))) {
      var xScale = this.getXScale();
      var yScale = this.getYScale();
      var xCount = xScale.values.length;
      var yCount = yScale.values.length;
      var xOffset = 0.5 * 1 / xCount;
      var yOffset = 0.5 * 1 / yCount;
      if (xScale.isCategory && yScale.isCategory) {
        x2 = [x2 - xOffset, x2 - xOffset, x2 + xOffset, x2 + xOffset];
        y2 = [y2 - yOffset, y2 + yOffset, y2 + yOffset, y2 - yOffset];
      } else if (isArray$1(x2)) {
        temp = x2;
        x2 = [temp[0], temp[0], temp[1], temp[1]];
        y2 = [y2 - yOffset / 2, y2 + yOffset / 2, y2 + yOffset / 2, y2 - yOffset / 2];
      } else if (isArray$1(y2)) {
        temp = y2;
        y2 = [temp[0], temp[1], temp[1], temp[0]];
        x2 = [x2 - xOffset / 2, x2 - xOffset / 2, x2 + xOffset / 2, x2 + xOffset / 2];
      }
      cfg.x = x2;
      cfg.y = y2;
    }
    return cfg;
  };
  return Polygon2;
}(Geometry);
registerShapeFactory("schema", {
  defaultShapeType: ""
});
var Schema = function(_super) {
  __extends$3(Schema2, _super);
  function Schema2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "schema";
    _this.shapeType = "schema";
    _this.generatePoints = true;
    return _this;
  }
  Schema2.prototype.createShapePointsCfg = function(record) {
    var cfg = _super.prototype.createShapePointsCfg.call(this, record);
    var size2;
    var sizeAttr = this.getAttribute("size");
    if (sizeAttr) {
      size2 = this.getAttributeValues(sizeAttr, record)[0];
      var coordinate2 = this.coordinate;
      var coordinateWidth = getXDimensionLength(coordinate2);
      size2 = size2 / coordinateWidth;
    } else {
      if (!this.defaultSize) {
        this.defaultSize = getDefaultSize(this);
      }
      size2 = this.defaultSize;
    }
    cfg.size = size2;
    return cfg;
  };
  return Schema2;
}(Geometry);
function normalizeSize(arr) {
  if (!isArray$1(arr)) {
    return [];
  }
  var maxValue = max$2(arr);
  return map$2(arr, function(num) {
    return num / maxValue;
  });
}
registerShapeFactory("violin", {
  defaultShapeType: "violin",
  getDefaultPoints: function(pointInfo) {
    var radius = pointInfo.size / 2;
    var points2 = [];
    var sizeArr = normalizeSize(pointInfo._size);
    each$1(pointInfo.y, function(y2, index2) {
      var offset3 = sizeArr[index2] * radius;
      var isMin = index2 === 0;
      var isMax = index2 === pointInfo.y.length - 1;
      points2.push({
        isMin,
        isMax,
        x: pointInfo.x - offset3,
        y: y2
      });
      points2.unshift({
        isMin,
        isMax,
        x: pointInfo.x + offset3,
        y: y2
      });
    });
    return points2;
  }
});
registerShape("violin", "violin", {
  draw: function(cfg, container) {
    var shapeAttrs = getStyle(cfg, true, true);
    var path2 = this.parsePath(getViolinPath(cfg.points));
    return container.addShape("path", {
      attrs: __assign$4(__assign$4({}, shapeAttrs), { path: path2 }),
      name: "violin"
    });
  },
  getMarker: function(markerCfg) {
    var color2 = markerCfg.color;
    return {
      symbol: "circle",
      style: {
        r: 4,
        fill: color2
      }
    };
  }
});
var Violin = function(_super) {
  __extends$3(Violin2, _super);
  function Violin2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "violin";
    _this.shapeType = "violin";
    _this.generatePoints = true;
    return _this;
  }
  Violin2.prototype.createShapePointsCfg = function(record) {
    var cfg = _super.prototype.createShapePointsCfg.call(this, record);
    var size2;
    var sizeAttr = this.getAttribute("size");
    if (sizeAttr) {
      size2 = this.getAttributeValues(sizeAttr, record)[0];
      var coordinate2 = this.coordinate;
      var coordinateWidth = getXDimensionLength(coordinate2);
      size2 = size2 / coordinateWidth;
    } else {
      if (!this.defaultSize) {
        this.defaultSize = getDefaultSize(this);
      }
      size2 = this.defaultSize;
    }
    cfg.size = size2;
    cfg._size = get(record[FIELD_ORIGIN], [this._sizeField]);
    return cfg;
  };
  Violin2.prototype.initAttributes = function() {
    var attributeOption = this.attributeOption;
    var sizeField = attributeOption.size ? attributeOption.size.fields[0] : this._sizeField ? this._sizeField : "size";
    this._sizeField = sizeField;
    delete attributeOption.size;
    _super.prototype.initAttributes.call(this);
  };
  return Violin2;
}(Geometry);
registerShape("area", "line", {
  draw: function(cfg, container) {
    var attrs = getShapeAttrs(cfg, true, false, this);
    var shape = container.addShape({
      type: "path",
      attrs,
      name: "area"
    });
    return shape;
  },
  getMarker: function(markerCfg) {
    var color2 = markerCfg.color;
    return {
      symbol: function(x2, y2, r2) {
        if (r2 === void 0) {
          r2 = 5.5;
        }
        return [["M", x2 - r2, y2 - 4], ["L", x2 + r2, y2 - 4], ["L", x2 + r2, y2 + 4], ["L", x2 - r2, y2 + 4], ["Z"]];
      },
      style: {
        r: 5,
        stroke: color2,
        fill: null
      }
    };
  }
});
registerShape("area", "smooth", {
  draw: function(cfg, container) {
    var coordinate2 = this.coordinate;
    var attrs = getShapeAttrs(cfg, false, true, this, getConstraint(coordinate2));
    var shape = container.addShape({
      type: "path",
      attrs,
      name: "area"
    });
    return shape;
  },
  getMarker: function(markerCfg) {
    var color2 = markerCfg.color;
    return {
      symbol: function(x2, y2, r2) {
        if (r2 === void 0) {
          r2 = 5.5;
        }
        return [["M", x2 - r2, y2 - 4], ["L", x2 + r2, y2 - 4], ["L", x2 + r2, y2 + 4], ["L", x2 - r2, y2 + 4], ["Z"]];
      },
      style: {
        r: 5,
        fill: color2,
        fillOpacity: 1
      }
    };
  }
});
registerShape("area", "smooth-line", {
  draw: function(cfg, container) {
    var coordinate2 = this.coordinate;
    var attrs = getShapeAttrs(cfg, true, true, this, getConstraint(coordinate2));
    var shape = container.addShape({
      type: "path",
      attrs,
      name: "area"
    });
    return shape;
  },
  getMarker: function(markerCfg) {
    var color2 = markerCfg.color;
    return {
      symbol: function(x2, y2, r2) {
        if (r2 === void 0) {
          r2 = 5.5;
        }
        return [["M", x2 - r2, y2 - 4], ["L", x2 + r2, y2 - 4], ["L", x2 + r2, y2 + 4], ["L", x2 - r2, y2 + 4], ["Z"]];
      },
      style: {
        r: 5,
        stroke: color2,
        fill: null
      }
    };
  }
});
function getCPath(from, to) {
  return ["C", from.x * 1 / 2 + to.x * 1 / 2, from.y, from.x * 1 / 2 + to.x * 1 / 2, to.y, to.x, to.y];
}
function getQPath(to, center2) {
  var points2 = [];
  points2.push({
    x: center2.x,
    y: center2.y
  });
  points2.push(to);
  var sub2 = ["Q"];
  each$1(points2, function(point2) {
    sub2.push(point2.x, point2.y);
  });
  return sub2;
}
function getArcShapePath(from, to, center2) {
  var sub2 = getQPath(to, center2);
  var path2 = [["M", from.x, from.y]];
  path2.push(sub2);
  return path2;
}
function getArcShapeWeightPath(points2, center2) {
  var arc1 = getQPath(points2[1], center2);
  var arc2 = getQPath(points2[3], center2);
  var path2 = [["M", points2[0].x, points2[0].y]];
  path2.push(arc2);
  path2.push(["L", points2[3].x, points2[3].y]);
  path2.push(["L", points2[2].x, points2[2].y]);
  path2.push(arc1);
  path2.push(["L", points2[1].x, points2[1].y]);
  path2.push(["L", points2[0].x, points2[0].y]);
  path2.push(["Z"]);
  return path2;
}
registerShape("edge", "arc", {
  draw: function(cfg, container) {
    var style2 = getStyle(cfg, true, false, "lineWidth");
    var points2 = cfg.points;
    var type4 = points2.length > 2 ? "weight" : "normal";
    var path2;
    if (cfg.isInCircle) {
      var center2 = { x: 0, y: 1 };
      if (type4 === "normal") {
        path2 = getArcShapePath(points2[0], points2[1], center2);
      } else {
        style2.fill = style2.stroke;
        path2 = getArcShapeWeightPath(points2, center2);
      }
      path2 = this.parsePath(path2);
      return container.addShape("path", {
        attrs: __assign$4(__assign$4({}, style2), { path: path2 })
      });
    } else {
      if (type4 === "normal") {
        points2 = this.parsePoints(points2);
        path2 = getArcPath((points2[1].x + points2[0].x) / 2, points2[0].y, Math.abs(points2[1].x - points2[0].x) / 2, Math.PI, Math.PI * 2);
        return container.addShape("path", {
          attrs: __assign$4(__assign$4({}, style2), { path: path2 })
        });
      } else {
        var c1 = getCPath(points2[1], points2[3]);
        var c2 = getCPath(points2[2], points2[0]);
        path2 = [
          ["M", points2[0].x, points2[0].y],
          ["L", points2[1].x, points2[1].y],
          c1,
          ["L", points2[3].x, points2[3].y],
          ["L", points2[2].x, points2[2].y],
          c2,
          ["Z"]
        ];
        path2 = this.parsePath(path2);
        style2.fill = style2.stroke;
        return container.addShape("path", {
          attrs: __assign$4(__assign$4({}, style2), { path: path2 })
        });
      }
    }
  },
  getMarker: function(markerCfg) {
    return {
      symbol: "circle",
      style: {
        r: 4.5,
        fill: markerCfg.color
      }
    };
  }
});
function getSmoothPath(from, to) {
  var sub2 = getCPath(from, to);
  var path2 = [["M", from.x, from.y]];
  path2.push(sub2);
  return path2;
}
registerShape("edge", "smooth", {
  draw: function(cfg, container) {
    var style2 = getStyle(cfg, true, false, "lineWidth");
    var points2 = cfg.points;
    var path2 = this.parsePath(getSmoothPath(points2[0], points2[1]));
    return container.addShape("path", {
      attrs: __assign$4(__assign$4({}, style2), { path: path2 })
    });
  },
  getMarker: function(markerCfg) {
    return {
      symbol: "circle",
      style: {
        r: 4.5,
        fill: markerCfg.color
      }
    };
  }
});
var CORNER_PERCENT = 1 / 3;
function getVHVPath(from, to) {
  var points2 = [];
  points2.push({
    x: from.x,
    y: from.y * (1 - CORNER_PERCENT) + to.y * CORNER_PERCENT
  });
  points2.push({
    x: to.x,
    y: from.y * (1 - CORNER_PERCENT) + to.y * CORNER_PERCENT
  });
  points2.push(to);
  var path2 = [["M", from.x, from.y]];
  each$1(points2, function(point2) {
    path2.push(["L", point2.x, point2.y]);
  });
  return path2;
}
registerShape("edge", "vhv", {
  draw: function(cfg, container) {
    var style2 = getStyle(cfg, true, false, "lineWidth");
    var points2 = cfg.points;
    var path2 = this.parsePath(getVHVPath(points2[0], points2[1]));
    return container.addShape("path", {
      attrs: __assign$4(__assign$4({}, style2), { path: path2 })
    });
  },
  getMarker: function(markerCfg) {
    return {
      symbol: "circle",
      style: {
        r: 4.5,
        fill: markerCfg.color
      }
    };
  }
});
registerShape("interval", "funnel", {
  getPoints: function(shapePoint) {
    shapePoint.size = shapePoint.size * 2;
    return getRectPoints$1(shapePoint);
  },
  draw: function(cfg, container) {
    var style2 = getStyle(cfg, false, true);
    var path2 = this.parsePath(getFunnelPath(cfg.points, cfg.nextPoints, false));
    var shape = container.addShape("path", {
      attrs: __assign$4(__assign$4({}, style2), { path: path2 }),
      name: "interval"
    });
    return shape;
  },
  getMarker: function(markerCfg) {
    var color2 = markerCfg.color;
    return {
      symbol: "square",
      style: {
        r: 4,
        fill: color2
      }
    };
  }
});
registerShape("interval", "hollow-rect", {
  draw: function(cfg, container) {
    var style2 = getStyle(cfg, true, false);
    var group2 = container;
    var backgroundCfg = cfg === null || cfg === void 0 ? void 0 : cfg.background;
    if (backgroundCfg) {
      group2 = container.addGroup();
      var backgroundStyle = getBackgroundRectStyle(cfg);
      var backgroundPath = getBackgroundRectPath(cfg, this.parsePoints(cfg.points), this.coordinate);
      group2.addShape("path", {
        attrs: __assign$4(__assign$4({}, backgroundStyle), { path: backgroundPath }),
        zIndex: -1,
        name: BACKGROUND_SHAPE
      });
    }
    var path2 = this.parsePath(getRectPath$1(cfg.points));
    var shape = group2.addShape("path", {
      attrs: __assign$4(__assign$4({}, style2), { path: path2 }),
      name: "interval"
    });
    return backgroundCfg ? group2 : shape;
  },
  getMarker: function(markerCfg) {
    var color2 = markerCfg.color, isInPolar = markerCfg.isInPolar;
    if (isInPolar) {
      return {
        symbol: "circle",
        style: {
          r: 4.5,
          stroke: color2,
          fill: null
        }
      };
    }
    return {
      symbol: "square",
      style: {
        r: 4,
        stroke: color2,
        fill: null
      }
    };
  }
});
function getLinePoints(pointInfo) {
  var x2 = pointInfo.x, y2 = pointInfo.y, y0 = pointInfo.y0;
  if (isArray$1(y2)) {
    return y2.map(function(yItem, idx) {
      return {
        x: isArray$1(x2) ? x2[idx] : x2,
        y: yItem
      };
    });
  }
  return [
    { x: x2, y: y0 },
    { x: x2, y: y2 }
  ];
}
registerShape("interval", "line", {
  getPoints: function(shapePoint) {
    return getLinePoints(shapePoint);
  },
  draw: function(cfg, container) {
    var style2 = getStyle(cfg, true, false, "lineWidth");
    var newStyle = omit(__assign$4({}, style2), ["fill"]);
    var path2 = this.parsePath(getRectPath$1(cfg.points, false));
    var shape = container.addShape("path", {
      attrs: __assign$4(__assign$4({}, newStyle), { path: path2 }),
      name: "interval"
    });
    return shape;
  },
  getMarker: function(markerCfg) {
    var color2 = markerCfg.color;
    return {
      symbol: function(x2, y2, r2) {
        return [
          ["M", x2, y2 - r2],
          ["L", x2, y2 + r2]
        ];
      },
      style: {
        r: 5,
        stroke: color2
      }
    };
  }
});
registerShape("interval", "pyramid", {
  getPoints: function(shapePoint) {
    shapePoint.size = shapePoint.size * 2;
    return getRectPoints$1(shapePoint);
  },
  draw: function(cfg, container) {
    var style2 = getStyle(cfg, false, true);
    var path2 = this.parsePath(getFunnelPath(cfg.points, cfg.nextPoints, true));
    var shape = container.addShape("path", {
      attrs: __assign$4(__assign$4({}, style2), { path: path2 }),
      name: "interval"
    });
    return shape;
  },
  getMarker: function(markerCfg) {
    var color2 = markerCfg.color;
    return {
      symbol: "square",
      style: {
        r: 4,
        fill: color2
      }
    };
  }
});
function getTickPoints(pointInfo) {
  var _a2;
  var x2 = pointInfo.x, y2 = pointInfo.y, y0 = pointInfo.y0, size2 = pointInfo.size;
  var yMin;
  var yMax;
  if (isArray$1(y2)) {
    _a2 = __read(y2, 2), yMin = _a2[0], yMax = _a2[1];
  } else {
    yMin = y0;
    yMax = y2;
  }
  var xMax = x2 + size2 / 2;
  var xMin = x2 - size2 / 2;
  return [
    { x: x2, y: yMin },
    { x: x2, y: yMax },
    { x: xMin, y: yMin },
    { x: xMax, y: yMin },
    { x: xMin, y: yMax },
    { x: xMax, y: yMax }
  ];
}
function getTickPath(points2) {
  return [
    ["M", points2[0].x, points2[0].y],
    ["L", points2[1].x, points2[1].y],
    ["M", points2[2].x, points2[2].y],
    ["L", points2[3].x, points2[3].y],
    ["M", points2[4].x, points2[4].y],
    ["L", points2[5].x, points2[5].y]
  ];
}
registerShape("interval", "tick", {
  getPoints: function(shapePoint) {
    return getTickPoints(shapePoint);
  },
  draw: function(cfg, container) {
    var style2 = getStyle(cfg, true, false);
    var path2 = this.parsePath(getTickPath(cfg.points));
    var shape = container.addShape("path", {
      attrs: __assign$4(__assign$4({}, style2), { path: path2 }),
      name: "interval"
    });
    return shape;
  },
  getMarker: function(markerCfg) {
    var color2 = markerCfg.color;
    return {
      symbol: function(x2, y2, r2) {
        return [
          ["M", x2 - r2 / 2, y2 - r2],
          ["L", x2 + r2 / 2, y2 - r2],
          ["M", x2, y2 - r2],
          ["L", x2, y2 + r2],
          ["M", x2 - r2 / 2, y2 + r2],
          ["L", x2 + r2 / 2, y2 + r2]
        ];
      },
      style: {
        r: 5,
        stroke: color2
      }
    };
  }
});
var interpolateCallback = function(point2, nextPoint, shapeType) {
  var x2 = point2.x;
  var y2 = point2.y;
  var nextX = nextPoint.x;
  var nextY = nextPoint.y;
  var result;
  switch (shapeType) {
    case "hv":
      result = [{ x: nextX, y: y2 }];
      break;
    case "vh":
      result = [{ x: x2, y: nextY }];
      break;
    case "hvh":
      var middleX = (nextX + x2) / 2;
      result = [
        { x: middleX, y: y2 },
        { x: middleX, y: nextY }
      ];
      break;
    case "vhv":
      var middleY = (y2 + nextY) / 2;
      result = [
        { x: x2, y: middleY },
        { x: nextX, y: middleY }
      ];
      break;
  }
  return result;
};
function getInterpolatePoints(points2, shapeType) {
  var result = [];
  each$1(points2, function(point2, index2) {
    var nextPoint = points2[index2 + 1];
    result.push(point2);
    if (nextPoint) {
      var interpolatePoint = interpolateCallback(point2, nextPoint, shapeType);
      result = result.concat(interpolatePoint);
    }
  });
  return result;
}
function getInterpolatePath(points2) {
  return points2.map(function(point2, index2) {
    return index2 === 0 ? ["M", point2.x, point2.y] : ["L", point2.x, point2.y];
  });
}
function getInterpolateShapeAttrs(cfg, shapeType) {
  var points2 = getPathPoints(cfg.points, cfg.connectNulls, cfg.showSinglePoint);
  var path2 = [];
  each$1(points2, function(eachLinePoints) {
    var interpolatePoints = getInterpolatePoints(eachLinePoints, shapeType);
    path2 = path2.concat(getInterpolatePath(interpolatePoints));
  });
  return __assign$4(__assign$4({}, getStyle(cfg, true, false, "lineWidth")), { path: path2 });
}
each$1(["hv", "vh", "hvh", "vhv"], function(shapeType) {
  registerShape("line", shapeType, {
    draw: function(cfg, container) {
      var attrs = getInterpolateShapeAttrs(cfg, shapeType);
      var shape = container.addShape({
        type: "path",
        attrs,
        name: "line"
      });
      return shape;
    },
    getMarker: function(markerCfg) {
      return getLineMarker(markerCfg, shapeType);
    }
  });
});
each$1(HOLLOW_SHAPES, function(shapeName) {
  registerShape("point", shapeName, {
    draw: function(cfg, container) {
      return drawPoints(this, cfg, container, shapeName, true);
    },
    getMarker: function(markerCfg) {
      var color2 = markerCfg.color;
      return {
        symbol: MarkerSymbols[shapeName],
        style: {
          r: 4.5,
          stroke: color2,
          fill: null
        }
      };
    }
  });
});
registerShape("point", "image", {
  draw: function(cfg, container) {
    var e_1, _a2;
    var size2 = getStyle(cfg, false, false, "r").r;
    var points2 = this.parsePoints(cfg.points);
    var pointPosition = points2[0];
    if (cfg.isStack) {
      pointPosition = points2[1];
    } else if (points2.length > 1) {
      var group2 = container.addGroup();
      try {
        for (var points_1 = __values(points2), points_1_1 = points_1.next(); !points_1_1.done; points_1_1 = points_1.next()) {
          var point2 = points_1_1.value;
          group2.addShape("image", {
            attrs: {
              x: point2.x - size2 / 2,
              y: point2.y - size2,
              width: size2,
              height: size2,
              img: cfg.shape[1]
            }
          });
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (points_1_1 && !points_1_1.done && (_a2 = points_1.return))
            _a2.call(points_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      return group2;
    }
    return container.addShape("image", {
      attrs: {
        x: pointPosition.x - size2 / 2,
        y: pointPosition.y - size2,
        width: size2,
        height: size2,
        img: cfg.shape[1]
      }
    });
  },
  getMarker: function(markerCfg) {
    var color2 = markerCfg.color;
    return {
      symbol: "circle",
      style: {
        r: 4.5,
        fill: color2
      }
    };
  }
});
each$1(SHAPES, function(shapeName) {
  registerShape("point", shapeName, {
    draw: function(cfg, container) {
      return drawPoints(this, cfg, container, shapeName, false);
    },
    getMarker: function(markerCfg) {
      var color2 = markerCfg.color;
      return {
        symbol: MarkerSymbols[shapeName] || shapeName,
        style: {
          r: 4.5,
          fill: color2
        }
      };
    }
  });
});
function parseValue(value2) {
  var array4 = !isArray$1(value2) ? [value2] : value2;
  var min2 = array4[0];
  var max2 = array4[array4.length - 1];
  var min1 = array4.length > 1 ? array4[1] : min2;
  var max1 = array4.length > 3 ? array4[3] : max2;
  var median2 = array4.length > 2 ? array4[2] : min1;
  return {
    min: min2,
    max: max2,
    min1,
    max1,
    median: median2
  };
}
function getBoxPoints(x2, y2, size2) {
  var halfSize = size2 / 2;
  var pointsArray;
  if (isArray$1(y2)) {
    var _a2 = parseValue(y2), min2 = _a2.min, max2 = _a2.max, median2 = _a2.median, min1 = _a2.min1, max1 = _a2.max1;
    var minX = x2 - halfSize;
    var maxX = x2 + halfSize;
    pointsArray = [
      [minX, max2],
      [maxX, max2],
      [x2, max2],
      [x2, max1],
      [minX, min1],
      [minX, max1],
      [maxX, max1],
      [maxX, min1],
      [x2, min1],
      [x2, min2],
      [minX, min2],
      [maxX, min2],
      [minX, median2],
      [maxX, median2]
    ];
  } else {
    y2 = isNil(y2) ? 0.5 : y2;
    var _b = parseValue(x2), min2 = _b.min, max2 = _b.max, median2 = _b.median, min1 = _b.min1, max1 = _b.max1;
    var minY = y2 - halfSize;
    var maxY2 = y2 + halfSize;
    pointsArray = [
      [min2, minY],
      [min2, maxY2],
      [min2, y2],
      [min1, y2],
      [min1, minY],
      [min1, maxY2],
      [max1, maxY2],
      [max1, minY],
      [max1, y2],
      [max2, y2],
      [max2, minY],
      [max2, maxY2],
      [median2, minY],
      [median2, maxY2]
    ];
  }
  return pointsArray.map(function(arr) {
    return {
      x: arr[0],
      y: arr[1]
    };
  });
}
function getBoxPath(points2) {
  return [
    ["M", points2[0].x, points2[0].y],
    ["L", points2[1].x, points2[1].y],
    ["M", points2[2].x, points2[2].y],
    ["L", points2[3].x, points2[3].y],
    ["M", points2[4].x, points2[4].y],
    ["L", points2[5].x, points2[5].y],
    ["L", points2[6].x, points2[6].y],
    ["L", points2[7].x, points2[7].y],
    ["L", points2[4].x, points2[4].y],
    ["Z"],
    ["M", points2[8].x, points2[8].y],
    ["L", points2[9].x, points2[9].y],
    ["M", points2[10].x, points2[10].y],
    ["L", points2[11].x, points2[11].y],
    ["M", points2[12].x, points2[12].y],
    ["L", points2[13].x, points2[13].y]
  ];
}
registerShape("schema", "box", {
  getPoints: function(shapePoint) {
    var x2 = shapePoint.x, y2 = shapePoint.y, size2 = shapePoint.size;
    return getBoxPoints(x2, y2, size2);
  },
  draw: function(cfg, container) {
    var style2 = getStyle(cfg, true, false);
    var path2 = this.parsePath(getBoxPath(cfg.points));
    var shape = container.addShape("path", {
      attrs: __assign$4(__assign$4({}, style2), { path: path2, name: "schema" })
    });
    return shape;
  },
  getMarker: function(markerCfg) {
    var color2 = markerCfg.color;
    return {
      symbol: function(x2, y2, r2) {
        var yValues = [y2 - 6, y2 - 3, y2, y2 + 3, y2 + 6];
        var points2 = getBoxPoints(x2, yValues, r2);
        return [
          ["M", points2[0].x + 1, points2[0].y],
          ["L", points2[1].x - 1, points2[1].y],
          ["M", points2[2].x, points2[2].y],
          ["L", points2[3].x, points2[3].y],
          ["M", points2[4].x, points2[4].y],
          ["L", points2[5].x, points2[5].y],
          ["L", points2[6].x, points2[6].y],
          ["L", points2[7].x, points2[7].y],
          ["L", points2[4].x, points2[4].y],
          ["Z"],
          ["M", points2[8].x, points2[8].y],
          ["L", points2[9].x, points2[9].y],
          ["M", points2[10].x + 1, points2[10].y],
          ["L", points2[11].x - 1, points2[11].y],
          ["M", points2[12].x, points2[12].y],
          ["L", points2[13].x, points2[13].y]
        ];
      },
      style: {
        r: 6,
        lineWidth: 1,
        stroke: color2
      }
    };
  }
});
function getCandleYValues(value2) {
  var array4 = !isArray$1(value2) ? [value2] : value2;
  var sorted = array4.sort(function(a2, b10) {
    return b10 - a2;
  });
  return padEnd(sorted, 4, sorted[sorted.length - 1]);
}
function getCandlePoints(x2, y2, size2) {
  var yValues = getCandleYValues(y2);
  return [
    { x: x2, y: yValues[0] },
    { x: x2, y: yValues[1] },
    { x: x2 - size2 / 2, y: yValues[2] },
    { x: x2 - size2 / 2, y: yValues[1] },
    { x: x2 + size2 / 2, y: yValues[1] },
    { x: x2 + size2 / 2, y: yValues[2] },
    { x: x2, y: yValues[2] },
    { x: x2, y: yValues[3] }
  ];
}
function getCandlePath(points2) {
  return [
    ["M", points2[0].x, points2[0].y],
    ["L", points2[1].x, points2[1].y],
    ["M", points2[2].x, points2[2].y],
    ["L", points2[3].x, points2[3].y],
    ["L", points2[4].x, points2[4].y],
    ["L", points2[5].x, points2[5].y],
    ["Z"],
    ["M", points2[6].x, points2[6].y],
    ["L", points2[7].x, points2[7].y]
  ];
}
registerShape("schema", "candle", {
  getPoints: function(shapePoint) {
    var x2 = shapePoint.x, y2 = shapePoint.y, size2 = shapePoint.size;
    return getCandlePoints(x2, y2, size2);
  },
  draw: function(cfg, container) {
    var style2 = getStyle(cfg, true, true);
    var path2 = this.parsePath(getCandlePath(cfg.points));
    var shape = container.addShape("path", {
      attrs: __assign$4(__assign$4({}, style2), { path: path2, name: "schema" })
    });
    return shape;
  },
  getMarker: function(markerCfg) {
    var color2 = markerCfg.color;
    return {
      symbol: function(x2, y2, r2) {
        var yValues = [y2 + 7.5, y2 + 3, y2 - 3, y2 - 7.5];
        var points2 = getCandlePoints(x2, yValues, r2);
        return [
          ["M", points2[0].x, points2[0].y],
          ["L", points2[1].x, points2[1].y],
          ["M", points2[2].x, points2[2].y],
          ["L", points2[3].x, points2[3].y],
          ["L", points2[4].x, points2[4].y],
          ["L", points2[5].x, points2[5].y],
          ["Z"],
          ["M", points2[6].x, points2[6].y],
          ["L", points2[7].x, points2[7].y]
        ];
      },
      style: {
        lineWidth: 1,
        stroke: color2,
        fill: color2,
        r: 6
      }
    };
  }
});
function getRectAttrs(points2, size2) {
  var width = Math.abs(points2[0].x - points2[2].x);
  var height = Math.abs(points2[0].y - points2[2].y);
  var len = Math.min(width, height);
  if (size2) {
    len = clamp(size2, 0, Math.min(width, height));
  }
  len = len / 2;
  var centerX = (points2[0].x + points2[2].x) / 2;
  var centerY = (points2[0].y + points2[2].y) / 2;
  return {
    x: centerX - len,
    y: centerY - len,
    width: len * 2,
    height: len * 2
  };
}
registerShape("polygon", "square", {
  draw: function(cfg, container) {
    if (!isEmpty(cfg.points)) {
      var shapeAttrs = getStyle(cfg, true, true);
      var points2 = this.parsePoints(cfg.points);
      return container.addShape("rect", {
        attrs: __assign$4(__assign$4({}, shapeAttrs), getRectAttrs(points2, cfg.size)),
        name: "polygon"
      });
    }
  },
  getMarker: function(markerCfg) {
    var color2 = markerCfg.color;
    return {
      symbol: "square",
      style: {
        r: 4,
        fill: color2
      }
    };
  }
});
registerShape("violin", "smooth", {
  draw: function(cfg, container) {
    var attrs = getStyle(cfg, true, true);
    var path2 = this.parsePath(getSmoothViolinPath(cfg.points));
    return container.addShape("path", {
      attrs: __assign$4(__assign$4({}, attrs), { path: path2 })
    });
  },
  getMarker: function(markerCfg) {
    var color2 = markerCfg.color;
    return {
      symbol: "circle",
      style: {
        stroke: null,
        r: 4,
        fill: color2
      }
    };
  }
});
registerShape("violin", "hollow", {
  draw: function(cfg, container) {
    var attrs = getStyle(cfg, true, false);
    var path2 = this.parsePath(getViolinPath(cfg.points));
    return container.addShape("path", {
      attrs: __assign$4(__assign$4({}, attrs), { path: path2 })
    });
  },
  getMarker: function(markerCfg) {
    var color2 = markerCfg.color;
    return {
      symbol: "circle",
      style: {
        r: 4,
        fill: null,
        stroke: color2
      }
    };
  }
});
registerShape("violin", "hollow-smooth", {
  draw: function(cfg, container) {
    var attrs = getStyle(cfg, true, false);
    var path2 = this.parsePath(getSmoothViolinPath(cfg.points));
    return container.addShape("path", {
      attrs: __assign$4(__assign$4({}, attrs), { path: path2 })
    });
  },
  getMarker: function(markerCfg) {
    var color2 = markerCfg.color;
    return {
      symbol: "circle",
      style: {
        r: 4,
        fill: null,
        stroke: color2
      }
    };
  }
});
var IntervalLabel = function(_super) {
  __extends$3(IntervalLabel2, _super);
  function IntervalLabel2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  IntervalLabel2.prototype.getLabelValueDir = function(mappingData) {
    var dim = "y";
    var points2 = mappingData.points;
    return points2[0][dim] <= points2[2][dim] ? 1 : -1;
  };
  IntervalLabel2.prototype.getLabelOffsetPoint = function(labelCfg, index2, total, position) {
    var _a2;
    var point2 = _super.prototype.getLabelOffsetPoint.call(this, labelCfg, index2, total);
    var coordinate2 = this.getCoordinate();
    var transposed = coordinate2.isTransposed;
    var dim = transposed ? "x" : "y";
    var dir = this.getLabelValueDir(labelCfg.mappingData);
    point2 = __assign$4(__assign$4({}, point2), (_a2 = {}, _a2[dim] = point2[dim] * dir, _a2));
    if (coordinate2.isReflect("x")) {
      point2 = __assign$4(__assign$4({}, point2), { x: point2.x * -1 });
    }
    if (coordinate2.isReflect("y")) {
      point2 = __assign$4(__assign$4({}, point2), { y: point2.y * -1 });
    }
    return point2;
  };
  IntervalLabel2.prototype.getThemedLabelCfg = function(labelCfg) {
    var geometry2 = this.geometry;
    var defaultLabelCfg = this.getDefaultLabelCfg();
    var theme2 = geometry2.theme;
    return deepMix({}, defaultLabelCfg, theme2.labels, labelCfg.position === "middle" ? { offset: 0 } : {}, labelCfg);
  };
  IntervalLabel2.prototype.setLabelPosition = function(labelPointCfg, mappingData, index2, position) {
    var coordinate2 = this.getCoordinate();
    var transposed = coordinate2.isTransposed;
    var shapePoints = mappingData.points;
    var point0 = coordinate2.convert(shapePoints[0]);
    var point2 = coordinate2.convert(shapePoints[2]);
    var dir = this.getLabelValueDir(mappingData);
    var top;
    var right2;
    var bottom;
    var left2;
    var shape = isArray$1(mappingData.shape) ? mappingData.shape[0] : mappingData.shape;
    if (shape === "funnel" || shape === "pyramid") {
      var nextPoints = get(mappingData, "nextPoints");
      var points2 = get(mappingData, "points");
      if (nextPoints) {
        var p0 = coordinate2.convert(points2[0]);
        var p1 = coordinate2.convert(points2[1]);
        var nextP0 = coordinate2.convert(nextPoints[0]);
        var nextP1 = coordinate2.convert(nextPoints[1]);
        if (transposed) {
          top = Math.min(nextP0.y, p0.y);
          bottom = Math.max(nextP0.y, p0.y);
          right2 = (p1.x + nextP1.x) / 2;
          left2 = (p0.x + nextP0.x) / 2;
        } else {
          top = Math.min((p1.y + nextP1.y) / 2, (p0.y + nextP0.y) / 2);
          bottom = Math.max((p1.y + nextP1.y) / 2, (p0.y + nextP0.y) / 2);
          right2 = nextP1.x;
          left2 = p0.x;
        }
      } else {
        top = Math.min(point2.y, point0.y);
        bottom = Math.max(point2.y, point0.y);
        right2 = point2.x;
        left2 = point0.x;
      }
    } else {
      top = Math.min(point2.y, point0.y);
      bottom = Math.max(point2.y, point0.y);
      right2 = point2.x;
      left2 = point0.x;
    }
    switch (position) {
      case "right":
        labelPointCfg.x = right2;
        labelPointCfg.y = (top + bottom) / 2;
        labelPointCfg.textAlign = get(labelPointCfg, "textAlign", dir > 0 ? "left" : "right");
        break;
      case "left":
        labelPointCfg.x = left2;
        labelPointCfg.y = (top + bottom) / 2;
        labelPointCfg.textAlign = get(labelPointCfg, "textAlign", dir > 0 ? "left" : "right");
        break;
      case "bottom":
        if (transposed) {
          labelPointCfg.x = (right2 + left2) / 2;
        }
        labelPointCfg.y = bottom;
        labelPointCfg.textAlign = get(labelPointCfg, "textAlign", "center");
        labelPointCfg.textBaseline = get(labelPointCfg, "textBaseline", dir > 0 ? "bottom" : "top");
        break;
      case "middle":
        if (transposed) {
          labelPointCfg.x = (right2 + left2) / 2;
        }
        labelPointCfg.y = (top + bottom) / 2;
        labelPointCfg.textAlign = get(labelPointCfg, "textAlign", "center");
        labelPointCfg.textBaseline = get(labelPointCfg, "textBaseline", "middle");
        break;
      case "top":
        if (transposed) {
          labelPointCfg.x = (right2 + left2) / 2;
        }
        labelPointCfg.y = top;
        labelPointCfg.textAlign = get(labelPointCfg, "textAlign", "center");
        labelPointCfg.textBaseline = get(labelPointCfg, "textBaseline", dir > 0 ? "bottom" : "top");
        break;
    }
  };
  return IntervalLabel2;
}(GeometryLabel);
var HALF_PI = Math.PI / 2;
var PolarLabel = function(_super) {
  __extends$3(PolarLabel2, _super);
  function PolarLabel2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  PolarLabel2.prototype.getLabelOffset = function(offset3) {
    var coordinate2 = this.getCoordinate();
    var actualOffset = 0;
    if (isNumber$1(offset3)) {
      actualOffset = offset3;
    } else if (isString(offset3) && offset3.indexOf("%") !== -1) {
      var r2 = coordinate2.getRadius();
      if (coordinate2.innerRadius > 0) {
        r2 = r2 * (1 - coordinate2.innerRadius);
      }
      actualOffset = parseFloat(offset3) * 0.01 * r2;
    }
    return actualOffset;
  };
  PolarLabel2.prototype.getLabelItems = function(mapppingArray) {
    var items = _super.prototype.getLabelItems.call(this, mapppingArray);
    var yScale = this.geometry.getYScale();
    return map$2(items, function(item) {
      if (item && yScale) {
        var percent2 = yScale.scale(get(item.data, yScale.field));
        return __assign$4(__assign$4({}, item), { percent: percent2 });
      }
      return item;
    });
  };
  PolarLabel2.prototype.getLabelAlign = function(point2) {
    var coordinate2 = this.getCoordinate();
    var align;
    if (point2.labelEmit) {
      align = point2.angle <= Math.PI / 2 && point2.angle >= -Math.PI / 2 ? "left" : "right";
    } else if (!coordinate2.isTransposed) {
      align = "center";
    } else {
      var center2 = coordinate2.getCenter();
      var offset3 = point2.offset;
      if (Math.abs(point2.x - center2.x) < 1) {
        align = "center";
      } else if (point2.angle > Math.PI || point2.angle <= 0) {
        align = offset3 > 0 ? "left" : "right";
      } else {
        align = offset3 > 0 ? "right" : "left";
      }
    }
    return align;
  };
  PolarLabel2.prototype.getLabelPoint = function(labelCfg, mappingData, index2) {
    var factor = 1;
    var arcPoint;
    var content = labelCfg.content[index2];
    if (this.isToMiddle(mappingData)) {
      arcPoint = this.getMiddlePoint(mappingData.points);
    } else {
      if (labelCfg.content.length === 1 && index2 === 0) {
        index2 = 1;
      } else if (index2 === 0) {
        factor = -1;
      }
      arcPoint = this.getArcPoint(mappingData, index2);
    }
    var offset3 = labelCfg.offset * factor;
    var middleAngle = this.getPointAngle(arcPoint);
    var isLabelEmit = labelCfg.labelEmit;
    var labelPositionCfg = this.getCirclePoint(middleAngle, offset3, arcPoint, isLabelEmit);
    if (labelPositionCfg.r === 0) {
      labelPositionCfg.content = "";
    } else {
      labelPositionCfg.content = content;
      labelPositionCfg.angle = middleAngle;
      labelPositionCfg.color = mappingData.color;
    }
    labelPositionCfg.rotate = labelCfg.autoRotate ? this.getLabelRotate(middleAngle, offset3, isLabelEmit) : labelCfg.rotate;
    labelPositionCfg.start = {
      x: arcPoint.x,
      y: arcPoint.y
    };
    return labelPositionCfg;
  };
  PolarLabel2.prototype.getArcPoint = function(mappingData, index2) {
    if (index2 === void 0) {
      index2 = 0;
    }
    if (!isArray$1(mappingData.x) && !isArray$1(mappingData.y)) {
      return {
        x: mappingData.x,
        y: mappingData.y
      };
    }
    return {
      x: isArray$1(mappingData.x) ? mappingData.x[index2] : mappingData.x,
      y: isArray$1(mappingData.y) ? mappingData.y[index2] : mappingData.y
    };
  };
  PolarLabel2.prototype.getPointAngle = function(point2) {
    return getAngleByPoint(this.getCoordinate(), point2);
  };
  PolarLabel2.prototype.getCirclePoint = function(angle2, offset3, point2, isLabelEmit) {
    var coordinate2 = this.getCoordinate();
    var center2 = coordinate2.getCenter();
    var r2 = getDistanceToCenter(coordinate2, point2);
    if (r2 === 0) {
      return __assign$4(__assign$4({}, center2), { r: r2 });
    }
    var labelAngle = angle2;
    if (coordinate2.isTransposed && r2 > offset3 && !isLabelEmit) {
      var appendAngle = Math.asin(offset3 / (2 * r2));
      labelAngle = angle2 + appendAngle * 2;
    } else {
      r2 = r2 + offset3;
    }
    return {
      x: center2.x + r2 * Math.cos(labelAngle),
      y: center2.y + r2 * Math.sin(labelAngle),
      r: r2
    };
  };
  PolarLabel2.prototype.getLabelRotate = function(angle2, offset3, isLabelEmit) {
    var rotate2 = angle2 + HALF_PI;
    if (isLabelEmit) {
      rotate2 -= HALF_PI;
    }
    if (rotate2) {
      if (rotate2 > HALF_PI) {
        rotate2 = rotate2 - Math.PI;
      } else if (rotate2 < -HALF_PI) {
        rotate2 = rotate2 + Math.PI;
      }
    }
    return rotate2;
  };
  PolarLabel2.prototype.getMiddlePoint = function(points2) {
    var coordinate2 = this.getCoordinate();
    var count2 = points2.length;
    var middlePoint = {
      x: 0,
      y: 0
    };
    each$1(points2, function(point2) {
      middlePoint.x += point2.x;
      middlePoint.y += point2.y;
    });
    middlePoint.x /= count2;
    middlePoint.y /= count2;
    middlePoint = coordinate2.convert(middlePoint);
    return middlePoint;
  };
  PolarLabel2.prototype.isToMiddle = function(mappingData) {
    return mappingData.x.length > 2;
  };
  return PolarLabel2;
}(GeometryLabel);
var PieLabel = function(_super) {
  __extends$3(PieLabel2, _super);
  function PieLabel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.defaultLayout = "distribute";
    return _this;
  }
  PieLabel2.prototype.getDefaultLabelCfg = function(offset3, position) {
    var cfg = _super.prototype.getDefaultLabelCfg.call(this, offset3, position);
    return deepMix({}, cfg, get(this.geometry.theme, "pieLabels", {}));
  };
  PieLabel2.prototype.getLabelOffset = function(offset3) {
    return _super.prototype.getLabelOffset.call(this, offset3) || 0;
  };
  PieLabel2.prototype.getLabelRotate = function(angle2, offset3, isLabelLimit) {
    var rotate2;
    if (offset3 < 0) {
      rotate2 = angle2;
      if (rotate2 > Math.PI / 2) {
        rotate2 = rotate2 - Math.PI;
      }
      if (rotate2 < -Math.PI / 2) {
        rotate2 = rotate2 + Math.PI;
      }
    }
    return rotate2;
  };
  PieLabel2.prototype.getLabelAlign = function(point2) {
    var coordinate2 = this.getCoordinate();
    var center2 = coordinate2.getCenter();
    var align;
    if (point2.angle <= Math.PI / 2 && point2.x >= center2.x) {
      align = "left";
    } else {
      align = "right";
    }
    if (point2.offset <= 0) {
      if (align === "right") {
        align = "left";
      } else {
        align = "right";
      }
    }
    return align;
  };
  PieLabel2.prototype.getArcPoint = function(point2) {
    return point2;
  };
  PieLabel2.prototype.getPointAngle = function(point2) {
    var coordinate2 = this.getCoordinate();
    var startPoint = {
      x: isArray$1(point2.x) ? point2.x[0] : point2.x,
      y: point2.y[0]
    };
    var endPoint = {
      x: isArray$1(point2.x) ? point2.x[1] : point2.x,
      y: point2.y[1]
    };
    var angle2;
    var startAngle = getAngleByPoint(coordinate2, startPoint);
    if (point2.points && point2.points[0].y === point2.points[1].y) {
      angle2 = startAngle;
    } else {
      var endAngle = getAngleByPoint(coordinate2, endPoint);
      if (startAngle >= endAngle) {
        endAngle = endAngle + Math.PI * 2;
      }
      angle2 = startAngle + (endAngle - startAngle) / 2;
    }
    return angle2;
  };
  PieLabel2.prototype.getCirclePoint = function(angle2, offset3) {
    var coordinate2 = this.getCoordinate();
    var center2 = coordinate2.getCenter();
    var r2 = coordinate2.getRadius() + offset3;
    return __assign$4(__assign$4({}, polarToCartesian(center2.x, center2.y, r2, angle2)), { angle: angle2, r: r2 });
  };
  return PieLabel2;
}(PolarLabel);
var MARGIN$1 = 4;
function antiCollision$1(labelShapes, labels, lineHeight, plotRange, center2, isRight) {
  var e_1, _a2;
  var overlapping = true;
  var start = plotRange.start;
  var end = plotRange.end;
  var startY = Math.min(start.y, end.y);
  var totalHeight = Math.abs(start.y - end.y);
  var i2;
  var maxY2 = 0;
  var minY = Number.MIN_VALUE;
  var boxes = labels.map(function(label2) {
    if (label2.y > maxY2) {
      maxY2 = label2.y;
    }
    if (label2.y < minY) {
      minY = label2.y;
    }
    return {
      size: lineHeight,
      targets: [label2.y - startY]
    };
  });
  minY -= startY;
  if (maxY2 - startY > totalHeight) {
    totalHeight = maxY2 - startY;
  }
  while (overlapping) {
    boxes.forEach(function(box3) {
      var target = (Math.min.apply(minY, box3.targets) + Math.max.apply(minY, box3.targets)) / 2;
      box3.pos = Math.min(Math.max(minY, target - box3.size / 2), totalHeight - box3.size);
    });
    overlapping = false;
    i2 = boxes.length;
    while (i2--) {
      if (i2 > 0) {
        var previousBox = boxes[i2 - 1];
        var box2 = boxes[i2];
        if (previousBox.pos + previousBox.size > box2.pos) {
          previousBox.size += box2.size;
          previousBox.targets = previousBox.targets.concat(box2.targets);
          if (previousBox.pos + previousBox.size > totalHeight) {
            previousBox.pos = totalHeight - previousBox.size;
          }
          boxes.splice(i2, 1);
          overlapping = true;
        }
      }
    }
  }
  i2 = 0;
  boxes.forEach(function(b10) {
    var posInCompositeBox = startY + lineHeight / 2;
    b10.targets.forEach(function() {
      labels[i2].y = b10.pos + posInCompositeBox;
      posInCompositeBox += lineHeight;
      i2++;
    });
  });
  var labelsMap = {};
  try {
    for (var labelShapes_1 = __values(labelShapes), labelShapes_1_1 = labelShapes_1.next(); !labelShapes_1_1.done; labelShapes_1_1 = labelShapes_1.next()) {
      var labelShape = labelShapes_1_1.value;
      labelsMap[labelShape.get("id")] = labelShape;
    }
  } catch (e_1_1) {
    e_1 = { error: e_1_1 };
  } finally {
    try {
      if (labelShapes_1_1 && !labelShapes_1_1.done && (_a2 = labelShapes_1.return))
        _a2.call(labelShapes_1);
    } finally {
      if (e_1)
        throw e_1.error;
    }
  }
  labels.forEach(function(label2) {
    var rPow2 = label2.r * label2.r;
    var dyPow2 = Math.pow(Math.abs(label2.y - center2.y), 2);
    if (rPow2 < dyPow2) {
      label2.x = center2.x;
    } else {
      var dx = Math.sqrt(rPow2 - dyPow2);
      if (!isRight) {
        label2.x = center2.x - dx;
      } else {
        label2.x = center2.x + dx;
      }
    }
    var labelShape2 = labelsMap[label2.id];
    labelShape2.attr("x", label2.x);
    labelShape2.attr("y", label2.y);
    var textShape = find$1(labelShape2.getChildren(), function(ele) {
      return ele.get("type") === "text";
    });
    if (textShape) {
      textShape.attr("y", label2.y);
      textShape.attr("x", label2.x);
    }
  });
}
function distribute(items, labels, shapes, region) {
  if (!items.length || !labels.length) {
    return;
  }
  var offset3 = items[0] ? items[0].offset : 0;
  var coordinate2 = labels[0].get("coordinate");
  var radius = coordinate2.getRadius();
  var center2 = coordinate2.getCenter();
  if (offset3 > 0) {
    var lineHeight_1 = 14;
    var totalR = radius + offset3;
    var totalHeight_1 = totalR * 2 + lineHeight_1 * 2;
    var plotRange_1 = {
      start: coordinate2.start,
      end: coordinate2.end
    };
    var halves_1 = [
      [],
      []
    ];
    items.forEach(function(labelItem) {
      if (!labelItem) {
        return;
      }
      if (labelItem.textAlign === "right") {
        halves_1[0].push(labelItem);
      } else {
        halves_1[1].push(labelItem);
      }
    });
    halves_1.forEach(function(half, index2) {
      var maxLabelsCountForOneSide = totalHeight_1 / lineHeight_1;
      if (half.length > maxLabelsCountForOneSide) {
        half.sort(function(a2, b10) {
          return b10["..percent"] - a2["..percent"];
        });
        half.splice(maxLabelsCountForOneSide, half.length - maxLabelsCountForOneSide);
      }
      half.sort(function(a2, b10) {
        return a2.y - b10.y;
      });
      antiCollision$1(labels, half, lineHeight_1, plotRange_1, center2, index2);
    });
  }
  each$1(items, function(item) {
    if (item && item.labelLine) {
      var distance2 = item.offset;
      var angle2 = item.angle;
      var startPoint = polarToCartesian(center2.x, center2.y, radius, angle2);
      var innerPoint = polarToCartesian(center2.x, center2.y, radius + distance2 / 2, angle2);
      var itemX = item.x + get(item, "offsetX", 0);
      var itemY = item.y + get(item, "offsetY", 0);
      var endPoint = {
        x: itemX - Math.cos(angle2) * MARGIN$1,
        y: itemY - Math.sin(angle2) * MARGIN$1
      };
      if (!isObject(item.labelLine)) {
        item.labelLine = {};
      }
      item.labelLine.path = [
        "M ".concat(startPoint.x),
        "".concat(startPoint.y, " Q").concat(innerPoint.x),
        "".concat(innerPoint.y, " ").concat(endPoint.x),
        endPoint.y
      ].join(",");
    }
  });
}
function antiCollision(items, labelHeight, plotRange) {
  var labels = items.filter(function(item) {
    return !item.invisible;
  });
  labels.sort(function(a2, b10) {
    return a2.y - b10.y;
  });
  var overlapping = true;
  var startY = plotRange.minY;
  var endY = plotRange.maxY;
  var totalHeight = Math.abs(startY - endY);
  var i2;
  var maxY2 = 0;
  var minY = Number.MIN_VALUE;
  var boxes = labels.map(function(label2) {
    if (label2.y > maxY2) {
      maxY2 = label2.y;
    }
    if (label2.y < minY) {
      minY = label2.y;
    }
    return {
      content: label2.content,
      size: labelHeight,
      targets: [label2.y - startY],
      pos: null
    };
  });
  minY -= startY;
  if (maxY2 - startY > totalHeight) {
    totalHeight = maxY2 - startY;
  }
  while (overlapping) {
    boxes.forEach(function(box3) {
      var target = (Math.min.apply(minY, box3.targets) + Math.max.apply(minY, box3.targets)) / 2;
      box3.pos = Math.min(Math.max(minY, target - box3.size / 2), totalHeight - box3.size);
      box3.pos = Math.max(0, box3.pos);
    });
    overlapping = false;
    i2 = boxes.length;
    while (i2--) {
      if (i2 > 0) {
        var previousBox = boxes[i2 - 1];
        var box2 = boxes[i2];
        if (previousBox.pos + previousBox.size > box2.pos) {
          previousBox.size += box2.size;
          previousBox.targets = previousBox.targets.concat(box2.targets);
          if (previousBox.pos + previousBox.size > totalHeight) {
            previousBox.pos = totalHeight - previousBox.size;
          }
          boxes.splice(i2, 1);
          overlapping = true;
        }
      }
    }
  }
  i2 = 0;
  boxes.forEach(function(b10) {
    var posInCompositeBox = startY + labelHeight / 2;
    b10.targets.forEach(function() {
      labels[i2].y = b10.pos + posInCompositeBox;
      posInCompositeBox += labelHeight;
      i2++;
    });
  });
}
var MARGIN = 4;
function drawLabelline$1(item, coordinate2) {
  var center2 = coordinate2.getCenter();
  var radius = coordinate2.getRadius();
  if (item && item.labelLine) {
    var angle2 = item.angle, labelOffset = item.offset;
    var startPoint = polarToCartesian(center2.x, center2.y, radius, angle2);
    var itemX = item.x + get(item, "offsetX", 0) * (Math.cos(angle2) > 0 ? 1 : -1);
    var itemY = item.y + get(item, "offsetY", 0) * (Math.sin(angle2) > 0 ? 1 : -1);
    var endPoint = {
      x: itemX - Math.cos(angle2) * MARGIN,
      y: itemY - Math.sin(angle2) * MARGIN
    };
    var smoothConnector = item.labelLine.smooth;
    var path2 = [];
    var dx = endPoint.x - center2.x;
    var dy = endPoint.y - center2.y;
    var endAngle = Math.atan(dy / dx);
    if (dx < 0) {
      endAngle += Math.PI;
    }
    if (smoothConnector === false) {
      if (!isObject(item.labelLine)) {
        item.labelLine = {};
      }
      var sweepFlag = 0;
      if (angle2 < 0 && angle2 > -Math.PI / 2 || angle2 > Math.PI * 1.5) {
        if (endPoint.y > startPoint.y) {
          sweepFlag = 1;
        }
      }
      if (angle2 >= 0 && angle2 < Math.PI / 2) {
        if (endPoint.y > startPoint.y) {
          sweepFlag = 1;
        }
      }
      if (angle2 >= Math.PI / 2 && angle2 < Math.PI) {
        if (startPoint.y > endPoint.y) {
          sweepFlag = 1;
        }
      }
      if (angle2 < -Math.PI / 2 || angle2 >= Math.PI && angle2 < Math.PI * 1.5) {
        if (startPoint.y > endPoint.y) {
          sweepFlag = 1;
        }
      }
      var distance2 = labelOffset / 2 > 4 ? 4 : Math.max(labelOffset / 2 - 1, 0);
      var breakPoint = polarToCartesian(center2.x, center2.y, radius + distance2, angle2);
      var breakPoint3 = polarToCartesian(center2.x, center2.y, radius + labelOffset / 2, endAngle);
      var largeArcFlag = 0;
      path2.push("M ".concat(startPoint.x, " ").concat(startPoint.y));
      path2.push("L ".concat(breakPoint.x, " ").concat(breakPoint.y));
      path2.push("A ".concat(center2.x, " ").concat(center2.y, " 0 ").concat(largeArcFlag, " ").concat(sweepFlag, " ").concat(breakPoint3.x, " ").concat(breakPoint3.y));
      path2.push("L ".concat(endPoint.x, " ").concat(endPoint.y));
    } else {
      var breakPoint = polarToCartesian(center2.x, center2.y, radius + (labelOffset / 2 > 4 ? 4 : Math.max(labelOffset / 2 - 1, 0)), angle2);
      var xSign = startPoint.x < center2.x ? 1 : -1;
      path2.push("M ".concat(endPoint.x, " ").concat(endPoint.y));
      var slope1 = (startPoint.y - center2.y) / (startPoint.x - center2.x);
      var slope2 = (endPoint.y - center2.y) / (endPoint.x - center2.x);
      if (Math.abs(slope1 - slope2) > Math.pow(Math.E, -16)) {
        path2.push.apply(path2, [
          "C",
          endPoint.x + xSign * 4,
          endPoint.y,
          2 * breakPoint.x - startPoint.x,
          2 * breakPoint.y - startPoint.y,
          startPoint.x,
          startPoint.y
        ]);
      }
      path2.push("L ".concat(startPoint.x, " ").concat(startPoint.y));
    }
    item.labelLine.path = path2.join(" ");
  }
}
function pieOuterLabelLayout(originalItems, labels, shapes, region) {
  var e_1, _a2;
  var items = filter(originalItems, function(item) {
    return !isNil(item);
  });
  var coordinate2 = labels[0] && labels[0].get("coordinate");
  if (!coordinate2) {
    return;
  }
  var center2 = coordinate2.getCenter();
  var radius = coordinate2.getRadius();
  var labelsMap = {};
  try {
    for (var labels_1 = __values(labels), labels_1_1 = labels_1.next(); !labels_1_1.done; labels_1_1 = labels_1.next()) {
      var labelShape = labels_1_1.value;
      labelsMap[labelShape.get("id")] = labelShape;
    }
  } catch (e_1_1) {
    e_1 = { error: e_1_1 };
  } finally {
    try {
      if (labels_1_1 && !labels_1_1.done && (_a2 = labels_1.return))
        _a2.call(labels_1);
    } finally {
      if (e_1)
        throw e_1.error;
    }
  }
  var labelHeight = get(items[0], "labelHeight", 14);
  var labelOffset = get(items[0], "offset", 0);
  if (labelOffset <= 0) {
    return;
  }
  var LEFT_HALF_KEY = "left";
  var RIGHT_HALF_KEY = "right";
  var separateLabels = groupBy(items, function(item) {
    return item.x < center2.x ? LEFT_HALF_KEY : RIGHT_HALF_KEY;
  });
  var start = coordinate2.start, end = coordinate2.end;
  var totalHeight = Math.min((radius + labelOffset + labelHeight) * 2, coordinate2.getHeight());
  var totalR = totalHeight / 2;
  var labelsContainerRange = {
    minX: start.x,
    maxX: end.x,
    minY: center2.y - totalR,
    maxY: center2.y + totalR
  };
  each$1(separateLabels, function(half, key2) {
    var maxLabelsCountForOneSide = Math.floor(totalHeight / labelHeight);
    if (half.length > maxLabelsCountForOneSide) {
      half.sort(function(a2, b10) {
        return b10.percent - a2.percent;
      });
      each$1(half, function(labelItem, idx) {
        if (idx + 1 > maxLabelsCountForOneSide) {
          labelsMap[labelItem.id].set("visible", false);
          labelItem.invisible = true;
        }
      });
    }
    antiCollision(half, labelHeight, labelsContainerRange);
  });
  each$1(separateLabels, function(half, key2) {
    each$1(half, function(item) {
      var isRight = key2 === RIGHT_HALF_KEY;
      var labelShape2 = labelsMap[item.id];
      var content = labelShape2.getChildByIndex(0);
      if (content) {
        var r2 = radius + labelOffset;
        var dy = item.y - center2.y;
        var rPow2 = Math.pow(r2, 2);
        var dyPow2 = Math.pow(dy, 2);
        var dxPow2 = rPow2 - dyPow2 > 0 ? rPow2 - dyPow2 : 0;
        var dx = Math.sqrt(dxPow2);
        var dx_offset = Math.abs(Math.cos(item.angle) * r2);
        if (!isRight) {
          item.x = center2.x - Math.max(dx, dx_offset);
        } else {
          item.x = center2.x + Math.max(dx, dx_offset);
        }
      }
      if (content) {
        content.attr("y", item.y);
        content.attr("x", item.x);
      }
      drawLabelline$1(item, coordinate2);
    });
  });
}
var INFLECTION_OFFSET = 4;
var LABEL_OFFSET_X = 4;
var LABEL_TEXT_LINE_OFFSET = 4;
function drawLabelline(item, coordinate2, inRight) {
  var center2 = coordinate2.getCenter();
  var radius = coordinate2.getRadius();
  var startPoint = {
    x: item.x - (inRight ? LABEL_TEXT_LINE_OFFSET : -LABEL_TEXT_LINE_OFFSET),
    y: item.y
  };
  var inflectionPoint = polarToCartesian(center2.x, center2.y, radius + INFLECTION_OFFSET, item.angle);
  var p1 = { x: startPoint.x, y: startPoint.y };
  var p2 = { x: inflectionPoint.x, y: inflectionPoint.y };
  var endPoint = polarToCartesian(center2.x, center2.y, radius, item.angle);
  var path2 = "";
  if (startPoint.y !== inflectionPoint.y) {
    var offset3 = inRight ? 4 : -4;
    p1.y = startPoint.y;
    if (item.angle < 0 && item.angle >= -Math.PI / 2) {
      p1.x = Math.max(inflectionPoint.x, startPoint.x - offset3);
      if (startPoint.y < inflectionPoint.y) {
        p2.y = p1.y;
      } else {
        p2.y = inflectionPoint.y;
        p2.x = Math.max(p2.x, p1.x - offset3);
      }
    }
    if (item.angle > 0 && item.angle < Math.PI / 2) {
      p1.x = Math.max(inflectionPoint.x, startPoint.x - offset3);
      if (startPoint.y > inflectionPoint.y) {
        p2.y = p1.y;
      } else {
        p2.y = inflectionPoint.y;
        p2.x = Math.max(p2.x, p1.x - offset3);
      }
    }
    if (item.angle > Math.PI / 2) {
      p1.x = Math.min(inflectionPoint.x, startPoint.x - offset3);
      if (startPoint.y > inflectionPoint.y) {
        p2.y = p1.y;
      } else {
        p2.y = inflectionPoint.y;
        p2.x = Math.min(p2.x, p1.x - offset3);
      }
    }
    if (item.angle < -Math.PI / 2) {
      p1.x = Math.min(inflectionPoint.x, startPoint.x - offset3);
      if (startPoint.y < inflectionPoint.y) {
        p2.y = p1.y;
      } else {
        p2.y = inflectionPoint.y;
        p2.x = Math.min(p2.x, p1.x - offset3);
      }
    }
  }
  path2 = [
    "M ".concat(startPoint.x, ",").concat(startPoint.y),
    "L ".concat(p1.x, ",").concat(p1.y),
    "L ".concat(p2.x, ",").concat(p2.y),
    "L ".concat(inflectionPoint.x, ",").concat(inflectionPoint.y),
    "L ".concat(endPoint.x, ",").concat(endPoint.y)
  ].join(" ");
  item.labelLine = deepMix({}, item.labelLine, { path: path2 });
}
function pieSpiderLabelLayout(items, labels, shapes, region) {
  var e_1, _a2;
  var coordinate2 = labels[0] && labels[0].get("coordinate");
  if (!coordinate2) {
    return;
  }
  var center2 = coordinate2.getCenter();
  var radius = coordinate2.getRadius();
  var labelsMap = {};
  try {
    for (var labels_1 = __values(labels), labels_1_1 = labels_1.next(); !labels_1_1.done; labels_1_1 = labels_1.next()) {
      var labelShape = labels_1_1.value;
      labelsMap[labelShape.get("id")] = labelShape;
    }
  } catch (e_1_1) {
    e_1 = { error: e_1_1 };
  } finally {
    try {
      if (labels_1_1 && !labels_1_1.done && (_a2 = labels_1.return))
        _a2.call(labels_1);
    } finally {
      if (e_1)
        throw e_1.error;
    }
  }
  var labelHeight = get(items[0], "labelHeight", 14);
  var labelOffset = Math.max(get(items[0], "offset", 0), INFLECTION_OFFSET);
  each$1(items, function(item) {
    if (!item)
      return;
    var label2 = get(labelsMap, [item.id]);
    if (!label2)
      return;
    var inRight = item.x > center2.x || item.x === center2.x && item.y > center2.y;
    var offsetX = !isNil(item.offsetX) ? item.offsetX : LABEL_OFFSET_X;
    var inflectionPoint = polarToCartesian(center2.x, center2.y, radius + INFLECTION_OFFSET, item.angle);
    var totalOffset = labelOffset + offsetX;
    item.x = center2.x + (inRight ? 1 : -1) * (radius + totalOffset);
    item.y = inflectionPoint.y;
  });
  var start = coordinate2.start, end = coordinate2.end;
  var LEFT_HALF_KEY = "left";
  var RIGHT_HALF_KEY = "right";
  var separateLabels = groupBy(items, function(item) {
    return item.x < center2.x ? LEFT_HALF_KEY : RIGHT_HALF_KEY;
  });
  var totalHeight = (radius + labelOffset) * 2 + labelHeight;
  each$1(separateLabels, function(half) {
    var halfHeight = half.length * labelHeight;
    if (halfHeight > totalHeight) {
      totalHeight = Math.min(halfHeight, Math.abs(start.y - end.y));
    }
  });
  var labelsContainerRange = {
    minX: start.x,
    maxX: end.x,
    minY: center2.y - totalHeight / 2,
    maxY: center2.y + totalHeight / 2
  };
  each$1(separateLabels, function(half, key2) {
    var maxLabelsCountForOneSide = totalHeight / labelHeight;
    if (half.length > maxLabelsCountForOneSide) {
      half.sort(function(a2, b10) {
        return b10.percent - a2.percent;
      });
      each$1(half, function(labelItem, idx) {
        if (idx > maxLabelsCountForOneSide) {
          labelsMap[labelItem.id].set("visible", false);
          labelItem.invisible = true;
        }
      });
    }
    antiCollision(half, labelHeight, labelsContainerRange);
  });
  var startY = labelsContainerRange.minY;
  var endY = labelsContainerRange.maxY;
  each$1(separateLabels, function(half, key2) {
    var inRight = key2 === RIGHT_HALF_KEY;
    each$1(half, function(item) {
      var label2 = get(labelsMap, item && [item.id]);
      if (!label2) {
        return;
      }
      if (item.y < startY || item.y > endY) {
        label2.set("visible", false);
        return;
      }
      var labelContent = label2.getChildByIndex(0);
      var box2 = labelContent.getCanvasBBox();
      var originalPos = { x: inRight ? box2.x : box2.maxX, y: box2.y + box2.height / 2 };
      translate(labelContent, item.x - originalPos.x, item.y - originalPos.y);
      if (item.labelLine) {
        drawLabelline(item, coordinate2, inRight);
      }
    });
  });
}
function limitInCanvas(items, labels, shapes, region) {
  each$1(labels, function(label2) {
    var regionMinX = region.minX, regionMinY = region.minY, regionMaxX = region.maxX, regionMaxY = region.maxY;
    var _a2 = label2.getCanvasBBox(), minX = _a2.minX, minY = _a2.minY, maxX = _a2.maxX, maxY2 = _a2.maxY, x2 = _a2.x, y2 = _a2.y, width = _a2.width, height = _a2.height;
    var finalX = x2;
    var finalY = y2;
    if (minX < regionMinX || maxX < regionMinX) {
      finalX = regionMinX;
    }
    if (minY < regionMinY || maxY2 < regionMinY) {
      finalY = regionMinY;
    }
    if (minX > regionMaxX) {
      finalX = regionMaxX - width;
    } else if (maxX > regionMaxX) {
      finalX = finalX - (maxX - regionMaxX);
    }
    if (minY > regionMaxY) {
      finalY = regionMaxY - height;
    } else if (maxY2 > regionMaxY) {
      finalY = finalY - (maxY2 - regionMaxY);
    }
    if (finalX !== x2 || finalY !== y2) {
      translate(label2, finalX - x2, finalY - y2);
    }
  });
}
function limitInShape(items, labels, shapes, region) {
  each$1(labels, function(label2, index2) {
    var labelBBox = label2.getCanvasBBox();
    var shapeBBox = shapes[index2].getBBox();
    if (labelBBox.minX < shapeBBox.minX || labelBBox.minY < shapeBBox.minY || labelBBox.maxX > shapeBBox.maxX || labelBBox.maxY > shapeBBox.maxY) {
      label2.remove(true);
    }
  });
}
var MAX_TIMES = 100;
var Greedy = function() {
  function Greedy2(cfg) {
    if (cfg === void 0) {
      cfg = {};
    }
    this.bitmap = {};
    var _a2 = cfg.xGap, xGap = _a2 === void 0 ? 1 : _a2, _b = cfg.yGap, yGap = _b === void 0 ? 8 : _b;
    this.xGap = xGap;
    this.yGap = yGap;
  }
  Greedy2.prototype.hasGap = function(bbox) {
    var hasGap = true;
    var bitmap = this.bitmap;
    var minX = Math.round(bbox.minX);
    var maxX = Math.round(bbox.maxX);
    var minY = Math.round(bbox.minY);
    var maxY2 = Math.round(bbox.maxY);
    for (var i2 = minX; i2 <= maxX; i2 += 1) {
      if (!bitmap[i2]) {
        bitmap[i2] = {};
        continue;
      }
      if (i2 === minX || i2 === maxX) {
        for (var j2 = minY; j2 <= maxY2; j2++) {
          if (bitmap[i2][j2]) {
            hasGap = false;
            break;
          }
        }
      } else {
        if (bitmap[i2][minY] || bitmap[i2][maxY2]) {
          hasGap = false;
          break;
        }
      }
    }
    return hasGap;
  };
  Greedy2.prototype.fillGap = function(bbox) {
    var bitmap = this.bitmap;
    var minX = Math.round(bbox.minX);
    var maxX = Math.round(bbox.maxX);
    var minY = Math.round(bbox.minY);
    var maxY2 = Math.round(bbox.maxY);
    for (var i2 = minX; i2 <= maxX; i2 += 1) {
      if (!bitmap[i2]) {
        bitmap[i2] = {};
      }
    }
    for (var i2 = minX; i2 <= maxX; i2 += this.xGap) {
      for (var j2 = minY; j2 <= maxY2; j2 += this.yGap) {
        bitmap[i2][j2] = true;
      }
      bitmap[i2][maxY2] = true;
    }
    if (this.yGap !== 1) {
      for (var i2 = minY; i2 <= maxY2; i2 += 1) {
        bitmap[minX][i2] = true;
        bitmap[maxX][i2] = true;
      }
    }
    if (this.xGap !== 1) {
      for (var i2 = minX; i2 <= maxX; i2 += 1) {
        bitmap[i2][minY] = true;
        bitmap[i2][maxY2] = true;
      }
    }
  };
  Greedy2.prototype.destroy = function() {
    this.bitmap = {};
  };
  return Greedy2;
}();
function spiralFill(label2, greedy, maxTimes) {
  if (maxTimes === void 0) {
    maxTimes = MAX_TIMES;
  }
  var dt = -1;
  var _a2 = label2.attr(), x2 = _a2.x, y2 = _a2.y;
  var bbox = label2.getCanvasBBox();
  var maxDelta = Math.sqrt(bbox.width * bbox.width + bbox.height * bbox.height);
  var dxdy;
  var t2 = -dt;
  var dx = 0;
  var dy = 0;
  var f2 = function(param) {
    var nt = param * 0.1;
    return [nt * Math.cos(nt), nt * Math.sin(nt)];
  };
  if (greedy.hasGap(bbox)) {
    greedy.fillGap(bbox);
    return true;
  }
  var canFill = false;
  var times = 0;
  var accessedCache = {};
  while (Math.min(Math.abs(dx), Math.abs(dy)) < maxDelta && times < maxTimes) {
    dxdy = f2(t2 += dt);
    dx = ~~dxdy[0];
    dy = ~~dxdy[1];
    if (!dx && !dy || accessedCache["".concat(dx, "-").concat(dy)]) {
      continue;
    }
    label2.attr({ x: x2 + dx, y: y2 + dy });
    if (dx + dy < 0) {
      label2.attr("textAlign", "right");
    }
    times++;
    if (greedy.hasGap(label2.getCanvasBBox())) {
      greedy.fillGap(label2.getCanvasBBox());
      canFill = true;
      accessedCache["".concat(dx, "-").concat(dy)] = true;
      break;
    }
  }
  return canFill;
}
function adjustLabelPosition(label2, x2, y2, index2) {
  var _a2 = label2.getCanvasBBox(), width = _a2.width, height = _a2.height;
  var attrs = {
    x: x2,
    y: y2,
    textAlign: "center"
  };
  switch (index2) {
    case 0:
      attrs.y -= height + 1;
      attrs.x += 1;
      attrs.textAlign = "left";
      break;
    case 1:
      attrs.y -= height + 1;
      attrs.x -= 1;
      attrs.textAlign = "right";
      break;
    case 2:
      attrs.y += height + 1;
      attrs.x -= 1;
      attrs.textAlign = "right";
      break;
    case 3:
      attrs.y += height + 1;
      attrs.x += 1;
      attrs.textAlign = "left";
      break;
    case 5:
      attrs.y -= height * 2 + 2;
      break;
    case 6:
      attrs.y += height * 2 + 2;
      break;
    case 7:
      attrs.x += width + 1;
      attrs.textAlign = "left";
      break;
    case 8:
      attrs.x -= width + 1;
      attrs.textAlign = "right";
      break;
  }
  label2.attr(attrs);
  return label2.getCanvasBBox();
}
function fixedOverlap(items, labels, shapes, region) {
  var greedy = new Greedy();
  each$1(labels, function(label2) {
    var labelShape = label2.find(function(shape) {
      return shape.get("type") === "text";
    });
    if (!spiralFill(labelShape, greedy)) {
      label2.remove(true);
    }
  });
  greedy.destroy();
}
function overlap(items, labels, shapes, region) {
  var greedy = new Greedy();
  each$1(labels, function(label2) {
    var labelShape = label2.find(function(shape) {
      return shape.get("type") === "text";
    });
    var _a2 = labelShape.attr(), x2 = _a2.x, y2 = _a2.y;
    var canFill = false;
    for (var i2 = 0; i2 <= 8; i2++) {
      var bbox = adjustLabelPosition(labelShape, x2, y2, i2);
      if (greedy.hasGap(bbox)) {
        greedy.fillGap(bbox);
        canFill = true;
        break;
      }
    }
    if (!canFill) {
      label2.remove(true);
    }
  });
  greedy.destroy();
}
function dot$1(a2, b10) {
  return (a2[0] || 0) * (b10[0] || 0) + (a2[1] || 0) * (b10[1] || 0) + (a2[2] || 0) * (b10[2] || 0);
}
function getAxes(points2) {
  if (points2.length > 4) {
    return [];
  }
  var vector = function(start, end) {
    return [end.x - start.x, end.y - start.y];
  };
  var AB = vector(points2[0], points2[1]);
  var BC = vector(points2[1], points2[2]);
  return [AB, BC];
}
function rotateAtPoint(point2, deg, origin) {
  if (deg === void 0) {
    deg = 0;
  }
  if (origin === void 0) {
    origin = { x: 0, y: 0 };
  }
  var x2 = point2.x, y2 = point2.y;
  return {
    x: (x2 - origin.x) * Math.cos(-deg) + (y2 - origin.y) * Math.sin(-deg) + origin.x,
    y: (origin.x - x2) * Math.sin(-deg) + (y2 - origin.y) * Math.cos(-deg) + origin.y
  };
}
function getRectPoints(box2) {
  var points2 = [
    { x: box2.x, y: box2.y },
    { x: box2.x + box2.width, y: box2.y },
    { x: box2.x + box2.width, y: box2.y + box2.height },
    { x: box2.x, y: box2.y + box2.height }
  ];
  var rotation = box2.rotation;
  if (rotation) {
    return [
      rotateAtPoint(points2[0], rotation, points2[0]),
      rotateAtPoint(points2[1], rotation, points2[0]),
      rotateAtPoint(points2[2], rotation, points2[0]),
      rotateAtPoint(points2[3], rotation, points2[0])
    ];
  }
  return points2;
}
function getProjection(points2, axis2) {
  if (points2.length > 4) {
    return { min: 0, max: 0 };
  }
  var scalars = [];
  points2.forEach(function(point2) {
    scalars.push(dot$1([point2.x, point2.y], axis2));
  });
  return { min: Math.min.apply(Math, __spreadArray$1([], __read(scalars), false)), max: Math.max.apply(Math, __spreadArray$1([], __read(scalars), false)) };
}
function isProjectionOverlap(projection1, projection2) {
  return projection1.max > projection2.min && projection1.min < projection2.max;
}
function isValidNumber(d2) {
  return typeof d2 === "number" && !Number.isNaN(d2) && d2 !== Infinity && d2 !== -Infinity;
}
function isValidBox(box2) {
  return ["x", "y", "width", "height"].every(function(attr) {
    return isValidNumber(box2[attr]);
  });
}
function isIntersectRect(box1, box2, margin) {
  if (margin === void 0) {
    margin = 0;
  }
  return !(box2.x > box1.x + box1.width + margin || box2.x + box2.width < box1.x - margin || box2.y > box1.y + box1.height + margin || box2.y + box2.height < box1.y - margin);
}
function intersect(box1, box2, margin) {
  if (margin === void 0) {
    margin = 0;
  }
  if (!isValidBox(box1) || !isValidBox(box2))
    return false;
  if (!box1.rotation && !box2.rotation) {
    return isIntersectRect(box1, box2, margin);
  }
  var rect1Points = getRectPoints(box1);
  var rect2Points = getRectPoints(box2);
  var axes = getAxes(rect1Points).concat(getAxes(rect2Points));
  for (var i2 = 0; i2 < axes.length; i2++) {
    var axis2 = axes[i2];
    var projection1 = getProjection(rect1Points, axis2);
    var projection2 = getProjection(rect2Points, axis2);
    if (!isProjectionOverlap(projection1, projection2)) {
      return false;
    }
  }
  return true;
}
var MyWorker = function() {
  function MyWorker2(url2) {
    var _this = this;
    this.queue = [];
    this.worker = new Worker(url2);
    this.worker.onmessage = function(e3) {
      var _a2;
      (_a2 = _this.queue.shift()) === null || _a2 === void 0 ? void 0 : _a2.resolve(e3);
    };
    this.worker.onmessageerror = function(e3) {
      var _a2;
      console.warn("[AntV G2] Web worker is not available");
      (_a2 = _this.queue.shift()) === null || _a2 === void 0 ? void 0 : _a2.reject(e3);
    };
  }
  MyWorker2.prototype.post = function(params, onError) {
    var _this = this;
    return new Promise(function(resolve, reject) {
      _this.queue.push({ resolve, reject });
      try {
        _this.worker.postMessage(params);
      } catch (e3) {
        console.warn("[AntV G2] Web worker is not available");
        isFunction(onError) && onError();
      }
    });
  };
  MyWorker2.prototype.destroy = function() {
    this.worker.terminate();
  };
  return MyWorker2;
}();
function createWorker(f2) {
  if (typeof window === "undefined")
    return;
  var blob;
  try {
    blob = new Blob([f2.toString()], { type: "application/javascript" });
  } catch (e3) {
    blob = new window.BlobBuilder();
    blob.append(f2.toString());
    blob = blob.getBlob();
  }
  return new MyWorker(URL.createObjectURL(blob));
}
var onmessage = function(e3) {
  function generateUtils() {
    function dot2(a2, b10) {
      return (a2[0] || 0) * (b10[0] || 0) + (a2[1] || 0) * (b10[1] || 0) + (a2[2] || 0) * (b10[2] || 0);
    }
    function getAxes2(points2) {
      if (points2.length > 4) {
        return [];
      }
      var vector = function(start, end) {
        return [end.x - start.x, end.y - start.y];
      };
      var AB = vector(points2[0], points2[1]);
      var BC = vector(points2[1], points2[2]);
      return [AB, BC];
    }
    function rotateAtPoint2(point2, deg, origin) {
      if (deg === void 0) {
        deg = 0;
      }
      if (origin === void 0) {
        origin = { x: 0, y: 0 };
      }
      var x2 = point2.x, y2 = point2.y;
      return {
        x: (x2 - origin.x) * Math.cos(-deg) + (y2 - origin.y) * Math.sin(-deg) + origin.x,
        y: (origin.x - x2) * Math.sin(-deg) + (y2 - origin.y) * Math.cos(-deg) + origin.y
      };
    }
    function getRectPoints2(box2) {
      var points2 = [
        { x: box2.x, y: box2.y },
        { x: box2.x + box2.width, y: box2.y },
        { x: box2.x + box2.width, y: box2.y + box2.height },
        { x: box2.x, y: box2.y + box2.height }
      ];
      var rotation = box2.rotation;
      if (rotation) {
        return [
          rotateAtPoint2(points2[0], rotation, points2[0]),
          rotateAtPoint2(points2[1], rotation, points2[0]),
          rotateAtPoint2(points2[2], rotation, points2[0]),
          rotateAtPoint2(points2[3], rotation, points2[0])
        ];
      }
      return points2;
    }
    function getProjection2(points2, axis2) {
      if (points2.length > 4) {
        return { min: 0, max: 0 };
      }
      var scalars = [];
      points2.forEach(function(point2) {
        scalars.push(dot2([point2.x, point2.y], axis2));
      });
      return { min: Math.min.apply(null, scalars), max: Math.max.apply(null, scalars) };
    }
    function isProjectionOverlap2(projection1, projection2) {
      return projection1.max > projection2.min && projection1.min < projection2.max;
    }
    function isValidNumber2(d2) {
      return typeof d2 === "number" && !Number.isNaN(d2) && d2 !== Infinity && d2 !== -Infinity;
    }
    function isValidBox2(box2) {
      return ["x", "y", "width", "height"].every(function(attr) {
        return isValidNumber2(box2[attr]);
      });
    }
    function isIntersectRect2(box1, box2, margin) {
      if (margin === void 0) {
        margin = 0;
      }
      return !(box2.x > box1.x + box1.width + margin || box2.x + box2.width < box1.x - margin || box2.y > box1.y + box1.height + margin || box2.y + box2.height < box1.y - margin);
    }
    function intersect3(box1, box2, margin) {
      if (margin === void 0) {
        margin = 0;
      }
      if (!isValidBox2(box1) || !isValidBox2(box2))
        return false;
      if (!box1.rotation && !box2.rotation) {
        return isIntersectRect2(box1, box2, margin);
      }
      var rect1Points = getRectPoints2(box1);
      var rect2Points = getRectPoints2(box2);
      var axes = getAxes2(rect1Points).concat(getAxes2(rect2Points));
      for (var i2 = 0; i2 < axes.length; i2++) {
        var axis2 = axes[i2];
        var projection1 = getProjection2(rect1Points, axis2);
        var projection2 = getProjection2(rect2Points, axis2);
        if (!isProjectionOverlap2(projection1, projection2))
          return false;
      }
      return true;
    }
    return { intersect: intersect3 };
  }
  var intersect2 = generateUtils().intersect;
  function hideOverlap2(items2) {
    var boxes = items2.slice();
    for (var i2 = 0; i2 < boxes.length; i2++) {
      var box1 = boxes[i2];
      if (box1.visible) {
        for (var j2 = i2 + 1; j2 < boxes.length; j2++) {
          var box2 = boxes[j2];
          if (box1 !== box2 && box2.visible) {
            if (intersect2(box1, box2)) {
              box2.visible = false;
            }
          }
        }
      }
    }
    return boxes;
  }
  var methods = {
    "hide-overlap": hideOverlap2
  };
  try {
    var eventData = JSON.parse(e3.data);
    if (!eventData || !eventData.type || !methods[eventData.type])
      return;
    var type4 = eventData.type, items = eventData.items;
    var result = methods[type4](items);
    self.postMessage(result);
  } catch (e4) {
    throw e4;
  }
};
var code = "\n   self.onmessage = ".concat(onmessage.toString(), "\n");
var layout = function(items) {
  var boxes = items.slice();
  for (var i2 = 0; i2 < boxes.length; i2++) {
    var box1 = boxes[i2];
    if (box1.visible) {
      for (var j2 = i2 + 1; j2 < boxes.length; j2++) {
        var box2 = boxes[j2];
        if (box1 !== box2 && box2.visible) {
          if (intersect(box1, box2)) {
            box2.visible = false;
          }
        }
      }
    }
  }
  return boxes;
};
var cache = /* @__PURE__ */ new Map();
var worker = createWorker(code);
function hideOverlap(labelItems, labels, shapes, region) {
  return __awaiter(this, void 0, void 0, function() {
    var boxes, memoKey, cb2, params, res, e_1;
    return __generator(this, function(_a2) {
      switch (_a2.label) {
        case 0:
          boxes = labels.map(function(d2, idx) {
            return __assign$4(__assign$4({}, getLabelBackgroundInfo(d2, labelItems[idx], get(labelItems[idx], "background.padding"))), { visible: true });
          });
          memoKey = JSON.stringify(boxes);
          cb2 = function(items) {
            cache.set(memoKey, items);
            each$1(items, function(_a3, idx) {
              var visible = _a3.visible;
              var labelShape = labels[idx];
              if (visible) {
                labelShape === null || labelShape === void 0 ? void 0 : labelShape.show();
              } else {
                labelShape === null || labelShape === void 0 ? void 0 : labelShape.hide();
              }
            });
            return items;
          };
          if (!cache.get(memoKey))
            return [3, 1];
          cb2(cache.get(memoKey));
          return [3, 7];
        case 1:
          if (!worker)
            return [3, 6];
          _a2.label = 2;
        case 2:
          _a2.trys.push([2, 4, , 5]);
          params = JSON.stringify({ type: "hide-overlap", items: boxes });
          return [4, worker.post(params, function() {
            return cb2(layout(boxes));
          })];
        case 3:
          res = _a2.sent();
          cb2(Array.isArray(res.data) ? res.data : []);
          return [3, 5];
        case 4:
          e_1 = _a2.sent();
          console.error(e_1);
          cb2(layout(boxes));
          return [3, 5];
        case 5:
          return [3, 7];
        case 6:
          cb2(layout(boxes));
          _a2.label = 7;
        case 7:
          return [2];
      }
    });
  });
}
var preset = {
  "#5B8FF9": true
};
var isContrastColorWhite = function(color2) {
  var rgb2 = colorUtil.toRGB(color2).toUpperCase();
  if (preset[rgb2]) {
    return preset[rgb2];
  }
  var _a2 = __read(colorUtil.rgb2arr(rgb2), 3), r2 = _a2[0], g2 = _a2[1], b10 = _a2[2];
  var isDark = (r2 * 299 + g2 * 587 + b10 * 114) / 1e3 < 128;
  return isDark;
};
function adjustColor(items, labels, shapes) {
  if (shapes.length === 0) {
    return;
  }
  var element = shapes[0].get("element");
  var theme2 = element.geometry.theme;
  var _a2 = theme2.labels || {}, fillColorLight = _a2.fillColorLight, fillColorDark = _a2.fillColorDark;
  shapes.forEach(function(shape, index2) {
    var label2 = labels[index2];
    var textShape = label2.find(function(el) {
      return el.get("type") === "text";
    });
    var shapeBBox = BBox.fromObject(shape.getBBox());
    var textBBox = BBox.fromObject(textShape.getCanvasBBox());
    var overflow = !shapeBBox.contains(textBBox);
    var bgColor = shape.attr("fill");
    var fillWhite = isContrastColorWhite(bgColor);
    if (!overflow) {
      if (fillWhite) {
        if (fillColorLight) {
          textShape.attr("fill", fillColorLight);
        }
      } else {
        if (fillColorDark) {
          textShape.attr("fill", fillColorDark);
        }
      }
    } else {
      textShape.attr(theme2.overflowLabels.style);
    }
  });
}
function shouldInShapeSingle(geometry2, label2, shape) {
  var coordinate2 = geometry2.coordinate;
  var textShape = findLabelTextShape(label2);
  var textBBox = BBox.fromObject(textShape.getCanvasBBox());
  var shapeBBox = BBox.fromObject(shape.getBBox());
  return coordinate2.isTransposed ? shapeBBox.height >= textBBox.height : shapeBBox.width >= textBBox.width;
}
function shouldInShape(geometry2, labels, shapes) {
  var isStack = !!geometry2.getAdjust("stack");
  return isStack || labels.every(function(label2, index2) {
    var shape = shapes[index2];
    return shouldInShapeSingle(geometry2, label2, shape);
  });
}
function moveInShape(geometry2, label2, shape) {
  var coordinate2 = geometry2.coordinate;
  var shapeBBox = BBox.fromObject(shape.getBBox());
  var textShape = findLabelTextShape(label2);
  if (coordinate2.isTransposed) {
    textShape.attr({
      x: shapeBBox.minX + shapeBBox.width / 2,
      textAlign: "center"
    });
  } else {
    textShape.attr({
      y: shapeBBox.minY + shapeBBox.height / 2,
      textBaseline: "middle"
    });
  }
}
function intervalAdjustPosition(items, labels, shapes) {
  var _a2;
  if (shapes.length === 0) {
    return;
  }
  var element = (_a2 = shapes[0]) === null || _a2 === void 0 ? void 0 : _a2.get("element");
  var geometry2 = element === null || element === void 0 ? void 0 : element.geometry;
  if (!geometry2 || geometry2.type !== "interval") {
    return;
  }
  var inShape = shouldInShape(geometry2, labels, shapes);
  if (inShape) {
    shapes.forEach(function(shape, index2) {
      var label2 = labels[index2];
      moveInShape(geometry2, label2, shape);
    });
  }
}
function filterLabel(labels) {
  var MAX_CNT = 500;
  var filteredLabels = [];
  var pages = Math.max(Math.floor(labels.length / MAX_CNT), 1);
  each$1(labels, function(label2, idx) {
    if (idx % pages === 0) {
      filteredLabels.push(label2);
    } else {
      label2.set("visible", false);
    }
  });
  return filteredLabels;
}
function intervalHideOverlap(items, labels, shapes) {
  var _a2;
  if (shapes.length === 0) {
    return;
  }
  var element = (_a2 = shapes[0]) === null || _a2 === void 0 ? void 0 : _a2.get("element");
  var geometry2 = element === null || element === void 0 ? void 0 : element.geometry;
  if (!geometry2 || geometry2.type !== "interval") {
    return;
  }
  var filteredLabels = filterLabel(labels);
  var _b = __read(geometry2.getXYFields(), 1), xField = _b[0];
  var dones = [];
  var todo = [];
  var groupedLabels = groupBy(filteredLabels, function(label2) {
    return label2.get("data")[xField];
  });
  var xValues = uniq$2(map$2(filteredLabels, function(label2) {
    return label2.get("data")[xField];
  }));
  var xValue;
  filteredLabels.forEach(function(label2) {
    label2.set("visible", true);
  });
  var addCurrentGroup = function(curItems) {
    if (curItems) {
      if (curItems.length) {
        todo.push(curItems.pop());
      }
      todo.push.apply(todo, __spreadArray$1([], __read(curItems), false));
    }
  };
  if (size(xValues) > 0) {
    xValue = xValues.shift();
    addCurrentGroup(groupedLabels[xValue]);
  }
  if (size(xValues) > 0) {
    xValue = xValues.pop();
    addCurrentGroup(groupedLabels[xValue]);
  }
  each$1(xValues.reverse(), function(val) {
    addCurrentGroup(groupedLabels[val]);
  });
  while (todo.length > 0) {
    var cur = todo.shift();
    if (cur.get("visible")) {
      if (checkShapeOverlap$2(cur, dones)) {
        cur.set("visible", false);
      } else {
        dones.push(cur);
      }
    }
  }
}
function sortLabels$1(geometry2, labels) {
  var yField = geometry2.getXYFields()[1];
  var result = [];
  var sortedLabels = labels.sort(function(left2, right2) {
    return left2.get("data")[yField] - left2.get("data")[yField];
  });
  if (sortedLabels.length > 0) {
    result.push(sortedLabels.shift());
  }
  if (sortedLabels.length > 0) {
    result.push(sortedLabels.pop());
  }
  result.push.apply(result, __spreadArray$1([], __read(sortedLabels), false));
  return result;
}
function hasSome$1(dones, current, compare2) {
  return dones.some(function(done) {
    return compare2(done, current);
  });
}
function getOverlapArea$1(a2, b10, margin) {
  if (margin === void 0) {
    margin = 0;
  }
  var xOverlap = Math.max(0, Math.min(a2.x + a2.width + margin, b10.x + b10.width + margin) - Math.max(a2.x - margin, b10.x - margin));
  var yOverlap = Math.max(0, Math.min(a2.y + a2.height + margin, b10.y + b10.height + margin) - Math.max(a2.y - margin, b10.y - margin));
  return xOverlap * yOverlap;
}
function checkShapeOverlap$1(dones, current) {
  return hasSome$1(dones, current, function(left2, right2) {
    var leftText = findLabelTextShape(left2);
    var rightText = findLabelTextShape(right2);
    return getOverlapArea$1(leftText.getCanvasBBox(), rightText.getCanvasBBox(), 2) > 0;
  });
}
function pointAdjustPosition(items, labels, shapes, region, cfg) {
  var _a2, _b;
  if (shapes.length === 0) {
    return;
  }
  var element = (_a2 = shapes[0]) === null || _a2 === void 0 ? void 0 : _a2.get("element");
  var geometry2 = element === null || element === void 0 ? void 0 : element.geometry;
  if (!geometry2 || geometry2.type !== "point") {
    return;
  }
  var _c = __read(geometry2.getXYFields(), 2), xField = _c[0], yField = _c[1];
  var groupedLabels = groupBy(labels, function(label2) {
    return label2.get("data")[xField];
  });
  var dones = [];
  var offset3 = cfg && cfg.offset || ((_b = items[0]) === null || _b === void 0 ? void 0 : _b.offset) || 12;
  map$2(keys(groupedLabels).reverse(), function(xValue) {
    var sortedCollections = sortLabels$1(geometry2, groupedLabels[xValue]);
    while (sortedCollections.length) {
      var current = sortedCollections.shift();
      var textShape = findLabelTextShape(current);
      if (hasSome$1(dones, current, function(left2, right2) {
        return left2.get("data")[xField] === right2.get("data")[xField] && left2.get("data")[yField] === right2.get("data")[yField];
      })) {
        textShape.set("visible", false);
        continue;
      }
      var upFail = checkShapeOverlap$1(dones, current);
      var downFail = false;
      if (upFail) {
        textShape.attr("y", textShape.attr("y") + 2 * offset3);
        downFail = checkShapeOverlap$1(dones, current);
      }
      if (downFail) {
        textShape.set("visible", false);
        continue;
      }
      dones.push(current);
    }
  });
}
function sortLabels(geometry2, labels) {
  var yField = geometry2.getXYFields()[1];
  var result = [];
  var sortedLabels = labels.sort(function(left2, right2) {
    return left2.get("data")[yField] - left2.get("data")[yField];
  });
  if (sortedLabels.length > 0) {
    result.push(sortedLabels.shift());
  }
  if (sortedLabels.length > 0) {
    result.push(sortedLabels.pop());
  }
  result.push.apply(result, __spreadArray$1([], __read(sortedLabels), false));
  return result;
}
function hasSome(dones, current, compare2) {
  return dones.some(function(done) {
    return compare2(done, current);
  });
}
function getOverlapArea(a2, b10, margin) {
  if (margin === void 0) {
    margin = 0;
  }
  var xOverlap = Math.max(0, Math.min(a2.x + a2.width + margin, b10.x + b10.width + margin) - Math.max(a2.x - margin, b10.x - margin));
  var yOverlap = Math.max(0, Math.min(a2.y + a2.height + margin, b10.y + b10.height + margin) - Math.max(a2.y - margin, b10.y - margin));
  return xOverlap * yOverlap;
}
function checkShapeOverlap(dones, current) {
  return hasSome(dones, current, function(left2, right2) {
    var leftText = findLabelTextShape(left2);
    var rightText = findLabelTextShape(right2);
    return getOverlapArea(leftText.getCanvasBBox(), rightText.getCanvasBBox(), 2) > 0;
  });
}
function pathAdjustPosition(items, labels, shapes, region, cfg) {
  var _a2, _b;
  if (shapes.length === 0) {
    return;
  }
  var element = (_a2 = shapes[0]) === null || _a2 === void 0 ? void 0 : _a2.get("element");
  var geometry2 = element === null || element === void 0 ? void 0 : element.geometry;
  if (!geometry2 || ["path", "line", "area"].indexOf(geometry2.type) < 0) {
    return;
  }
  var _c = __read(geometry2.getXYFields(), 2), xField = _c[0], yField = _c[1];
  var groupedLabels = groupBy(labels, function(label2) {
    return label2.get("data")[xField];
  });
  var dones = [];
  var offset3 = cfg && cfg.offset || ((_b = items[0]) === null || _b === void 0 ? void 0 : _b.offset) || 12;
  map$2(keys(groupedLabels).reverse(), function(xValue) {
    var sortedCollections = sortLabels(geometry2, groupedLabels[xValue]);
    while (sortedCollections.length) {
      var current = sortedCollections.shift();
      var textShape = findLabelTextShape(current);
      if (hasSome(dones, current, function(left2, right2) {
        return left2.get("data")[xField] === right2.get("data")[xField] && left2.get("data")[yField] === right2.get("data")[yField];
      })) {
        textShape.set("visible", false);
        continue;
      }
      var upFail = checkShapeOverlap(dones, current);
      var downFail = false;
      if (upFail) {
        textShape.attr("y", textShape.attr("y") + 2 * offset3);
        downFail = checkShapeOverlap(dones, current);
      }
      if (downFail) {
        textShape.set("visible", false);
        continue;
      }
      dones.push(current);
    }
  });
}
var ctx$1;
function getCanvasContext$1() {
  if (!ctx$1) {
    ctx$1 = document.createElement("canvas").getContext("2d");
  }
  return ctx$1;
}
var measureTextWidth = memoize(function(text2, font) {
  if (font === void 0) {
    font = {};
  }
  var fontSize = font.fontSize, fontFamily = font.fontFamily, fontWeight = font.fontWeight, fontStyle = font.fontStyle, fontVariant = font.fontVariant;
  var ctx2 = getCanvasContext$1();
  ctx2.font = [fontStyle, fontVariant, fontWeight, "".concat(fontSize, "px"), fontFamily].join(" ");
  return ctx2.measureText(isString(text2) ? text2 : "").width;
}, function(text2, font) {
  if (font === void 0) {
    font = {};
  }
  return __spreadArray$1([text2], __read(values(font)), false).join("");
});
var getEllipsisText = function(text2, maxWidth, font) {
  var STEP = 16;
  var DOT_WIDTH = measureTextWidth("...", font);
  var leftText;
  if (!isString(text2)) {
    leftText = toString$2(text2);
  } else {
    leftText = text2;
  }
  var leftWidth = maxWidth;
  var r2 = [];
  var currentText;
  var currentWidth;
  if (measureTextWidth(text2, font) <= maxWidth) {
    return text2;
  }
  while (true) {
    currentText = leftText.substr(0, STEP);
    currentWidth = measureTextWidth(currentText, font);
    if (currentWidth + DOT_WIDTH > leftWidth) {
      if (currentWidth > leftWidth) {
        break;
      }
    }
    r2.push(currentText);
    leftWidth -= currentWidth;
    leftText = leftText.substr(STEP);
    if (!leftText) {
      return r2.join("");
    }
  }
  while (true) {
    currentText = leftText.substr(0, 1);
    currentWidth = measureTextWidth(currentText, font);
    if (currentWidth + DOT_WIDTH > leftWidth) {
      break;
    }
    r2.push(currentText);
    leftWidth -= currentWidth;
    leftText = leftText.substr(1);
    if (!leftText) {
      return r2.join("");
    }
  }
  return "".concat(r2.join(""), "...");
};
function limitInPlot$3(items, labels, shapes, region, cfg) {
  if (labels.length <= 0) {
    return;
  }
  var direction2 = (cfg === null || cfg === void 0 ? void 0 : cfg.direction) || ["top", "right", "bottom", "left"];
  var action = (cfg === null || cfg === void 0 ? void 0 : cfg.action) || "translate";
  var margin = (cfg === null || cfg === void 0 ? void 0 : cfg.margin) || 0;
  var coordinate2 = labels[0].get("coordinate");
  if (!coordinate2) {
    return;
  }
  var _a2 = getCoordinateBBox(coordinate2, margin), regionMinX = _a2.minX, regionMinY = _a2.minY, regionMaxX = _a2.maxX, regionMaxY = _a2.maxY;
  each$1(labels, function(label2) {
    var _a3 = label2.getCanvasBBox(), minX = _a3.minX, minY = _a3.minY, maxX = _a3.maxX, maxY2 = _a3.maxY, x2 = _a3.x, y2 = _a3.y, width = _a3.width, height = _a3.height;
    var finalX = x2;
    var finalY = y2;
    if (direction2.indexOf("left") >= 0 && (minX < regionMinX || maxX < regionMinX)) {
      finalX = regionMinX;
    }
    if (direction2.indexOf("top") >= 0 && (minY < regionMinY || maxY2 < regionMinY)) {
      finalY = regionMinY;
    }
    if (direction2.indexOf("right") >= 0) {
      if (minX > regionMaxX) {
        finalX = regionMaxX - width;
      } else if (maxX > regionMaxX) {
        finalX = finalX - (maxX - regionMaxX);
      }
    }
    if (direction2.indexOf("bottom") >= 0) {
      if (minY > regionMaxY) {
        finalY = regionMaxY - height;
      } else if (maxY2 > regionMaxY) {
        finalY = finalY - (maxY2 - regionMaxY);
      }
    }
    if (finalX !== x2 || finalY !== y2) {
      var translateX_1 = finalX - x2;
      if (action === "translate") {
        translate(label2, translateX_1, finalY - y2);
      } else if (action === "ellipsis") {
        var textShapes = label2.findAll(function(shape) {
          return shape.get("type") === "text";
        });
        textShapes.forEach(function(textShape) {
          var style2 = pick$1(textShape.attr(), ["fontSize", "fontFamily", "fontWeight", "fontStyle", "fontVariant"]);
          var textBox = textShape.getCanvasBBox();
          var text2 = getEllipsisText(textShape.attr("text"), textBox.width - Math.abs(translateX_1), style2);
          textShape.attr("text", text2);
        });
      } else {
        label2.hide();
      }
    }
  });
}
function fadeIn(shape, animateCfg, cfg) {
  var endState = {
    fillOpacity: isNil(shape.attr("fillOpacity")) ? 1 : shape.attr("fillOpacity"),
    strokeOpacity: isNil(shape.attr("strokeOpacity")) ? 1 : shape.attr("strokeOpacity"),
    opacity: isNil(shape.attr("opacity")) ? 1 : shape.attr("opacity")
  };
  shape.attr({
    fillOpacity: 0,
    strokeOpacity: 0,
    opacity: 0
  });
  shape.animate(endState, animateCfg);
}
function fadeOut(shape, animateCfg, cfg) {
  var endState = {
    fillOpacity: 0,
    strokeOpacity: 0,
    opacity: 0
  };
  var easing = animateCfg.easing, duration = animateCfg.duration, delay = animateCfg.delay;
  shape.animate(endState, duration, easing, function() {
    shape.remove(true);
  }, delay);
}
function transformShape(shape, vector, direct) {
  var scaledMatrix;
  var _a2 = __read(vector, 2), x2 = _a2[0], y2 = _a2[1];
  shape.applyToMatrix([x2, y2, 1]);
  if (direct === "x") {
    shape.setMatrix(transform$6(shape.getMatrix(), [
      ["t", -x2, -y2],
      ["s", 0.01, 1],
      ["t", x2, y2]
    ]));
    scaledMatrix = transform$6(shape.getMatrix(), [
      ["t", -x2, -y2],
      ["s", 100, 1],
      ["t", x2, y2]
    ]);
  } else if (direct === "y") {
    shape.setMatrix(transform$6(shape.getMatrix(), [
      ["t", -x2, -y2],
      ["s", 1, 0.01],
      ["t", x2, y2]
    ]));
    scaledMatrix = transform$6(shape.getMatrix(), [
      ["t", -x2, -y2],
      ["s", 1, 100],
      ["t", x2, y2]
    ]);
  } else if (direct === "xy") {
    shape.setMatrix(transform$6(shape.getMatrix(), [
      ["t", -x2, -y2],
      ["s", 0.01, 0.01],
      ["t", x2, y2]
    ]));
    scaledMatrix = transform$6(shape.getMatrix(), [
      ["t", -x2, -y2],
      ["s", 100, 100],
      ["t", x2, y2]
    ]);
  }
  return scaledMatrix;
}
function doScaleAnimate(element, animateCfg, coordinate2, yMinPoint, type4) {
  var start = coordinate2.start, end = coordinate2.end;
  var width = coordinate2.getWidth();
  var height = coordinate2.getHeight();
  var x2;
  var y2;
  if (type4 === "y") {
    x2 = start.x + width / 2;
    y2 = yMinPoint.y < start.y ? yMinPoint.y : start.y;
  } else if (type4 === "x") {
    x2 = yMinPoint.x > start.x ? yMinPoint.x : start.x;
    y2 = start.y + height / 2;
  } else if (type4 === "xy") {
    if (coordinate2.isPolar) {
      x2 = coordinate2.getCenter().x;
      y2 = coordinate2.getCenter().y;
    } else {
      x2 = (start.x + end.x) / 2;
      y2 = (start.y + end.y) / 2;
    }
  }
  var endMatrix = transformShape(element, [x2, y2], type4);
  element.animate({
    matrix: endMatrix
  }, animateCfg);
}
function growInX(element, animateCfg, cfg) {
  var coordinate2 = cfg.coordinate, minYPoint = cfg.minYPoint;
  doScaleAnimate(element, animateCfg, coordinate2, minYPoint, "x");
}
function growInY(element, animateCfg, cfg) {
  var coordinate2 = cfg.coordinate, minYPoint = cfg.minYPoint;
  doScaleAnimate(element, animateCfg, coordinate2, minYPoint, "y");
}
function growInXY(element, animateCfg, cfg) {
  var coordinate2 = cfg.coordinate, minYPoint = cfg.minYPoint;
  doScaleAnimate(element, animateCfg, coordinate2, minYPoint, "xy");
}
function pathIn(element, animateCfg, cfg) {
  var length2 = element.getTotalLength();
  element.attr("lineDash", [length2]);
  element.animate(function(ratio) {
    return {
      lineDashOffset: (1 - ratio) * length2
    };
  }, animateCfg);
}
function positionUpdate(shape, animateCfg, cfg) {
  var toAttrs = cfg.toAttrs;
  var x2 = toAttrs.x;
  var y2 = toAttrs.y;
  delete toAttrs.x;
  delete toAttrs.y;
  shape.attr(toAttrs);
  shape.animate({
    x: x2,
    y: y2
  }, animateCfg);
}
function scaleInX(shape, animateCfg, cfg) {
  var box2 = shape.getBBox();
  var mappingData = shape.get("origin").mappingData;
  var points2 = mappingData.points;
  var x2 = points2[0].y - points2[1].y > 0 ? box2.maxX : box2.minX;
  var y2 = (box2.minY + box2.maxY) / 2;
  shape.applyToMatrix([x2, y2, 1]);
  var matrix = transform$6(shape.getMatrix(), [
    ["t", -x2, -y2],
    ["s", 0.01, 1],
    ["t", x2, y2]
  ]);
  shape.setMatrix(matrix);
  shape.animate({
    matrix: transform$6(shape.getMatrix(), [
      ["t", -x2, -y2],
      ["s", 100, 1],
      ["t", x2, y2]
    ])
  }, animateCfg);
}
function scaleInY(shape, animateCfg, cfg) {
  var box2 = shape.getBBox();
  var mappingData = shape.get("origin").mappingData;
  var x2 = (box2.minX + box2.maxX) / 2;
  var points2 = mappingData.points;
  var y2 = points2[0].y - points2[1].y <= 0 ? box2.maxY : box2.minY;
  shape.applyToMatrix([x2, y2, 1]);
  var matrix = transform$6(shape.getMatrix(), [
    ["t", -x2, -y2],
    ["s", 1, 0.01],
    ["t", x2, y2]
  ]);
  shape.setMatrix(matrix);
  shape.animate({
    matrix: transform$6(shape.getMatrix(), [
      ["t", -x2, -y2],
      ["s", 1, 100],
      ["t", x2, y2]
    ])
  }, animateCfg);
}
function getAngle(startPoint, arcPath) {
  var _a2;
  var _b = getArcParams(startPoint, arcPath), startAngle = _b.startAngle, endAngle = _b.endAngle;
  if (!isNumberEqual$1(startAngle, -Math.PI * 0.5) && startAngle < -Math.PI * 0.5) {
    startAngle += Math.PI * 2;
  }
  if (!isNumberEqual$1(endAngle, -Math.PI * 0.5) && endAngle < -Math.PI * 0.5) {
    endAngle += Math.PI * 2;
  }
  if (arcPath[5] === 0) {
    _a2 = __read([endAngle, startAngle], 2), startAngle = _a2[0], endAngle = _a2[1];
  }
  if (isNumberEqual$1(startAngle, Math.PI * 1.5)) {
    startAngle = Math.PI * -0.5;
  }
  if (isNumberEqual$1(endAngle, Math.PI * -0.5) && !isNumberEqual$1(startAngle, endAngle)) {
    endAngle = Math.PI * 1.5;
  }
  return {
    startAngle,
    endAngle
  };
}
function getArcStartPoint(path2) {
  var startPoint;
  if (path2[0] === "M" || path2[0] === "L") {
    startPoint = [path2[1], path2[2]];
  } else if (path2[0] === "a" || path2[0] === "A" || path2[0] === "C") {
    startPoint = [path2[path2.length - 2], path2[path2.length - 1]];
  }
  return startPoint;
}
function getArcInfo(path2) {
  var _a2;
  var startAngle;
  var endAngle;
  var arcPaths = path2.filter(function(command) {
    return command[0] === "A" || command[0] === "a";
  });
  if (arcPaths.length === 0) {
    return {
      startAngle: 0,
      endAngle: 0,
      radius: 0,
      innerRadius: 0
    };
  }
  var firstArcPathCommand = arcPaths[0];
  var lastArcPathCommand = arcPaths.length > 1 ? arcPaths[1] : arcPaths[0];
  var firstIndex = path2.indexOf(firstArcPathCommand);
  var lastIndex = path2.indexOf(lastArcPathCommand);
  var firstStartPoint = getArcStartPoint(path2[firstIndex - 1]);
  var lastStartPoint = getArcStartPoint(path2[lastIndex - 1]);
  var _b = getAngle(firstStartPoint, firstArcPathCommand), firstStartAngle = _b.startAngle, firstEndAngle = _b.endAngle;
  var _c = getAngle(lastStartPoint, lastArcPathCommand), lastStartAngle = _c.startAngle, lastEndAngle = _c.endAngle;
  if (isNumberEqual$1(firstStartAngle, lastStartAngle) && isNumberEqual$1(firstEndAngle, lastEndAngle)) {
    startAngle = firstStartAngle;
    endAngle = firstEndAngle;
  } else {
    startAngle = Math.min(firstStartAngle, lastStartAngle);
    endAngle = Math.max(firstEndAngle, lastEndAngle);
  }
  var radius = firstArcPathCommand[1];
  var innerRadius = arcPaths[arcPaths.length - 1][1];
  if (radius < innerRadius) {
    _a2 = __read([innerRadius, radius], 2), radius = _a2[0], innerRadius = _a2[1];
  } else if (radius === innerRadius) {
    innerRadius = 0;
  }
  return {
    startAngle,
    endAngle,
    radius,
    innerRadius
  };
}
function sectorPathUpdate(shape, animateCfg, cfg) {
  var toAttrs = cfg.toAttrs, coordinate2 = cfg.coordinate;
  var path2 = toAttrs.path || [];
  var pathCommands = path2.map(function(command) {
    return command[0];
  });
  if (path2.length < 1)
    return;
  var _a2 = getArcInfo(path2), curStartAngle = _a2.startAngle, curEndAngle = _a2.endAngle, radius = _a2.radius, innerRadius = _a2.innerRadius;
  var _b = getArcInfo(shape.attr("path")), preStartAngle = _b.startAngle, preEndAngle = _b.endAngle;
  var center2 = coordinate2.getCenter();
  var diffStartAngle = curStartAngle - preStartAngle;
  var diffEndAngle = curEndAngle - preEndAngle;
  if (diffStartAngle === 0 && diffEndAngle === 0) {
    shape.attr("path", path2);
    return;
  }
  shape.animate(function(ratio) {
    var onFrameStartAngle = preStartAngle + ratio * diffStartAngle;
    var onFrameEndAngle = preEndAngle + ratio * diffEndAngle;
    return __assign$4(__assign$4({}, toAttrs), { path: isEqual$1(pathCommands, ["M", "A", "A", "Z"]) ? getArcPath(center2.x, center2.y, radius, onFrameStartAngle, onFrameEndAngle) : getSectorPath(center2.x, center2.y, radius, onFrameStartAngle, onFrameEndAngle, innerRadius) });
  }, __assign$4(__assign$4({}, animateCfg), { callback: function() {
    shape.attr("path", path2);
  } }));
}
function waveIn(element, animateCfg, cfg) {
  var _a2 = getCoordinateClipCfg(cfg.coordinate, 20), type4 = _a2.type, startState = _a2.startState, endState = _a2.endState;
  var clipShape = element.setClip({
    type: type4,
    attrs: startState
  });
  if (cfg.toAttrs) {
    element.attr(cfg.toAttrs);
  }
  clipShape.animate(endState, __assign$4(__assign$4({}, animateCfg), { callback: function() {
    if (element && !element.get("destroyed")) {
      element.set("clipShape", null);
    }
    clipShape.remove(true);
  } }));
}
function doShapeZoom(shape, animateCfg, type4) {
  if (shape.isGroup()) {
    each$1(shape.getChildren(), function(child) {
      doShapeZoom(child, animateCfg, type4);
    });
  } else {
    var bbox = shape.getBBox();
    var x2 = (bbox.minX + bbox.maxX) / 2;
    var y2 = (bbox.minY + bbox.maxY) / 2;
    shape.applyToMatrix([x2, y2, 1]);
    if (type4 === "zoomIn") {
      var matrix = transform$6(shape.getMatrix(), [
        ["t", -x2, -y2],
        ["s", 0.01, 0.01],
        ["t", x2, y2]
      ]);
      shape.setMatrix(matrix);
      shape.animate({
        matrix: transform$6(shape.getMatrix(), [
          ["t", -x2, -y2],
          ["s", 100, 100],
          ["t", x2, y2]
        ])
      }, animateCfg);
    } else {
      shape.animate({
        matrix: transform$6(shape.getMatrix(), [
          ["t", -x2, -y2],
          ["s", 0.01, 0.01],
          ["t", x2, y2]
        ])
      }, __assign$4(__assign$4({}, animateCfg), { callback: function() {
        shape.remove(true);
      } }));
    }
  }
}
function zoomIn(shape, animateCfg, cfg) {
  doShapeZoom(shape, animateCfg, "zoomIn");
}
function zoomOut(shape, animateCfg, cfg) {
  doShapeZoom(shape, animateCfg, "zoomOut");
}
function getFactTitleConfig(direction2) {
  if ([DIRECTION.TOP, DIRECTION.BOTTOM].includes(direction2)) {
    return {
      offsetX: 0,
      offsetY: direction2 === DIRECTION.TOP ? -8 : 8,
      style: {
        textAlign: "center",
        textBaseline: direction2 === DIRECTION.TOP ? "bottom" : "top"
      }
    };
  }
  if ([DIRECTION.LEFT, DIRECTION.RIGHT].includes(direction2)) {
    return {
      offsetX: direction2 === DIRECTION.LEFT ? -8 : 8,
      offsetY: 0,
      style: {
        textAlign: direction2 === DIRECTION.LEFT ? "right" : "left",
        textBaseline: "middle",
        rotate: Math.PI / 2
      }
    };
  }
  return {};
}
function getAnglePoint(center2, r2, angle2) {
  return {
    x: center2.x + r2 * Math.cos(angle2),
    y: center2.y + r2 * Math.sin(angle2)
  };
}
var Circle = function(_super) {
  __extends$3(Circle2, _super);
  function Circle2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Circle2.prototype.getDefaultCfg = function() {
    return deepMix({}, _super.prototype.getDefaultCfg.call(this), {
      type: "circle",
      showTitle: true,
      title: _super.prototype.getDefaultTitleCfg.call(this)
    });
  };
  Circle2.prototype.render = function() {
    _super.prototype.render.call(this);
    if (this.cfg.showTitle) {
      this.renderTitle();
    }
  };
  Circle2.prototype.getRegion = function(count2, index2) {
    var r2 = 1 / 2;
    var center2 = { x: 0.5, y: 0.5 };
    var avgAngle = Math.PI * 2 / count2;
    var angle2 = -1 * Math.PI / 2 + avgAngle * index2;
    var facetR = r2 / (1 + 1 / Math.sin(avgAngle / 2));
    var middle = getAnglePoint(center2, r2 - facetR, angle2);
    var startAngle = Math.PI * 5 / 4;
    var endAngle = Math.PI * 1 / 4;
    return {
      start: getAnglePoint(middle, facetR, startAngle),
      end: getAnglePoint(middle, facetR, endAngle)
    };
  };
  Circle2.prototype.afterEachView = function(view, facet) {
    this.processAxis(view, facet);
  };
  Circle2.prototype.beforeEachView = function(view, facet) {
  };
  Circle2.prototype.generateFacets = function(data2) {
    var _this = this;
    var _a2 = this.cfg, fields = _a2.fields, type4 = _a2.type;
    var _b = __read(fields, 1), field2 = _b[0];
    if (!field2) {
      throw new Error("No `fields` specified!");
    }
    var values2 = this.getFieldValues(data2, field2);
    var count2 = values2.length;
    var rst = [];
    values2.forEach(function(value2, index2) {
      var conditions = [{ field: field2, value: value2, values: values2 }];
      var facetData = filter(data2, _this.getFacetDataFilter(conditions));
      var facet = {
        type: type4,
        data: facetData,
        region: _this.getRegion(count2, index2),
        columnValue: value2,
        columnField: field2,
        columnIndex: index2,
        columnValuesLength: count2,
        rowValue: null,
        rowField: null,
        rowIndex: 0,
        rowValuesLength: 1
      };
      rst.push(facet);
    });
    return rst;
  };
  Circle2.prototype.getXAxisOption = function(x2, axes, option, facet) {
    return option;
  };
  Circle2.prototype.getYAxisOption = function(y2, axes, option, facet) {
    return option;
  };
  Circle2.prototype.renderTitle = function() {
    var _this = this;
    each$1(this.facets, function(facet) {
      var columnValue = facet.columnValue, view = facet.view;
      var formatter = get(_this.cfg.title, "formatter");
      var config = deepMix({
        position: ["50%", "0%"],
        content: formatter ? formatter(columnValue) : columnValue
      }, getFactTitleConfig(DIRECTION.TOP), _this.cfg.title);
      view.annotation().text(config);
    });
  };
  return Circle2;
}(Facet);
var List = function(_super) {
  __extends$3(List3, _super);
  function List3() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  List3.prototype.getDefaultCfg = function() {
    return deepMix({}, _super.prototype.getDefaultCfg.call(this), {
      type: "list",
      cols: null,
      showTitle: true,
      title: _super.prototype.getDefaultTitleCfg.call(this)
    });
  };
  List3.prototype.render = function() {
    _super.prototype.render.call(this);
    if (this.cfg.showTitle) {
      this.renderTitle();
    }
  };
  List3.prototype.afterEachView = function(view, facet) {
    this.processAxis(view, facet);
  };
  List3.prototype.beforeEachView = function(view, facet) {
  };
  List3.prototype.generateFacets = function(data2) {
    var _this = this;
    var fields = this.cfg.fields;
    var cols = this.cfg.cols;
    var _a2 = __read(fields, 1), columnField = _a2[0];
    if (!columnField) {
      throw new Error("No `fields` specified!");
    }
    var colValues = this.getFieldValues(data2, columnField);
    var count2 = colValues.length;
    cols = cols || count2;
    var rows = this.getPageCount(count2, cols);
    var rst = [];
    colValues.forEach(function(val, index2) {
      var _a3 = _this.getRowCol(index2, cols), row = _a3.row, col = _a3.col;
      var conditions = [{ field: columnField, value: val, values: colValues }];
      var facetData = filter(data2, _this.getFacetDataFilter(conditions));
      var facet = {
        type: _this.cfg.type,
        data: facetData,
        region: _this.getRegion(rows, cols, col, row),
        columnValue: val,
        rowValue: val,
        columnField,
        rowField: null,
        columnIndex: col,
        rowIndex: row,
        columnValuesLength: cols,
        rowValuesLength: rows,
        total: count2
      };
      rst.push(facet);
    });
    return rst;
  };
  List3.prototype.getXAxisOption = function(x2, axes, option, facet) {
    if (facet.rowIndex !== facet.rowValuesLength - 1 && facet.columnValuesLength * facet.rowIndex + facet.columnIndex + 1 + facet.columnValuesLength <= facet.total) {
      return __assign$4(__assign$4({}, option), { label: null, title: null });
    }
    return option;
  };
  List3.prototype.getYAxisOption = function(y2, axes, option, facet) {
    if (facet.columnIndex !== 0) {
      return __assign$4(__assign$4({}, option), { title: null, label: null });
    }
    return option;
  };
  List3.prototype.renderTitle = function() {
    var _this = this;
    each$1(this.facets, function(facet) {
      var columnValue = facet.columnValue, view = facet.view;
      var formatter = get(_this.cfg.title, "formatter");
      var config = deepMix({
        position: ["50%", "0%"],
        content: formatter ? formatter(columnValue) : columnValue
      }, getFactTitleConfig(DIRECTION.TOP), _this.cfg.title);
      view.annotation().text(config);
    });
  };
  List3.prototype.getPageCount = function(total, pageSize) {
    return Math.floor((total + pageSize - 1) / pageSize);
  };
  List3.prototype.getRowCol = function(index2, pageSize) {
    var row = Math.floor(index2 / pageSize);
    var col = index2 % pageSize;
    return { row, col };
  };
  return List3;
}(Facet);
var Matrix = function(_super) {
  __extends$3(Matrix2, _super);
  function Matrix2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Matrix2.prototype.getDefaultCfg = function() {
    return deepMix({}, _super.prototype.getDefaultCfg.call(this), {
      type: "matrix",
      showTitle: false,
      columnTitle: __assign$4({}, _super.prototype.getDefaultTitleCfg.call(this)),
      rowTitle: __assign$4({}, _super.prototype.getDefaultTitleCfg.call(this))
    });
  };
  Matrix2.prototype.render = function() {
    _super.prototype.render.call(this);
    if (this.cfg.showTitle) {
      this.renderTitle();
    }
  };
  Matrix2.prototype.afterEachView = function(view, facet) {
    this.processAxis(view, facet);
  };
  Matrix2.prototype.beforeEachView = function(view, facet) {
  };
  Matrix2.prototype.generateFacets = function(data2) {
    var _a2 = this.cfg, fields = _a2.fields, type4 = _a2.type;
    var rowValuesLength = fields.length;
    var columnValuesLength = rowValuesLength;
    var rst = [];
    for (var i2 = 0; i2 < columnValuesLength; i2++) {
      var columnField = fields[i2];
      for (var j2 = 0; j2 < rowValuesLength; j2++) {
        var rowField = fields[j2];
        var facet = {
          type: type4,
          data: data2,
          region: this.getRegion(rowValuesLength, columnValuesLength, i2, j2),
          columnValue: columnField,
          rowValue: rowField,
          columnField,
          rowField,
          columnIndex: i2,
          rowIndex: j2,
          columnValuesLength,
          rowValuesLength
        };
        rst.push(facet);
      }
    }
    return rst;
  };
  Matrix2.prototype.getXAxisOption = function(x2, axes, option, facet) {
    if (facet.rowIndex !== facet.rowValuesLength - 1) {
      return __assign$4(__assign$4({}, option), { label: null, title: null });
    }
    return option;
  };
  Matrix2.prototype.getYAxisOption = function(y2, axes, option, facet) {
    if (facet.columnIndex !== 0) {
      return __assign$4(__assign$4({}, option), { title: null, label: null });
    }
    return option;
  };
  Matrix2.prototype.renderTitle = function() {
    var _this = this;
    each$1(this.facets, function(facet, facetIndex) {
      var columnIndex = facet.columnIndex, rowIndex = facet.rowIndex, columnValuesLength = facet.columnValuesLength;
      facet.rowValuesLength;
      var columnValue = facet.columnValue, rowValue = facet.rowValue, view = facet.view;
      if (rowIndex === 0) {
        var formatter = get(_this.cfg.columnTitle, "formatter");
        var config = deepMix({
          position: ["50%", "0%"],
          content: formatter ? formatter(columnValue) : columnValue
        }, getFactTitleConfig(DIRECTION.TOP), _this.cfg.columnTitle);
        view.annotation().text(config);
      }
      if (columnIndex === columnValuesLength - 1) {
        var formatter = get(_this.cfg.rowTitle, "formatter");
        var config = deepMix({
          position: ["100%", "50%"],
          content: formatter ? formatter(rowValue) : rowValue
        }, getFactTitleConfig(DIRECTION.RIGHT), _this.cfg.rowTitle);
        view.annotation().text(config);
      }
    });
  };
  return Matrix2;
}(Facet);
var Mirror = function(_super) {
  __extends$3(Mirror2, _super);
  function Mirror2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Mirror2.prototype.getDefaultCfg = function() {
    return deepMix({}, _super.prototype.getDefaultCfg.call(this), {
      type: "mirror",
      showTitle: true,
      title: _super.prototype.getDefaultTitleCfg.call(this),
      transpose: false
    });
  };
  Mirror2.prototype.render = function() {
    _super.prototype.render.call(this);
    if (this.cfg.showTitle) {
      this.renderTitle();
    }
  };
  Mirror2.prototype.beforeEachView = function(view, facet) {
    if (this.cfg.transpose) {
      if (facet.columnIndex % 2 === 0) {
        view.coordinate().transpose().reflect("x");
      } else {
        view.coordinate().transpose();
      }
    } else {
      if (facet.rowIndex % 2 !== 0) {
        view.coordinate().reflect("y");
      }
    }
  };
  Mirror2.prototype.afterEachView = function(view, facet) {
    this.processAxis(view, facet);
  };
  Mirror2.prototype.generateFacets = function(data2) {
    var _this = this;
    var _a2 = __read(this.cfg.fields, 1), f2 = _a2[0];
    var rst = [];
    var columnValuesLength = 1;
    var rowValuesLength = 1;
    var columnValues = [""];
    var rowValues = [""];
    var columnField;
    var rowField;
    if (this.cfg.transpose) {
      columnField = f2;
      columnValues = this.getFieldValues(data2, columnField).slice(0, 2);
      columnValuesLength = columnValues.length;
    } else {
      rowField = f2;
      rowValues = this.getFieldValues(data2, rowField).slice(0, 2);
      rowValuesLength = rowValues.length;
    }
    columnValues.forEach(function(xVal, xIndex) {
      rowValues.forEach(function(yVal, yIndex) {
        var conditions = [
          { field: columnField, value: xVal, values: columnValues },
          { field: rowField, value: yVal, values: rowValues }
        ];
        var facetData = filter(data2, _this.getFacetDataFilter(conditions));
        var facet = {
          type: _this.cfg.type,
          data: facetData,
          region: _this.getRegion(rowValuesLength, columnValuesLength, xIndex, yIndex),
          columnValue: xVal,
          rowValue: yVal,
          columnField,
          rowField,
          columnIndex: xIndex,
          rowIndex: yIndex,
          columnValuesLength,
          rowValuesLength
        };
        rst.push(facet);
      });
    });
    return rst;
  };
  Mirror2.prototype.getXAxisOption = function(x2, axes, option, facet) {
    if (facet.columnIndex === 1 || facet.rowIndex === 1) {
      return __assign$4(__assign$4({}, option), { label: null, title: null });
    }
    return option;
  };
  Mirror2.prototype.getYAxisOption = function(y2, axes, option, facet) {
    return option;
  };
  Mirror2.prototype.renderTitle = function() {
    var _this = this;
    each$1(this.facets, function(facet, facetIndex) {
      var columnValue = facet.columnValue, rowValue = facet.rowValue, view = facet.view;
      var formatter = get(_this.cfg.title, "formatter");
      if (_this.cfg.transpose) {
        var config = deepMix({
          position: ["50%", "0%"],
          content: formatter ? formatter(columnValue) : columnValue
        }, getFactTitleConfig(DIRECTION.TOP), _this.cfg.title);
        view.annotation().text(config);
      } else {
        var config = deepMix({
          position: ["100%", "50%"],
          content: formatter ? formatter(rowValue) : rowValue
        }, getFactTitleConfig(DIRECTION.RIGHT), _this.cfg.title);
        view.annotation().text(config);
      }
    });
  };
  return Mirror2;
}(Facet);
var Rect = function(_super) {
  __extends$3(Rect2, _super);
  function Rect2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Rect2.prototype.afterEachView = function(view, facet) {
    this.processAxis(view, facet);
  };
  Rect2.prototype.beforeEachView = function(view, facet) {
  };
  Rect2.prototype.getDefaultCfg = function() {
    return deepMix({}, _super.prototype.getDefaultCfg.call(this), {
      type: "rect",
      columnTitle: __assign$4({}, _super.prototype.getDefaultTitleCfg.call(this)),
      rowTitle: __assign$4({}, _super.prototype.getDefaultTitleCfg.call(this))
    });
  };
  Rect2.prototype.render = function() {
    _super.prototype.render.call(this);
    if (this.cfg.showTitle) {
      this.renderTitle();
    }
  };
  Rect2.prototype.generateFacets = function(data2) {
    var _this = this;
    var _a2 = __read(this.cfg.fields, 2), columnField = _a2[0], rowField = _a2[1];
    var rst = [];
    var columnValuesLength = 1;
    var rowValuesLength = 1;
    var columnValues = [""];
    var rowValues = [""];
    if (columnField) {
      columnValues = this.getFieldValues(data2, columnField);
      columnValuesLength = columnValues.length;
    }
    if (rowField) {
      rowValues = this.getFieldValues(data2, rowField);
      rowValuesLength = rowValues.length;
    }
    columnValues.forEach(function(xVal, xIndex) {
      rowValues.forEach(function(yVal, yIndex) {
        var conditions = [
          { field: columnField, value: xVal, values: columnValues },
          { field: rowField, value: yVal, values: rowValues }
        ];
        var facetData = filter(data2, _this.getFacetDataFilter(conditions));
        var facet = {
          type: _this.cfg.type,
          data: facetData,
          region: _this.getRegion(rowValuesLength, columnValuesLength, xIndex, yIndex),
          columnValue: xVal,
          rowValue: yVal,
          columnField,
          rowField,
          columnIndex: xIndex,
          rowIndex: yIndex,
          columnValuesLength,
          rowValuesLength
        };
        rst.push(facet);
      });
    });
    return rst;
  };
  Rect2.prototype.renderTitle = function() {
    var _this = this;
    each$1(this.facets, function(facet, facetIndex) {
      var columnIndex = facet.columnIndex, rowIndex = facet.rowIndex, columnValuesLength = facet.columnValuesLength, columnValue = facet.columnValue, rowValue = facet.rowValue, view = facet.view;
      if (rowIndex === 0) {
        var formatter = get(_this.cfg.columnTitle, "formatter");
        var config = deepMix({
          position: ["50%", "0%"],
          content: formatter ? formatter(columnValue) : columnValue
        }, getFactTitleConfig(DIRECTION.TOP), _this.cfg.columnTitle);
        view.annotation().text(config);
      }
      if (columnIndex === columnValuesLength - 1) {
        var formatter = get(_this.cfg.rowTitle, "formatter");
        var config = deepMix({
          position: ["100%", "50%"],
          content: formatter ? formatter(rowValue) : rowValue
        }, getFactTitleConfig(DIRECTION.RIGHT), _this.cfg.rowTitle);
        view.annotation().text(config);
      }
    });
  };
  Rect2.prototype.getXAxisOption = function(x2, axes, option, facet) {
    if (facet.rowIndex !== facet.rowValuesLength - 1) {
      return __assign$4(__assign$4({}, option), { title: null, label: null });
    } else if (facet.columnIndex !== Math.floor((facet.columnValuesLength - 1) / 2)) {
      return __assign$4(__assign$4({}, option), { title: null });
    }
    return option;
  };
  Rect2.prototype.getYAxisOption = function(y2, axes, option, facet) {
    if (facet.columnIndex !== 0) {
      return __assign$4(__assign$4({}, option), { title: null, label: null });
    } else if (facet.rowIndex !== Math.floor((facet.rowValuesLength - 1) / 2)) {
      return __assign$4(__assign$4({}, option), { title: null });
    }
    return option;
  };
  return Rect2;
}(Facet);
var Tree = function(_super) {
  __extends$3(Tree2, _super);
  function Tree2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.afterChartRender = function() {
      if (_this.facets && _this.cfg.line) {
        _this.container.clear();
        _this.drawLines(_this.facets);
      }
    };
    return _this;
  }
  Tree2.prototype.afterEachView = function(view, facet) {
    this.processAxis(view, facet);
  };
  Tree2.prototype.beforeEachView = function(view, facet) {
  };
  Tree2.prototype.init = function() {
    _super.prototype.init.call(this);
    this.view.on(VIEW_LIFE_CIRCLE.AFTER_RENDER, this.afterChartRender);
  };
  Tree2.prototype.getDefaultCfg = function() {
    return deepMix({}, _super.prototype.getDefaultCfg.call(this), {
      type: "tree",
      line: {
        style: {
          lineWidth: 1,
          stroke: "#ddd"
        },
        smooth: false
      },
      showTitle: true,
      title: _super.prototype.getDefaultTitleCfg.call(this)
    });
  };
  Tree2.prototype.generateFacets = function(data2) {
    var fields = this.cfg.fields;
    if (!fields.length) {
      throw new Error("Please specify for the fields for rootFacet!");
    }
    var rst = [];
    var rootFacet = {
      type: this.cfg.type,
      data: data2,
      region: null,
      rowValuesLength: this.getRows(),
      columnValuesLength: 1,
      rowIndex: 0,
      columnIndex: 0,
      rowField: "",
      columnField: "",
      rowValue: "",
      columnValue: ""
    };
    rst.push(rootFacet);
    rootFacet.children = this.getChildFacets(data2, 1, rst);
    this.setRegion(rst);
    return rst;
  };
  Tree2.prototype.setRegion = function(facets) {
    var _this = this;
    this.forceColIndex(facets);
    facets.forEach(function(facet) {
      facet.region = _this.getRegion(facet.rowValuesLength, facet.columnValuesLength, facet.columnIndex, facet.rowIndex);
    });
  };
  Tree2.prototype.getRegion = function(rows, cols, xIndex, yIndex) {
    var xWidth = 1 / cols;
    var yWidth = 1 / rows;
    var start = {
      x: xWidth * xIndex,
      y: yWidth * yIndex
    };
    var end = {
      x: start.x + xWidth,
      y: start.y + yWidth * 2 / 3
    };
    return {
      start,
      end
    };
  };
  Tree2.prototype.forceColIndex = function(facets) {
    var e_1, _a2;
    var _this = this;
    var leafs = [];
    var index2 = 0;
    facets.forEach(function(facet2) {
      if (_this.isLeaf(facet2)) {
        leafs.push(facet2);
        facet2.columnIndex = index2;
        index2++;
      }
    });
    leafs.forEach(function(facet2) {
      facet2.columnValuesLength = leafs.length;
    });
    var maxLevel = this.cfg.fields.length;
    for (var i2 = maxLevel - 1; i2 >= 0; i2--) {
      var levelFacets = this.getFacetsByLevel(facets, i2);
      try {
        for (var levelFacets_1 = (e_1 = void 0, __values(levelFacets)), levelFacets_1_1 = levelFacets_1.next(); !levelFacets_1_1.done; levelFacets_1_1 = levelFacets_1.next()) {
          var facet = levelFacets_1_1.value;
          if (!this.isLeaf(facet)) {
            facet.originColIndex = facet.columnIndex;
            facet.columnIndex = this.getRegionIndex(facet.children);
            facet.columnValuesLength = leafs.length;
          }
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (levelFacets_1_1 && !levelFacets_1_1.done && (_a2 = levelFacets_1.return))
            _a2.call(levelFacets_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
    }
  };
  Tree2.prototype.getFacetsByLevel = function(facets, level) {
    var rst = [];
    facets.forEach(function(facet) {
      if (facet.rowIndex === level) {
        rst.push(facet);
      }
    });
    return rst;
  };
  Tree2.prototype.getRegionIndex = function(children) {
    var first = children[0];
    var last2 = children[children.length - 1];
    return (last2.columnIndex - first.columnIndex) / 2 + first.columnIndex;
  };
  Tree2.prototype.isLeaf = function(facet) {
    return !facet.children || !facet.children.length;
  };
  Tree2.prototype.getRows = function() {
    return this.cfg.fields.length + 1;
  };
  Tree2.prototype.getChildFacets = function(data2, level, arr) {
    var _this = this;
    var fields = this.cfg.fields;
    var length2 = fields.length;
    if (length2 < level) {
      return;
    }
    var rst = [];
    var field2 = fields[level - 1];
    var values2 = this.getFieldValues(data2, field2);
    values2.forEach(function(value2, index2) {
      var conditions = [{ field: field2, value: value2, values: values2 }];
      var subData = data2.filter(_this.getFacetDataFilter(conditions));
      if (subData.length) {
        var facet = {
          type: _this.cfg.type,
          data: subData,
          region: null,
          columnValue: value2,
          rowValue: "",
          columnField: field2,
          rowField: "",
          columnIndex: index2,
          rowValuesLength: _this.getRows(),
          columnValuesLength: 1,
          rowIndex: level,
          children: _this.getChildFacets(subData, level + 1, arr)
        };
        rst.push(facet);
        arr.push(facet);
      }
    });
    return rst;
  };
  Tree2.prototype.render = function() {
    _super.prototype.render.call(this);
    if (this.cfg.showTitle) {
      this.renderTitle();
    }
  };
  Tree2.prototype.renderTitle = function() {
    var _this = this;
    each$1(this.facets, function(facet) {
      var columnValue = facet.columnValue, view = facet.view;
      var formatter = get(_this.cfg.title, "formatter");
      var config = deepMix({
        position: ["50%", "0%"],
        content: formatter ? formatter(columnValue) : columnValue
      }, getFactTitleConfig(DIRECTION.TOP), _this.cfg.title);
      view.annotation().text(config);
    });
  };
  Tree2.prototype.drawLines = function(facets) {
    var _this = this;
    facets.forEach(function(facet) {
      if (!_this.isLeaf(facet)) {
        var children = facet.children;
        _this.addFacetLines(facet, children);
      }
    });
  };
  Tree2.prototype.addFacetLines = function(facet, children) {
    var _this = this;
    var view = facet.view;
    var region = view.coordinateBBox;
    var start = {
      x: region.x + region.width / 2,
      y: region.y + region.height
    };
    children.forEach(function(subFacet) {
      var subRegion = subFacet.view.coordinateBBox;
      var end = {
        x: subRegion.bl.x + (subRegion.tr.x - subRegion.bl.x) / 2,
        y: subRegion.tr.y
      };
      var middle1 = {
        x: start.x,
        y: start.y + (end.y - start.y) / 2
      };
      var middle2 = {
        x: end.x,
        y: middle1.y
      };
      _this.drawLine([start, middle1, middle2, end]);
    });
  };
  Tree2.prototype.getPath = function(points2) {
    var path2 = [];
    var smooth = this.cfg.line.smooth;
    if (smooth) {
      path2.push(["M", points2[0].x, points2[0].y]);
      path2.push(["C", points2[1].x, points2[1].y, points2[2].x, points2[2].y, points2[3].x, points2[3].y]);
    } else {
      points2.forEach(function(point2, index2) {
        if (index2 === 0) {
          path2.push(["M", point2.x, point2.y]);
        } else {
          path2.push(["L", point2.x, point2.y]);
        }
      });
    }
    return path2;
  };
  Tree2.prototype.drawLine = function(points2) {
    var path2 = this.getPath(points2);
    var line2 = this.cfg.line.style;
    this.container.addShape("path", {
      attrs: mix({
        path: path2
      }, line2)
    });
  };
  Tree2.prototype.getXAxisOption = function(x2, axes, option, facet) {
    if (facet.rowIndex !== facet.rowValuesLength - 1) {
      return __assign$4(__assign$4({}, option), { title: null, label: null });
    }
    return option;
  };
  Tree2.prototype.getYAxisOption = function(y2, axes, option, facet) {
    if (facet.originColIndex !== 0 && facet.columnIndex !== 0) {
      return __assign$4(__assign$4({}, option), { title: null, label: null });
    }
    return option;
  };
  return Tree2;
}(Facet);
function getMedian(array4) {
  var arr = __spreadArray$1([], __read(array4), false);
  arr.sort(function(a2, b10) {
    return a2 - b10;
  });
  var len = arr.length;
  if (len === 0) {
    return 0;
  }
  if (len % 2 === 1) {
    return arr[(len - 1) / 2];
  }
  return (arr[len / 2] + arr[len / 2 - 1]) / 2;
}
function getMean(array4) {
  var sum = reduce(array4, function(r2, num) {
    return r2 += isNaN(num) || !isNumber$1(num) ? 0 : num;
  }, 0);
  return array4.length === 0 ? 0 : sum / array4.length;
}
function getNormalizedValue(val, scale2) {
  if (!scale2) {
    return null;
  }
  var scaled;
  switch (val) {
    case "start":
      return 0;
    case "center":
      return 0.5;
    case "end":
      return 1;
    case "median": {
      scaled = scale2.isCategory ? getMedian(scale2.values.map(function(_2, idx) {
        return idx;
      })) : getMedian(scale2.values);
      break;
    }
    case "mean": {
      scaled = scale2.isCategory ? (scale2.values.length - 1) / 2 : getMean(scale2.values);
      break;
    }
    case "min":
      scaled = scale2.isCategory ? 0 : scale2[val];
      break;
    case "max":
      scaled = scale2.isCategory ? scale2.values.length - 1 : scale2[val];
      break;
    default:
      scaled = val;
      break;
  }
  return scale2.scale(scaled);
}
var ANNOTATIONS_AFTER_RENDER = ["regionFilter", "shape"];
var Annotation = function(_super) {
  __extends$3(Annotation2, _super);
  function Annotation2(view) {
    var _this = _super.call(this, view) || this;
    _this.cache = /* @__PURE__ */ new Map();
    _this.foregroundContainer = _this.view.getLayer(LAYER.FORE).addGroup();
    _this.backgroundContainer = _this.view.getLayer(LAYER.BG).addGroup();
    _this.option = [];
    return _this;
  }
  Object.defineProperty(Annotation2.prototype, "name", {
    get: function() {
      return "annotation";
    },
    enumerable: false,
    configurable: true
  });
  Annotation2.prototype.init = function() {
  };
  Annotation2.prototype.layout = function() {
    this.update();
  };
  Annotation2.prototype.render = function() {
  };
  Annotation2.prototype.update = function() {
    var _this = this;
    this.onAfterRender(function() {
      var updated = /* @__PURE__ */ new Map();
      each$1(_this.option, function(option) {
        if (contains(ANNOTATIONS_AFTER_RENDER, option.type)) {
          var co = _this.updateOrCreate(option);
          if (co) {
            updated.set(_this.getCacheKey(option), co);
          }
        }
      });
      _this.cache = _this.syncCache(updated);
    });
    var updateCache = /* @__PURE__ */ new Map();
    each$1(this.option, function(option) {
      if (!contains(ANNOTATIONS_AFTER_RENDER, option.type)) {
        var co = _this.updateOrCreate(option);
        if (co) {
          updateCache.set(_this.getCacheKey(option), co);
        }
      }
    });
    this.cache = this.syncCache(updateCache);
  };
  Annotation2.prototype.clear = function(includeOption) {
    if (includeOption === void 0) {
      includeOption = false;
    }
    _super.prototype.clear.call(this);
    this.clearComponents();
    this.foregroundContainer.clear();
    this.backgroundContainer.clear();
    if (includeOption) {
      this.option = [];
    }
  };
  Annotation2.prototype.destroy = function() {
    this.clear(true);
    this.foregroundContainer.remove(true);
    this.backgroundContainer.remove(true);
  };
  Annotation2.prototype.getComponents = function() {
    var co = [];
    this.cache.forEach(function(value2) {
      co.push(value2);
    });
    return co;
  };
  Annotation2.prototype.clearComponents = function() {
    this.getComponents().forEach(function(co) {
      co.component.destroy();
    });
    this.cache.clear();
  };
  Annotation2.prototype.onAfterRender = function(doWhat) {
    var done = false;
    if (this.view.getOptions().animate) {
      this.view.geometries.forEach(function(g2) {
        if (g2.animateOption) {
          g2.once(GEOMETRY_LIFE_CIRCLE.AFTER_DRAW_ANIMATE, function() {
            doWhat();
          });
          done = true;
        }
      });
    }
    if (!done) {
      this.view.getRootView().once(VIEW_LIFE_CIRCLE.AFTER_RENDER, function() {
        doWhat();
      });
    }
  };
  Annotation2.prototype.createAnnotation = function(option) {
    var type4 = option.type;
    var Ctor = AnnotationComponent[upperFirst(type4)];
    if (Ctor) {
      var theme2 = this.getAnnotationTheme(type4);
      var cfg = this.getAnnotationCfg(type4, option, theme2);
      if (!cfg) {
        return null;
      }
      var annotation2 = new Ctor(cfg);
      return {
        component: annotation2,
        layer: this.isTop(cfg) ? LAYER.FORE : LAYER.BG,
        direction: DIRECTION.NONE,
        type: COMPONENT_TYPE.ANNOTATION,
        extra: option
      };
    }
  };
  Annotation2.prototype.annotation = function(option) {
    this.option.push(option);
  };
  Annotation2.prototype.arc = function(option) {
    this.annotation(__assign$4({ type: "arc" }, option));
    return this;
  };
  Annotation2.prototype.image = function(option) {
    this.annotation(__assign$4({ type: "image" }, option));
    return this;
  };
  Annotation2.prototype.line = function(option) {
    this.annotation(__assign$4({ type: "line" }, option));
    return this;
  };
  Annotation2.prototype.region = function(option) {
    this.annotation(__assign$4({ type: "region" }, option));
    return this;
  };
  Annotation2.prototype.text = function(option) {
    this.annotation(__assign$4({ type: "text" }, option));
    return this;
  };
  Annotation2.prototype.dataMarker = function(option) {
    this.annotation(__assign$4({ type: "dataMarker" }, option));
    return this;
  };
  Annotation2.prototype.dataRegion = function(option) {
    this.annotation(__assign$4({ type: "dataRegion" }, option));
  };
  Annotation2.prototype.regionFilter = function(option) {
    this.annotation(__assign$4({ type: "regionFilter" }, option));
  };
  Annotation2.prototype.shape = function(option) {
    this.annotation(__assign$4({ type: "shape" }, option));
  };
  Annotation2.prototype.html = function(option) {
    this.annotation(__assign$4({ type: "html" }, option));
  };
  Annotation2.prototype.parsePosition = function(p2) {
    var e_1, _a2;
    var xScale = this.view.getXScale();
    var yScales = this.view.getScalesByDim("y");
    var position = isFunction(p2) ? p2.call(null, xScale, yScales) : p2;
    var x2 = 0;
    var y2 = 0;
    if (isArray$1(position)) {
      var _b = __read(position, 2), xPos = _b[0], yPos = _b[1];
      if (isString(xPos) && xPos.indexOf("%") !== -1 && !isNaN(xPos.slice(0, -1))) {
        return this.parsePercentPosition(position);
      }
      x2 = getNormalizedValue(xPos, xScale);
      y2 = getNormalizedValue(yPos, Object.values(yScales)[0]);
    } else if (!isNil(position)) {
      try {
        for (var _c = __values(keys(position)), _d = _c.next(); !_d.done; _d = _c.next()) {
          var key2 = _d.value;
          var value2 = position[key2];
          if (key2 === xScale.field) {
            x2 = getNormalizedValue(value2, xScale);
          }
          if (yScales[key2]) {
            y2 = getNormalizedValue(value2, yScales[key2]);
          }
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (_d && !_d.done && (_a2 = _c.return))
            _a2.call(_c);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
    }
    if (isNaN(x2) || isNaN(y2)) {
      return null;
    }
    return this.view.getCoordinate().convert({ x: x2, y: y2 });
  };
  Annotation2.prototype.getRegionPoints = function(start, end) {
    var _this = this;
    var xScale = this.view.getXScale();
    var yScales = this.view.getScalesByDim("y");
    var yScale = Object.values(yScales)[0];
    var xField = xScale.field;
    var viewData = this.view.getData();
    var startXValue = isArray$1(start) ? start[0] : start[xField];
    var endXValue = isArray$1(end) ? end[0] : end[xField];
    var arr = [];
    var startIndex;
    each$1(viewData, function(item, idx) {
      if (item[xField] === startXValue) {
        startIndex = idx;
      }
      if (idx >= startIndex) {
        var point2 = _this.parsePosition([item[xField], item[yScale.field]]);
        if (point2) {
          arr.push(point2);
        }
      }
      if (item[xField] === endXValue) {
        return false;
      }
    });
    return arr;
  };
  Annotation2.prototype.parsePercentPosition = function(position) {
    var xPercent = parseFloat(position[0]) / 100;
    var yPercent = parseFloat(position[1]) / 100;
    var coordinate2 = this.view.getCoordinate();
    var start = coordinate2.start, end = coordinate2.end;
    var topLeft = {
      x: Math.min(start.x, end.x),
      y: Math.min(start.y, end.y)
    };
    var x2 = coordinate2.getWidth() * xPercent + topLeft.x;
    var y2 = coordinate2.getHeight() * yPercent + topLeft.y;
    return { x: x2, y: y2 };
  };
  Annotation2.prototype.getCoordinateBBox = function() {
    var coordinate2 = this.view.getCoordinate();
    var start = coordinate2.start, end = coordinate2.end;
    var width = coordinate2.getWidth();
    var height = coordinate2.getHeight();
    var topLeft = {
      x: Math.min(start.x, end.x),
      y: Math.min(start.y, end.y)
    };
    return {
      x: topLeft.x,
      y: topLeft.y,
      minX: topLeft.x,
      minY: topLeft.y,
      maxX: topLeft.x + width,
      maxY: topLeft.y + height,
      width,
      height
    };
  };
  Annotation2.prototype.getAnnotationCfg = function(type4, option, theme2) {
    var _this = this;
    var coordinate2 = this.view.getCoordinate();
    var canvas = this.view.getCanvas();
    var o2 = {};
    if (isNil(option)) {
      return null;
    }
    var start = option.start, end = option.end, position = option.position;
    var sp = this.parsePosition(start);
    var ep = this.parsePosition(end);
    var textPoint = this.parsePosition(position);
    if (["arc", "image", "line", "region", "regionFilter"].includes(type4) && (!sp || !ep)) {
      return null;
    } else if (["text", "dataMarker", "html"].includes(type4) && !textPoint) {
      return null;
    }
    if (type4 === "arc") {
      var _a2 = option;
      _a2.start;
      _a2.end;
      var rest = __rest$3(_a2, ["start", "end"]);
      var startAngle = getAngleByPoint(coordinate2, sp);
      var endAngle = getAngleByPoint(coordinate2, ep);
      if (startAngle > endAngle) {
        endAngle = Math.PI * 2 + endAngle;
      }
      o2 = __assign$4(__assign$4({}, rest), { center: coordinate2.getCenter(), radius: getDistanceToCenter(coordinate2, sp), startAngle, endAngle });
    } else if (type4 === "image") {
      var _b = option;
      _b.start;
      _b.end;
      var rest = __rest$3(_b, ["start", "end"]);
      o2 = __assign$4(__assign$4({}, rest), { start: sp, end: ep, src: option.src });
    } else if (type4 === "line") {
      var _c = option;
      _c.start;
      _c.end;
      var rest = __rest$3(_c, ["start", "end"]);
      o2 = __assign$4(__assign$4({}, rest), { start: sp, end: ep, text: get(option, "text", null) });
    } else if (type4 === "region") {
      var _d = option;
      _d.start;
      _d.end;
      var rest = __rest$3(_d, ["start", "end"]);
      o2 = __assign$4(__assign$4({}, rest), { start: sp, end: ep });
    } else if (type4 === "text") {
      var filteredData = this.view.getData();
      var _e = option;
      _e.position;
      var content = _e.content, rest = __rest$3(_e, ["position", "content"]);
      var textContent = content;
      if (isFunction(content)) {
        textContent = content(filteredData);
      }
      o2 = __assign$4(__assign$4(__assign$4({}, textPoint), rest), { content: textContent });
    } else if (type4 === "dataMarker") {
      var _f = option;
      _f.position;
      var point2 = _f.point, line2 = _f.line, text2 = _f.text, autoAdjust = _f.autoAdjust, direction2 = _f.direction, rest = __rest$3(_f, ["position", "point", "line", "text", "autoAdjust", "direction"]);
      o2 = __assign$4(__assign$4(__assign$4({}, rest), textPoint), { coordinateBBox: this.getCoordinateBBox(), point: point2, line: line2, text: text2, autoAdjust, direction: direction2 });
    } else if (type4 === "dataRegion") {
      var _g = option, start_5 = _g.start, end_5 = _g.end, region = _g.region, text2 = _g.text, lineLength = _g.lineLength, rest = __rest$3(_g, ["start", "end", "region", "text", "lineLength"]);
      o2 = __assign$4(__assign$4({}, rest), { points: this.getRegionPoints(start_5, end_5), region, text: text2, lineLength });
    } else if (type4 === "regionFilter") {
      var _h = option;
      _h.start;
      _h.end;
      var apply_1 = _h.apply, color2 = _h.color, rest = __rest$3(_h, ["start", "end", "apply", "color"]);
      var geometries = this.view.geometries;
      var shapes_1 = [];
      var addShapes_1 = function(item) {
        if (!item) {
          return;
        }
        if (item.isGroup()) {
          item.getChildren().forEach(function(child) {
            return addShapes_1(child);
          });
        } else {
          shapes_1.push(item);
        }
      };
      each$1(geometries, function(geom) {
        if (apply_1) {
          if (contains(apply_1, geom.type)) {
            each$1(geom.elements, function(elem) {
              addShapes_1(elem.shape);
            });
          }
        } else {
          each$1(geom.elements, function(elem) {
            addShapes_1(elem.shape);
          });
        }
      });
      o2 = __assign$4(__assign$4({}, rest), { color: color2, shapes: shapes_1, start: sp, end: ep });
    } else if (type4 === "shape") {
      var _j = option, render_1 = _j.render, restOptions = __rest$3(_j, ["render"]);
      var wrappedRender = function(container) {
        if (isFunction(option.render)) {
          return render_1(container, _this.view, { parsePosition: _this.parsePosition.bind(_this) });
        }
      };
      o2 = __assign$4(__assign$4({}, restOptions), { render: wrappedRender });
    } else if (type4 === "html") {
      var _k = option, html_1 = _k.html;
      _k.position;
      var restOptions = __rest$3(_k, ["html", "position"]);
      var wrappedHtml = function(container) {
        if (isFunction(html_1)) {
          return html_1(container, _this.view);
        }
        return html_1;
      };
      o2 = __assign$4(__assign$4(__assign$4({}, restOptions), textPoint), {
        parent: canvas.get("el").parentNode,
        html: wrappedHtml
      });
    }
    var cfg = deepMix({}, theme2, __assign$4(__assign$4({}, o2), { top: option.top, style: option.style, offsetX: option.offsetX, offsetY: option.offsetY }));
    if (type4 !== "html") {
      cfg.container = this.getComponentContainer(cfg);
    }
    cfg.animate = this.view.getOptions().animate && cfg.animate && get(option, "animate", cfg.animate);
    cfg.animateOption = deepMix({}, DEFAULT_ANIMATE_CFG, cfg.animateOption, option.animateOption);
    return cfg;
  };
  Annotation2.prototype.isTop = function(option) {
    return get(option, "top", true);
  };
  Annotation2.prototype.getComponentContainer = function(option) {
    return this.isTop(option) ? this.foregroundContainer : this.backgroundContainer;
  };
  Annotation2.prototype.getAnnotationTheme = function(type4) {
    return get(this.view.getTheme(), ["components", "annotation", type4], {});
  };
  Annotation2.prototype.updateOrCreate = function(option) {
    var co = this.cache.get(this.getCacheKey(option));
    if (co) {
      var type4 = option.type;
      var theme2 = this.getAnnotationTheme(type4);
      var cfg = this.getAnnotationCfg(type4, option, theme2);
      if (cfg) {
        omit(cfg, ["container"]);
      }
      co.component.update(__assign$4(__assign$4({}, cfg || {}), { visible: !!cfg }));
      if (contains(ANNOTATIONS_AFTER_RENDER, option.type)) {
        co.component.render();
      }
    } else {
      co = this.createAnnotation(option);
      if (co) {
        co.component.init();
        if (contains(ANNOTATIONS_AFTER_RENDER, option.type)) {
          co.component.render();
        }
      }
    }
    return co;
  };
  Annotation2.prototype.syncCache = function(updated) {
    var _this = this;
    var newCache = new Map(this.cache);
    updated.forEach(function(co, key2) {
      newCache.set(key2, co);
    });
    newCache.forEach(function(co, key2) {
      if (!find$1(_this.option, function(option) {
        return key2 === _this.getCacheKey(option);
      })) {
        co.component.destroy();
        newCache.delete(key2);
      }
    });
    return newCache;
  };
  Annotation2.prototype.getCacheKey = function(option) {
    return option;
  };
  return Annotation2;
}(Controller);
function getGridThemeCfg(theme2, direction2) {
  var axisTheme = deepMix({}, get(theme2, ["components", "axis", "common"]), get(theme2, ["components", "axis", direction2]));
  return get(axisTheme, ["grid"], {});
}
function getLineGridItems(coordinate2, scale2, dim, alignTick) {
  var items = [];
  var ticks = scale2.getTicks();
  if (coordinate2.isPolar) {
    ticks.push({
      value: 1,
      text: "",
      tickValue: ""
    });
  }
  ticks.reduce(function(preTick, currentTick, currentIndex) {
    var currentValue = currentTick.value;
    if (alignTick) {
      items.push({
        points: [
          coordinate2.convert(dim === "y" ? { x: 0, y: currentValue } : { x: currentValue, y: 0 }),
          coordinate2.convert(dim === "y" ? { x: 1, y: currentValue } : { x: currentValue, y: 1 })
        ]
      });
    } else {
      if (currentIndex) {
        var preValue = preTick.value;
        var middleValue = (preValue + currentValue) / 2;
        items.push({
          points: [
            coordinate2.convert(dim === "y" ? { x: 0, y: middleValue } : { x: middleValue, y: 0 }),
            coordinate2.convert(dim === "y" ? { x: 1, y: middleValue } : { x: middleValue, y: 1 })
          ]
        });
      }
    }
    return currentTick;
  }, ticks[0]);
  return items;
}
function getCircleGridItems(coordinate2, xScale, yScale, alignTick, dim) {
  var count2 = xScale.values.length;
  var items = [];
  var ticks = yScale.getTicks();
  ticks.reduce(function(preTick, currentTick) {
    var preValue = preTick ? preTick.value : currentTick.value;
    var currentValue = currentTick.value;
    var middleValue = (preValue + currentValue) / 2;
    if (dim === "x") {
      items.push({
        points: [
          coordinate2.convert({
            x: alignTick ? currentValue : middleValue,
            y: 0
          }),
          coordinate2.convert({
            x: alignTick ? currentValue : middleValue,
            y: 1
          })
        ]
      });
    } else {
      items.push({
        points: map$2(Array(count2 + 1), function(__, idx) {
          return coordinate2.convert({
            x: idx / count2,
            y: alignTick ? currentValue : middleValue
          });
        })
      });
    }
    return currentTick;
  }, ticks[0]);
  return items;
}
function showGrid(axisTheme, axisOption) {
  var userGrid = get(axisOption, "grid");
  if (userGrid === null) {
    return false;
  }
  var themeGrid = get(axisTheme, "grid");
  return !(userGrid === void 0 && themeGrid === null);
}
var OMIT_CFG = ["container"];
var AXIS_DEFAULT_ANIMATE_CFG = __assign$4(__assign$4({}, DEFAULT_ANIMATE_CFG), { appear: null });
var Axis = function(_super) {
  __extends$3(Axis2, _super);
  function Axis2(view) {
    var _this = _super.call(this, view) || this;
    _this.cache = /* @__PURE__ */ new Map();
    _this.gridContainer = _this.view.getLayer(LAYER.BG).addGroup();
    _this.gridForeContainer = _this.view.getLayer(LAYER.FORE).addGroup();
    _this.axisContainer = _this.view.getLayer(LAYER.BG).addGroup();
    _this.axisForeContainer = _this.view.getLayer(LAYER.FORE).addGroup();
    return _this;
  }
  Object.defineProperty(Axis2.prototype, "name", {
    get: function() {
      return "axis";
    },
    enumerable: false,
    configurable: true
  });
  Axis2.prototype.init = function() {
  };
  Axis2.prototype.render = function() {
    this.update();
  };
  Axis2.prototype.layout = function() {
    var _this = this;
    var coordinate2 = this.view.getCoordinate();
    each$1(this.getComponents(), function(co) {
      var component2 = co.component, direction2 = co.direction, type4 = co.type, extra = co.extra;
      var dim = extra.dim, scale2 = extra.scale, alignTick = extra.alignTick;
      var updated;
      if (type4 === COMPONENT_TYPE.AXIS) {
        if (coordinate2.isPolar) {
          if (dim === "x") {
            updated = coordinate2.isTransposed ? getAxisRegion(coordinate2, direction2) : getCircleAxisCenterRadius(coordinate2);
          } else if (dim === "y") {
            updated = coordinate2.isTransposed ? getCircleAxisCenterRadius(coordinate2) : getAxisRegion(coordinate2, direction2);
          }
        } else {
          updated = getAxisRegion(coordinate2, direction2);
        }
      } else if (type4 === COMPONENT_TYPE.GRID) {
        if (coordinate2.isPolar) {
          var items = void 0;
          if (coordinate2.isTransposed) {
            items = dim === "x" ? getCircleGridItems(coordinate2, _this.view.getYScales()[0], scale2, alignTick, dim) : getLineGridItems(coordinate2, scale2, dim, alignTick);
          } else {
            items = dim === "x" ? getLineGridItems(coordinate2, scale2, dim, alignTick) : getCircleGridItems(coordinate2, _this.view.getXScale(), scale2, alignTick, dim);
          }
          updated = {
            items,
            center: _this.view.getCoordinate().getCenter()
          };
        } else {
          updated = { items: getLineGridItems(coordinate2, scale2, dim, alignTick) };
        }
      }
      component2.update(updated);
    });
  };
  Axis2.prototype.update = function() {
    this.option = this.view.getOptions().axes;
    var updatedCache = /* @__PURE__ */ new Map();
    this.updateXAxes(updatedCache);
    this.updateYAxes(updatedCache);
    var newCache = /* @__PURE__ */ new Map();
    this.cache.forEach(function(co, key2) {
      if (updatedCache.has(key2)) {
        newCache.set(key2, co);
      } else {
        co.component.destroy();
      }
    });
    this.cache = newCache;
  };
  Axis2.prototype.clear = function() {
    _super.prototype.clear.call(this);
    this.cache.clear();
    this.gridContainer.clear();
    this.gridForeContainer.clear();
    this.axisContainer.clear();
    this.axisForeContainer.clear();
  };
  Axis2.prototype.destroy = function() {
    _super.prototype.destroy.call(this);
    this.gridContainer.remove(true);
    this.gridForeContainer.remove(true);
    this.axisContainer.remove(true);
    this.axisForeContainer.remove(true);
  };
  Axis2.prototype.getComponents = function() {
    var co = [];
    this.cache.forEach(function(value2) {
      co.push(value2);
    });
    return co;
  };
  Axis2.prototype.updateXAxes = function(updatedCache) {
    var scale2 = this.view.getXScale();
    if (!scale2 || scale2.isIdentity) {
      return;
    }
    var xAxisOption = getAxisOption(this.option, scale2.field);
    if (xAxisOption === false) {
      return;
    }
    var direction2 = getAxisDirection(xAxisOption, DIRECTION.BOTTOM);
    var layer = LAYER.BG;
    var dim = "x";
    var coordinate2 = this.view.getCoordinate();
    var axisId = this.getId("axis", scale2.field);
    var gridId = this.getId("grid", scale2.field);
    if (coordinate2.isRect) {
      var axis2 = this.cache.get(axisId);
      if (axis2) {
        var cfg = this.getLineAxisCfg(scale2, xAxisOption, direction2);
        omit(cfg, OMIT_CFG);
        axis2.component.update(cfg);
        updatedCache.set(axisId, axis2);
      } else {
        axis2 = this.createLineAxis(scale2, xAxisOption, layer, direction2, dim);
        this.cache.set(axisId, axis2);
        updatedCache.set(axisId, axis2);
      }
      var grid = this.cache.get(gridId);
      if (grid) {
        var cfg = this.getLineGridCfg(scale2, xAxisOption, direction2, dim);
        omit(cfg, OMIT_CFG);
        grid.component.update(cfg);
        updatedCache.set(gridId, grid);
      } else {
        grid = this.createLineGrid(scale2, xAxisOption, layer, direction2, dim);
        if (grid) {
          this.cache.set(gridId, grid);
          updatedCache.set(gridId, grid);
        }
      }
    } else if (coordinate2.isPolar) {
      var axis2 = this.cache.get(axisId);
      if (axis2) {
        var cfg = coordinate2.isTransposed ? this.getLineAxisCfg(scale2, xAxisOption, DIRECTION.RADIUS) : this.getCircleAxisCfg(scale2, xAxisOption, direction2);
        omit(cfg, OMIT_CFG);
        axis2.component.update(cfg);
        updatedCache.set(axisId, axis2);
      } else {
        if (coordinate2.isTransposed) {
          if (isUndefined(xAxisOption)) {
            return;
          } else {
            axis2 = this.createLineAxis(scale2, xAxisOption, layer, DIRECTION.RADIUS, dim);
          }
        } else {
          axis2 = this.createCircleAxis(scale2, xAxisOption, layer, direction2, dim);
        }
        this.cache.set(axisId, axis2);
        updatedCache.set(axisId, axis2);
      }
      var grid = this.cache.get(gridId);
      if (grid) {
        var cfg = coordinate2.isTransposed ? this.getCircleGridCfg(scale2, xAxisOption, DIRECTION.RADIUS, dim) : this.getLineGridCfg(scale2, xAxisOption, DIRECTION.CIRCLE, dim);
        omit(cfg, OMIT_CFG);
        grid.component.update(cfg);
        updatedCache.set(gridId, grid);
      } else {
        if (coordinate2.isTransposed) {
          if (isUndefined(xAxisOption)) {
            return;
          } else {
            grid = this.createCircleGrid(scale2, xAxisOption, layer, DIRECTION.RADIUS, dim);
          }
        } else {
          grid = this.createLineGrid(scale2, xAxisOption, layer, DIRECTION.CIRCLE, dim);
        }
        if (grid) {
          this.cache.set(gridId, grid);
          updatedCache.set(gridId, grid);
        }
      }
    } else
      ;
  };
  Axis2.prototype.updateYAxes = function(updatedCache) {
    var _this = this;
    var yScales = this.view.getYScales();
    each$1(yScales, function(scale2, idx) {
      if (!scale2 || scale2.isIdentity) {
        return;
      }
      var field2 = scale2.field;
      var yAxisOption = getAxisOption(_this.option, field2);
      if (yAxisOption !== false) {
        var layer = LAYER.BG;
        var dim = "y";
        var axisId = _this.getId("axis", field2);
        var gridId = _this.getId("grid", field2);
        var coordinate2 = _this.view.getCoordinate();
        if (coordinate2.isRect) {
          var direction2 = getAxisDirection(yAxisOption, idx === 0 ? DIRECTION.LEFT : DIRECTION.RIGHT);
          var axis2 = _this.cache.get(axisId);
          if (axis2) {
            var cfg = _this.getLineAxisCfg(scale2, yAxisOption, direction2);
            omit(cfg, OMIT_CFG);
            axis2.component.update(cfg);
            updatedCache.set(axisId, axis2);
          } else {
            axis2 = _this.createLineAxis(scale2, yAxisOption, layer, direction2, dim);
            _this.cache.set(axisId, axis2);
            updatedCache.set(axisId, axis2);
          }
          var grid = _this.cache.get(gridId);
          if (grid) {
            var cfg = _this.getLineGridCfg(scale2, yAxisOption, direction2, dim);
            omit(cfg, OMIT_CFG);
            grid.component.update(cfg);
            updatedCache.set(gridId, grid);
          } else {
            grid = _this.createLineGrid(scale2, yAxisOption, layer, direction2, dim);
            if (grid) {
              _this.cache.set(gridId, grid);
              updatedCache.set(gridId, grid);
            }
          }
        } else if (coordinate2.isPolar) {
          var axis2 = _this.cache.get(axisId);
          if (axis2) {
            var cfg = coordinate2.isTransposed ? _this.getCircleAxisCfg(scale2, yAxisOption, DIRECTION.CIRCLE) : _this.getLineAxisCfg(scale2, yAxisOption, DIRECTION.RADIUS);
            omit(cfg, OMIT_CFG);
            axis2.component.update(cfg);
            updatedCache.set(axisId, axis2);
          } else {
            if (coordinate2.isTransposed) {
              if (isUndefined(yAxisOption)) {
                return;
              } else {
                axis2 = _this.createCircleAxis(scale2, yAxisOption, layer, DIRECTION.CIRCLE, dim);
              }
            } else {
              axis2 = _this.createLineAxis(scale2, yAxisOption, layer, DIRECTION.RADIUS, dim);
            }
            _this.cache.set(axisId, axis2);
            updatedCache.set(axisId, axis2);
          }
          var grid = _this.cache.get(gridId);
          if (grid) {
            var cfg = coordinate2.isTransposed ? _this.getLineGridCfg(scale2, yAxisOption, DIRECTION.CIRCLE, dim) : _this.getCircleGridCfg(scale2, yAxisOption, DIRECTION.RADIUS, dim);
            omit(cfg, OMIT_CFG);
            grid.component.update(cfg);
            updatedCache.set(gridId, grid);
          } else {
            if (coordinate2.isTransposed) {
              if (isUndefined(yAxisOption)) {
                return;
              } else {
                grid = _this.createLineGrid(scale2, yAxisOption, layer, DIRECTION.CIRCLE, dim);
              }
            } else {
              grid = _this.createCircleGrid(scale2, yAxisOption, layer, DIRECTION.RADIUS, dim);
            }
            if (grid) {
              _this.cache.set(gridId, grid);
              updatedCache.set(gridId, grid);
            }
          }
        } else
          ;
      }
    });
  };
  Axis2.prototype.createLineAxis = function(scale2, option, layer, direction2, dim) {
    var axis2 = {
      component: new LineAxis(this.getLineAxisCfg(scale2, option, direction2)),
      layer,
      direction: direction2 === DIRECTION.RADIUS ? DIRECTION.NONE : direction2,
      type: COMPONENT_TYPE.AXIS,
      extra: { dim, scale: scale2 }
    };
    axis2.component.set("field", scale2.field);
    axis2.component.init();
    return axis2;
  };
  Axis2.prototype.createLineGrid = function(scale2, option, layer, direction2, dim) {
    var cfg = this.getLineGridCfg(scale2, option, direction2, dim);
    if (cfg) {
      var grid = {
        component: new LineGrid(cfg),
        layer,
        direction: DIRECTION.NONE,
        type: COMPONENT_TYPE.GRID,
        extra: {
          dim,
          scale: scale2,
          alignTick: get(cfg, "alignTick", true)
        }
      };
      grid.component.init();
      return grid;
    }
  };
  Axis2.prototype.createCircleAxis = function(scale2, option, layer, direction2, dim) {
    var axis2 = {
      component: new CircleAxis(this.getCircleAxisCfg(scale2, option, direction2)),
      layer,
      direction: direction2,
      type: COMPONENT_TYPE.AXIS,
      extra: { dim, scale: scale2 }
    };
    axis2.component.set("field", scale2.field);
    axis2.component.init();
    return axis2;
  };
  Axis2.prototype.createCircleGrid = function(scale2, option, layer, direction2, dim) {
    var cfg = this.getCircleGridCfg(scale2, option, direction2, dim);
    if (cfg) {
      var grid = {
        component: new CircleGrid(cfg),
        layer,
        direction: DIRECTION.NONE,
        type: COMPONENT_TYPE.GRID,
        extra: {
          dim,
          scale: scale2,
          alignTick: get(cfg, "alignTick", true)
        }
      };
      grid.component.init();
      return grid;
    }
  };
  Axis2.prototype.getLineAxisCfg = function(scale2, axisOption, direction2) {
    var container = get(axisOption, ["top"]) ? this.axisForeContainer : this.axisContainer;
    var coordinate2 = this.view.getCoordinate();
    var region = getAxisRegion(coordinate2, direction2);
    var titleText = getAxisTitleText(scale2, axisOption);
    var axisThemeCfg = getAxisThemeCfg(this.view.getTheme(), direction2);
    var optionWithTitle = get(axisOption, ["title"]) ? deepMix({ title: { style: { text: titleText } } }, { title: getAxisTitleOptions(this.view.getTheme(), direction2, axisOption.title) }, axisOption) : axisOption;
    var cfg = deepMix(__assign$4(__assign$4({ container }, region), { ticks: scale2.getTicks().map(function(tick) {
      return { id: "".concat(tick.tickValue), name: tick.text, value: tick.value };
    }), verticalFactor: coordinate2.isPolar ? getAxisFactorByRegion(region, coordinate2.getCenter()) * -1 : getAxisFactorByRegion(region, coordinate2.getCenter()), theme: axisThemeCfg }), axisThemeCfg, optionWithTitle);
    var _a2 = this.getAnimateCfg(cfg), animate = _a2.animate, animateOption = _a2.animateOption;
    cfg.animateOption = animateOption;
    cfg.animate = animate;
    var isAxisVertical = isVertical(region);
    var verticalLimitLength = get(cfg, "verticalLimitLength", isAxisVertical ? 1 / 3 : 1 / 2);
    if (verticalLimitLength <= 1) {
      var canvasWidth = this.view.getCanvas().get("width");
      var canvasHeight = this.view.getCanvas().get("height");
      cfg.verticalLimitLength = verticalLimitLength * (isAxisVertical ? canvasWidth : canvasHeight);
    }
    return cfg;
  };
  Axis2.prototype.getLineGridCfg = function(scale2, axisOption, direction2, dim) {
    if (!showGrid(getAxisThemeCfg(this.view.getTheme(), direction2), axisOption)) {
      return void 0;
    }
    var gridThemeCfg = getGridThemeCfg(this.view.getTheme(), direction2);
    var gridCfg = deepMix({
      container: get(axisOption, ["top"]) ? this.gridForeContainer : this.gridContainer
    }, gridThemeCfg, get(axisOption, "grid"), this.getAnimateCfg(axisOption));
    gridCfg.items = getLineGridItems(this.view.getCoordinate(), scale2, dim, get(gridCfg, "alignTick", true));
    return gridCfg;
  };
  Axis2.prototype.getCircleAxisCfg = function(scale2, axisOption, direction2) {
    var container = get(axisOption, ["top"]) ? this.axisForeContainer : this.axisContainer;
    var coordinate2 = this.view.getCoordinate();
    var ticks = scale2.getTicks().map(function(tick) {
      return { id: "".concat(tick.tickValue), name: tick.text, value: tick.value };
    });
    if (!scale2.isCategory && Math.abs(coordinate2.endAngle - coordinate2.startAngle) === Math.PI * 2) {
      ticks.pop();
    }
    var titleText = getAxisTitleText(scale2, axisOption);
    var axisThemeCfg = getAxisThemeCfg(this.view.getTheme(), DIRECTION.CIRCLE);
    var optionWithTitle = get(axisOption, ["title"]) ? deepMix({ title: { style: { text: titleText } } }, { title: getAxisTitleOptions(this.view.getTheme(), direction2, axisOption.title) }, axisOption) : axisOption;
    var cfg = deepMix(__assign$4(__assign$4({ container }, getCircleAxisCenterRadius(this.view.getCoordinate())), { ticks, verticalFactor: 1, theme: axisThemeCfg }), axisThemeCfg, optionWithTitle);
    var _a2 = this.getAnimateCfg(cfg), animate = _a2.animate, animateOption = _a2.animateOption;
    cfg.animate = animate;
    cfg.animateOption = animateOption;
    return cfg;
  };
  Axis2.prototype.getCircleGridCfg = function(scale2, axisOption, direction2, dim) {
    if (!showGrid(getAxisThemeCfg(this.view.getTheme(), direction2), axisOption)) {
      return void 0;
    }
    var gridThemeCfg = getGridThemeCfg(this.view.getTheme(), DIRECTION.RADIUS);
    var gridCfg = deepMix({
      container: get(axisOption, ["top"]) ? this.gridForeContainer : this.gridContainer,
      center: this.view.getCoordinate().getCenter()
    }, gridThemeCfg, get(axisOption, "grid"), this.getAnimateCfg(axisOption));
    var alignTick = get(gridCfg, "alignTick", true);
    var verticalScale = dim === "x" ? this.view.getYScales()[0] : this.view.getXScale();
    gridCfg.items = getCircleGridItems(this.view.getCoordinate(), verticalScale, scale2, alignTick, dim);
    return gridCfg;
  };
  Axis2.prototype.getId = function(name, key2) {
    var coordinate2 = this.view.getCoordinate();
    return "".concat(name, "-").concat(key2, "-").concat(coordinate2.type);
  };
  Axis2.prototype.getAnimateCfg = function(cfg) {
    return {
      animate: this.view.getOptions().animate && get(cfg, "animate"),
      animateOption: cfg && cfg.animateOption ? deepMix({}, AXIS_DEFAULT_ANIMATE_CFG, cfg.animateOption) : AXIS_DEFAULT_ANIMATE_CFG
    };
  };
  return Axis2;
}(Controller);
function directionToPosition(parentBBox, bbox, direction2) {
  if (direction2 === DIRECTION.TOP) {
    return [parentBBox.minX + parentBBox.width / 2 - bbox.width / 2, parentBBox.minY];
  }
  if (direction2 === DIRECTION.BOTTOM) {
    return [parentBBox.minX + parentBBox.width / 2 - bbox.width / 2, parentBBox.maxY - bbox.height];
  }
  if (direction2 === DIRECTION.LEFT) {
    return [parentBBox.minX, parentBBox.minY + parentBBox.height / 2 - bbox.height / 2];
  }
  if (direction2 === DIRECTION.RIGHT) {
    return [parentBBox.maxX - bbox.width, parentBBox.minY + parentBBox.height / 2 - bbox.height / 2];
  }
  if (direction2 === DIRECTION.TOP_LEFT || direction2 === DIRECTION.LEFT_TOP) {
    return [parentBBox.tl.x, parentBBox.tl.y];
  }
  if (direction2 === DIRECTION.TOP_RIGHT || direction2 === DIRECTION.RIGHT_TOP) {
    return [parentBBox.tr.x - bbox.width, parentBBox.tr.y];
  }
  if (direction2 === DIRECTION.BOTTOM_LEFT || direction2 === DIRECTION.LEFT_BOTTOM) {
    return [parentBBox.bl.x, parentBBox.bl.y - bbox.height];
  }
  if (direction2 === DIRECTION.BOTTOM_RIGHT || direction2 === DIRECTION.RIGHT_BOTTOM) {
    return [parentBBox.br.x - bbox.width, parentBBox.br.y - bbox.height];
  }
  return [0, 0];
}
function getLegendOption(legends, field2) {
  if (isBoolean(legends)) {
    return legends === false ? false : {};
  }
  return get(legends, [field2], legends);
}
function getDirection(legendOption) {
  return get(legendOption, "position", DIRECTION.BOTTOM);
}
var Legend = function(_super) {
  __extends$3(Legend2, _super);
  function Legend2(view) {
    var _this = _super.call(this, view) || this;
    _this.container = _this.view.getLayer(LAYER.FORE).addGroup();
    return _this;
  }
  Object.defineProperty(Legend2.prototype, "name", {
    get: function() {
      return "legend";
    },
    enumerable: false,
    configurable: true
  });
  Legend2.prototype.init = function() {
  };
  Legend2.prototype.render = function() {
    this.update();
  };
  Legend2.prototype.layout = function() {
    var _this = this;
    this.layoutBBox = this.view.viewBBox;
    each$1(this.components, function(co) {
      var component2 = co.component, direction2 = co.direction;
      var layout2 = getLegendLayout(direction2);
      var maxWidthRatio = component2.get("maxWidthRatio");
      var maxHeightRatio = component2.get("maxHeightRatio");
      var maxSize = _this.getCategoryLegendSizeCfg(layout2, maxWidthRatio, maxHeightRatio);
      var maxWidth = component2.get("maxWidth");
      var maxHeight = component2.get("maxHeight");
      component2.update({
        maxWidth: Math.min(maxSize.maxWidth, maxWidth || 0),
        maxHeight: Math.min(maxSize.maxHeight, maxHeight || 0)
      });
      var padding2 = component2.get("padding");
      var bboxObject = component2.getLayoutBBox();
      var bbox = new BBox(bboxObject.x, bboxObject.y, bboxObject.width, bboxObject.height).expand(padding2);
      var _a2 = __read(directionToPosition(_this.view.viewBBox, bbox, direction2), 2), x1 = _a2[0], y1 = _a2[1];
      var _b = __read(directionToPosition(_this.layoutBBox, bbox, direction2), 2), x2 = _b[0], y2 = _b[1];
      var x3 = 0;
      var y3 = 0;
      if (direction2.startsWith("top") || direction2.startsWith("bottom")) {
        x3 = x1;
        y3 = y2;
      } else {
        x3 = x2;
        y3 = y1;
      }
      component2.setLocation({ x: x3 + padding2[3], y: y3 + padding2[0] });
      _this.layoutBBox = _this.layoutBBox.cut(bbox, direction2);
    });
  };
  Legend2.prototype.update = function() {
    var _this = this;
    this.option = this.view.getOptions().legends;
    var updated = {};
    var eachLegend = function(geometry2, attr, scale2) {
      var id3 = _this.getId(scale2.field);
      var existCo2 = _this.getComponentById(id3);
      if (existCo2) {
        var cfg = void 0;
        var legendOption = getLegendOption(_this.option, scale2.field);
        if (legendOption !== false) {
          if (get(legendOption, "custom")) {
            cfg = _this.getCategoryCfg(geometry2, attr, scale2, legendOption, true);
          } else {
            if (scale2.isLinear) {
              cfg = _this.getContinuousCfg(geometry2, attr, scale2, legendOption);
            } else if (scale2.isCategory) {
              cfg = _this.getCategoryCfg(geometry2, attr, scale2, legendOption);
            }
          }
        }
        if (cfg) {
          omit(cfg, ["container"]);
          existCo2.direction = getDirection(legendOption);
          existCo2.component.update(cfg);
          updated[id3] = true;
        }
      } else {
        var legend2 = _this.createFieldLegend(geometry2, attr, scale2);
        if (legend2) {
          legend2.component.init();
          _this.components.push(legend2);
          updated[id3] = true;
        }
      }
    };
    if (get(this.option, "custom")) {
      var id2 = "global-custom";
      var existCo = this.getComponentById(id2);
      if (existCo) {
        var customCfg = this.getCategoryCfg(void 0, void 0, void 0, this.option, true);
        omit(customCfg, ["container"]);
        existCo.component.update(customCfg);
        updated[id2] = true;
      } else {
        var component2 = this.createCustomLegend(void 0, void 0, void 0, this.option);
        if (component2) {
          component2.init();
          var layer = LAYER.FORE;
          var direction2 = getDirection(this.option);
          this.components.push({
            id: id2,
            component: component2,
            layer,
            direction: direction2,
            type: COMPONENT_TYPE.LEGEND,
            extra: void 0
          });
          updated[id2] = true;
        }
      }
    } else {
      this.loopLegends(eachLegend);
    }
    var components = [];
    each$1(this.getComponents(), function(co) {
      if (updated[co.id]) {
        components.push(co);
      } else {
        co.component.destroy();
      }
    });
    this.components = components;
  };
  Legend2.prototype.clear = function() {
    _super.prototype.clear.call(this);
    this.container.clear();
  };
  Legend2.prototype.destroy = function() {
    _super.prototype.destroy.call(this);
    this.container.remove(true);
  };
  Legend2.prototype.getGeometries = function(view) {
    var _this = this;
    var geometries = view.geometries;
    each$1(view.views, function(v2) {
      geometries = geometries.concat(_this.getGeometries(v2));
    });
    return geometries;
  };
  Legend2.prototype.loopLegends = function(doEach) {
    var isRootView = this.view.getRootView() === this.view;
    if (!isRootView) {
      return;
    }
    var geometries = this.getGeometries(this.view);
    var looped = {};
    each$1(geometries, function(geometry2) {
      var attributes2 = geometry2.getGroupAttributes();
      each$1(attributes2, function(attr) {
        var scale2 = attr.getScale(attr.type);
        if (!scale2 || scale2.type === "identity" || looped[scale2.field]) {
          return;
        }
        doEach(geometry2, attr, scale2);
        looped[scale2.field] = true;
      });
    });
  };
  Legend2.prototype.createFieldLegend = function(geometry2, attr, scale2) {
    var component2;
    var legendOption = getLegendOption(this.option, scale2.field);
    var layer = LAYER.FORE;
    var direction2 = getDirection(legendOption);
    if (legendOption !== false) {
      if (get(legendOption, "custom")) {
        component2 = this.createCustomLegend(geometry2, attr, scale2, legendOption);
      } else {
        if (scale2.isLinear) {
          component2 = this.createContinuousLegend(geometry2, attr, scale2, legendOption);
        } else if (scale2.isCategory) {
          component2 = this.createCategoryLegend(geometry2, attr, scale2, legendOption);
        }
      }
    }
    if (component2) {
      component2.set("field", scale2.field);
      return {
        id: this.getId(scale2.field),
        component: component2,
        layer,
        direction: direction2,
        type: COMPONENT_TYPE.LEGEND,
        extra: { scale: scale2 }
      };
    }
  };
  Legend2.prototype.createCustomLegend = function(geometry2, attr, scale2, legendOption) {
    var cfg = this.getCategoryCfg(geometry2, attr, scale2, legendOption, true);
    return new CategoryLegend(cfg);
  };
  Legend2.prototype.createContinuousLegend = function(geometry2, attr, scale2, legendOption) {
    var cfg = this.getContinuousCfg(geometry2, attr, scale2, omit(legendOption, ["value"]));
    return new ContinuousLegend(cfg);
  };
  Legend2.prototype.createCategoryLegend = function(geometry2, attr, scale2, legendOption) {
    var cfg = this.getCategoryCfg(geometry2, attr, scale2, legendOption);
    return new CategoryLegend(cfg);
  };
  Legend2.prototype.getContinuousCfg = function(geometry2, attr, scale2, legendOption) {
    var ticks = scale2.getTicks();
    var containMin = find$1(ticks, function(tick) {
      return tick.value === 0;
    });
    var containMax = find$1(ticks, function(tick) {
      return tick.value === 1;
    });
    var items = ticks.map(function(tick) {
      var value2 = tick.value, tickValue = tick.tickValue;
      var attrValue = attr.mapping(scale2.invert(value2)).join("");
      return {
        value: tickValue,
        attrValue,
        color: attrValue,
        scaleValue: value2
      };
    });
    if (!containMin) {
      items.push({
        value: scale2.min,
        attrValue: attr.mapping(scale2.invert(0)).join(""),
        color: attr.mapping(scale2.invert(0)).join(""),
        scaleValue: 0
      });
    }
    if (!containMax) {
      items.push({
        value: scale2.max,
        attrValue: attr.mapping(scale2.invert(1)).join(""),
        color: attr.mapping(scale2.invert(1)).join(""),
        scaleValue: 1
      });
    }
    items.sort(function(a2, b10) {
      return a2.value - b10.value;
    });
    var attrLegendCfg = {
      min: head(items).value,
      max: last(items).value,
      colors: [],
      rail: {
        type: attr.type
      },
      track: {}
    };
    if (attr.type === "size") {
      attrLegendCfg.track = {
        style: {
          fill: attr.type === "size" ? this.view.getTheme().defaultColor : void 0
        }
      };
    }
    if (attr.type === "color") {
      attrLegendCfg.colors = items.map(function(item) {
        return item.attrValue;
      });
    }
    var container = this.container;
    var direction2 = getDirection(legendOption);
    var layout2 = getLegendLayout(direction2);
    var title = get(legendOption, "title");
    if (title) {
      title = deepMix({
        text: getName(scale2)
      }, title);
    }
    attrLegendCfg.container = container;
    attrLegendCfg.layout = layout2;
    attrLegendCfg.title = title;
    attrLegendCfg.animateOption = DEFAULT_ANIMATE_CFG;
    return this.mergeLegendCfg(attrLegendCfg, legendOption, "continuous");
  };
  Legend2.prototype.getCategoryCfg = function(geometry2, attr, scale2, legendOption, custom12) {
    var container = this.container;
    var direction2 = get(legendOption, "position", DIRECTION.BOTTOM);
    var legendTheme = getLegendThemeCfg(this.view.getTheme(), direction2);
    var themeMarker = get(legendTheme, ["marker"]);
    var userMarker = get(legendOption, "marker");
    var layout2 = getLegendLayout(direction2);
    var themePageNavigator = get(legendTheme, ["pageNavigator"]);
    var userPageNavigator = get(legendOption, "pageNavigator");
    var items = custom12 ? getCustomLegendItems(themeMarker, userMarker, legendOption.items) : getLegendItems(this.view, geometry2, attr, themeMarker, userMarker);
    var title = get(legendOption, "title");
    if (title) {
      title = deepMix({
        text: scale2 ? getName(scale2) : ""
      }, title);
    }
    var maxWidthRatio = get(legendOption, "maxWidthRatio");
    var maxHeightRatio = get(legendOption, "maxHeightRatio");
    var baseCfg = this.getCategoryLegendSizeCfg(layout2, maxWidthRatio, maxHeightRatio);
    baseCfg.container = container;
    baseCfg.layout = layout2;
    baseCfg.items = items;
    baseCfg.title = title;
    baseCfg.animateOption = DEFAULT_ANIMATE_CFG;
    baseCfg.pageNavigator = deepMix({}, themePageNavigator, userPageNavigator);
    var categoryCfg = this.mergeLegendCfg(baseCfg, legendOption, direction2);
    if (categoryCfg.reversed) {
      categoryCfg.items.reverse();
    }
    var maxItemWidth = get(categoryCfg, "maxItemWidth");
    if (maxItemWidth && maxItemWidth <= 1) {
      categoryCfg.maxItemWidth = this.view.viewBBox.width * maxItemWidth;
    }
    return categoryCfg;
  };
  Legend2.prototype.mergeLegendCfg = function(baseCfg, legendOption, direction2) {
    var position = direction2.split("-")[0];
    var themeObject = getLegendThemeCfg(this.view.getTheme(), position);
    return deepMix({}, themeObject, baseCfg, legendOption);
  };
  Legend2.prototype.getId = function(key2) {
    return "".concat(this.name, "-").concat(key2);
  };
  Legend2.prototype.getComponentById = function(id2) {
    return find$1(this.components, function(co) {
      return co.id === id2;
    });
  };
  Legend2.prototype.getCategoryLegendSizeCfg = function(layout2, maxWidthRatio, maxHeightRatio) {
    if (maxWidthRatio === void 0) {
      maxWidthRatio = COMPONENT_MAX_VIEW_PERCENTAGE;
    }
    if (maxHeightRatio === void 0) {
      maxHeightRatio = COMPONENT_MAX_VIEW_PERCENTAGE;
    }
    var _a2 = this.view.viewBBox, vw = _a2.width, vh2 = _a2.height;
    return layout2 === "vertical" ? {
      maxWidth: vw * maxWidthRatio,
      maxHeight: vh2
    } : {
      maxWidth: vw,
      maxHeight: vh2 * maxHeightRatio
    };
  };
  return Legend2;
}(Controller);
var Slider = function(_super) {
  __extends$3(Slider2, _super);
  function Slider2(view) {
    var _this = _super.call(this, view) || this;
    _this.onChangeFn = noop;
    _this.resetMeasure = function() {
      _this.clear();
    };
    _this.onValueChange = function(v2) {
      var _a2 = __read(v2, 2), min2 = _a2[0], max2 = _a2[1];
      _this.start = min2;
      _this.end = max2;
      _this.changeViewData(min2, max2);
    };
    _this.container = _this.view.getLayer(LAYER.FORE).addGroup();
    _this.onChangeFn = throttle(_this.onValueChange, 20, {
      leading: true
    });
    _this.width = 0;
    _this.view.on(VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, _this.resetMeasure);
    _this.view.on(VIEW_LIFE_CIRCLE.BEFORE_CHANGE_SIZE, _this.resetMeasure);
    return _this;
  }
  Object.defineProperty(Slider2.prototype, "name", {
    get: function() {
      return "slider";
    },
    enumerable: false,
    configurable: true
  });
  Slider2.prototype.destroy = function() {
    _super.prototype.destroy.call(this);
    this.view.off(VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, this.resetMeasure);
    this.view.off(VIEW_LIFE_CIRCLE.BEFORE_CHANGE_SIZE, this.resetMeasure);
  };
  Slider2.prototype.init = function() {
  };
  Slider2.prototype.render = function() {
    this.option = this.view.getOptions().slider;
    var _a2 = this.getSliderCfg(), start = _a2.start, end = _a2.end;
    if (isNil(this.start)) {
      this.start = start;
      this.end = end;
    }
    var viewData = this.view.getOptions().data;
    if (this.option && !isEmpty(viewData)) {
      if (this.slider) {
        this.slider = this.updateSlider();
      } else {
        this.slider = this.createSlider();
        this.slider.component.on("sliderchange", this.onChangeFn);
      }
    } else {
      if (this.slider) {
        this.slider.component.destroy();
        this.slider = void 0;
      }
    }
  };
  Slider2.prototype.layout = function() {
    var _this = this;
    if (this.option && !this.width) {
      this.measureSlider();
      setTimeout(function() {
        if (!_this.view.destroyed) {
          _this.changeViewData(_this.start, _this.end);
        }
      }, 0);
    }
    if (this.slider) {
      var width = this.view.coordinateBBox.width;
      var padding2 = this.slider.component.get("padding");
      var _a2 = __read(padding2, 4), paddingTop = _a2[0];
      _a2[1];
      _a2[2];
      var paddingLeft = _a2[3];
      var bboxObject = this.slider.component.getLayoutBBox();
      var bbox = new BBox(bboxObject.x, bboxObject.y, Math.min(bboxObject.width, width), bboxObject.height).expand(padding2);
      var _b = this.getMinMaxText(this.start, this.end), minText = _b.minText, maxText = _b.maxText;
      var _c = __read(directionToPosition(this.view.viewBBox, bbox, DIRECTION.BOTTOM), 2);
      _c[0];
      var y1 = _c[1];
      var _d = __read(directionToPosition(this.view.coordinateBBox, bbox, DIRECTION.BOTTOM), 2), x2 = _d[0];
      _d[1];
      this.slider.component.update(__assign$4(__assign$4({}, this.getSliderCfg()), { x: x2 + paddingLeft, y: y1 + paddingTop, width: this.width, start: this.start, end: this.end, minText, maxText }));
      this.view.viewBBox = this.view.viewBBox.cut(bbox, DIRECTION.BOTTOM);
    }
  };
  Slider2.prototype.update = function() {
    this.render();
  };
  Slider2.prototype.createSlider = function() {
    var cfg = this.getSliderCfg();
    var component2 = new Slider$1(__assign$4({ container: this.container }, cfg));
    component2.init();
    return {
      component: component2,
      layer: LAYER.FORE,
      direction: DIRECTION.BOTTOM,
      type: COMPONENT_TYPE.SLIDER
    };
  };
  Slider2.prototype.updateSlider = function() {
    var cfg = this.getSliderCfg();
    if (this.width) {
      var _a2 = this.getMinMaxText(this.start, this.end), minText = _a2.minText, maxText = _a2.maxText;
      cfg = __assign$4(__assign$4({}, cfg), { width: this.width, start: this.start, end: this.end, minText, maxText });
    }
    this.slider.component.update(cfg);
    return this.slider;
  };
  Slider2.prototype.measureSlider = function() {
    var width = this.getSliderCfg().width;
    this.width = width;
  };
  Slider2.prototype.getSliderCfg = function() {
    var cfg = {
      height: 16,
      start: 0,
      end: 1,
      minText: "",
      maxText: "",
      x: 0,
      y: 0,
      width: this.view.coordinateBBox.width
    };
    if (isObject(this.option)) {
      var trendCfg = __assign$4({ data: this.getData() }, get(this.option, "trendCfg", {}));
      cfg = deepMix({}, cfg, this.getThemeOptions(), this.option);
      cfg = __assign$4(__assign$4({}, cfg), { trendCfg });
    }
    cfg.start = clamp(Math.min(isNil(cfg.start) ? 0 : cfg.start, isNil(cfg.end) ? 1 : cfg.end), 0, 1);
    cfg.end = clamp(Math.max(isNil(cfg.start) ? 0 : cfg.start, isNil(cfg.end) ? 1 : cfg.end), 0, 1);
    return cfg;
  };
  Slider2.prototype.getData = function() {
    var data2 = this.view.getOptions().data;
    var _a2 = __read(this.view.getYScales(), 1), yScale = _a2[0];
    var groupScales = this.view.getGroupScales();
    if (groupScales.length) {
      var _b = groupScales[0], field_1 = _b.field, ticks_1 = _b.ticks;
      return data2.reduce(function(pre, cur) {
        if (cur[field_1] === ticks_1[0]) {
          pre.push(cur[yScale.field]);
        }
        return pre;
      }, []);
    }
    return data2.map(function(datum) {
      return datum[yScale.field] || 0;
    });
  };
  Slider2.prototype.getThemeOptions = function() {
    var theme2 = this.view.getTheme();
    return get(theme2, ["components", "slider", "common"], {});
  };
  Slider2.prototype.getMinMaxText = function(min2, max2) {
    var data2 = this.view.getOptions().data;
    var xScale = this.view.getXScale();
    var values2 = valuesOfKey(data2, xScale.field);
    if (xScale.isLinear) {
      values2 = values2.sort();
    }
    var xValues = values2;
    var dataSize = size(data2);
    if (!xScale || !dataSize) {
      return {};
    }
    var xTickCount = size(xValues);
    var minIndex = Math.round(min2 * (xTickCount - 1));
    var maxIndex = Math.round(max2 * (xTickCount - 1));
    var minText = get(xValues, [minIndex]);
    var maxText = get(xValues, [maxIndex]);
    var formatter = this.getSliderCfg().formatter;
    if (formatter) {
      minText = formatter(minText, data2[minIndex], minIndex);
      maxText = formatter(maxText, data2[maxIndex], maxIndex);
    }
    return {
      minText,
      maxText
    };
  };
  Slider2.prototype.changeViewData = function(min2, max2) {
    var data2 = this.view.getOptions().data;
    var xScale = this.view.getXScale();
    var dataSize = size(data2);
    if (!xScale || !dataSize) {
      return;
    }
    var values2 = valuesOfKey(data2, xScale.field);
    var xScaleValues = this.view.getXScale().isLinear ? values2.sort(function(a2, b10) {
      return Number(a2) - Number(b10);
    }) : values2;
    var xValues = xScaleValues;
    var xTickCount = size(xValues);
    var minIndex = Math.round(min2 * (xTickCount - 1));
    var maxIndex = Math.round(max2 * (xTickCount - 1));
    this.view.filter(xScale.field, function(value2, datum) {
      var idx = xValues.indexOf(value2);
      return idx > -1 ? isBetween$1(idx, minIndex, maxIndex) : true;
    });
    this.view.render(true);
  };
  Slider2.prototype.getComponents = function() {
    return this.slider ? [this.slider] : [];
  };
  Slider2.prototype.clear = function() {
    if (this.slider) {
      this.slider.component.destroy();
      this.slider = void 0;
    }
    this.width = 0;
    this.start = void 0;
    this.end = void 0;
  };
  return Slider2;
}(Controller);
var DEFAULT_PADDING = 0;
var DEFAULT_SIZE = 8;
var DEFAULT_CATEGORY_SIZE = 32;
var MIN_THUMB_LENGTH = 20;
var Scrollbar = function(_super) {
  __extends$3(Scrollbar2, _super);
  function Scrollbar2(view) {
    var _this = _super.call(this, view) || this;
    _this.onChangeFn = noop;
    _this.resetMeasure = function() {
      _this.clear();
    };
    _this.onValueChange = function(_a2) {
      var ratio = _a2.ratio;
      var animate = _this.getValidScrollbarCfg().animate;
      _this.ratio = clamp(ratio, 0, 1);
      var originalAnimate = _this.view.getOptions().animate;
      if (!animate) {
        _this.view.animate(false);
      }
      _this.changeViewData(_this.getScrollRange(), true);
      _this.view.animate(originalAnimate);
    };
    _this.container = _this.view.getLayer(LAYER.FORE).addGroup();
    _this.onChangeFn = throttle(_this.onValueChange, 20, {
      leading: true
    });
    _this.trackLen = 0;
    _this.thumbLen = 0;
    _this.ratio = 0;
    _this.view.on(VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, _this.resetMeasure);
    _this.view.on(VIEW_LIFE_CIRCLE.BEFORE_CHANGE_SIZE, _this.resetMeasure);
    return _this;
  }
  Object.defineProperty(Scrollbar2.prototype, "name", {
    get: function() {
      return "scrollbar";
    },
    enumerable: false,
    configurable: true
  });
  Scrollbar2.prototype.destroy = function() {
    _super.prototype.destroy.call(this);
    this.view.off(VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, this.resetMeasure);
    this.view.off(VIEW_LIFE_CIRCLE.BEFORE_CHANGE_SIZE, this.resetMeasure);
  };
  Scrollbar2.prototype.init = function() {
  };
  Scrollbar2.prototype.render = function() {
    this.option = this.view.getOptions().scrollbar;
    if (this.option) {
      if (this.scrollbar) {
        this.scrollbar = this.updateScrollbar();
      } else {
        this.scrollbar = this.createScrollbar();
        this.scrollbar.component.on("scrollchange", this.onChangeFn);
      }
    } else {
      if (this.scrollbar) {
        this.scrollbar.component.destroy();
        this.scrollbar = void 0;
      }
    }
  };
  Scrollbar2.prototype.layout = function() {
    var _this = this;
    if (this.option && !this.trackLen) {
      this.measureScrollbar();
      setTimeout(function() {
        if (!_this.view.destroyed) {
          _this.changeViewData(_this.getScrollRange(), true);
        }
      });
    }
    if (this.scrollbar) {
      var width = this.view.coordinateBBox.width;
      var padding2 = this.scrollbar.component.get("padding");
      var bboxObject = this.scrollbar.component.getLayoutBBox();
      var bbox = new BBox(bboxObject.x, bboxObject.y, Math.min(bboxObject.width, width), bboxObject.height).expand(padding2);
      var cfg = this.getScrollbarComponentCfg();
      var x2 = void 0;
      var y2 = void 0;
      if (cfg.isHorizontal) {
        var _a2 = __read(directionToPosition(this.view.viewBBox, bbox, DIRECTION.BOTTOM), 2);
        _a2[0];
        var y1 = _a2[1];
        var _b = __read(directionToPosition(this.view.coordinateBBox, bbox, DIRECTION.BOTTOM), 2), x22 = _b[0];
        _b[1];
        x2 = x22;
        y2 = y1;
      } else {
        var _c = __read(directionToPosition(this.view.viewBBox, bbox, DIRECTION.RIGHT), 2);
        _c[0];
        var y1 = _c[1];
        var _d = __read(directionToPosition(this.view.viewBBox, bbox, DIRECTION.RIGHT), 2), x22 = _d[0];
        _d[1];
        x2 = x22;
        y2 = y1;
      }
      x2 += padding2[3];
      y2 += padding2[0];
      if (this.trackLen) {
        this.scrollbar.component.update(__assign$4(__assign$4({}, cfg), { x: x2, y: y2, trackLen: this.trackLen, thumbLen: this.thumbLen, thumbOffset: (this.trackLen - this.thumbLen) * this.ratio }));
      } else {
        this.scrollbar.component.update(__assign$4(__assign$4({}, cfg), { x: x2, y: y2 }));
      }
      this.view.viewBBox = this.view.viewBBox.cut(bbox, cfg.isHorizontal ? DIRECTION.BOTTOM : DIRECTION.RIGHT);
    }
  };
  Scrollbar2.prototype.update = function() {
    this.render();
  };
  Scrollbar2.prototype.getComponents = function() {
    return this.scrollbar ? [this.scrollbar] : [];
  };
  Scrollbar2.prototype.clear = function() {
    if (this.scrollbar) {
      this.scrollbar.component.destroy();
      this.scrollbar = void 0;
    }
    this.trackLen = 0;
    this.thumbLen = 0;
    this.ratio = 0;
    this.cnt = 0;
    this.step = 0;
    this.data = void 0;
    this.xScaleCfg = void 0;
    this.yScalesCfg = [];
  };
  Scrollbar2.prototype.setValue = function(ratio) {
    this.onValueChange({ ratio });
  };
  Scrollbar2.prototype.getValue = function() {
    return this.ratio;
  };
  Scrollbar2.prototype.getThemeOptions = function() {
    var theme2 = this.view.getTheme();
    return get(theme2, ["components", "scrollbar", "common"], {});
  };
  Scrollbar2.prototype.getScrollbarTheme = function(style2) {
    var theme2 = get(this.view.getTheme(), ["components", "scrollbar"]);
    var _a2 = style2 || {}, thumbHighlightColor = _a2.thumbHighlightColor, restStyles = __rest$3(_a2, ["thumbHighlightColor"]);
    return {
      default: deepMix({}, get(theme2, ["default", "style"], {}), restStyles),
      hover: deepMix({}, get(theme2, ["hover", "style"], {}), { thumbColor: thumbHighlightColor })
    };
  };
  Scrollbar2.prototype.measureScrollbar = function() {
    var xScale = this.view.getXScale();
    var yScales = this.view.getYScales().slice();
    this.data = this.getScrollbarData();
    this.step = this.getStep();
    this.cnt = this.getCnt();
    var _a2 = this.getScrollbarComponentCfg(), trackLen = _a2.trackLen, thumbLen = _a2.thumbLen;
    this.trackLen = trackLen;
    this.thumbLen = thumbLen;
    this.xScaleCfg = {
      field: xScale.field,
      values: xScale.values || []
    };
    this.yScalesCfg = yScales;
  };
  Scrollbar2.prototype.getScrollRange = function() {
    var startIdx = Math.floor((this.cnt - this.step) * clamp(this.ratio, 0, 1));
    var endIdx = Math.min(startIdx + this.step - 1, this.cnt - 1);
    return [startIdx, endIdx];
  };
  Scrollbar2.prototype.changeViewData = function(_a2, render2) {
    var _this = this;
    var _b = __read(_a2, 2), startIdx = _b[0], endIdx = _b[1];
    var type4 = this.getValidScrollbarCfg().type;
    var isHorizontal2 = type4 !== "vertical";
    var values2 = valuesOfKey(this.data, this.xScaleCfg.field);
    var xScaleValues = this.view.getXScale().isLinear ? values2.sort(function(a2, b10) {
      return Number(a2) - Number(b10);
    }) : values2;
    var xValues = isHorizontal2 ? xScaleValues : xScaleValues.reverse();
    this.yScalesCfg.forEach(function(cfg) {
      _this.view.scale(cfg.field, {
        formatter: cfg.formatter,
        type: cfg.type,
        min: cfg.min,
        max: cfg.max,
        tickMethod: cfg.tickMethod
      });
    });
    this.view.filter(this.xScaleCfg.field, function(val) {
      var idx = xValues.indexOf(val);
      return idx > -1 ? isBetween$1(idx, startIdx, endIdx) : true;
    });
    this.view.render(true);
  };
  Scrollbar2.prototype.createScrollbar = function() {
    var type4 = this.getValidScrollbarCfg().type;
    var isHorizontal2 = type4 !== "vertical";
    var component2 = new Scrollbar$1(__assign$4(__assign$4({ container: this.container }, this.getScrollbarComponentCfg()), { x: 0, y: 0 }));
    component2.init();
    return {
      component: component2,
      layer: LAYER.FORE,
      direction: isHorizontal2 ? DIRECTION.BOTTOM : DIRECTION.RIGHT,
      type: COMPONENT_TYPE.SCROLLBAR
    };
  };
  Scrollbar2.prototype.updateScrollbar = function() {
    var config = this.getScrollbarComponentCfg();
    var realConfig = this.trackLen ? __assign$4(__assign$4({}, config), { trackLen: this.trackLen, thumbLen: this.thumbLen, thumbOffset: (this.trackLen - this.thumbLen) * this.ratio }) : __assign$4({}, config);
    this.scrollbar.component.update(realConfig);
    return this.scrollbar;
  };
  Scrollbar2.prototype.getStep = function() {
    if (this.step) {
      return this.step;
    }
    var coordinateBBox = this.view.coordinateBBox;
    var _a2 = this.getValidScrollbarCfg(), type4 = _a2.type, categorySize = _a2.categorySize;
    var isHorizontal2 = type4 !== "vertical";
    return Math.floor((isHorizontal2 ? coordinateBBox.width : coordinateBBox.height) / categorySize);
  };
  Scrollbar2.prototype.getCnt = function() {
    if (this.cnt) {
      return this.cnt;
    }
    var xScale = this.view.getXScale();
    var data2 = this.getScrollbarData();
    var values2 = valuesOfKey(data2, xScale.field);
    return size(values2);
  };
  Scrollbar2.prototype.getScrollbarComponentCfg = function() {
    var _a2 = this.view, coordinateBBox = _a2.coordinateBBox, viewBBox = _a2.viewBBox;
    var _b = this.getValidScrollbarCfg(), type4 = _b.type, padding2 = _b.padding, width = _b.width, height = _b.height, style2 = _b.style;
    var isHorizontal2 = type4 !== "vertical";
    var _c = __read(padding2, 4), paddingTop = _c[0], paddingRight = _c[1], paddingBottom = _c[2], paddingLeft = _c[3];
    var position = isHorizontal2 ? {
      x: coordinateBBox.minX + paddingLeft,
      y: viewBBox.maxY - height - paddingBottom
    } : {
      x: viewBBox.maxX - width - paddingRight,
      y: coordinateBBox.minY + paddingTop
    };
    var step = this.getStep();
    var cnt = this.getCnt();
    var trackLen = isHorizontal2 ? coordinateBBox.width - paddingLeft - paddingRight : coordinateBBox.height - paddingTop - paddingBottom;
    var thumbLen = Math.max(trackLen * clamp(step / cnt, 0, 1), MIN_THUMB_LENGTH);
    return __assign$4(__assign$4({}, this.getThemeOptions()), { x: position.x, y: position.y, size: isHorizontal2 ? height : width, isHorizontal: isHorizontal2, trackLen, thumbLen, thumbOffset: 0, theme: this.getScrollbarTheme(style2) });
  };
  Scrollbar2.prototype.getValidScrollbarCfg = function() {
    var cfg = {
      type: "horizontal",
      categorySize: DEFAULT_CATEGORY_SIZE,
      width: DEFAULT_SIZE,
      height: DEFAULT_SIZE,
      padding: [0, 0, 0, 0],
      animate: true,
      style: {}
    };
    if (isObject(this.option)) {
      cfg = __assign$4(__assign$4({}, cfg), this.option);
    }
    if (!isObject(this.option) || !this.option.padding) {
      cfg.padding = cfg.type === "horizontal" ? [DEFAULT_PADDING, 0, DEFAULT_PADDING, 0] : [0, DEFAULT_PADDING, 0, DEFAULT_PADDING];
    }
    return cfg;
  };
  Scrollbar2.prototype.getScrollbarData = function() {
    var coordinate2 = this.view.getCoordinate();
    var cfg = this.getValidScrollbarCfg();
    var data2 = this.view.getOptions().data || [];
    if (coordinate2.isReflect("y") && cfg.type === "vertical") {
      data2 = __spreadArray$1([], __read(data2), false).reverse();
    }
    return data2;
  };
  return Scrollbar2;
}(Controller);
var DEFAULT_REGION_PATH_STYLE = {
  fill: "#CCD6EC",
  opacity: 0.3
};
function getItemsOfView(view, point2, tooltipCfg) {
  var e_1, _a2, e_2, _b, e_3, _c;
  var items = findItemsFromViewRecurisive(view, point2, tooltipCfg);
  if (items.length) {
    items = flatten(items);
    try {
      for (var items_1 = __values(items), items_1_1 = items_1.next(); !items_1_1.done; items_1_1 = items_1.next()) {
        var itemArr = items_1_1.value;
        try {
          for (var itemArr_1 = (e_2 = void 0, __values(itemArr)), itemArr_1_1 = itemArr_1.next(); !itemArr_1_1.done; itemArr_1_1 = itemArr_1.next()) {
            var item = itemArr_1_1.value;
            var _d = item.mappingData, x2 = _d.x, y2 = _d.y;
            item.x = isArray$1(x2) ? x2[x2.length - 1] : x2;
            item.y = isArray$1(y2) ? y2[y2.length - 1] : y2;
          }
        } catch (e_2_1) {
          e_2 = { error: e_2_1 };
        } finally {
          try {
            if (itemArr_1_1 && !itemArr_1_1.done && (_b = itemArr_1.return))
              _b.call(itemArr_1);
          } finally {
            if (e_2)
              throw e_2.error;
          }
        }
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (items_1_1 && !items_1_1.done && (_a2 = items_1.return))
          _a2.call(items_1);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
    var shared = tooltipCfg.shared;
    if (shared === false && items.length > 1) {
      var snapItem = items[0];
      var min2 = Math.abs(point2.y - snapItem[0].y);
      try {
        for (var items_2 = __values(items), items_2_1 = items_2.next(); !items_2_1.done; items_2_1 = items_2.next()) {
          var aItem = items_2_1.value;
          var yDistance = Math.abs(point2.y - aItem[0].y);
          if (yDistance <= min2) {
            snapItem = aItem;
            min2 = yDistance;
          }
        }
      } catch (e_3_1) {
        e_3 = { error: e_3_1 };
      } finally {
        try {
          if (items_2_1 && !items_2_1.done && (_c = items_2.return))
            _c.call(items_2);
        } finally {
          if (e_3)
            throw e_3.error;
        }
      }
      items = [snapItem];
    }
    return uniq$2(flatten(items));
  }
  return [];
}
var ActiveRegion = function(_super) {
  __extends$3(ActiveRegion2, _super);
  function ActiveRegion2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  ActiveRegion2.prototype.show = function(args) {
    var view = this.context.view;
    var ev = this.context.event;
    var tooltipCfg = view.getController("tooltip").getTooltipCfg();
    var tooltipItems = getItemsOfView(view, {
      x: ev.x,
      y: ev.y
    }, tooltipCfg);
    if (isEqual$1(tooltipItems, this.items)) {
      return;
    }
    this.items = tooltipItems;
    if (tooltipItems.length) {
      var xField_1 = view.getXScale().field;
      var xValue_1 = tooltipItems[0].data[xField_1];
      var elements_1 = [];
      var geometries = view.geometries;
      each$1(geometries, function(geometry2) {
        if (geometry2.type === "interval" || geometry2.type === "schema") {
          var result = geometry2.getElementsBy(function(ele) {
            var eleData = ele.getData();
            return eleData[xField_1] === xValue_1;
          });
          elements_1 = elements_1.concat(result);
        }
      });
      if (elements_1.length) {
        var coordinate_1 = view.getCoordinate();
        var firstBBox_1 = elements_1[0].shape.getCanvasBBox();
        var lastBBox_1 = elements_1[0].shape.getCanvasBBox();
        var groupBBox_1 = firstBBox_1;
        each$1(elements_1, function(ele) {
          var bbox = ele.shape.getCanvasBBox();
          if (coordinate_1.isTransposed) {
            if (bbox.minY < firstBBox_1.minY) {
              firstBBox_1 = bbox;
            }
            if (bbox.maxY > lastBBox_1.maxY) {
              lastBBox_1 = bbox;
            }
          } else {
            if (bbox.minX < firstBBox_1.minX) {
              firstBBox_1 = bbox;
            }
            if (bbox.maxX > lastBBox_1.maxX) {
              lastBBox_1 = bbox;
            }
          }
          groupBBox_1.x = Math.min(bbox.minX, groupBBox_1.minX);
          groupBBox_1.y = Math.min(bbox.minY, groupBBox_1.minY);
          groupBBox_1.width = Math.max(bbox.maxX, groupBBox_1.maxX) - groupBBox_1.x;
          groupBBox_1.height = Math.max(bbox.maxY, groupBBox_1.maxY) - groupBBox_1.y;
        });
        var backgroundGroup = view.backgroundGroup, coordinateBBox = view.coordinateBBox;
        var path2 = void 0;
        if (coordinate_1.isRect) {
          var xScale = view.getXScale();
          var _a2 = args || {}, appendRatio = _a2.appendRatio, appendWidth = _a2.appendWidth;
          if (isNil(appendWidth)) {
            appendRatio = isNil(appendRatio) ? xScale.isLinear ? 0 : 0.25 : appendRatio;
            appendWidth = coordinate_1.isTransposed ? appendRatio * lastBBox_1.height : appendRatio * firstBBox_1.width;
          }
          var minX = void 0;
          var minY = void 0;
          var width = void 0;
          var height = void 0;
          if (coordinate_1.isTransposed) {
            minX = coordinateBBox.minX;
            minY = Math.min(lastBBox_1.minY, firstBBox_1.minY) - appendWidth;
            width = coordinateBBox.width;
            height = groupBBox_1.height + appendWidth * 2;
          } else {
            minX = Math.min(firstBBox_1.minX, lastBBox_1.minX) - appendWidth;
            minY = coordinateBBox.minY;
            width = groupBBox_1.width + appendWidth * 2;
            height = coordinateBBox.height;
          }
          path2 = [
            ["M", minX, minY],
            ["L", minX + width, minY],
            ["L", minX + width, minY + height],
            ["L", minX, minY + height],
            ["Z"]
          ];
        } else {
          var firstElement = head(elements_1);
          var lastElement = last(elements_1);
          var startAngle = getAngle$1(firstElement.getModel(), coordinate_1).startAngle;
          var endAngle = getAngle$1(lastElement.getModel(), coordinate_1).endAngle;
          var center2 = coordinate_1.getCenter();
          var radius = coordinate_1.getRadius();
          var innterRadius = coordinate_1.innerRadius * radius;
          path2 = getSectorPath(center2.x, center2.y, radius, startAngle, endAngle, innterRadius);
        }
        if (this.regionPath) {
          this.regionPath.attr("path", path2);
          this.regionPath.show();
        } else {
          var style2 = get(args, "style", DEFAULT_REGION_PATH_STYLE);
          this.regionPath = backgroundGroup.addShape({
            type: "path",
            name: "active-region",
            capture: false,
            attrs: __assign$4(__assign$4({}, style2), { path: path2 })
          });
        }
      }
    }
  };
  ActiveRegion2.prototype.hide = function() {
    if (this.regionPath) {
      this.regionPath.hide();
    }
    this.items = null;
  };
  ActiveRegion2.prototype.destroy = function() {
    this.hide();
    if (this.regionPath) {
      this.regionPath.remove(true);
    }
    _super.prototype.destroy.call(this);
  };
  return ActiveRegion2;
}(Action);
var TooltipAction = function(_super) {
  __extends$3(TooltipAction2, _super);
  function TooltipAction2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.timeStamp = 0;
    return _this;
  }
  TooltipAction2.prototype.show = function() {
    var context2 = this.context;
    var ev = context2.event;
    var view = context2.view;
    var isTooltipLocked = view.isTooltipLocked();
    if (isTooltipLocked) {
      return;
    }
    var lastTimeStamp = this.timeStamp;
    var timeStamp = +new Date();
    var showDelay = get(context2.view.getOptions(), "tooltip.showDelay", 16);
    if (timeStamp - lastTimeStamp > showDelay) {
      var preLoc = this.location;
      var curLoc = { x: ev.x, y: ev.y };
      if (!preLoc || !isEqual$1(preLoc, curLoc)) {
        this.showTooltip(view, curLoc);
      }
      this.timeStamp = timeStamp;
      this.location = curLoc;
    }
  };
  TooltipAction2.prototype.hide = function() {
    var view = this.context.view;
    var tooltip2 = view.getController("tooltip");
    var _a2 = this.context.event, clientX = _a2.clientX, clientY = _a2.clientY;
    if (tooltip2.isCursorEntered({ x: clientX, y: clientY })) {
      return;
    }
    if (view.isTooltipLocked()) {
      return;
    }
    this.hideTooltip(view);
    this.location = null;
  };
  TooltipAction2.prototype.showTooltip = function(view, point2) {
    view.showTooltip(point2);
  };
  TooltipAction2.prototype.hideTooltip = function(view) {
    view.hideTooltip();
  };
  return TooltipAction2;
}(Action);
var SiblingTooltip = function(_super) {
  __extends$3(SiblingTooltip2, _super);
  function SiblingTooltip2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  SiblingTooltip2.prototype.showTooltip = function(view, point2) {
    var siblings2 = getSilbings(view);
    each$1(siblings2, function(sibling) {
      var siblingPoint = getSiblingPoint(view, sibling, point2);
      sibling.showTooltip(siblingPoint);
    });
  };
  SiblingTooltip2.prototype.hideTooltip = function(view) {
    var siblings2 = getSilbings(view);
    each$1(siblings2, function(sibling) {
      sibling.hideTooltip();
    });
  };
  return SiblingTooltip2;
}(TooltipAction);
var EllipsisText = function(_super) {
  __extends$3(EllipsisText2, _super);
  function EllipsisText2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.timeStamp = 0;
    return _this;
  }
  EllipsisText2.prototype.destroy = function() {
    _super.prototype.destroy.call(this);
    this.tooltip && this.tooltip.destroy();
  };
  EllipsisText2.prototype.show = function() {
    var context2 = this.context;
    var ev = context2.event;
    var lastTimeStamp = this.timeStamp;
    var timeStamp = +new Date();
    if (timeStamp - lastTimeStamp > 16) {
      var preLoc = this.location;
      var curLoc = { x: ev.x, y: ev.y };
      if (!preLoc || !isEqual$1(preLoc, curLoc)) {
        this.showTooltip(curLoc);
      }
      this.timeStamp = timeStamp;
      this.location = curLoc;
    }
  };
  EllipsisText2.prototype.hide = function() {
    this.hideTooltip();
    this.location = null;
  };
  EllipsisText2.prototype.showTooltip = function(curLoc) {
    var context2 = this.context;
    var ev = context2.event;
    var target = ev.target;
    if (target && target.get("tip")) {
      if (!this.tooltip) {
        this.renderTooltip();
      }
      var tipContent = target.get("tip");
      this.tooltip.update(__assign$4({ title: tipContent }, curLoc));
      this.tooltip.show();
    }
  };
  EllipsisText2.prototype.hideTooltip = function() {
    this.tooltip && this.tooltip.hide();
  };
  EllipsisText2.prototype.renderTooltip = function() {
    var _a2;
    var view = this.context.view;
    var canvas = view.canvas;
    var region = {
      start: { x: 0, y: 0 },
      end: { x: canvas.get("width"), y: canvas.get("height") }
    };
    var theme2 = view.getTheme();
    var tooltipStyles = get(theme2, ["components", "tooltip", "domStyles"], {});
    var tooltip2 = new HtmlTooltip({
      parent: canvas.get("el").parentNode,
      region,
      visible: false,
      crosshairs: null,
      domStyles: __assign$4({}, deepMix({}, tooltipStyles, (_a2 = {}, _a2[CONTAINER_CLASS] = { "max-width": "50%" }, _a2[TITLE_CLASS] = { "word-break": "break-all" }, _a2)))
    });
    tooltip2.init();
    tooltip2.setCapture(false);
    this.tooltip = tooltip2;
  };
  return EllipsisText2;
}(Action);
var StateBase = function(_super) {
  __extends$3(StateBase2, _super);
  function StateBase2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.stateName = "";
    return _this;
  }
  StateBase2.prototype.hasState = function(element) {
    return element.hasState(this.stateName);
  };
  StateBase2.prototype.setElementState = function(element, enable) {
    element.setState(this.stateName, enable);
  };
  StateBase2.prototype.setState = function() {
    this.setStateEnable(true);
  };
  StateBase2.prototype.clear = function() {
    var view = this.context.view;
    this.clearViewState(view);
  };
  StateBase2.prototype.clearViewState = function(view) {
    var _this = this;
    var elements = getElementsByState(view, this.stateName);
    each$1(elements, function(el) {
      _this.setElementState(el, false);
    });
  };
  return StateBase2;
}(Action);
function getItem(shape) {
  return get(shape.get("delegateObject"), "item");
}
var ElementState = function(_super) {
  __extends$3(ElementState2, _super);
  function ElementState2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.ignoreListItemStates = ["unchecked"];
    return _this;
  }
  ElementState2.prototype.isItemIgnore = function(item, list) {
    var states = this.ignoreListItemStates;
    var filtered = states.filter(function(state2) {
      return list.hasState(item, state2);
    });
    return !!filtered.length;
  };
  ElementState2.prototype.setStateByComponent = function(component2, item, enable) {
    var view = this.context.view;
    var field2 = component2.get("field");
    var elements = getElements(view);
    this.setElementsStateByItem(elements, field2, item, enable);
  };
  ElementState2.prototype.setStateByElement = function(element, enable) {
    this.setElementState(element, enable);
  };
  ElementState2.prototype.isMathItem = function(element, field2, item) {
    var view = this.context.view;
    var scale2 = getScaleByField(view, field2);
    var value2 = getElementValue$1(element, field2);
    return !isNil(value2) && item.name === scale2.getText(value2);
  };
  ElementState2.prototype.setElementsStateByItem = function(elements, field2, item, enable) {
    var _this = this;
    each$1(elements, function(el) {
      if (_this.isMathItem(el, field2, item)) {
        el.setState(_this.stateName, enable);
      }
    });
  };
  ElementState2.prototype.setStateEnable = function(enable) {
    var element = getCurrentElement$1(this.context);
    if (element) {
      if (isElementChange(this.context)) {
        this.setStateByElement(element, enable);
      }
    } else {
      var delegateObject = getDelegationObject(this.context);
      if (isList(delegateObject)) {
        var item = delegateObject.item, component2 = delegateObject.component;
        if (item && component2 && !this.isItemIgnore(item, component2)) {
          var event_1 = this.context.event.gEvent;
          if (event_1 && event_1.fromShape && event_1.toShape && getItem(event_1.fromShape) === getItem(event_1.toShape)) {
            return;
          }
          this.setStateByComponent(component2, item, enable);
        }
      }
    }
  };
  ElementState2.prototype.toggle = function() {
    var element = getCurrentElement$1(this.context);
    if (element) {
      var hasState = element.hasState(this.stateName);
      this.setElementState(element, !hasState);
    }
  };
  ElementState2.prototype.reset = function() {
    this.setStateEnable(false);
  };
  return ElementState2;
}(StateBase);
var ElementActive = function(_super) {
  __extends$3(ElementActive2, _super);
  function ElementActive2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.stateName = "active";
    return _this;
  }
  ElementActive2.prototype.active = function() {
    this.setState();
  };
  return ElementActive2;
}(ElementState);
var LinkByColor = function(_super) {
  __extends$3(LinkByColor2, _super);
  function LinkByColor2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.cache = {};
    return _this;
  }
  LinkByColor2.prototype.getColorScale = function(view, element) {
    var colorAttr = element.geometry.getAttribute("color");
    if (!colorAttr) {
      return null;
    }
    var scale2 = view.getScaleByField(colorAttr.getFields()[0]);
    return scale2;
  };
  LinkByColor2.prototype.getLinkPath = function(element, nextElement) {
    var view = this.context.view;
    var isTransposed = view.getCoordinate().isTransposed;
    var bbox = element.shape.getCanvasBBox();
    var nextBBox = nextElement.shape.getCanvasBBox();
    var path2 = isTransposed ? [
      ["M", bbox.minX, bbox.minY],
      ["L", nextBBox.minX, nextBBox.maxY],
      ["L", nextBBox.maxX, nextBBox.maxY],
      ["L", bbox.maxX, bbox.minY],
      ["Z"]
    ] : [
      ["M", bbox.maxX, bbox.minY],
      ["L", nextBBox.minX, nextBBox.minY],
      ["L", nextBBox.minX, nextBBox.maxY],
      ["L", bbox.maxX, bbox.maxY],
      ["Z"]
    ];
    return path2;
  };
  LinkByColor2.prototype.addLinkShape = function(group2, element, nextElement, activeStyle) {
    var style2 = {
      opacity: 0.4,
      fill: element.shape.attr("fill")
    };
    group2.addShape({
      type: "path",
      attrs: __assign$4(__assign$4({}, deepMix({}, style2, isFunction(activeStyle) ? activeStyle(style2, element) : activeStyle)), { path: this.getLinkPath(element, nextElement) })
    });
  };
  LinkByColor2.prototype.linkByElement = function(element, activeStyle) {
    var _this = this;
    var view = this.context.view;
    var scale2 = this.getColorScale(view, element);
    if (!scale2) {
      return;
    }
    var value2 = getElementValue$1(element, scale2.field);
    if (!this.cache[value2]) {
      var elements_1 = getElementsByField(view, scale2.field, value2);
      var linkGroup = this.linkGroup;
      var group_1 = linkGroup.addGroup();
      this.cache[value2] = group_1;
      var count_1 = elements_1.length;
      each$1(elements_1, function(el, index2) {
        if (index2 < count_1 - 1) {
          var nextEl = elements_1[index2 + 1];
          _this.addLinkShape(group_1, el, nextEl, activeStyle);
        }
      });
    }
  };
  LinkByColor2.prototype.removeLink = function(element) {
    var scale2 = this.getColorScale(this.context.view, element);
    if (!scale2) {
      return;
    }
    var value2 = getElementValue$1(element, scale2.field);
    if (this.cache[value2]) {
      this.cache[value2].remove();
      this.cache[value2] = null;
    }
  };
  LinkByColor2.prototype.link = function(args) {
    var context2 = this.context;
    if (!this.linkGroup) {
      this.linkGroup = context2.view.foregroundGroup.addGroup({
        id: "link-by-color-group",
        capture: false
      });
    }
    var element = getCurrentElement$1(context2);
    if (element) {
      this.linkByElement(element, args === null || args === void 0 ? void 0 : args.style);
    }
  };
  LinkByColor2.prototype.unlink = function() {
    var element = getCurrentElement$1(this.context);
    if (element) {
      this.removeLink(element);
    }
  };
  LinkByColor2.prototype.clear = function() {
    if (this.linkGroup) {
      this.linkGroup.clear();
    }
    this.cache = {};
  };
  LinkByColor2.prototype.destroy = function() {
    _super.prototype.destroy.call(this);
    if (this.linkGroup) {
      this.linkGroup.remove();
    }
  };
  return LinkByColor2;
}(Action);
var ElementRangeState = function(_super) {
  __extends$3(ElementRangeState2, _super);
  function ElementRangeState2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.startPoint = null;
    _this.endPoint = null;
    _this.isStarted = false;
    _this.effectSiblings = false;
    _this.effectByRecord = false;
    return _this;
  }
  ElementRangeState2.prototype.getCurrentPoint = function() {
    var event = this.context.event;
    return {
      x: event.x,
      y: event.y
    };
  };
  ElementRangeState2.prototype.start = function() {
    this.clear();
    this.startPoint = this.getCurrentPoint();
    this.isStarted = true;
  };
  ElementRangeState2.prototype.getIntersectElements = function() {
    var elements = null;
    if (isMask(this.context)) {
      elements = getMaskedElements(this.context, 10);
    } else {
      var startPoint = this.startPoint;
      var endPoint = this.isStarted ? this.getCurrentPoint() : this.endPoint;
      if (!startPoint || !endPoint) {
        return;
      }
      var box2 = {
        minX: Math.min(startPoint.x, endPoint.x),
        minY: Math.min(startPoint.y, endPoint.y),
        maxX: Math.max(startPoint.x, endPoint.x),
        maxY: Math.max(startPoint.y, endPoint.y)
      };
      var view = this.context.view;
      elements = getIntersectElements(view, box2);
    }
    return elements;
  };
  ElementRangeState2.prototype.setStateEnable = function(enable) {
    if (this.effectSiblings && !this.effectByRecord) {
      this.setSiblingsState(enable);
    } else {
      var allElements = getElements(this.context.view);
      var elements = this.getIntersectElements();
      if (elements && elements.length) {
        if (this.effectByRecord) {
          this.setSiblingsStateByRecord(elements, enable);
        } else {
          this.setElementsState(elements, enable, allElements);
        }
      } else {
        this.clear();
      }
    }
  };
  ElementRangeState2.prototype.setSiblingsStateByRecord = function(elements, enable) {
    var _this = this;
    var view = this.context.view;
    var siblings2 = getSilbings(view);
    var records = elements.map(function(el) {
      return el.getModel().data;
    });
    var xFiled = view.getXScale().field;
    var yField = view.getYScales()[0].field;
    each$1(siblings2, function(sibling) {
      var allElements = getElements(sibling);
      var effectElements = allElements.filter(function(el) {
        var record = el.getModel().data;
        return isInRecords(records, record, xFiled, yField);
      });
      _this.setElementsState(effectElements, enable, allElements);
    });
  };
  ElementRangeState2.prototype.setSiblingsState = function(enable) {
    var _this = this;
    var view = this.context.view;
    var siblings2 = getSilbings(view);
    if (isMask(this.context)) {
      each$1(siblings2, function(sibling) {
        var allElements = getElements(sibling);
        var effectElements = getSiblingMaskElements(_this.context, sibling, 10);
        if (effectElements && effectElements.length) {
          _this.setElementsState(effectElements, enable, allElements);
        } else {
          _this.clearViewState(sibling);
        }
      });
    }
  };
  ElementRangeState2.prototype.setElementsState = function(elements, enable, allElements) {
    var _this = this;
    each$1(allElements, function(el) {
      if (!elements.includes(el)) {
        _this.setElementState(el, false);
      } else {
        _this.setElementState(el, enable);
      }
    });
  };
  ElementRangeState2.prototype.end = function() {
    this.isStarted = false;
    this.endPoint = this.getCurrentPoint();
  };
  ElementRangeState2.prototype.clear = function() {
    var _this = this;
    var view = this.context.view;
    if (this.effectSiblings) {
      var siblings2 = getSilbings(view);
      each$1(siblings2, function(sibling) {
        _this.clearViewState(sibling);
      });
    } else {
      this.clearViewState(view);
    }
  };
  return ElementRangeState2;
}(StateBase);
var ElementRangeActive = function(_super) {
  __extends$3(ElementRangeActive2, _super);
  function ElementRangeActive2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.stateName = "active";
    return _this;
  }
  ElementRangeActive2.prototype.active = function() {
    this.setState();
  };
  return ElementRangeActive2;
}(ElementRangeState);
var ElementSingleState = function(_super) {
  __extends$3(ElementSingleState2, _super);
  function ElementSingleState2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  ElementSingleState2.prototype.setStateEnable = function(enable) {
    var element = getCurrentElement$1(this.context);
    if (element) {
      if (!isElementChange(this.context)) {
        return;
      }
      if (enable) {
        this.clear();
        this.setElementState(element, true);
      } else if (this.hasState(element)) {
        this.setElementState(element, false);
      }
    }
  };
  ElementSingleState2.prototype.toggle = function() {
    var element = getCurrentElement$1(this.context);
    if (element) {
      var hasState = this.hasState(element);
      if (!hasState) {
        this.clear();
      }
      this.setElementState(element, !hasState);
    }
  };
  ElementSingleState2.prototype.reset = function() {
    this.setStateEnable(false);
  };
  return ElementSingleState2;
}(StateBase);
var ElementSingleActive = function(_super) {
  __extends$3(ElementSingleActive2, _super);
  function ElementSingleActive2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.stateName = "active";
    return _this;
  }
  ElementSingleActive2.prototype.active = function() {
    this.setState();
  };
  return ElementSingleActive2;
}(ElementSingleState);
var STATUS_UNACTIVE$3 = "inactive";
var STATUS_ACTIVE$3 = "active";
function clearHighlight$1(view) {
  var elements = getElements(view);
  each$1(elements, function(el) {
    if (el.hasState(STATUS_ACTIVE$3)) {
      el.setState(STATUS_ACTIVE$3, false);
    }
    if (el.hasState(STATUS_UNACTIVE$3)) {
      el.setState(STATUS_UNACTIVE$3, false);
    }
  });
}
function setHighlightBy(elements, callback, enable) {
  each$1(elements, function(el) {
    if (callback(el)) {
      if (el.hasState(STATUS_UNACTIVE$3)) {
        el.setState(STATUS_UNACTIVE$3, false);
      }
      el.setState(STATUS_ACTIVE$3, enable);
    } else {
      if (el.hasState(STATUS_ACTIVE$3)) {
        el.setState(STATUS_ACTIVE$3, false);
      }
      el.setState(STATUS_UNACTIVE$3, enable);
    }
  });
}
var STATUS_UNACTIVE$2 = ELEMENT_STATE.INACTIVE;
var STATUS_ACTIVE$2 = ELEMENT_STATE.ACTIVE;
var ElementHighlight = function(_super) {
  __extends$3(ElementHighlight2, _super);
  function ElementHighlight2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.stateName = STATUS_ACTIVE$2;
    return _this;
  }
  ElementHighlight2.prototype.setElementsStateByItem = function(elements, field2, item, enable) {
    var _this = this;
    var callback = function(el) {
      return _this.isMathItem(el, field2, item);
    };
    this.setHighlightBy(elements, callback, enable);
  };
  ElementHighlight2.prototype.setElementHighlight = function(el, callback) {
    if (callback(el)) {
      if (el.hasState(STATUS_UNACTIVE$2)) {
        el.setState(STATUS_UNACTIVE$2, false);
      }
      el.setState(STATUS_ACTIVE$2, true);
    } else if (!el.hasState(STATUS_ACTIVE$2)) {
      el.setState(STATUS_UNACTIVE$2, true);
    }
  };
  ElementHighlight2.prototype.setHighlightBy = function(elements, callback, enable) {
    var _this = this;
    if (enable) {
      each$1(elements, function(el) {
        _this.setElementHighlight(el, callback);
      });
    } else {
      var activeElements = getElementsByState(this.context.view, STATUS_ACTIVE$2);
      var allCancel_1 = true;
      each$1(activeElements, function(el) {
        if (!callback(el)) {
          allCancel_1 = false;
          return false;
        }
      });
      if (allCancel_1) {
        this.clear();
      } else {
        each$1(elements, function(el) {
          if (callback(el)) {
            if (el.hasState(STATUS_ACTIVE$2)) {
              el.setState(STATUS_ACTIVE$2, false);
            }
            el.setState(STATUS_UNACTIVE$2, true);
          }
        });
      }
    }
  };
  ElementHighlight2.prototype.setElementState = function(element, enable) {
    var view = this.context.view;
    var elements = getElements(view);
    this.setHighlightBy(elements, function(el) {
      return element === el;
    }, enable);
  };
  ElementHighlight2.prototype.highlight = function() {
    this.setState();
  };
  ElementHighlight2.prototype.clear = function() {
    var view = this.context.view;
    clearHighlight$1(view);
  };
  return ElementHighlight2;
}(ElementState);
var HighlightColor = function(_super) {
  __extends$3(HighlightColor2, _super);
  function HighlightColor2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  HighlightColor2.prototype.setStateByElement = function(element, enable) {
    var view = this.context.view;
    var colorAttr = element.geometry.getAttribute("color");
    if (!colorAttr) {
      return;
    }
    var scale2 = view.getScaleByField(colorAttr.getFields()[0]);
    var value2 = getElementValue$1(element, scale2.field);
    var elements = getElements(view);
    var highlightElements = elements.filter(function(el) {
      return getElementValue$1(el, scale2.field) === value2;
    });
    this.setHighlightBy(elements, function(el) {
      return highlightElements.includes(el);
    }, enable);
  };
  return HighlightColor2;
}(ElementHighlight);
var HighlightX = function(_super) {
  __extends$3(HighlightX2, _super);
  function HighlightX2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  HighlightX2.prototype.setElementHighlight = function(el, callback) {
    if (callback(el)) {
      if (el.hasState(STATUS_UNACTIVE$2)) {
        el.setState(STATUS_UNACTIVE$2, false);
      }
      el.setState(STATUS_ACTIVE$2, true);
    } else {
      el.setState(STATUS_UNACTIVE$2, true);
      if (el.hasState(STATUS_ACTIVE$2)) {
        el.setState(STATUS_ACTIVE$2, false);
      }
    }
  };
  HighlightX2.prototype.setStateByElement = function(element, enable) {
    var view = this.context.view;
    var scale2 = view.getXScale();
    var value2 = getElementValue$1(element, scale2.field);
    var elements = getElements(view);
    var highlightElements = elements.filter(function(el) {
      return getElementValue$1(el, scale2.field) === value2;
    });
    this.setHighlightBy(elements, function(el) {
      return highlightElements.includes(el);
    }, enable);
  };
  HighlightX2.prototype.toggle = function() {
    var element = getCurrentElement$1(this.context);
    if (element) {
      var hasState = element.hasState(this.stateName);
      this.setStateByElement(element, !hasState);
    }
  };
  return HighlightX2;
}(ElementHighlight);
var EVENTS$1;
(function(EVENTS2) {
  EVENTS2["BEFORE_HIGHLIGHT"] = "element-range-highlight:beforehighlight";
  EVENTS2["AFTER_HIGHLIGHT"] = "element-range-highlight:afterhighlight";
  EVENTS2["BEFORE_CLEAR"] = "element-range-highlight:beforeclear";
  EVENTS2["AFTER_CLEAR"] = "element-range-highlight:afterclear";
})(EVENTS$1 || (EVENTS$1 = {}));
var ElementRangeHighlight = function(_super) {
  __extends$3(ElementRangeHighlight2, _super);
  function ElementRangeHighlight2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.stateName = "active";
    return _this;
  }
  ElementRangeHighlight2.prototype.clearViewState = function(view) {
    clearHighlight$1(view);
  };
  ElementRangeHighlight2.prototype.highlight = function() {
    var _a2 = this.context, view = _a2.view, event = _a2.event;
    var elements = this.getIntersectElements();
    var payload = { view, event, highlightElements: elements };
    view.emit(EVENTS$1.BEFORE_HIGHLIGHT, Event.fromData(view, EVENTS$1.BEFORE_HIGHLIGHT, payload));
    this.setState();
    view.emit(EVENTS$1.AFTER_HIGHLIGHT, Event.fromData(view, EVENTS$1.AFTER_HIGHLIGHT, payload));
  };
  ElementRangeHighlight2.prototype.clear = function() {
    var view = this.context.view;
    view.emit(EVENTS$1.BEFORE_CLEAR, Event.fromData(view, EVENTS$1.BEFORE_CLEAR, {}));
    _super.prototype.clear.call(this);
    view.emit(EVENTS$1.AFTER_CLEAR, Event.fromData(view, EVENTS$1.AFTER_CLEAR, {}));
  };
  ElementRangeHighlight2.prototype.setElementsState = function(elements, enable, allElements) {
    setHighlightBy(allElements, function(el) {
      return elements.indexOf(el) >= 0;
    }, enable);
  };
  return ElementRangeHighlight2;
}(ElementRangeState);
var ElementSingleHighlight = function(_super) {
  __extends$3(ElementSingleHighlight2, _super);
  function ElementSingleHighlight2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.stateName = "active";
    return _this;
  }
  ElementSingleHighlight2.prototype.highlight = function() {
    this.setState();
  };
  ElementSingleHighlight2.prototype.setElementState = function(element, enable) {
    var view = this.context.view;
    var elements = getElements(view);
    setHighlightBy(elements, function(el) {
      return element === el;
    }, enable);
  };
  ElementSingleHighlight2.prototype.clear = function() {
    var view = this.context.view;
    clearHighlight$1(view);
  };
  return ElementSingleHighlight2;
}(ElementSingleState);
var ElementRangeSelected = function(_super) {
  __extends$3(ElementRangeSelected2, _super);
  function ElementRangeSelected2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.stateName = "selected";
    return _this;
  }
  ElementRangeSelected2.prototype.selected = function() {
    this.setState();
  };
  return ElementRangeSelected2;
}(ElementRangeState);
var ElementMultipleSelected = function(_super) {
  __extends$3(ElementMultipleSelected2, _super);
  function ElementMultipleSelected2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.stateName = "selected";
    return _this;
  }
  ElementMultipleSelected2.prototype.selected = function() {
    this.setState();
  };
  return ElementMultipleSelected2;
}(ElementState);
var ElementSingleSelected = function(_super) {
  __extends$3(ElementSingleSelected2, _super);
  function ElementSingleSelected2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.stateName = "selected";
    return _this;
  }
  ElementSingleSelected2.prototype.selected = function() {
    this.setState();
  };
  return ElementSingleSelected2;
}(ElementSingleState);
var ListState = function(_super) {
  __extends$3(ListState2, _super);
  function ListState2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.stateName = "";
    _this.ignoreItemStates = [];
    return _this;
  }
  ListState2.prototype.getTriggerListInfo = function() {
    var delegateObject = getDelegationObject(this.context);
    var info = null;
    if (isList(delegateObject)) {
      info = {
        item: delegateObject.item,
        list: delegateObject.component
      };
    }
    return info;
  };
  ListState2.prototype.getAllowComponents = function() {
    var _this = this;
    var view = this.context.view;
    var components = getComponents(view);
    var rst = [];
    each$1(components, function(component2) {
      if (component2.isList() && _this.allowSetStateByElement(component2)) {
        rst.push(component2);
      }
    });
    return rst;
  };
  ListState2.prototype.hasState = function(list, item) {
    return list.hasState(item, this.stateName);
  };
  ListState2.prototype.clearAllComponentsState = function() {
    var _this = this;
    var components = this.getAllowComponents();
    each$1(components, function(component2) {
      component2.clearItemsState(_this.stateName);
    });
  };
  ListState2.prototype.allowSetStateByElement = function(component2) {
    var field2 = component2.get("field");
    if (!field2) {
      return false;
    }
    if (this.cfg && this.cfg.componentNames) {
      var name_1 = component2.get("name");
      if (this.cfg.componentNames.indexOf(name_1) === -1) {
        return false;
      }
    }
    var view = this.context.view;
    var scale2 = getScaleByField(view, field2);
    return scale2 && scale2.isCategory;
  };
  ListState2.prototype.allowSetStateByItem = function(item, list) {
    var ignoreStates = this.ignoreItemStates;
    if (ignoreStates.length) {
      var filterStates = ignoreStates.filter(function(state2) {
        return list.hasState(item, state2);
      });
      return filterStates.length === 0;
    }
    return true;
  };
  ListState2.prototype.setStateByElement = function(component2, element, enable) {
    var field2 = component2.get("field");
    var view = this.context.view;
    var scale2 = getScaleByField(view, field2);
    var value2 = getElementValue$1(element, field2);
    var text2 = scale2.getText(value2);
    this.setItemsState(component2, text2, enable);
  };
  ListState2.prototype.setStateEnable = function(enable) {
    var _this = this;
    var element = getCurrentElement$1(this.context);
    if (element) {
      var components = this.getAllowComponents();
      each$1(components, function(component3) {
        _this.setStateByElement(component3, element, enable);
      });
    } else {
      var delegateObject = getDelegationObject(this.context);
      if (isList(delegateObject)) {
        var item = delegateObject.item, component2 = delegateObject.component;
        if (this.allowSetStateByElement(component2) && this.allowSetStateByItem(item, component2)) {
          this.setItemState(component2, item, enable);
        }
      }
    }
  };
  ListState2.prototype.setItemsState = function(list, name, enable) {
    var _this = this;
    var items = list.getItems();
    each$1(items, function(item) {
      if (item.name === name) {
        _this.setItemState(list, item, enable);
      }
    });
  };
  ListState2.prototype.setItemState = function(list, item, enable) {
    list.setItemState(item, this.stateName, enable);
  };
  ListState2.prototype.setState = function() {
    this.setStateEnable(true);
  };
  ListState2.prototype.reset = function() {
    this.setStateEnable(false);
  };
  ListState2.prototype.toggle = function() {
    var triggerInfo = this.getTriggerListInfo();
    if (triggerInfo && triggerInfo.item) {
      var list = triggerInfo.list, item = triggerInfo.item;
      var enable = this.hasState(list, item);
      this.setItemState(list, item, !enable);
    }
  };
  ListState2.prototype.clear = function() {
    var triggerInfo = this.getTriggerListInfo();
    if (triggerInfo) {
      triggerInfo.list.clearItemsState(this.stateName);
    } else {
      this.clearAllComponentsState();
    }
  };
  return ListState2;
}(Action);
var ListActive = function(_super) {
  __extends$3(ListActive2, _super);
  function ListActive2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.stateName = "active";
    return _this;
  }
  ListActive2.prototype.active = function() {
    this.setState();
  };
  return ListActive2;
}(ListState);
var STATUS_UNACTIVE$1 = "inactive";
var STATUS_ACTIVE$1 = "active";
function clearList(list) {
  var items = list.getItems();
  each$1(items, function(item) {
    if (list.hasState(item, STATUS_ACTIVE$1)) {
      list.setItemState(item, STATUS_ACTIVE$1, false);
    }
    if (list.hasState(item, STATUS_UNACTIVE$1)) {
      list.setItemState(item, STATUS_UNACTIVE$1, false);
    }
  });
}
var STATUS_UNACTIVE = "inactive";
var STATUS_ACTIVE = "active";
var ListHighlight = function(_super) {
  __extends$3(ListHighlight2, _super);
  function ListHighlight2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.stateName = STATUS_ACTIVE;
    _this.ignoreItemStates = ["unchecked"];
    return _this;
  }
  ListHighlight2.prototype.setItemsState = function(list, name, enable) {
    this.setHighlightBy(list, function(item) {
      return item.name === name;
    }, enable);
  };
  ListHighlight2.prototype.setItemState = function(list, item, enable) {
    list.getItems();
    this.setHighlightBy(list, function(el) {
      return el === item;
    }, enable);
  };
  ListHighlight2.prototype.setHighlightBy = function(list, callback, enable) {
    var items = list.getItems();
    if (enable) {
      each$1(items, function(item) {
        if (callback(item)) {
          if (list.hasState(item, STATUS_UNACTIVE)) {
            list.setItemState(item, STATUS_UNACTIVE, false);
          }
          list.setItemState(item, STATUS_ACTIVE, true);
        } else if (!list.hasState(item, STATUS_ACTIVE)) {
          list.setItemState(item, STATUS_UNACTIVE, true);
        }
      });
    } else {
      var activeItems = list.getItemsByState(STATUS_ACTIVE);
      var allCancel_1 = true;
      each$1(activeItems, function(item) {
        if (!callback(item)) {
          allCancel_1 = false;
          return false;
        }
      });
      if (allCancel_1) {
        this.clear();
      } else {
        each$1(items, function(item) {
          if (callback(item)) {
            if (list.hasState(item, STATUS_ACTIVE)) {
              list.setItemState(item, STATUS_ACTIVE, false);
            }
            list.setItemState(item, STATUS_UNACTIVE, true);
          }
        });
      }
    }
  };
  ListHighlight2.prototype.highlight = function() {
    this.setState();
  };
  ListHighlight2.prototype.clear = function() {
    var triggerInfo = this.getTriggerListInfo();
    if (triggerInfo) {
      clearList(triggerInfo.list);
    } else {
      var components = this.getAllowComponents();
      each$1(components, function(component2) {
        component2.clearItemsState(STATUS_ACTIVE);
        component2.clearItemsState(STATUS_UNACTIVE);
      });
    }
  };
  return ListHighlight2;
}(ListState);
var ListSelected = function(_super) {
  __extends$3(ListSelected2, _super);
  function ListSelected2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.stateName = "selected";
    return _this;
  }
  ListSelected2.prototype.selected = function() {
    this.setState();
  };
  return ListSelected2;
}(ListState);
var ListUnchecked = function(_super) {
  __extends$3(ListUnchecked2, _super);
  function ListUnchecked2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.stateName = "unchecked";
    return _this;
  }
  ListUnchecked2.prototype.unchecked = function() {
    this.setState();
  };
  return ListUnchecked2;
}(ListState);
var STATUS_UNCHECKED$1 = "unchecked";
var STATUS_CHECKED = "checked";
var ListChecked = function(_super) {
  __extends$3(ListChecked2, _super);
  function ListChecked2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.stateName = STATUS_CHECKED;
    return _this;
  }
  ListChecked2.prototype.setItemState = function(list, item, enable) {
    this.setCheckedBy(list, function(el) {
      return el === item;
    }, enable);
  };
  ListChecked2.prototype.setCheckedBy = function(list, callback, enable) {
    var items = list.getItems();
    if (enable) {
      each$1(items, function(item) {
        if (callback(item)) {
          if (list.hasState(item, STATUS_UNCHECKED$1)) {
            list.setItemState(item, STATUS_UNCHECKED$1, false);
          }
          list.setItemState(item, STATUS_CHECKED, true);
        } else if (!list.hasState(item, STATUS_CHECKED)) {
          list.setItemState(item, STATUS_UNCHECKED$1, true);
        }
      });
    }
  };
  ListChecked2.prototype.toggle = function() {
    var triggerInfo = this.getTriggerListInfo();
    if (triggerInfo && triggerInfo.item) {
      var list_1 = triggerInfo.list, item = triggerInfo.item;
      var allChecked = !some(list_1.getItems(), function(t2) {
        return list_1.hasState(t2, STATUS_UNCHECKED$1);
      });
      if (allChecked || list_1.hasState(item, STATUS_UNCHECKED$1)) {
        this.setItemState(list_1, item, true);
      } else {
        this.reset();
      }
    }
  };
  ListChecked2.prototype.checked = function() {
    this.setState();
  };
  ListChecked2.prototype.reset = function() {
    var components = this.getAllowComponents();
    each$1(components, function(component2) {
      component2.clearItemsState(STATUS_CHECKED);
      component2.clearItemsState(STATUS_UNCHECKED$1);
    });
  };
  return ListChecked2;
}(ListState);
var STATUS_UNCHECKED = "unchecked";
var ListFocus = function(_super) {
  __extends$3(ListFocus2, _super);
  function ListFocus2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  ListFocus2.prototype.toggle = function() {
    var e_1, _a2, e_2, _b, e_3, _c, e_4, _d;
    var triggerInfo = this.getTriggerListInfo();
    if (triggerInfo === null || triggerInfo === void 0 ? void 0 : triggerInfo.item) {
      var list_1 = triggerInfo.list, clickedItem = triggerInfo.item;
      var items = list_1.getItems();
      var checkedItems = items.filter(function(t2) {
        return !list_1.hasState(t2, STATUS_UNCHECKED);
      });
      var uncheckedItems = items.filter(function(t2) {
        return list_1.hasState(t2, STATUS_UNCHECKED);
      });
      var checkedItem = checkedItems[0];
      if (items.length === checkedItems.length) {
        try {
          for (var items_1 = __values(items), items_1_1 = items_1.next(); !items_1_1.done; items_1_1 = items_1.next()) {
            var item = items_1_1.value;
            list_1.setItemState(item, STATUS_UNCHECKED, item.id !== clickedItem.id);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (items_1_1 && !items_1_1.done && (_a2 = items_1.return))
              _a2.call(items_1);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
      } else if (items.length - uncheckedItems.length === 1) {
        if (checkedItem.id === clickedItem.id) {
          try {
            for (var items_2 = __values(items), items_2_1 = items_2.next(); !items_2_1.done; items_2_1 = items_2.next()) {
              var item = items_2_1.value;
              list_1.setItemState(item, STATUS_UNCHECKED, false);
            }
          } catch (e_2_1) {
            e_2 = { error: e_2_1 };
          } finally {
            try {
              if (items_2_1 && !items_2_1.done && (_b = items_2.return))
                _b.call(items_2);
            } finally {
              if (e_2)
                throw e_2.error;
            }
          }
        } else {
          try {
            for (var items_3 = __values(items), items_3_1 = items_3.next(); !items_3_1.done; items_3_1 = items_3.next()) {
              var item = items_3_1.value;
              list_1.setItemState(item, STATUS_UNCHECKED, item.id !== clickedItem.id);
            }
          } catch (e_3_1) {
            e_3 = { error: e_3_1 };
          } finally {
            try {
              if (items_3_1 && !items_3_1.done && (_c = items_3.return))
                _c.call(items_3);
            } finally {
              if (e_3)
                throw e_3.error;
            }
          }
        }
      } else {
        try {
          for (var items_4 = __values(items), items_4_1 = items_4.next(); !items_4_1.done; items_4_1 = items_4.next()) {
            var item = items_4_1.value;
            list_1.setItemState(item, STATUS_UNCHECKED, item.id !== clickedItem.id);
          }
        } catch (e_4_1) {
          e_4 = { error: e_4_1 };
        } finally {
          try {
            if (items_4_1 && !items_4_1.done && (_d = items_4.return))
              _d.call(items_4);
          } finally {
            if (e_4)
              throw e_4.error;
          }
        }
      }
    }
  };
  return ListFocus2;
}(ListState);
var STATUS_SHOW = "showRadio";
var TIP_ID = "legend-radio-tip";
var ListRadio = function(_super) {
  __extends$3(ListRadio2, _super);
  function ListRadio2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.timeStamp = 0;
    return _this;
  }
  ListRadio2.prototype.show = function() {
    var triggerInfo = this.getTriggerListInfo();
    if (triggerInfo === null || triggerInfo === void 0 ? void 0 : triggerInfo.item) {
      var list = triggerInfo.list, item = triggerInfo.item;
      list.setItemState(item, STATUS_SHOW, true);
    }
  };
  ListRadio2.prototype.hide = function() {
    var triggerInfo = this.getTriggerListInfo();
    if (triggerInfo === null || triggerInfo === void 0 ? void 0 : triggerInfo.item) {
      var list = triggerInfo.list, item = triggerInfo.item;
      list.setItemState(item, STATUS_SHOW, false);
    }
  };
  ListRadio2.prototype.destroy = function() {
    _super.prototype.destroy.call(this);
    this.tooltip && this.tooltip.destroy();
  };
  ListRadio2.prototype.showTip = function() {
    var context2 = this.context;
    var ev = context2.event;
    var lastTimeStamp = this.timeStamp;
    var timeStamp = +new Date();
    var target = this.context.event.target;
    if (timeStamp - lastTimeStamp > 16 && target.get("name") === "legend-item-radio") {
      var preLoc = this.location;
      var curLoc = { x: ev.x, y: ev.y };
      this.timeStamp = timeStamp;
      this.location = curLoc;
      if (!preLoc || !isEqual$1(preLoc, curLoc)) {
        this.showTooltip(curLoc);
      }
    }
  };
  ListRadio2.prototype.hideTip = function() {
    this.hideTooltip();
    this.location = null;
  };
  ListRadio2.prototype.showTooltip = function(curLoc) {
    var context2 = this.context;
    var ev = context2.event;
    var target = ev.target;
    if (target && target.get("tip")) {
      if (!this.tooltip) {
        this.renderTooltip();
      }
      var _a2 = context2.view.getCanvas().get("el").getBoundingClientRect(), offsetX = _a2.x, offsetY = _a2.y;
      this.tooltip.update(__assign$4(__assign$4({ title: target.get("tip") }, curLoc), { x: curLoc.x + offsetX, y: curLoc.y + offsetY }));
      this.tooltip.show();
    }
  };
  ListRadio2.prototype.hideTooltip = function() {
    this.tooltip && this.tooltip.hide();
  };
  ListRadio2.prototype.renderTooltip = function() {
    var _a2;
    var tooltipStyles = (_a2 = {}, _a2[CONTAINER_CLASS] = {
      padding: "6px 8px",
      transform: "translate(-50%, -80%)",
      background: "rgba(0,0,0,0.75)",
      color: "#fff",
      "border-radius": "2px",
      "z-index": 100
    }, _a2[TITLE_CLASS] = {
      "font-size": "12px",
      "line-height": "14px",
      "margin-bottom": 0,
      "word-break": "break-all"
    }, _a2);
    if (document.getElementById(TIP_ID)) {
      document.body.removeChild(document.getElementById(TIP_ID));
    }
    var tooltip2 = new HtmlTooltip({
      parent: document.body,
      region: null,
      visible: false,
      crosshairs: null,
      domStyles: tooltipStyles,
      containerId: TIP_ID
    });
    tooltip2.init();
    tooltip2.setCapture(false);
    this.tooltip = tooltip2;
  };
  return ListRadio2;
}(ListState);
var MaskBase = function(_super) {
  __extends$3(MaskBase2, _super);
  function MaskBase2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.maskShape = null;
    _this.points = [];
    _this.starting = false;
    _this.moving = false;
    _this.preMovePoint = null;
    _this.shapeType = "path";
    return _this;
  }
  MaskBase2.prototype.getCurrentPoint = function() {
    var event = this.context.event;
    return {
      x: event.x,
      y: event.y
    };
  };
  MaskBase2.prototype.emitEvent = function(type4) {
    var eventName = "mask:".concat(type4);
    var view = this.context.view;
    var event = this.context.event;
    view.emit(eventName, {
      target: this.maskShape,
      shape: this.maskShape,
      points: this.points,
      x: event.x,
      y: event.y
    });
  };
  MaskBase2.prototype.createMask = function() {
    var view = this.context.view;
    var maskAttrs = this.getMaskAttrs();
    var maskShape = view.foregroundGroup.addShape({
      type: this.shapeType,
      name: "mask",
      draggable: true,
      attrs: __assign$4({ fill: "#C5D4EB", opacity: 0.3 }, maskAttrs)
    });
    return maskShape;
  };
  MaskBase2.prototype.getMaskPath = function() {
    return [];
  };
  MaskBase2.prototype.show = function() {
    if (this.maskShape) {
      this.maskShape.show();
      this.emitEvent("show");
    }
  };
  MaskBase2.prototype.start = function(arg) {
    this.starting = true;
    this.moving = false;
    this.points = [this.getCurrentPoint()];
    if (!this.maskShape) {
      this.maskShape = this.createMask();
      this.maskShape.set("capture", false);
    }
    this.updateMask(arg === null || arg === void 0 ? void 0 : arg.maskStyle);
    this.emitEvent("start");
  };
  MaskBase2.prototype.moveStart = function() {
    this.moving = true;
    this.preMovePoint = this.getCurrentPoint();
  };
  MaskBase2.prototype.move = function() {
    if (!this.moving || !this.maskShape) {
      return;
    }
    var currentPoint = this.getCurrentPoint();
    var preMovePoint = this.preMovePoint;
    var dx = currentPoint.x - preMovePoint.x;
    var dy = currentPoint.y - preMovePoint.y;
    var points2 = this.points;
    each$1(points2, function(point2) {
      point2.x += dx;
      point2.y += dy;
    });
    this.updateMask();
    this.emitEvent("change");
    this.preMovePoint = currentPoint;
  };
  MaskBase2.prototype.updateMask = function(maskStyle) {
    var attrs = deepMix({}, this.getMaskAttrs(), maskStyle);
    this.maskShape.attr(attrs);
  };
  MaskBase2.prototype.moveEnd = function() {
    this.moving = false;
    this.preMovePoint = null;
  };
  MaskBase2.prototype.end = function() {
    this.starting = false;
    this.emitEvent("end");
    if (this.maskShape) {
      this.maskShape.set("capture", true);
    }
  };
  MaskBase2.prototype.hide = function() {
    if (this.maskShape) {
      this.maskShape.hide();
      this.emitEvent("hide");
    }
  };
  MaskBase2.prototype.resize = function() {
    if (this.starting && this.maskShape) {
      this.points.push(this.getCurrentPoint());
      this.updateMask();
      this.emitEvent("change");
    }
  };
  MaskBase2.prototype.destroy = function() {
    this.points = [];
    if (this.maskShape) {
      this.maskShape.remove();
    }
    this.maskShape = null;
    this.preMovePoint = null;
    _super.prototype.destroy.call(this);
  };
  return MaskBase2;
}(Action);
var CircleMask = function(_super) {
  __extends$3(CircleMask2, _super);
  function CircleMask2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.shapeType = "circle";
    return _this;
  }
  CircleMask2.prototype.getMaskAttrs = function() {
    var points2 = this.points;
    var currentPoint = last(this.points);
    var r2 = 0;
    var x2 = 0;
    var y2 = 0;
    if (points2.length) {
      var first = points2[0];
      r2 = distance$2(first, currentPoint) / 2;
      x2 = (currentPoint.x + first.x) / 2;
      y2 = (currentPoint.y + first.y) / 2;
    }
    return {
      x: x2,
      y: y2,
      r: r2
    };
  };
  return CircleMask2;
}(MaskBase);
var RectMask = function(_super) {
  __extends$3(RectMask2, _super);
  function RectMask2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.shapeType = "rect";
    return _this;
  }
  RectMask2.prototype.getRegion = function() {
    var points2 = this.points;
    return {
      start: head(points2),
      end: last(points2)
    };
  };
  RectMask2.prototype.getMaskAttrs = function() {
    var _a2 = this.getRegion(), start = _a2.start, end = _a2.end;
    var x2 = Math.min(start.x, end.x);
    var y2 = Math.min(start.y, end.y);
    var width = Math.abs(end.x - start.x);
    var height = Math.abs(end.y - start.y);
    return {
      x: x2,
      y: y2,
      width,
      height
    };
  };
  return RectMask2;
}(MaskBase);
function clampPoint(point2) {
  point2.x = clamp(point2.x, 0, 1);
  point2.y = clamp(point2.y, 0, 1);
}
var DimRect = function(_super) {
  __extends$3(DimRect2, _super);
  function DimRect2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.dim = "x";
    _this.inPlot = true;
    return _this;
  }
  DimRect2.prototype.getRegion = function() {
    var start = null;
    var end = null;
    var points2 = this.points;
    var dim = this.dim;
    var coord2 = this.context.view.getCoordinate();
    var normalStart = coord2.invert(head(points2));
    var normalEnd = coord2.invert(last(points2));
    if (this.inPlot) {
      clampPoint(normalStart);
      clampPoint(normalEnd);
    }
    if (dim === "x") {
      start = coord2.convert({
        x: normalStart.x,
        y: 0
      });
      end = coord2.convert({
        x: normalEnd.x,
        y: 1
      });
    } else {
      start = coord2.convert({
        x: 0,
        y: normalStart.y
      });
      end = coord2.convert({
        x: 1,
        y: normalEnd.y
      });
    }
    return {
      start,
      end
    };
  };
  return DimRect2;
}(RectMask);
var PathMask = function(_super) {
  __extends$3(PathMask2, _super);
  function PathMask2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  PathMask2.prototype.getMaskPath = function() {
    var points2 = this.points;
    var path2 = [];
    if (points2.length) {
      each$1(points2, function(point2, index2) {
        if (index2 === 0) {
          path2.push(["M", point2.x, point2.y]);
        } else {
          path2.push(["L", point2.x, point2.y]);
        }
      });
      path2.push(["L", points2[0].x, points2[0].y]);
    }
    return path2;
  };
  PathMask2.prototype.getMaskAttrs = function() {
    return {
      path: this.getMaskPath()
    };
  };
  PathMask2.prototype.addPoint = function() {
    this.resize();
  };
  return PathMask2;
}(MaskBase);
var SmoothPathMask = function(_super) {
  __extends$3(SmoothPathMask2, _super);
  function SmoothPathMask2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  SmoothPathMask2.prototype.getMaskPath = function() {
    var points2 = this.points;
    return getSpline(points2, true);
  };
  return SmoothPathMask2;
}(PathMask);
var CursorAction = function(_super) {
  __extends$3(CursorAction2, _super);
  function CursorAction2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  CursorAction2.prototype.setCursor = function(cursor) {
    var view = this.context.view;
    view.getCanvas().setCursor(cursor);
  };
  CursorAction2.prototype.default = function() {
    this.setCursor("default");
  };
  CursorAction2.prototype.pointer = function() {
    this.setCursor("pointer");
  };
  CursorAction2.prototype.move = function() {
    this.setCursor("move");
  };
  CursorAction2.prototype.crosshair = function() {
    this.setCursor("crosshair");
  };
  CursorAction2.prototype.wait = function() {
    this.setCursor("wait");
  };
  CursorAction2.prototype.help = function() {
    this.setCursor("help");
  };
  CursorAction2.prototype.text = function() {
    this.setCursor("text");
  };
  CursorAction2.prototype.eResize = function() {
    this.setCursor("e-resize");
  };
  CursorAction2.prototype.wResize = function() {
    this.setCursor("w-resize");
  };
  CursorAction2.prototype.nResize = function() {
    this.setCursor("n-resize");
  };
  CursorAction2.prototype.sResize = function() {
    this.setCursor("s-resize");
  };
  CursorAction2.prototype.neResize = function() {
    this.setCursor("ne-resize");
  };
  CursorAction2.prototype.nwResize = function() {
    this.setCursor("nw-resize");
  };
  CursorAction2.prototype.seResize = function() {
    this.setCursor("se-resize");
  };
  CursorAction2.prototype.swResize = function() {
    this.setCursor("sw-resize");
  };
  CursorAction2.prototype.nsResize = function() {
    this.setCursor("ns-resize");
  };
  CursorAction2.prototype.ewResize = function() {
    this.setCursor("ew-resize");
  };
  CursorAction2.prototype.zoomIn = function() {
    this.setCursor("zoom-in");
  };
  CursorAction2.prototype.zoomOut = function() {
    this.setCursor("zoom-out");
  };
  return CursorAction2;
}(Action);
var DataFilter = function(_super) {
  __extends$3(DataFilter2, _super);
  function DataFilter2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  DataFilter2.prototype.filterView = function(view, field2, filter3) {
    var _this = this;
    if (view.getScaleByField(field2)) {
      view.filter(field2, filter3);
    }
    if (view.views && view.views.length) {
      each$1(view.views, function(subView) {
        _this.filterView(subView, field2, filter3);
      });
    }
  };
  DataFilter2.prototype.filter = function() {
    var delegateObject = getDelegationObject(this.context);
    if (delegateObject) {
      var view = this.context.view;
      var component2 = delegateObject.component;
      var field2 = component2.get("field");
      if (isList(delegateObject)) {
        if (field2) {
          var unCheckedItems = component2.getItemsByState("unchecked");
          var scale_1 = getScaleByField(view, field2);
          var names_1 = unCheckedItems.map(function(item) {
            return item.name;
          });
          if (names_1.length) {
            this.filterView(view, field2, function(value2) {
              var text2 = scale_1.getText(value2);
              return !names_1.includes(text2);
            });
          } else {
            this.filterView(view, field2, null);
          }
          view.render(true);
        }
      } else if (isSlider(delegateObject)) {
        var range3 = component2.getValue();
        var _a2 = __read(range3, 2), min_1 = _a2[0], max_1 = _a2[1];
        this.filterView(view, field2, function(value2) {
          return value2 >= min_1 && value2 <= max_1;
        });
        view.render(true);
      }
    }
  };
  return DataFilter2;
}(Action);
function getFilter(scale2, dim, point1, point2) {
  var min2 = Math.min(point1[dim], point2[dim]);
  var max2 = Math.max(point1[dim], point2[dim]);
  var _a2 = __read(scale2.range, 2), rangeMin = _a2[0], rangeMax = _a2[1];
  if (min2 < rangeMin) {
    min2 = rangeMin;
  }
  if (max2 > rangeMax) {
    max2 = rangeMax;
  }
  if (min2 === rangeMax && max2 === rangeMax) {
    return null;
  }
  var minValue = scale2.invert(min2);
  var maxValue = scale2.invert(max2);
  if (scale2.isCategory) {
    var minIndex = scale2.values.indexOf(minValue);
    var maxIndex = scale2.values.indexOf(maxValue);
    var arr_1 = scale2.values.slice(minIndex, maxIndex + 1);
    return function(value2) {
      return arr_1.includes(value2);
    };
  } else {
    return function(value2) {
      return value2 >= minValue && value2 <= maxValue;
    };
  }
}
var EVENTS;
(function(EVENTS2) {
  EVENTS2["FILTER"] = "brush-filter-processing";
  EVENTS2["RESET"] = "brush-filter-reset";
  EVENTS2["BEFORE_FILTER"] = "brush-filter:beforefilter";
  EVENTS2["AFTER_FILTER"] = "brush-filter:afterfilter";
  EVENTS2["BEFORE_RESET"] = "brush-filter:beforereset";
  EVENTS2["AFTER_RESET"] = "brush-filter:afterreset";
})(EVENTS || (EVENTS = {}));
var RangeFilter = function(_super) {
  __extends$3(RangeFilter2, _super);
  function RangeFilter2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.dims = ["x", "y"];
    _this.startPoint = null;
    _this.isStarted = false;
    return _this;
  }
  RangeFilter2.prototype.hasDim = function(dim) {
    return this.dims.includes(dim);
  };
  RangeFilter2.prototype.start = function() {
    var context2 = this.context;
    this.isStarted = true;
    this.startPoint = context2.getCurrentPoint();
  };
  RangeFilter2.prototype.filter = function() {
    var startPoint;
    var currentPoint;
    if (isMask(this.context)) {
      var maskShape = this.context.event.target;
      var bbox = maskShape.getCanvasBBox();
      startPoint = { x: bbox.x, y: bbox.y };
      currentPoint = { x: bbox.maxX, y: bbox.maxY };
    } else {
      if (!this.isStarted) {
        return;
      }
      startPoint = this.startPoint;
      currentPoint = this.context.getCurrentPoint();
    }
    if (Math.abs(startPoint.x - currentPoint.x) < 5 || Math.abs(startPoint.x - currentPoint.y) < 5) {
      return;
    }
    var _a2 = this.context, view = _a2.view, event = _a2.event;
    var payload = { view, event, dims: this.dims };
    view.emit(EVENTS.BEFORE_FILTER, Event.fromData(view, EVENTS.BEFORE_FILTER, payload));
    var coord2 = view.getCoordinate();
    var normalCurrent = coord2.invert(currentPoint);
    var normalStart = coord2.invert(startPoint);
    if (this.hasDim("x")) {
      var xScale = view.getXScale();
      var filter3 = getFilter(xScale, "x", normalCurrent, normalStart);
      this.filterView(view, xScale.field, filter3);
    }
    if (this.hasDim("y")) {
      var yScale = view.getYScales()[0];
      var filter3 = getFilter(yScale, "y", normalCurrent, normalStart);
      this.filterView(view, yScale.field, filter3);
    }
    this.reRender(view, { source: EVENTS.FILTER });
    view.emit(EVENTS.AFTER_FILTER, Event.fromData(view, EVENTS.AFTER_FILTER, payload));
  };
  RangeFilter2.prototype.end = function() {
    this.isStarted = false;
  };
  RangeFilter2.prototype.reset = function() {
    var view = this.context.view;
    view.emit(EVENTS.BEFORE_RESET, Event.fromData(view, EVENTS.BEFORE_RESET, {}));
    this.isStarted = false;
    if (this.hasDim("x")) {
      var xScale = view.getXScale();
      this.filterView(view, xScale.field, null);
    }
    if (this.hasDim("y")) {
      var yScale = view.getYScales()[0];
      this.filterView(view, yScale.field, null);
    }
    this.reRender(view, { source: EVENTS.RESET });
    view.emit(EVENTS.AFTER_RESET, Event.fromData(view, EVENTS.AFTER_RESET, {}));
  };
  RangeFilter2.prototype.filterView = function(view, field2, filter3) {
    view.filter(field2, filter3);
  };
  RangeFilter2.prototype.reRender = function(view, payload) {
    view.render(true, payload);
  };
  return RangeFilter2;
}(Action);
var SiblingFilter$1 = function(_super) {
  __extends$3(SiblingFilter2, _super);
  function SiblingFilter2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  SiblingFilter2.prototype.filterView = function(view, field2, filter3) {
    var siblings2 = getSilbings(view);
    each$1(siblings2, function(sibling) {
      sibling.filter(field2, filter3);
    });
  };
  SiblingFilter2.prototype.reRender = function(view) {
    var siblings2 = getSilbings(view);
    each$1(siblings2, function(sibling) {
      sibling.render(true);
    });
  };
  return SiblingFilter2;
}(RangeFilter);
var ElementFilter = function(_super) {
  __extends$3(ElementFilter2, _super);
  function ElementFilter2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  ElementFilter2.prototype.filter = function() {
    var delegateObject = getDelegationObject(this.context);
    var view = this.context.view;
    var elements = getElements(view);
    if (isMask(this.context)) {
      var maskElements_1 = getMaskedElements(this.context, 10);
      if (maskElements_1) {
        each$1(elements, function(el) {
          if (maskElements_1.includes(el)) {
            el.show();
          } else {
            el.hide();
          }
        });
      }
    } else if (delegateObject) {
      var component2 = delegateObject.component;
      var field_1 = component2.get("field");
      if (isList(delegateObject)) {
        if (field_1) {
          var unCheckedItems = component2.getItemsByState("unchecked");
          var scale_1 = getScaleByField(view, field_1);
          var names_1 = unCheckedItems.map(function(item) {
            return item.name;
          });
          each$1(elements, function(el) {
            var value2 = getElementValue$1(el, field_1);
            var text2 = scale_1.getText(value2);
            if (names_1.indexOf(text2) >= 0) {
              el.hide();
            } else {
              el.show();
            }
          });
        }
      } else if (isSlider(delegateObject)) {
        var range3 = component2.getValue();
        var _a2 = __read(range3, 2), min_1 = _a2[0], max_1 = _a2[1];
        each$1(elements, function(el) {
          var value2 = getElementValue$1(el, field_1);
          if (value2 >= min_1 && value2 <= max_1) {
            el.show();
          } else {
            el.hide();
          }
        });
      }
    }
  };
  ElementFilter2.prototype.clear = function() {
    var elements = getElements(this.context.view);
    each$1(elements, function(el) {
      el.show();
    });
  };
  ElementFilter2.prototype.reset = function() {
    this.clear();
  };
  return ElementFilter2;
}(Action);
var SiblingFilter = function(_super) {
  __extends$3(SiblingFilter2, _super);
  function SiblingFilter2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.byRecord = false;
    return _this;
  }
  SiblingFilter2.prototype.filter = function() {
    if (isMask(this.context)) {
      if (this.byRecord) {
        this.filterByRecord();
      } else {
        this.filterByBBox();
      }
    }
  };
  SiblingFilter2.prototype.filterByRecord = function() {
    var view = this.context.view;
    var maskElements = getMaskedElements(this.context, 10);
    if (!maskElements) {
      return;
    }
    var xFiled = view.getXScale().field;
    var yField = view.getYScales()[0].field;
    var records = maskElements.map(function(el) {
      return el.getModel().data;
    });
    var siblings2 = getSilbings(view);
    each$1(siblings2, function(sibling) {
      var elements = getElements(sibling);
      each$1(elements, function(el) {
        var record = el.getModel().data;
        if (isInRecords(records, record, xFiled, yField)) {
          el.show();
        } else {
          el.hide();
        }
      });
    });
  };
  SiblingFilter2.prototype.filterByBBox = function() {
    var _this = this;
    var view = this.context.view;
    var siblings2 = getSilbings(view);
    each$1(siblings2, function(sibling) {
      var maskElements = getSiblingMaskElements(_this.context, sibling, 10);
      var elements = getElements(sibling);
      if (maskElements) {
        each$1(elements, function(el) {
          if (maskElements.includes(el)) {
            el.show();
          } else {
            el.hide();
          }
        });
      }
    });
  };
  SiblingFilter2.prototype.reset = function() {
    var siblings2 = getSilbings(this.context.view);
    each$1(siblings2, function(sibling) {
      var elements = getElements(sibling);
      each$1(elements, function(el) {
        el.show();
      });
    });
  };
  return SiblingFilter2;
}(Action);
var PADDING_RIGHT$1 = 10;
var PADDING_TOP$2 = 5;
var ButtonAction$1 = function(_super) {
  __extends$3(ButtonAction2, _super);
  function ButtonAction2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.buttonGroup = null;
    _this.buttonCfg = {
      name: "button",
      text: "button",
      textStyle: {
        x: 0,
        y: 0,
        fontSize: 12,
        fill: "#333333",
        cursor: "pointer"
      },
      padding: [8, 10],
      style: {
        fill: "#f7f7f7",
        stroke: "#cccccc",
        cursor: "pointer"
      },
      activeStyle: {
        fill: "#e6e6e6"
      }
    };
    return _this;
  }
  ButtonAction2.prototype.getButtonCfg = function() {
    return deepMix(this.buttonCfg, this.cfg);
  };
  ButtonAction2.prototype.drawButton = function() {
    var config = this.getButtonCfg();
    var group2 = this.context.view.foregroundGroup.addGroup({
      name: config.name
    });
    var textShape = group2.addShape({
      type: "text",
      name: "button-text",
      attrs: __assign$4({ text: config.text }, config.textStyle)
    });
    var textBBox = textShape.getBBox();
    var padding2 = parsePadding(config.padding);
    var buttonShape = group2.addShape({
      type: "rect",
      name: "button-rect",
      attrs: __assign$4({ x: textBBox.x - padding2[3], y: textBBox.y - padding2[0], width: textBBox.width + padding2[1] + padding2[3], height: textBBox.height + padding2[0] + padding2[2] }, config.style)
    });
    buttonShape.toBack();
    group2.on("mouseenter", function() {
      buttonShape.attr(config.activeStyle);
    });
    group2.on("mouseleave", function() {
      buttonShape.attr(config.style);
    });
    this.buttonGroup = group2;
  };
  ButtonAction2.prototype.resetPosition = function() {
    var view = this.context.view;
    var coord2 = view.getCoordinate();
    var point2 = coord2.convert({ x: 1, y: 1 });
    var buttonGroup = this.buttonGroup;
    var bbox = buttonGroup.getBBox();
    var matrix = transform$6(null, [
      ["t", point2.x - bbox.width - PADDING_RIGHT$1, point2.y + bbox.height + PADDING_TOP$2]
    ]);
    buttonGroup.setMatrix(matrix);
  };
  ButtonAction2.prototype.show = function() {
    if (!this.buttonGroup) {
      this.drawButton();
    }
    this.resetPosition();
    this.buttonGroup.show();
  };
  ButtonAction2.prototype.hide = function() {
    if (this.buttonGroup) {
      this.buttonGroup.hide();
    }
  };
  ButtonAction2.prototype.destroy = function() {
    var buttonGroup = this.buttonGroup;
    if (buttonGroup) {
      buttonGroup.remove();
    }
    _super.prototype.destroy.call(this);
  };
  return ButtonAction2;
}(Action);
var DISTANCE = 4;
var Drag = function(_super) {
  __extends$3(Drag2, _super);
  function Drag2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.starting = false;
    _this.dragStart = false;
    return _this;
  }
  Drag2.prototype.start = function() {
    this.starting = true;
    this.startPoint = this.context.getCurrentPoint();
  };
  Drag2.prototype.drag = function() {
    if (!this.startPoint) {
      return;
    }
    var current = this.context.getCurrentPoint();
    var view = this.context.view;
    var event = this.context.event;
    if (!this.dragStart) {
      if (distance$2(current, this.startPoint) > DISTANCE) {
        view.emit("dragstart", {
          target: event.target,
          x: event.x,
          y: event.y
        });
        this.dragStart = true;
      }
    } else {
      view.emit("drag", {
        target: event.target,
        x: event.x,
        y: event.y
      });
    }
  };
  Drag2.prototype.end = function() {
    if (this.dragStart) {
      var view = this.context.view;
      var event_1 = this.context.event;
      view.emit("dragend", {
        target: event_1.target,
        x: event_1.x,
        y: event_1.y
      });
    }
    this.starting = false;
    this.dragStart = false;
  };
  return Drag2;
}(Action);
var MIN_DISTANCE = 5;
var Move = function(_super) {
  __extends$3(Move2, _super);
  function Move2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.starting = false;
    _this.isMoving = false;
    _this.startPoint = null;
    _this.startMatrix = null;
    return _this;
  }
  Move2.prototype.start = function() {
    this.starting = true;
    this.startPoint = this.context.getCurrentPoint();
    this.startMatrix = this.context.view.middleGroup.getMatrix();
  };
  Move2.prototype.move = function() {
    if (!this.starting) {
      return;
    }
    var startPoint = this.startPoint;
    var currentPoint = this.context.getCurrentPoint();
    var d2 = distance$2(startPoint, currentPoint);
    if (d2 > MIN_DISTANCE && !this.isMoving) {
      this.isMoving = true;
    }
    if (this.isMoving) {
      var view = this.context.view;
      var matrix = transform$6(this.startMatrix, [
        ["t", currentPoint.x - startPoint.x, currentPoint.y - startPoint.y]
      ]);
      view.backgroundGroup.setMatrix(matrix);
      view.foregroundGroup.setMatrix(matrix);
      view.middleGroup.setMatrix(matrix);
    }
  };
  Move2.prototype.end = function() {
    if (this.isMoving) {
      this.isMoving = false;
    }
    this.startMatrix = null;
    this.starting = false;
    this.startPoint = null;
  };
  Move2.prototype.reset = function() {
    this.starting = false;
    this.startPoint = null;
    this.isMoving = false;
    var view = this.context.view;
    view.backgroundGroup.resetMatrix();
    view.foregroundGroup.resetMatrix();
    view.middleGroup.resetMatrix();
    this.isMoving = false;
  };
  return Move2;
}(Action);
var DIM_X = "x";
var DIM_Y = "y";
var ScaleTranslate$2 = function(_super) {
  __extends$3(ScaleTranslate2, _super);
  function ScaleTranslate2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.dims = [DIM_X, DIM_Y];
    _this.cfgFields = ["dims"];
    _this.cacheScaleDefs = {};
    return _this;
  }
  ScaleTranslate2.prototype.hasDim = function(dim) {
    return this.dims.includes(dim);
  };
  ScaleTranslate2.prototype.getScale = function(dim) {
    var view = this.context.view;
    if (dim === "x") {
      return view.getXScale();
    } else {
      return view.getYScales()[0];
    }
  };
  ScaleTranslate2.prototype.resetDim = function(dim) {
    var view = this.context.view;
    if (this.hasDim(dim) && this.cacheScaleDefs[dim]) {
      var scale2 = this.getScale(dim);
      view.scale(scale2.field, this.cacheScaleDefs[dim]);
      this.cacheScaleDefs[dim] = null;
    }
  };
  ScaleTranslate2.prototype.reset = function() {
    this.resetDim(DIM_X);
    this.resetDim(DIM_Y);
    var view = this.context.view;
    view.render(true);
  };
  return ScaleTranslate2;
}(Action);
var ScaleTranslate$1 = function(_super) {
  __extends$3(ScaleTranslate2, _super);
  function ScaleTranslate2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.startPoint = null;
    _this.starting = false;
    _this.startCache = {};
    return _this;
  }
  ScaleTranslate2.prototype.start = function() {
    var _this = this;
    this.startPoint = this.context.getCurrentPoint();
    this.starting = true;
    var dims = this.dims;
    each$1(dims, function(dim) {
      var scale2 = _this.getScale(dim);
      var min2 = scale2.min, max2 = scale2.max, values2 = scale2.values;
      _this.startCache[dim] = { min: min2, max: max2, values: values2 };
    });
  };
  ScaleTranslate2.prototype.end = function() {
    this.startPoint = null;
    this.starting = false;
    this.startCache = {};
  };
  ScaleTranslate2.prototype.translate = function() {
    var _this = this;
    if (!this.starting) {
      return;
    }
    var startPoint = this.startPoint;
    var coord2 = this.context.view.getCoordinate();
    var currentPoint = this.context.getCurrentPoint();
    var normalStart = coord2.invert(startPoint);
    var noramlCurrent = coord2.invert(currentPoint);
    var dx = noramlCurrent.x - normalStart.x;
    var dy = noramlCurrent.y - normalStart.y;
    var view = this.context.view;
    var dims = this.dims;
    each$1(dims, function(dim) {
      _this.translateDim(dim, { x: dx * -1, y: dy * -1 });
    });
    view.render(true);
  };
  ScaleTranslate2.prototype.translateDim = function(dim, normalPoint) {
    if (this.hasDim(dim)) {
      var scale2 = this.getScale(dim);
      if (scale2.isLinear) {
        this.translateLinear(dim, scale2, normalPoint);
      }
    }
  };
  ScaleTranslate2.prototype.translateLinear = function(dim, scale2, normalPoint) {
    var view = this.context.view;
    var _a2 = this.startCache[dim], min2 = _a2.min, max2 = _a2.max;
    var range3 = max2 - min2;
    var d2 = normalPoint[dim] * range3;
    if (!this.cacheScaleDefs[dim]) {
      this.cacheScaleDefs[dim] = {
        nice: scale2.nice,
        min: min2,
        max: max2
      };
    }
    view.scale(scale2.field, {
      nice: false,
      min: min2 + d2,
      max: max2 + d2
    });
  };
  ScaleTranslate2.prototype.reset = function() {
    _super.prototype.reset.call(this);
    this.startPoint = null;
    this.starting = false;
  };
  return ScaleTranslate2;
}(ScaleTranslate$2);
var ScaleTranslate = function(_super) {
  __extends$3(ScaleTranslate2, _super);
  function ScaleTranslate2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.zoomRatio = 0.05;
    return _this;
  }
  ScaleTranslate2.prototype.zoomIn = function() {
    this.zoom(this.zoomRatio);
  };
  ScaleTranslate2.prototype.zoom = function(scale2) {
    var _this = this;
    var dims = this.dims;
    each$1(dims, function(dim) {
      _this.zoomDim(dim, scale2);
    });
    this.context.view.render(true);
  };
  ScaleTranslate2.prototype.zoomOut = function() {
    this.zoom(-1 * this.zoomRatio);
  };
  ScaleTranslate2.prototype.zoomDim = function(dim, dRatio) {
    if (this.hasDim(dim)) {
      var scale2 = this.getScale(dim);
      if (scale2.isLinear) {
        this.zoomLinear(dim, scale2, dRatio);
      }
    }
  };
  ScaleTranslate2.prototype.zoomLinear = function(dim, scale2, dRatio) {
    var view = this.context.view;
    if (!this.cacheScaleDefs[dim]) {
      this.cacheScaleDefs[dim] = {
        nice: scale2.nice,
        min: scale2.min,
        max: scale2.max
      };
    }
    var scaleDef = this.cacheScaleDefs[dim];
    var range3 = scaleDef.max - scaleDef.min;
    var min2 = scale2.min, max2 = scale2.max;
    var d2 = dRatio * range3;
    var toMin = min2 - d2;
    var toMax = max2 + d2;
    var curRange = toMax - toMin;
    var scaled = curRange / range3;
    if (toMax > toMin && scaled < 100 && scaled > 0.01) {
      view.scale(scale2.field, {
        nice: false,
        min: min2 - d2,
        max: max2 + d2
      });
    }
  };
  return ScaleTranslate2;
}(ScaleTranslate$2);
function isWheelDown$1(event) {
  var wheelEvent = event.gEvent.originalEvent;
  return wheelEvent.deltaY > 0;
}
var DEFAULT_WHEELDELTA = 1;
var MousewheelScroll = function(_super) {
  __extends$3(MousewheelScroll2, _super);
  function MousewheelScroll2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  MousewheelScroll2.prototype.scroll = function(arg) {
    var _a2 = this.context, view = _a2.view, event = _a2.event;
    if (!view.getOptions().scrollbar) {
      return;
    }
    var wheelDelta = (arg === null || arg === void 0 ? void 0 : arg.wheelDelta) || DEFAULT_WHEELDELTA;
    var scrollbarController = view.getController("scrollbar");
    var xScale = view.getXScale();
    var data2 = view.getOptions().data;
    var dataSize = size(valuesOfKey(data2, xScale.field));
    var step = size(xScale.values);
    var currentRatio = scrollbarController.getValue();
    var currentStart = Math.floor((dataSize - step) * currentRatio);
    var nextStart = currentStart + (isWheelDown$1(event) ? wheelDelta : -wheelDelta);
    var correction = wheelDelta / (dataSize - step) / 1e4;
    var nextRatio = clamp(nextStart / (dataSize - step) + correction, 0, 1);
    scrollbarController.setValue(nextRatio);
  };
  return MousewheelScroll2;
}(Action);
var AXIS_DESCRIPTION_TOOLTIP = "aixs-description-tooltip";
var AxisDescription = function(_super) {
  __extends$3(AxisDescription2, _super);
  function AxisDescription2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  AxisDescription2.prototype.show = function() {
    var context2 = this.context;
    var axis2 = getDelegationObject(context2).axis;
    var _a2 = axis2.cfg.title, description = _a2.description, text2 = _a2.text, descriptionTooltipStyle = _a2.descriptionTooltipStyle;
    var _b = context2.event, x2 = _b.x, y2 = _b.y;
    if (!this.tooltip) {
      this.renderTooltip();
    }
    this.tooltip.update({
      title: text2 || "",
      customContent: function() {
        return '\n          <div class="'.concat(CONTAINER_CLASS, '" style={').concat(descriptionTooltipStyle, '}>\n            <div class="').concat(TITLE_CLASS, '">\n              \u5B57\u6BB5\u8BF4\u660E\uFF1A').concat(description, "\n            </div>\n          </div>\n        ");
      },
      x: x2,
      y: y2
    });
    this.tooltip.show();
  };
  AxisDescription2.prototype.destroy = function() {
    _super.prototype.destroy.call(this);
    this.tooltip && this.tooltip.destroy();
  };
  AxisDescription2.prototype.hide = function() {
    this.tooltip && this.tooltip.hide();
  };
  AxisDescription2.prototype.renderTooltip = function() {
    var _a2;
    var view = this.context.view;
    var canvas = view.canvas;
    var region = {
      start: { x: 0, y: 0 },
      end: { x: canvas.get("width"), y: canvas.get("height") }
    };
    var tooltip2 = new HtmlTooltip({
      parent: canvas.get("el").parentNode,
      region,
      visible: false,
      containerId: AXIS_DESCRIPTION_TOOLTIP,
      domStyles: __assign$4({}, deepMix({}, (_a2 = {}, _a2[CONTAINER_CLASS] = {
        "max-width": "50%",
        padding: "10px",
        "line-height": "15px",
        "font-size": "12px",
        color: "rgba(0, 0, 0, .65)"
      }, _a2[TITLE_CLASS] = {
        "word-break": "break-all",
        "margin-bottom": "3px"
      }, _a2)))
    });
    tooltip2.init();
    tooltip2.setCapture(false);
    this.tooltip = tooltip2;
  };
  return AxisDescription2;
}(Action);
registerTheme("dark", createThemeByStyleSheet(antvDark));
registerEngine("canvas", CanvasEngine);
registerEngine("svg", SVGEngine);
registerGeometry("Polygon", Polygon);
registerGeometry("Interval", Interval);
registerGeometry("Schema", Schema);
registerGeometry("Path", Path);
registerGeometry("Point", Point);
registerGeometry("Line", Line$2);
registerGeometry("Area", Area$1);
registerGeometry("Edge", Edge);
registerGeometry("Heatmap", Heatmap);
registerGeometry("Violin", Violin);
registerGeometryLabel("base", GeometryLabel);
registerGeometryLabel("interval", IntervalLabel);
registerGeometryLabel("pie", PieLabel);
registerGeometryLabel("polar", PolarLabel);
registerGeometryLabelLayout("overlap", overlap);
registerGeometryLabelLayout("distribute", distribute);
registerGeometryLabelLayout("fixed-overlap", fixedOverlap);
registerGeometryLabelLayout("hide-overlap", hideOverlap);
registerGeometryLabelLayout("limit-in-shape", limitInShape);
registerGeometryLabelLayout("limit-in-canvas", limitInCanvas);
registerGeometryLabelLayout("limit-in-plot", limitInPlot$3);
registerGeometryLabelLayout("pie-outer", pieOuterLabelLayout);
registerGeometryLabelLayout("adjust-color", adjustColor);
registerGeometryLabelLayout("interval-adjust-position", intervalAdjustPosition);
registerGeometryLabelLayout("interval-hide-overlap", intervalHideOverlap);
registerGeometryLabelLayout("point-adjust-position", pointAdjustPosition);
registerGeometryLabelLayout("pie-spider", pieSpiderLabelLayout);
registerGeometryLabelLayout("path-adjust-position", pathAdjustPosition);
registerAnimation("fade-in", fadeIn);
registerAnimation("fade-out", fadeOut);
registerAnimation("grow-in-x", growInX);
registerAnimation("grow-in-xy", growInXY);
registerAnimation("grow-in-y", growInY);
registerAnimation("scale-in-x", scaleInX);
registerAnimation("scale-in-y", scaleInY);
registerAnimation("wave-in", waveIn);
registerAnimation("zoom-in", zoomIn);
registerAnimation("zoom-out", zoomOut);
registerAnimation("position-update", positionUpdate);
registerAnimation("sector-path-update", sectorPathUpdate);
registerAnimation("path-in", pathIn);
registerFacet("rect", Rect);
registerFacet("mirror", Mirror);
registerFacet("list", List);
registerFacet("matrix", Matrix);
registerFacet("circle", Circle);
registerFacet("tree", Tree);
registerComponentController("axis", Axis);
registerComponentController("legend", Legend);
registerComponentController("tooltip", Tooltip);
registerComponentController("annotation", Annotation);
registerComponentController("slider", Slider);
registerComponentController("scrollbar", Scrollbar);
registerAction("tooltip", TooltipAction);
registerAction("sibling-tooltip", SiblingTooltip);
registerAction("ellipsis-text", EllipsisText);
registerAction("element-active", ElementActive);
registerAction("element-single-active", ElementSingleActive);
registerAction("element-range-active", ElementRangeActive);
registerAction("element-highlight", ElementHighlight);
registerAction("element-highlight-by-x", HighlightX);
registerAction("element-highlight-by-color", HighlightColor);
registerAction("element-single-highlight", ElementSingleHighlight);
registerAction("element-range-highlight", ElementRangeHighlight);
registerAction("element-sibling-highlight", ElementRangeHighlight, {
  effectSiblings: true,
  effectByRecord: true
});
registerAction("element-selected", ElementMultipleSelected);
registerAction("element-single-selected", ElementSingleSelected);
registerAction("element-range-selected", ElementRangeSelected);
registerAction("element-link-by-color", LinkByColor);
registerAction("active-region", ActiveRegion);
registerAction("list-active", ListActive);
registerAction("list-selected", ListSelected);
registerAction("list-highlight", ListHighlight);
registerAction("list-unchecked", ListUnchecked);
registerAction("list-checked", ListChecked);
registerAction("list-focus", ListFocus);
registerAction("list-radio", ListRadio);
registerAction("legend-item-highlight", ListHighlight, {
  componentNames: ["legend"]
});
registerAction("axis-label-highlight", ListHighlight, {
  componentNames: ["axis"]
});
registerAction("axis-description", AxisDescription);
registerAction("rect-mask", RectMask);
registerAction("x-rect-mask", DimRect, { dim: "x" });
registerAction("y-rect-mask", DimRect, { dim: "y" });
registerAction("circle-mask", CircleMask);
registerAction("path-mask", PathMask);
registerAction("smooth-path-mask", SmoothPathMask);
registerAction("cursor", CursorAction);
registerAction("data-filter", DataFilter);
registerAction("brush", RangeFilter);
registerAction("brush-x", RangeFilter, { dims: ["x"] });
registerAction("brush-y", RangeFilter, { dims: ["y"] });
registerAction("sibling-filter", SiblingFilter$1);
registerAction("sibling-x-filter", SiblingFilter$1);
registerAction("sibling-y-filter", SiblingFilter$1);
registerAction("element-filter", ElementFilter);
registerAction("element-sibling-filter", SiblingFilter);
registerAction("element-sibling-filter-record", SiblingFilter, { byRecord: true });
registerAction("view-drag", Drag);
registerAction("view-move", Move);
registerAction("scale-translate", ScaleTranslate$1);
registerAction("scale-zoom", ScaleTranslate);
registerAction("reset-button", ButtonAction$1, {
  name: "reset-button",
  text: "reset"
});
registerAction("mousewheel-scroll", MousewheelScroll);
function isPointInView$1(context2) {
  return context2.isInPlot();
}
registerInteraction("tooltip", {
  start: [
    { trigger: "plot:mousemove", action: "tooltip:show", throttle: { wait: 50, leading: true, trailing: false } },
    { trigger: "plot:touchmove", action: "tooltip:show", throttle: { wait: 50, leading: true, trailing: false } }
  ],
  end: [
    { trigger: "plot:mouseleave", action: "tooltip:hide" },
    { trigger: "plot:leave", action: "tooltip:hide" },
    { trigger: "plot:touchend", action: "tooltip:hide" }
  ]
});
registerInteraction("ellipsis-text", {
  start: [
    {
      trigger: "legend-item-name:mousemove",
      action: "ellipsis-text:show",
      throttle: { wait: 50, leading: true, trailing: false }
    },
    {
      trigger: "legend-item-name:touchstart",
      action: "ellipsis-text:show",
      throttle: { wait: 50, leading: true, trailing: false }
    },
    {
      trigger: "axis-label:mousemove",
      action: "ellipsis-text:show",
      throttle: { wait: 50, leading: true, trailing: false }
    },
    {
      trigger: "axis-label:touchstart",
      action: "ellipsis-text:show",
      throttle: { wait: 50, leading: true, trailing: false }
    }
  ],
  end: [
    { trigger: "legend-item-name:mouseleave", action: "ellipsis-text:hide" },
    { trigger: "legend-item-name:touchend", action: "ellipsis-text:hide" },
    { trigger: "axis-label:mouseleave", action: "ellipsis-text:hide" },
    { trigger: "axis-label:mouseout", action: "ellipsis-text:hide" },
    { trigger: "axis-label:touchend", action: "ellipsis-text:hide" }
  ]
});
registerInteraction("element-active", {
  start: [{ trigger: "element:mouseenter", action: "element-active:active" }],
  end: [{ trigger: "element:mouseleave", action: "element-active:reset" }]
});
registerInteraction("element-selected", {
  start: [{ trigger: "element:click", action: "element-selected:toggle" }]
});
registerInteraction("element-highlight", {
  start: [{ trigger: "element:mouseenter", action: "element-highlight:highlight" }],
  end: [{ trigger: "element:mouseleave", action: "element-highlight:reset" }]
});
registerInteraction("element-highlight-by-x", {
  start: [{ trigger: "element:mouseenter", action: "element-highlight-by-x:highlight" }],
  end: [{ trigger: "element:mouseleave", action: "element-highlight-by-x:reset" }]
});
registerInteraction("element-highlight-by-color", {
  start: [{ trigger: "element:mouseenter", action: "element-highlight-by-color:highlight" }],
  end: [{ trigger: "element:mouseleave", action: "element-highlight-by-color:reset" }]
});
registerInteraction("legend-active", {
  start: [{ trigger: "legend-item:mouseenter", action: ["list-active:active", "element-active:active"] }],
  end: [{ trigger: "legend-item:mouseleave", action: ["list-active:reset", "element-active:reset"] }]
});
registerInteraction("legend-highlight", {
  start: [
    { trigger: "legend-item:mouseenter", action: ["legend-item-highlight:highlight", "element-highlight:highlight"] }
  ],
  end: [{ trigger: "legend-item:mouseleave", action: ["legend-item-highlight:reset", "element-highlight:reset"] }]
});
registerInteraction("axis-label-highlight", {
  start: [
    { trigger: "axis-label:mouseenter", action: ["axis-label-highlight:highlight", "element-highlight:highlight"] }
  ],
  end: [{ trigger: "axis-label:mouseleave", action: ["axis-label-highlight:reset", "element-highlight:reset"] }]
});
registerInteraction("element-list-highlight", {
  start: [{ trigger: "element:mouseenter", action: ["list-highlight:highlight", "element-highlight:highlight"] }],
  end: [{ trigger: "element:mouseleave", action: ["list-highlight:reset", "element-highlight:reset"] }]
});
registerInteraction("element-range-highlight", {
  showEnable: [
    { trigger: "plot:mouseenter", action: "cursor:crosshair" },
    { trigger: "mask:mouseenter", action: "cursor:move" },
    { trigger: "plot:mouseleave", action: "cursor:default" },
    { trigger: "mask:mouseleave", action: "cursor:crosshair" }
  ],
  start: [
    {
      trigger: "plot:mousedown",
      isEnable: function(context2) {
        return !context2.isInShape("mask");
      },
      action: ["rect-mask:start", "rect-mask:show"]
    },
    {
      trigger: "mask:dragstart",
      action: ["rect-mask:moveStart"]
    }
  ],
  processing: [
    {
      trigger: "plot:mousemove",
      action: ["rect-mask:resize"]
    },
    {
      trigger: "mask:drag",
      action: ["rect-mask:move"]
    },
    {
      trigger: "mask:change",
      action: ["element-range-highlight:highlight"]
    }
  ],
  end: [
    { trigger: "plot:mouseup", action: ["rect-mask:end"] },
    { trigger: "mask:dragend", action: ["rect-mask:moveEnd"] },
    {
      trigger: "document:mouseup",
      isEnable: function(context2) {
        return !context2.isInPlot();
      },
      action: ["element-range-highlight:clear", "rect-mask:end", "rect-mask:hide"]
    }
  ],
  rollback: [{ trigger: "dblclick", action: ["element-range-highlight:clear", "rect-mask:hide"] }]
});
registerInteraction("brush", {
  showEnable: [
    { trigger: "plot:mouseenter", action: "cursor:crosshair" },
    { trigger: "plot:mouseleave", action: "cursor:default" }
  ],
  start: [
    {
      trigger: "mousedown",
      isEnable: isPointInView$1,
      action: ["brush:start", "rect-mask:start", "rect-mask:show"]
    }
  ],
  processing: [
    {
      trigger: "mousemove",
      isEnable: isPointInView$1,
      action: ["rect-mask:resize"]
    }
  ],
  end: [
    {
      trigger: "mouseup",
      isEnable: isPointInView$1,
      action: ["brush:filter", "brush:end", "rect-mask:end", "rect-mask:hide", "reset-button:show"]
    }
  ],
  rollback: [{ trigger: "reset-button:click", action: ["brush:reset", "reset-button:hide", "cursor:crosshair"] }]
});
registerInteraction("brush-visible", {
  showEnable: [
    { trigger: "plot:mouseenter", action: "cursor:crosshair" },
    { trigger: "plot:mouseleave", action: "cursor:default" }
  ],
  start: [
    {
      trigger: "plot:mousedown",
      action: ["rect-mask:start", "rect-mask:show"]
    }
  ],
  processing: [
    {
      trigger: "plot:mousemove",
      action: ["rect-mask:resize"]
    },
    { trigger: "mask:change", action: ["element-range-highlight:highlight"] }
  ],
  end: [
    {
      trigger: "plot:mouseup",
      action: ["rect-mask:end", "rect-mask:hide", "element-filter:filter", "element-range-highlight:clear"]
    }
  ],
  rollback: [
    {
      trigger: "dblclick",
      action: ["element-filter:clear"]
    }
  ]
});
registerInteraction("brush-x", {
  showEnable: [
    { trigger: "plot:mouseenter", action: "cursor:crosshair" },
    { trigger: "plot:mouseleave", action: "cursor:default" }
  ],
  start: [
    {
      trigger: "mousedown",
      isEnable: isPointInView$1,
      action: ["brush-x:start", "x-rect-mask:start", "x-rect-mask:show"]
    }
  ],
  processing: [
    {
      trigger: "mousemove",
      isEnable: isPointInView$1,
      action: ["x-rect-mask:resize"]
    }
  ],
  end: [
    {
      trigger: "mouseup",
      isEnable: isPointInView$1,
      action: ["brush-x:filter", "brush-x:end", "x-rect-mask:end", "x-rect-mask:hide"]
    }
  ],
  rollback: [{ trigger: "dblclick", action: ["brush-x:reset"] }]
});
registerInteraction("element-path-highlight", {
  showEnable: [
    { trigger: "plot:mouseenter", action: "cursor:crosshair" },
    { trigger: "plot:mouseleave", action: "cursor:default" }
  ],
  start: [
    { trigger: "mousedown", isEnable: isPointInView$1, action: "path-mask:start" },
    { trigger: "mousedown", isEnable: isPointInView$1, action: "path-mask:show" }
  ],
  processing: [{ trigger: "mousemove", action: "path-mask:addPoint" }],
  end: [{ trigger: "mouseup", action: "path-mask:end" }],
  rollback: [{ trigger: "dblclick", action: "path-mask:hide" }]
});
registerInteraction("element-single-selected", {
  start: [{ trigger: "element:click", action: "element-single-selected:toggle" }]
});
registerInteraction("legend-filter", {
  showEnable: [
    { trigger: "legend-item:mouseenter", action: ["cursor:pointer", "list-radio:show"] },
    { trigger: "legend-item:mouseleave", action: ["cursor:default", "list-radio:hide"] }
  ],
  start: [
    {
      trigger: "legend-item:click",
      isEnable: function(context2) {
        return !context2.isInShape("legend-item-radio");
      },
      action: ["legend-item-highlight:reset", "element-highlight:reset", "list-unchecked:toggle", "data-filter:filter", "list-radio:show"]
    },
    {
      trigger: "legend-item-radio:mouseenter",
      action: ["list-radio:showTip"]
    },
    {
      trigger: "legend-item-radio:mouseleave",
      action: ["list-radio:hideTip"]
    },
    {
      trigger: "legend-item-radio:click",
      action: ["list-focus:toggle", "data-filter:filter", "list-radio:show"]
    }
  ]
});
registerInteraction("continuous-filter", {
  start: [{ trigger: "legend:valuechanged", action: "data-filter:filter" }]
});
registerInteraction("continuous-visible-filter", {
  start: [{ trigger: "legend:valuechanged", action: "element-filter:filter" }]
});
registerInteraction("legend-visible-filter", {
  showEnable: [
    { trigger: "legend-item:mouseenter", action: "cursor:pointer" },
    { trigger: "legend-item:mouseleave", action: "cursor:default" }
  ],
  start: [{ trigger: "legend-item:click", action: ["legend-item-highlight:reset", "element-highlight:reset", "list-unchecked:toggle", "element-filter:filter"] }]
});
registerInteraction("active-region", {
  start: [{ trigger: "plot:mousemove", action: "active-region:show" }],
  end: [{ trigger: "plot:mouseleave", action: "active-region:hide" }]
});
registerInteraction("axis-description", {
  start: [{ trigger: "axis-description:mousemove", action: "axis-description:show" }],
  end: [{ trigger: "axis-description:mouseleave", action: "axis-description:hide" }]
});
function isWheelDown(event) {
  event.gEvent.preventDefault();
  return event.gEvent.originalEvent.deltaY > 0;
}
registerInteraction("view-zoom", {
  start: [
    {
      trigger: "plot:mousewheel",
      isEnable: function(context2) {
        return isWheelDown(context2.event);
      },
      action: "scale-zoom:zoomOut",
      throttle: { wait: 100, leading: true, trailing: false }
    },
    {
      trigger: "plot:mousewheel",
      isEnable: function(context2) {
        return !isWheelDown(context2.event);
      },
      action: "scale-zoom:zoomIn",
      throttle: { wait: 100, leading: true, trailing: false }
    }
  ]
});
registerInteraction("sibling-tooltip", {
  start: [{ trigger: "plot:mousemove", action: "sibling-tooltip:show" }],
  end: [{ trigger: "plot:mouseleave", action: "sibling-tooltip:hide" }]
});
registerInteraction("plot-mousewheel-scroll", {
  start: [{ trigger: "plot:mousewheel", action: "mousewheel-scroll:scroll" }]
});
function flow() {
  var flows = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    flows[_i] = arguments[_i];
  }
  return function(param) {
    return flows.reduce(function(result, f2) {
      return f2(result);
    }, param);
  };
}
function pick(obj, keys2) {
  var r2 = {};
  if (obj !== null && typeof obj === "object") {
    keys2.forEach(function(key2) {
      var v2 = obj[key2];
      if (v2 !== void 0) {
        r2[key2] = v2;
      }
    });
  }
  return r2;
}
function template(source, data2) {
  if (!data2) {
    return source;
  }
  return reduce(
    data2,
    function(r2, v2, k2) {
      return r2.replace(new RegExp("{\\s*" + k2 + "\\s*}", "g"), v2);
    },
    source
  );
}
var LEVEL;
(function(LEVEL2) {
  LEVEL2["ERROR"] = "error";
  LEVEL2["WARN"] = "warn";
  LEVEL2["INFO"] = "log";
})(LEVEL || (LEVEL = {}));
var BRAND = "AntV/G2Plot";
function getMessage(format2) {
  var args = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    args[_i - 1] = arguments[_i];
  }
  var argIndex = 0;
  return BRAND + ": " + format2.replace(/%s/g, function() {
    return "" + args[argIndex++];
  });
}
function log(level, condition, format2) {
  var args = [];
  for (var _i = 3; _i < arguments.length; _i++) {
    args[_i - 3] = arguments[_i];
  }
  if (!condition) {
    console[level](getMessage.apply(void 0, __spreadArrays([format2], args)));
  }
}
function getContainerSize(ele) {
  if (!ele) {
    return { width: 0, height: 0 };
  }
  var style2 = getComputedStyle(ele);
  return {
    width: (ele.clientWidth || parseInt(style2.width, 10)) - parseInt(style2.paddingLeft, 10) - parseInt(style2.paddingRight, 10),
    height: (ele.clientHeight || parseInt(style2.height, 10)) - parseInt(style2.paddingTop, 10) - parseInt(style2.paddingBottom, 10)
  };
}
function findGeometry(view, type4) {
  return view.geometries.find(function(g2) {
    return g2.type === type4;
  });
}
function getAllElements(view) {
  return reduce(view.geometries, function(r2, geometry2) {
    return r2.concat(geometry2.elements);
  }, []);
}
function getAllElementsRecursively(view) {
  if (get(view, ["views", "length"], 0) <= 0) {
    return getAllElements(view);
  }
  return reduce(view.views, function(ele, subView) {
    return ele.concat(getAllElementsRecursively(subView));
  }, getAllElements(view));
}
function getAllGeometriesRecursively(view) {
  if (get(view, ["views", "length"], 0) <= 0) {
    return view.geometries;
  }
  return reduce(view.views, function(ele, subView) {
    return ele.concat(subView.geometries);
  }, view.geometries);
}
function findViewById(chart, id2) {
  return chart.views.find(function(view) {
    return view.id === id2;
  });
}
function getViews(view) {
  var parent = view.parent;
  return parent ? parent.views : [];
}
function getSiblingViews(view) {
  return getViews(view).filter(function(sub2) {
    return sub2 !== view;
  });
}
function transformLabel(labelOptions) {
  if (!isType$2(labelOptions, "Object")) {
    return labelOptions;
  }
  var label2 = __assign$4({}, labelOptions);
  if (label2.formatter && !label2.content) {
    label2.content = label2.formatter;
  }
  return label2;
}
function points2Path(points2, isInCircle) {
  var path2 = [];
  if (points2.length) {
    path2.push(["M", points2[0].x, points2[0].y]);
    for (var i2 = 1, length_1 = points2.length; i2 < length_1; i2 += 1) {
      var item = points2[i2];
      path2.push(["L", item.x, item.y]);
    }
    if (isInCircle) {
      path2.push(["Z"]);
    }
  }
  return path2;
}
var smoothBezier = function(points2, smooth, isLoop, constraint) {
  var cps = [];
  var prevPoint;
  var nextPoint;
  var hasConstraint = !!constraint;
  var min2;
  var max2;
  if (hasConstraint) {
    min2 = [Infinity, Infinity];
    max2 = [-Infinity, -Infinity];
    for (var i2 = 0, l2 = points2.length; i2 < l2; i2++) {
      var point2 = points2[i2];
      min2 = min$1([0, 0], min2, point2);
      max2 = max$1([0, 0], max2, point2);
    }
    min2 = min$1([0, 0], min2, constraint[0]);
    max2 = max$1([0, 0], max2, constraint[1]);
  }
  for (var i2 = 0, len = points2.length; i2 < len; i2++) {
    var point2 = points2[i2];
    if (isLoop) {
      prevPoint = points2[i2 ? i2 - 1 : len - 1];
      nextPoint = points2[(i2 + 1) % len];
    } else {
      if (i2 === 0 || i2 === len - 1) {
        cps.push(point2);
        continue;
      } else {
        prevPoint = points2[i2 - 1];
        nextPoint = points2[i2 + 1];
      }
    }
    var v2 = [0, 0];
    v2 = sub(v2, nextPoint, prevPoint);
    v2 = scale$3(v2, v2, smooth);
    var d0 = distance$6(point2, prevPoint);
    var d1 = distance$6(point2, nextPoint);
    var sum = d0 + d1;
    if (sum !== 0) {
      d0 /= sum;
      d1 /= sum;
    }
    var v1 = scale$3([0, 0], v2, -d0);
    var v22 = scale$3([0, 0], v2, d1);
    var cp0 = add([0, 0], point2, v1);
    var cp1 = add([0, 0], point2, v22);
    if (hasConstraint) {
      cp0 = max$1([0, 0], cp0, min2);
      cp0 = min$1([0, 0], cp0, max2);
      cp1 = max$1([0, 0], cp1, min2);
      cp1 = min$1([0, 0], cp1, max2);
    }
    cps.push(cp0);
    cps.push(cp1);
  }
  if (isLoop) {
    cps.push(cps.shift());
  }
  return cps;
};
function catmullRom2bezier(crp, z2, constraint) {
  var isLoop = !!z2;
  var pointList = [];
  for (var i2 = 0, l2 = crp.length; i2 < l2; i2 += 2) {
    pointList.push([crp[i2], crp[i2 + 1]]);
  }
  var controlPointList = smoothBezier(pointList, 0.4, isLoop, constraint);
  var len = pointList.length;
  var d1 = [];
  var cp1;
  var cp2;
  var p2;
  for (var i2 = 0; i2 < len - 1; i2++) {
    cp1 = controlPointList[i2 * 2];
    cp2 = controlPointList[i2 * 2 + 1];
    p2 = pointList[i2 + 1];
    d1.push(["C", cp1[0], cp1[1], cp2[0], cp2[1], p2[0], p2[1]]);
  }
  if (isLoop) {
    cp1 = controlPointList[len];
    cp2 = controlPointList[len + 1];
    p2 = pointList[0];
    d1.push(["C", cp1[0], cp1[1], cp2[0], cp2[1], p2[0], p2[1]]);
  }
  return d1;
}
function getSplinePath(points2, isInCircle, constaint) {
  var data2 = [];
  var first = points2[0];
  var prePoint = null;
  if (points2.length <= 2) {
    return points2Path(points2, isInCircle);
  }
  for (var i2 = 0, len = points2.length; i2 < len; i2++) {
    var point2 = points2[i2];
    if (!prePoint || !(prePoint.x === point2.x && prePoint.y === point2.y)) {
      data2.push(point2.x);
      data2.push(point2.y);
      prePoint = point2;
    }
  }
  var constraint = constaint || [
    [0, 0],
    [1, 1]
  ];
  var splinePath2 = catmullRom2bezier(data2, isInCircle, constraint);
  splinePath2.unshift(["M", first.x, first.y]);
  return splinePath2;
}
var MAX_MIX_LEVEL = 5;
var toString = {}.toString;
var isType$1 = function(value2, type4) {
  return toString.call(value2) === "[object " + type4 + "]";
};
var isArray = function(value2) {
  return isType$1(value2, "Array");
};
var isObjectLike = function(value2) {
  return typeof value2 === "object" && value2 !== null;
};
var isPlainObject = function(value2) {
  if (!isObjectLike(value2) || !isType$1(value2, "Object")) {
    return false;
  }
  var proto = value2;
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }
  return Object.getPrototypeOf(value2) === proto;
};
var deep = function(dist, src2, level, maxLevel) {
  level = level || 0;
  maxLevel = maxLevel || MAX_MIX_LEVEL;
  for (var key2 in src2) {
    if (Object.prototype.hasOwnProperty.call(src2, key2)) {
      var value2 = src2[key2];
      if (!value2) {
        dist[key2] = value2;
      } else {
        if (isPlainObject(value2)) {
          if (!isPlainObject(dist[key2])) {
            dist[key2] = {};
          }
          if (level < maxLevel) {
            deep(dist[key2], value2, level + 1, maxLevel);
          } else {
            dist[key2] = src2[key2];
          }
        } else if (isArray(value2)) {
          dist[key2] = [];
          dist[key2] = dist[key2].concat(value2);
        } else {
          dist[key2] = value2;
        }
      }
    }
  }
};
var deepAssign = function(rst) {
  var args = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    args[_i - 1] = arguments[_i];
  }
  for (var i2 = 0; i2 < args.length; i2 += 1) {
    deep(rst, args[i2]);
  }
  return rst;
};
function kebabCase(word2) {
  if (!word2) {
    return word2;
  }
  var result = word2.match(/(([A-Z]{0,1}[a-z]*[^A-Z])|([A-Z]{1}))/g);
  return result.map(function(s2) {
    return s2.toLowerCase();
  }).join("-");
}
function adapteStyle(style2) {
  var styleObject = {
    overflow: "hidden",
    "white-space": "nowrap",
    "text-overflow": "ellipsis",
    display: "flex",
    justifyContent: "center",
    alignItems: "center"
  };
  var shapeStyleKeys = [
    "stroke",
    "lineWidth",
    "shadowColor",
    "strokeOpacity",
    "shadowBlur",
    "shadowOffsetX",
    "shadowOffsetY",
    "fill"
  ];
  if (get(style2, "fill")) {
    styleObject["color"] = style2["fill"];
  }
  var _a2 = pick(style2, shapeStyleKeys), shadowColor = _a2.shadowColor, _b = _a2.shadowBlur, shadowBlur = _b === void 0 ? 0 : _b, _c = _a2.shadowOffsetX, shadowOffsetX = _c === void 0 ? 0 : _c, _d = _a2.shadowOffsetY, shadowOffsetY = _d === void 0 ? 0 : _d;
  styleObject["text-shadow"] = "" + [shadowColor, shadowOffsetX + "px", shadowOffsetY + "px", shadowBlur + "px"].join(" ");
  var _e = pick(style2, shapeStyleKeys), stroke = _e.stroke, _f = _e.lineWidth, lineWidth = _f === void 0 ? 0 : _f;
  styleObject["-webkit-text-stroke"] = "" + [lineWidth + "px", stroke].join(" ");
  each$1(style2, function(v2, k2) {
    if (["fontSize"].includes(k2) && isNumber$1(v2)) {
      styleObject[kebabCase(k2)] = v2 + "px";
    } else if (k2 && !shapeStyleKeys.includes(k2)) {
      styleObject[kebabCase(k2)] = "" + v2;
    }
  });
  return styleObject;
}
function setStatisticContainerStyle(container, style2) {
  container.style["pointer-events"] = "none";
  each$1(style2, function(v2, k2) {
    if (k2 && v2) {
      container.style[k2] = v2;
    }
  });
}
var renderStatistic = function(chart, options, datum) {
  var statistic2 = options.statistic, plotType = options.plotType;
  var titleOpt = statistic2.title, contentOpt = statistic2.content;
  [titleOpt, contentOpt].forEach(function(option, idx) {
    if (!option) {
      return;
    }
    var transform2 = "";
    if (idx === 0) {
      transform2 = contentOpt ? "translate(-50%, -100%)" : "translate(-50%, -50%)";
    } else {
      transform2 = titleOpt ? "translate(-50%, 0)" : "translate(-50%, -50%)";
    }
    var style2 = isFunction(option.style) ? option.style(datum) : option.style;
    chart.annotation().html(__assign$4({
      position: ["50%", "50%"],
      html: function(container, view) {
        var coordinate2 = view.getCoordinate();
        var containerW = 0;
        if (plotType === "pie" || plotType === "ring-progress") {
          containerW = coordinate2.getRadius() * coordinate2.innerRadius * 2;
        } else if (plotType === "liquid") {
          var liquidShape = get(view.geometries, [0, "elements", 0, "shape"]);
          if (liquidShape) {
            var path2 = liquidShape.find(function(t2) {
              return t2.get("name") === "wrap";
            });
            var width = path2.getCanvasBBox().width;
            containerW = width;
          }
        } else if (!containerW) {
          containerW = coordinate2.getWidth();
        }
        setStatisticContainerStyle(container, __assign$4({ width: containerW + "px", transform: transform2 }, adapteStyle(style2)));
        var filteredData = view.getData();
        if (option.customHtml) {
          return option.customHtml(container, view, datum, filteredData);
        }
        var text2 = option.content;
        if (option.formatter) {
          text2 = option.formatter(datum, filteredData);
        }
        return text2 ? isString(text2) ? text2 : "" + text2 : "<div></div>";
      },
      key: (idx === 0 ? "top" : "bottom") + "-statistic"
    }, pick(option, ["offsetX", "offsetY", "rotate", "style", "formatter"])));
  });
};
var renderGaugeStatistic = function(chart, options, datum) {
  var statistic2 = options.statistic;
  var titleOpt = statistic2.title, contentOpt = statistic2.content;
  [titleOpt, contentOpt].forEach(function(option) {
    if (!option) {
      return;
    }
    var style2 = isFunction(option.style) ? option.style(datum) : option.style;
    chart.annotation().html(__assign$4({ position: ["50%", "100%"], html: function(container, view) {
      var coordinate2 = view.getCoordinate();
      var polarCoord = view.views[0].getCoordinate();
      var polarCenter = polarCoord.getCenter();
      var polarRadius = polarCoord.getRadius();
      var polarMaxY = Math.max(Math.sin(polarCoord.startAngle), Math.sin(polarCoord.endAngle)) * polarRadius;
      var offsetY = polarCenter.y + polarMaxY - coordinate2.y.start - parseFloat(get(style2, "fontSize", 0));
      var containerWidth = coordinate2.getRadius() * coordinate2.innerRadius * 2;
      setStatisticContainerStyle(container, __assign$4({ width: containerWidth + "px", transform: "translate(-50%, " + offsetY + "px)" }, adapteStyle(style2)));
      var filteredData = view.getData();
      if (option.customHtml) {
        return option.customHtml(container, view, datum, filteredData);
      }
      var text2 = option.content;
      if (option.formatter) {
        text2 = option.formatter(datum, filteredData);
      }
      return text2 ? isString(text2) ? text2 : "" + text2 : "<div></div>";
    } }, pick(option, ["offsetX", "offsetY", "rotate", "style", "formatter"])));
  });
};
var ctx;
function getCanvasContext() {
  if (!ctx) {
    ctx = document.createElement("canvas").getContext("2d");
  }
  return ctx;
}
memoize(function(text2, font) {
  if (font === void 0) {
    font = {};
  }
  var fontSize = font.fontSize, _a2 = font.fontFamily, fontFamily = _a2 === void 0 ? "sans-serif" : _a2, fontWeight = font.fontWeight, fontStyle = font.fontStyle, fontVariant = font.fontVariant;
  var ctx2 = getCanvasContext();
  ctx2.font = [fontStyle, fontWeight, fontVariant, fontSize + "px", fontFamily].join(" ");
  var metrics = ctx2.measureText(isString(text2) ? text2 : "");
  return metrics.width;
}, function(text2, font) {
  if (font === void 0) {
    font = {};
  }
  return __spreadArrays([text2], values(font)).join("");
});
function isRealNumber(v2) {
  return typeof v2 === "number" && !isNaN(v2);
}
function isBetween(value2, start, end) {
  var min2 = Math.min(start, end);
  var max2 = Math.max(start, end);
  return value2 >= min2 && value2 <= max2;
}
function adjustYMetaByZero(data2, field2) {
  if (!data2)
    return {};
  var numberData = data2.filter(function(datum) {
    var v2 = get(datum, [field2]);
    return isNumber$1(v2) && !isNaN(v2);
  });
  var gtZero = numberData.every(function(datum) {
    return get(datum, [field2]) >= 0;
  });
  var ltZero = numberData.every(function(datum) {
    return get(datum, [field2]) <= 0;
  });
  if (gtZero) {
    return { min: 0 };
  }
  if (ltZero) {
    return { max: 0 };
  }
  return {};
}
function transformDataToNodeLinkData(data2, sourceField, targetField, weightField, rawFields) {
  if (rawFields === void 0) {
    rawFields = [];
  }
  if (!Array.isArray(data2)) {
    return {
      nodes: [],
      links: []
    };
  }
  var links = [];
  var nodesMap = {};
  var nodesIndex = -1;
  data2.forEach(function(datum) {
    var source = datum[sourceField];
    var target = datum[targetField];
    var weight = datum[weightField];
    var rawData = pick(datum, rawFields);
    if (!nodesMap[source]) {
      nodesMap[source] = __assign$4({ id: ++nodesIndex, name: source }, rawData);
    }
    if (!nodesMap[target]) {
      nodesMap[target] = __assign$4({ id: ++nodesIndex, name: target }, rawData);
    }
    links.push(__assign$4({
      source: nodesMap[source].id,
      target: nodesMap[target].id,
      value: weight
    }, rawData));
  });
  return {
    nodes: Object.values(nodesMap).sort(function(a2, b10) {
      return a2.id - b10.id;
    }),
    links
  };
}
function processIllegalData(data2, field2) {
  var processData2 = filter(data2, function(d2) {
    var v2 = d2[field2];
    return v2 === null || typeof v2 === "number" && !isNaN(v2);
  });
  log(LEVEL.WARN, processData2.length === data2.length, "illegal data existed in chart data.");
  return processData2;
}
function normalPadding(padding2) {
  if (isNumber$1(padding2)) {
    return [padding2, padding2, padding2, padding2];
  }
  if (isArray$1(padding2)) {
    var length_1 = padding2.length;
    if (length_1 === 1) {
      return [padding2[0], padding2[0], padding2[0], padding2[0]];
    }
    if (length_1 === 2) {
      return [padding2[0], padding2[1], padding2[0], padding2[1]];
    }
    if (length_1 === 3) {
      return [padding2[0], padding2[1], padding2[2], padding2[1]];
    }
    if (length_1 === 4) {
      return padding2;
    }
  }
  return [0, 0, 0, 0];
}
function getAdjustAppendPadding(padding2, position, append2) {
  if (position === void 0) {
    position = "bottom";
  }
  if (append2 === void 0) {
    append2 = 25;
  }
  var currentAppendPadding = normalPadding(padding2);
  var PADDING2 = [
    position.startsWith("top") ? append2 : 0,
    position.startsWith("right") ? append2 : 0,
    position.startsWith("bottom") ? append2 : 0,
    position.startsWith("left") ? append2 : 0
  ];
  return [
    currentAppendPadding[0] + PADDING2[0],
    currentAppendPadding[1] + PADDING2[1],
    currentAppendPadding[2] + PADDING2[2],
    currentAppendPadding[3] + PADDING2[3]
  ];
}
function resolveAllPadding(paddings) {
  var normalPaddings = paddings.map(function(item) {
    return normalPadding(item);
  });
  var finalPadding = [0, 0, 0, 0];
  if (normalPaddings.length > 0) {
    finalPadding = finalPadding.map(function(item, index2) {
      normalPaddings.forEach(function(d2, i2) {
        item += normalPaddings[i2][index2];
      });
      return item;
    });
  }
  return finalPadding;
}
var GLOBAL = {
  locale: "en-US"
};
var LocaleMap = {};
function registerLocale(locale2, localeObj) {
  LocaleMap[locale2] = localeObj;
}
function getLocale(locale2) {
  return {
    get: function(key2, obj) {
      return template(get(LocaleMap[locale2], key2) || get(LocaleMap[GLOBAL.locale], key2) || get(LocaleMap["en-US"], key2) || key2, obj);
    }
  };
}
var EN_US_LOCALE = {
  locale: "en-US",
  general: {
    increase: "Increase",
    decrease: "Decrease",
    root: "Root"
  },
  statistic: {
    total: "Total"
  },
  conversionTag: {
    label: "Rate"
  },
  legend: {},
  tooltip: {},
  slider: {},
  scrollbar: {},
  waterfall: {
    total: "Total"
  }
};
var ZH_CN_LOCALE = {
  locale: "zh-CN",
  general: {
    increase: "\u589E\u52A0",
    decrease: "\u51CF\u5C11",
    root: "\u521D\u59CB"
  },
  statistic: {
    total: "\u603B\u8BA1"
  },
  conversionTag: {
    label: "\u8F6C\u5316\u7387"
  },
  legend: {},
  tooltip: {},
  slider: {},
  scrollbar: {},
  waterfall: {
    total: "\u603B\u8BA1"
  }
};
var lib = {};
var sensorPool = {};
var id = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports["default"] = void 0;
  var id2 = 1;
  var _default = function _default2() {
    return "".concat(id2++);
  };
  exports["default"] = _default;
})(id);
var sensors = {};
var object = {};
var debounce = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports["default"] = void 0;
  var _default = function _default2(fn2) {
    var delay = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 60;
    var timer2 = null;
    return function() {
      var _this = this;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      clearTimeout(timer2);
      timer2 = setTimeout(function() {
        fn2.apply(_this, args);
      }, delay);
    };
  };
  exports["default"] = _default;
})(debounce);
var constant$2 = {};
Object.defineProperty(constant$2, "__esModule", {
  value: true
});
constant$2.SensorTabIndex = constant$2.SensorClassName = constant$2.SizeSensorId = void 0;
var SizeSensorId = "size-sensor-id";
constant$2.SizeSensorId = SizeSensorId;
var SensorClassName = "size-sensor-object";
constant$2.SensorClassName = SensorClassName;
var SensorTabIndex = "-1";
constant$2.SensorTabIndex = SensorTabIndex;
Object.defineProperty(object, "__esModule", {
  value: true
});
object.createSensor = void 0;
var _debounce$1 = _interopRequireDefault$2(debounce);
var _constant$1 = constant$2;
function _interopRequireDefault$2(obj) {
  return obj && obj.__esModule ? obj : { "default": obj };
}
var createSensor$2 = function createSensor2(element) {
  var sensor = void 0;
  var listeners = [];
  var newSensor = function newSensor2() {
    if (getComputedStyle(element).position === "static") {
      element.style.position = "relative";
    }
    var obj = document.createElement("object");
    obj.onload = function() {
      obj.contentDocument.defaultView.addEventListener("resize", resizeListener);
      resizeListener();
    };
    obj.style.display = "block";
    obj.style.position = "absolute";
    obj.style.top = "0";
    obj.style.left = "0";
    obj.style.height = "100%";
    obj.style.width = "100%";
    obj.style.overflow = "hidden";
    obj.style.pointerEvents = "none";
    obj.style.zIndex = "-1";
    obj.style.opacity = "0";
    obj.setAttribute("class", _constant$1.SensorClassName);
    obj.setAttribute("tabindex", _constant$1.SensorTabIndex);
    obj.type = "text/html";
    element.appendChild(obj);
    obj.data = "about:blank";
    return obj;
  };
  var resizeListener = (0, _debounce$1["default"])(function() {
    listeners.forEach(function(listener) {
      listener(element);
    });
  });
  var bind3 = function bind4(cb2) {
    if (!sensor) {
      sensor = newSensor();
    }
    if (listeners.indexOf(cb2) === -1) {
      listeners.push(cb2);
    }
  };
  var destroy3 = function destroy4() {
    if (sensor && sensor.parentNode) {
      if (sensor.contentDocument) {
        sensor.contentDocument.defaultView.removeEventListener("resize", resizeListener);
      }
      sensor.parentNode.removeChild(sensor);
      sensor = void 0;
      listeners = [];
    }
  };
  var unbind = function unbind2(cb2) {
    var idx = listeners.indexOf(cb2);
    if (idx !== -1) {
      listeners.splice(idx, 1);
    }
    if (listeners.length === 0 && sensor) {
      destroy3();
    }
  };
  return {
    element,
    bind: bind3,
    destroy: destroy3,
    unbind
  };
};
object.createSensor = createSensor$2;
var resizeObserver = {};
Object.defineProperty(resizeObserver, "__esModule", {
  value: true
});
resizeObserver.createSensor = void 0;
var _debounce = _interopRequireDefault$1(debounce);
function _interopRequireDefault$1(obj) {
  return obj && obj.__esModule ? obj : { "default": obj };
}
var createSensor$1 = function createSensor3(element) {
  var sensor = void 0;
  var listeners = [];
  var resizeListener = (0, _debounce["default"])(function() {
    listeners.forEach(function(listener) {
      listener(element);
    });
  });
  var newSensor = function newSensor2() {
    var s2 = new ResizeObserver(resizeListener);
    s2.observe(element);
    resizeListener();
    return s2;
  };
  var bind3 = function bind4(cb2) {
    if (!sensor) {
      sensor = newSensor();
    }
    if (listeners.indexOf(cb2) === -1) {
      listeners.push(cb2);
    }
  };
  var destroy3 = function destroy4() {
    sensor.disconnect();
    listeners = [];
    sensor = void 0;
  };
  var unbind = function unbind2(cb2) {
    var idx = listeners.indexOf(cb2);
    if (idx !== -1) {
      listeners.splice(idx, 1);
    }
    if (listeners.length === 0 && sensor) {
      destroy3();
    }
  };
  return {
    element,
    bind: bind3,
    destroy: destroy3,
    unbind
  };
};
resizeObserver.createSensor = createSensor$1;
Object.defineProperty(sensors, "__esModule", {
  value: true
});
sensors.createSensor = void 0;
var _object = object;
var _resizeObserver = resizeObserver;
var createSensor = typeof ResizeObserver !== "undefined" ? _resizeObserver.createSensor : _object.createSensor;
sensors.createSensor = createSensor;
Object.defineProperty(sensorPool, "__esModule", {
  value: true
});
sensorPool.removeSensor = sensorPool.getSensor = void 0;
var _id = _interopRequireDefault(id);
var _sensors = sensors;
var _constant = constant$2;
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { "default": obj };
}
var Sensors = {};
var getSensor = function getSensor2(element) {
  var sensorId = element.getAttribute(_constant.SizeSensorId);
  if (sensorId && Sensors[sensorId]) {
    return Sensors[sensorId];
  }
  var newId = (0, _id["default"])();
  element.setAttribute(_constant.SizeSensorId, newId);
  var sensor = (0, _sensors.createSensor)(element);
  Sensors[newId] = sensor;
  return sensor;
};
sensorPool.getSensor = getSensor;
var removeSensor = function removeSensor2(sensor) {
  var sensorId = sensor.element.getAttribute(_constant.SizeSensorId);
  sensor.element.removeAttribute(_constant.SizeSensorId);
  sensor.destroy();
  if (sensorId && Sensors[sensorId]) {
    delete Sensors[sensorId];
  }
};
sensorPool.removeSensor = removeSensor;
Object.defineProperty(lib, "__esModule", {
  value: true
});
lib.ver = lib.clear = bind_1 = lib.bind = void 0;
var _sensorPool = sensorPool;
var bind = function bind2(element, cb2) {
  var sensor = (0, _sensorPool.getSensor)(element);
  sensor.bind(cb2);
  return function() {
    sensor.unbind(cb2);
  };
};
var bind_1 = lib.bind = bind;
var clear = function clear2(element) {
  var sensor = (0, _sensorPool.getSensor)(element);
  (0, _sensorPool.removeSensor)(sensor);
};
lib.clear = clear;
var ver = "1.0.1";
lib.ver = ver;
var SOURCE_ATTRIBUTE_NAME = "data-chart-source-type";
var PLOT_CONTAINER_OPTIONS = [
  "padding",
  "appendPadding",
  "renderer",
  "pixelRatio",
  "syncViewPadding",
  "supportCSSTransform",
  "limitInPlot"
];
var Plot = function(_super) {
  __extends$3(Plot2, _super);
  function Plot2(container, options) {
    var _this = _super.call(this) || this;
    _this.container = typeof container === "string" ? document.getElementById(container) : container;
    _this.options = deepAssign({}, _this.getDefaultOptions(), options);
    _this.createG2();
    _this.bindEvents();
    return _this;
  }
  Plot2.getDefaultOptions = function() {
    return {
      renderer: "canvas",
      xAxis: {
        nice: true,
        label: {
          autoRotate: false,
          autoHide: { type: "equidistance", cfg: { minGap: 6 } }
        }
      },
      yAxis: {
        nice: true,
        label: {
          autoHide: true,
          autoRotate: false
        }
      },
      animation: true
    };
  };
  Plot2.prototype.createG2 = function() {
    var _a2 = this.options, width = _a2.width, height = _a2.height, defaultInteractions = _a2.defaultInteractions;
    this.chart = new Chart(__assign$4(__assign$4(__assign$4(__assign$4({ container: this.container, autoFit: false }, this.getChartSize(width, height)), { localRefresh: false }), pick(this.options, PLOT_CONTAINER_OPTIONS)), { defaultInteractions }));
    this.container.setAttribute(SOURCE_ATTRIBUTE_NAME, "G2Plot");
  };
  Plot2.prototype.getChartSize = function(width, height) {
    var chartSize = getContainerSize(this.container);
    return { width: width || chartSize.width || 400, height: height || chartSize.height || 400 };
  };
  Plot2.prototype.bindEvents = function() {
    var _this = this;
    if (this.chart) {
      this.chart.on("*", function(e3) {
        if (e3 === null || e3 === void 0 ? void 0 : e3.type) {
          _this.emit(e3.type, e3);
        }
      });
    }
  };
  Plot2.prototype.getDefaultOptions = function() {
    return Plot2.getDefaultOptions();
  };
  Plot2.prototype.render = function() {
    this.chart.clear();
    this.chart.options = {
      data: [],
      animate: true
    };
    this.chart.views = [];
    this.execAdaptor();
    this.chart.render();
    this.bindSizeSensor();
  };
  Plot2.prototype.update = function(options) {
    this.updateOption(options);
    this.render();
  };
  Plot2.prototype.updateOption = function(options) {
    this.options = deepAssign({}, this.options, options);
  };
  Plot2.prototype.setState = function(type4, condition, status) {
    if (status === void 0) {
      status = true;
    }
    var elements = getAllElementsRecursively(this.chart);
    each$1(elements, function(ele) {
      if (condition(ele.getData())) {
        ele.setState(type4, status);
      }
    });
  };
  Plot2.prototype.getStates = function() {
    var elements = getAllElementsRecursively(this.chart);
    var stateObjects = [];
    each$1(elements, function(element) {
      var data2 = element.getData();
      var states = element.getStates();
      each$1(states, function(state2) {
        stateObjects.push({ data: data2, state: state2, geometry: element.geometry, element });
      });
    });
    return stateObjects;
  };
  Plot2.prototype.changeData = function(data2) {
    this.update({ data: data2 });
  };
  Plot2.prototype.changeSize = function(width, height) {
    this.chart.changeSize(width, height);
  };
  Plot2.prototype.addAnnotations = function(annotations, view) {
    view = view ? view : this.chart;
    var incoming = __spreadArrays(annotations);
    var controller = view.getController("annotation");
    var current = controller.getComponents().map(function(co) {
      return co.extra;
    });
    controller.clear(true);
    var _loop_1 = function(i3) {
      var annotation2 = current[i3];
      var findIndex2 = incoming.findIndex(function(item) {
        return item.id && item.id === annotation2.id;
      });
      if (findIndex2 !== -1) {
        annotation2 = deepAssign({}, annotation2, incoming[findIndex2]);
        incoming.splice(findIndex2, 1);
      }
      controller.annotation(annotation2);
    };
    for (var i2 = 0; i2 < current.length; i2++) {
      _loop_1(i2);
    }
    incoming.forEach(function(annotation2) {
      return controller.annotation(annotation2);
    });
    view.render(true);
  };
  Plot2.prototype.removeAnnotations = function(annotations) {
    var controller = this.chart.getController("annotation");
    var current = controller.getComponents().map(function(co) {
      return co.extra;
    });
    controller.clear(true);
    var _loop_2 = function(i3) {
      var annotation2 = current[i3];
      if (!annotations.find(function(item) {
        return item.id && item.id === annotation2.id;
      })) {
        controller.annotation(annotation2);
      }
    };
    for (var i2 = 0; i2 < current.length; i2++) {
      _loop_2(i2);
    }
    this.chart.render(true);
  };
  Plot2.prototype.destroy = function() {
    this.unbindSizeSensor();
    this.chart.destroy();
    this.off();
    this.container.removeAttribute(SOURCE_ATTRIBUTE_NAME);
  };
  Plot2.prototype.execAdaptor = function() {
    var adaptor2 = this.getSchemaAdaptor();
    var _a2 = this.options, padding2 = _a2.padding, appendPadding = _a2.appendPadding;
    this.chart.padding = padding2;
    this.chart.appendPadding = appendPadding;
    adaptor2({
      chart: this.chart,
      options: this.options
    });
  };
  Plot2.prototype.triggerResize = function() {
    this.chart.forceFit();
  };
  Plot2.prototype.bindSizeSensor = function() {
    var _this = this;
    if (this.unbind) {
      return;
    }
    var _a2 = this.options.autoFit, autoFit = _a2 === void 0 ? true : _a2;
    if (autoFit) {
      this.unbind = bind_1(this.container, function() {
        var _a3 = getContainerSize(_this.container), width = _a3.width, height = _a3.height;
        if (width !== _this.chart.width || height !== _this.chart.height) {
          _this.triggerResize();
        }
      });
    }
  };
  Plot2.prototype.unbindSizeSensor = function() {
    if (this.unbind) {
      this.unbind();
      this.unbind = void 0;
    }
  };
  return Plot2;
}(EventEmitter);
var AXIS_META_CONFIG_KEYS = [
  "type",
  "alias",
  "tickCount",
  "tickInterval",
  "min",
  "max",
  "nice",
  "minLimit",
  "maxLimit",
  "range",
  "tickMethod",
  "base",
  "exponent",
  "mask",
  "sync"
];
function getPixelRatio() {
  return typeof window === "object" ? window === null || window === void 0 ? void 0 : window.devicePixelRatio : 2;
}
function initCanvas(width, height) {
  if (height === void 0) {
    height = width;
  }
  var canvas = document.createElement("canvas");
  var pixelRatio = getPixelRatio();
  canvas.width = width * pixelRatio;
  canvas.height = height * pixelRatio;
  canvas.style.width = width + "px";
  canvas.style.height = height + "px";
  var ctx2 = canvas.getContext("2d");
  ctx2.scale(pixelRatio, pixelRatio);
  return canvas;
}
function drawBackground(context2, cfg, width, height) {
  if (height === void 0) {
    height = width;
  }
  var backgroundColor = cfg.backgroundColor, opacity = cfg.opacity;
  context2.globalAlpha = opacity;
  context2.fillStyle = backgroundColor;
  context2.beginPath();
  context2.fillRect(0, 0, width, height);
  context2.closePath();
}
function getUnitPatternSize(size2, padding2, isStagger) {
  var unitSize = size2 + padding2;
  return isStagger ? unitSize * 2 : unitSize;
}
function getSymbolsPosition(unitSize, isStagger) {
  var symbolsPos = isStagger ? [
    [unitSize * (1 / 4), unitSize * (1 / 4)],
    [unitSize * (3 / 4), unitSize * (3 / 4)]
  ] : [[unitSize * (1 / 2), unitSize * (1 / 2)]];
  return symbolsPos;
}
function transformMatrix(dpr, rotation) {
  var radian = rotation * Math.PI / 180;
  var matrix = {
    a: Math.cos(radian) * (1 / dpr),
    b: Math.sin(radian) * (1 / dpr),
    c: -Math.sin(radian) * (1 / dpr),
    d: Math.cos(radian) * (1 / dpr),
    e: 0,
    f: 0
  };
  return matrix;
}
var defaultDotPatternCfg = {
  size: 6,
  padding: 2,
  backgroundColor: "transparent",
  opacity: 1,
  rotation: 0,
  fill: "#fff",
  fillOpacity: 0.5,
  stroke: "transparent",
  lineWidth: 0,
  isStagger: true
};
function drawDot(context2, cfg, x2, y2) {
  var size2 = cfg.size, fill = cfg.fill, lineWidth = cfg.lineWidth, stroke = cfg.stroke, fillOpacity = cfg.fillOpacity;
  context2.beginPath();
  context2.globalAlpha = fillOpacity;
  context2.fillStyle = fill;
  context2.strokeStyle = stroke;
  context2.lineWidth = lineWidth;
  context2.arc(x2, y2, size2 / 2, 0, 2 * Math.PI, false);
  context2.fill();
  if (lineWidth) {
    context2.stroke();
  }
  context2.closePath();
}
function createDotPattern(cfg) {
  var dotCfg = deepAssign({}, defaultDotPatternCfg, cfg);
  var size2 = dotCfg.size, padding2 = dotCfg.padding, isStagger = dotCfg.isStagger, rotation = dotCfg.rotation;
  var unitSize = getUnitPatternSize(size2, padding2, isStagger);
  var dots = getSymbolsPosition(unitSize, isStagger);
  var canvas = initCanvas(unitSize, unitSize);
  var ctx2 = canvas.getContext("2d");
  drawBackground(ctx2, dotCfg, unitSize);
  for (var _i = 0, dots_1 = dots; _i < dots_1.length; _i++) {
    var _a2 = dots_1[_i], x2 = _a2[0], y2 = _a2[1];
    drawDot(ctx2, dotCfg, x2, y2);
  }
  var pattern4 = ctx2.createPattern(canvas, "repeat");
  if (pattern4) {
    var dpr = getPixelRatio();
    var matrix = transformMatrix(dpr, rotation);
    pattern4.setTransform(matrix);
  }
  return pattern4;
}
var defaultLinePatternCfg = {
  rotation: 45,
  spacing: 5,
  opacity: 1,
  backgroundColor: "transparent",
  strokeOpacity: 0.5,
  stroke: "#fff",
  lineWidth: 2
};
function drawLine(context2, cfg, d2) {
  var stroke = cfg.stroke, lineWidth = cfg.lineWidth, strokeOpacity = cfg.strokeOpacity;
  var path2 = new Path2D(d2);
  context2.globalAlpha = strokeOpacity;
  context2.lineCap = "square";
  context2.strokeStyle = lineWidth ? stroke : "transparent";
  context2.lineWidth = lineWidth;
  context2.stroke(path2);
}
function createLinePattern(cfg) {
  var lineCfg = deepAssign({}, defaultLinePatternCfg, cfg);
  var spacing = lineCfg.spacing, rotation = lineCfg.rotation, lineWidth = lineCfg.lineWidth;
  var width = spacing + lineWidth || 1;
  var height = spacing + lineWidth || 1;
  var d2 = "\n            M 0 0 L " + width + " 0\n            M 0 " + height + " L " + width + " " + height + "\n            ";
  var canvas = initCanvas(width, height);
  var ctx2 = canvas.getContext("2d");
  drawBackground(ctx2, lineCfg, width, height);
  drawLine(ctx2, lineCfg, d2);
  var pattern4 = ctx2.createPattern(canvas, "repeat");
  if (pattern4) {
    var dpr = getPixelRatio();
    var matrix = transformMatrix(dpr, rotation);
    pattern4.setTransform(matrix);
  }
  return pattern4;
}
var defaultSquarePatternCfg = {
  size: 6,
  padding: 1,
  isStagger: true,
  backgroundColor: "transparent",
  opacity: 1,
  rotation: 0,
  fill: "#fff",
  fillOpacity: 0.5,
  stroke: "transparent",
  lineWidth: 0
};
function drawSquare(context2, cfg, x2, y2) {
  var stroke = cfg.stroke, size2 = cfg.size, fill = cfg.fill, lineWidth = cfg.lineWidth, fillOpacity = cfg.fillOpacity;
  context2.globalAlpha = fillOpacity;
  context2.strokeStyle = stroke;
  context2.lineWidth = lineWidth;
  context2.fillStyle = fill;
  context2.strokeRect(x2 - size2 / 2, y2 - size2 / 2, size2, size2);
  context2.fillRect(x2 - size2 / 2, y2 - size2 / 2, size2, size2);
}
function createSquarePattern(cfg) {
  var squareCfg = deepAssign({}, defaultSquarePatternCfg, cfg);
  var size2 = squareCfg.size, padding2 = squareCfg.padding, isStagger = squareCfg.isStagger, rotation = squareCfg.rotation;
  var unitSize = getUnitPatternSize(size2, padding2, isStagger);
  var squares = getSymbolsPosition(unitSize, isStagger);
  var canvas = initCanvas(unitSize, unitSize);
  var ctx2 = canvas.getContext("2d");
  drawBackground(ctx2, squareCfg, unitSize);
  for (var _i = 0, squares_1 = squares; _i < squares_1.length; _i++) {
    var _a2 = squares_1[_i], x2 = _a2[0], y2 = _a2[1];
    drawSquare(ctx2, squareCfg, x2, y2);
  }
  var pattern4 = ctx2.createPattern(canvas, "repeat");
  if (pattern4) {
    var dpr = getPixelRatio();
    var matrix = transformMatrix(dpr, rotation);
    pattern4.setTransform(matrix);
  }
  return pattern4;
}
function getCanvasPattern(options) {
  var type4 = options.type, cfg = options.cfg;
  var pattern4;
  switch (type4) {
    case "dot":
      pattern4 = createDotPattern(cfg);
      break;
    case "line":
      pattern4 = createLinePattern(cfg);
      break;
    case "square":
      pattern4 = createSquarePattern(cfg);
      break;
  }
  return pattern4;
}
function pattern(key2) {
  var _this = this;
  return function(params) {
    var _a2;
    var options = params.options, chart = params.chart;
    var patternOption = options.pattern;
    if (!patternOption) {
      return params;
    }
    var style2 = function(datum) {
      var _a3, _b, _c;
      var args = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
      }
      var defaultColor = chart.getTheme().defaultColor;
      var color2 = defaultColor;
      var colorAttribute = (_b = (_a3 = chart.geometries) === null || _a3 === void 0 ? void 0 : _a3[0]) === null || _b === void 0 ? void 0 : _b.getAttribute("color");
      if (colorAttribute) {
        var colorField = colorAttribute.getFields()[0];
        var seriesValue = get(datum, colorField);
        color2 = Util.getMappingValue(colorAttribute, seriesValue, ((_c = colorAttribute.values) === null || _c === void 0 ? void 0 : _c[0]) || defaultColor);
      }
      var pattern4 = patternOption;
      if (typeof patternOption === "function") {
        pattern4 = patternOption.call(_this, datum, color2);
      }
      if (pattern4 instanceof CanvasPattern === false) {
        pattern4 = getCanvasPattern(deepAssign({}, { cfg: { backgroundColor: color2 } }, pattern4));
      }
      var styleOption = options[key2];
      return __assign$4(__assign$4({}, typeof styleOption === "function" ? styleOption.call.apply(styleOption, __spreadArrays([_this, datum], args)) : styleOption || {}), { fill: pattern4 || color2 });
    };
    return deepAssign({}, params, { options: (_a2 = {}, _a2[key2] = style2, _a2) });
  };
}
function legend$g(params) {
  var chart = params.chart, options = params.options;
  var legend2 = options.legend, colorField = options.colorField, seriesField = options.seriesField;
  if (legend2 === false) {
    chart.legend(false);
  } else if (colorField || seriesField) {
    chart.legend(colorField || seriesField, legend2);
  }
  return params;
}
function tooltip$9(params) {
  var chart = params.chart, options = params.options;
  var tooltip2 = options.tooltip;
  if (tooltip2 !== void 0) {
    chart.tooltip(tooltip2);
  }
  return params;
}
function interaction$7(params) {
  var chart = params.chart, options = params.options;
  var interactions = options.interactions;
  each$1(interactions, function(i2) {
    if (i2.enable === false) {
      chart.removeInteraction(i2.type);
    } else {
      chart.interaction(i2.type, i2.cfg || {});
    }
  });
  return params;
}
function animation$5(params) {
  var chart = params.chart, options = params.options;
  var animation2 = options.animation;
  if (typeof animation2 === "boolean") {
    chart.animate(animation2);
  } else {
    chart.animate(true);
  }
  each$1(chart.geometries, function(g2) {
    g2.animate(animation2);
  });
  return params;
}
function theme$2(params) {
  var chart = params.chart, options = params.options;
  var theme2 = options.theme;
  if (theme2) {
    chart.theme(theme2);
  }
  return params;
}
function state(params) {
  var chart = params.chart, options = params.options;
  var state2 = options.state;
  if (state2) {
    each$1(chart.geometries, function(geometry2) {
      geometry2.state(state2);
    });
  }
  return params;
}
function slider$2(params) {
  var chart = params.chart, options = params.options;
  var slider2 = options.slider;
  chart.option("slider", slider2);
  return params;
}
function scrollbar(params) {
  var chart = params.chart, options = params.options;
  var scrollbar2 = options.scrollbar;
  chart.option("scrollbar", scrollbar2);
  return params;
}
function scale$2(axes, meta2) {
  return function(params) {
    var chart = params.chart, options = params.options;
    var scales = {};
    each$1(axes, function(axis2, field2) {
      scales[field2] = pick(axis2, AXIS_META_CONFIG_KEYS);
    });
    scales = deepAssign({}, meta2, options.meta, scales);
    chart.scale(scales);
    return params;
  };
}
function annotation$2(annotationOptions) {
  return function(params) {
    var chart = params.chart, options = params.options;
    var annotationController = chart.getController("annotation");
    each$1(__spreadArrays(options.annotations || [], annotationOptions || []), function(annotationOption) {
      annotationController.annotation(annotationOption);
    });
    return params;
  };
}
function limitInPlot$2(params) {
  var chart = params.chart, options = params.options;
  var yAxis = options.yAxis, limitInPlot2 = options.limitInPlot;
  var value2 = limitInPlot2;
  if (isObject(yAxis) && isNil(limitInPlot2)) {
    if (Object.values(pick(yAxis, ["min", "max", "minLimit", "maxLimit"])).some(function(value3) {
      return !isNil(value3);
    })) {
      value2 = true;
    } else {
      value2 = false;
    }
  }
  chart.limitInPlot = value2;
  return params;
}
function transformations(coordinateType) {
  if (coordinateType === void 0) {
    coordinateType = "rect";
  }
  return function(params) {
    var chart = params.chart, options = params.options;
    var coordinate2 = options.coordinate;
    var actions = Array.from(coordinate2 || []).map(function(cfg) {
      if (cfg.type === "reflectX")
        return ["reflect", "x"];
      if (cfg.type === "reflectY")
        return ["reflect", "y"];
      if (cfg.type === "transpose")
        return ["transpose"];
      return null;
    }).filter(function(d2) {
      return !!d2;
    });
    if (actions.length !== 0) {
      chart.coordinate({ type: coordinateType, actions });
    }
    return params;
  };
}
function getTooltipMapping(tooltip2, defaultFields) {
  if (tooltip2 === false) {
    return {
      fields: false
    };
  }
  var fields = get(tooltip2, "fields");
  var formatter = get(tooltip2, "formatter");
  if (formatter && !fields) {
    fields = defaultFields;
  }
  return {
    fields,
    formatter
  };
}
function getMappingField(o2, field2) {
  var type4 = o2.type, xField = o2.xField, yField = o2.yField, colorField = o2.colorField, shapeField = o2.shapeField, sizeField = o2.sizeField, styleField = o2.styleField, _a2 = o2.rawFields, rawFields = _a2 === void 0 ? [] : _a2;
  var fields = [];
  if (field2 === "color") {
    fields = __spreadArrays([colorField || xField], rawFields);
  } else if (field2 === "shape") {
    fields = __spreadArrays([shapeField || xField], rawFields);
  } else if (field2 === "size") {
    fields = __spreadArrays([sizeField || xField], rawFields);
  } else {
    fields = __spreadArrays([xField, yField, colorField, shapeField, sizeField, styleField], rawFields);
    var idx = ["x", "y", "color", "shape", "size", "style"].indexOf(field2);
    var f2 = fields[idx];
    fields.splice(idx, 1);
    fields.unshift(f2);
  }
  var mappingFields = uniq$2(fields.filter(function(f3) {
    return !!f3;
  }));
  var tileMappingField = type4 === "line" && [xField, yField].includes(mappingFields.join("*")) ? "" : mappingFields.join("*");
  return {
    mappingFields,
    tileMappingField
  };
}
function getMappingFunction(mappingFields, func) {
  if (!func)
    return void 0;
  return function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var params = {};
    mappingFields.forEach(function(f2, idx) {
      params[f2] = args[idx];
    });
    delete params["undefined"];
    return func(params);
  };
}
function geometry$x(params) {
  var chart = params.chart, options = params.options;
  var type4 = options.type, args = options.args, mapping = options.mapping, xField = options.xField, yField = options.yField, colorField = options.colorField, shapeField = options.shapeField, sizeField = options.sizeField, tooltipFields = options.tooltipFields, label2 = options.label, state2 = options.state, customInfo = options.customInfo;
  if (!mapping) {
    return params;
  }
  var color2 = mapping.color, shape = mapping.shape, size2 = mapping.size, style2 = mapping.style, tooltip2 = mapping.tooltip;
  var geometry2 = chart[type4](args).position(xField + "*" + yField);
  if (isString(color2)) {
    colorField ? geometry2.color(colorField, color2) : geometry2.color(color2);
  } else if (isFunction(color2)) {
    var _a2 = getMappingField(options, "color"), mappingFields = _a2.mappingFields, tileMappingField = _a2.tileMappingField;
    geometry2.color(tileMappingField, getMappingFunction(mappingFields, color2));
  } else {
    colorField && geometry2.color(colorField, color2);
  }
  if (isString(shape)) {
    shapeField ? geometry2.shape(shapeField, [shape]) : geometry2.shape(shape);
  } else if (isFunction(shape)) {
    var _b = getMappingField(options, "shape"), mappingFields = _b.mappingFields, tileMappingField = _b.tileMappingField;
    geometry2.shape(tileMappingField, getMappingFunction(mappingFields, shape));
  } else {
    shapeField && geometry2.shape(shapeField, shape);
  }
  if (isNumber$1(size2)) {
    sizeField ? geometry2.size(sizeField, size2) : geometry2.size(size2);
  } else if (isFunction(size2)) {
    var _c = getMappingField(options, "size"), mappingFields = _c.mappingFields, tileMappingField = _c.tileMappingField;
    geometry2.size(tileMappingField, getMappingFunction(mappingFields, size2));
  } else {
    sizeField && geometry2.size(sizeField, size2);
  }
  if (isFunction(style2)) {
    var _d = getMappingField(options, "style"), mappingFields = _d.mappingFields, tileMappingField = _d.tileMappingField;
    geometry2.style(tileMappingField, getMappingFunction(mappingFields, style2));
  } else if (isObject(style2)) {
    geometry2.style(style2);
  }
  if (tooltipFields === false) {
    geometry2.tooltip(false);
  } else if (!isEmpty(tooltipFields)) {
    geometry2.tooltip(tooltipFields.join("*"), getMappingFunction(tooltipFields, tooltip2));
  }
  if (label2 === false) {
    geometry2.label(false);
  } else if (label2) {
    var callback = label2.callback, fields = label2.fields, cfg = __rest$3(label2, ["callback", "fields"]);
    geometry2.label({
      fields: fields || [yField],
      callback,
      cfg: transformLabel(cfg)
    });
  }
  if (state2) {
    geometry2.state(state2);
  }
  if (customInfo) {
    geometry2.customInfo(customInfo);
  }
  [xField, yField].filter(function(f2) {
    return f2 !== colorField;
  }).forEach(function(f2) {
    chart.legend(f2, false);
  });
  return __assign$4(__assign$4({}, params), {
    ext: { geometry: geometry2 }
  });
}
function area(params) {
  var options = params.options;
  var area2 = options.area, xField = options.xField, yField = options.yField, seriesField = options.seriesField, smooth = options.smooth, tooltip2 = options.tooltip, useDeferredLabel = options.useDeferredLabel;
  var _a2 = getTooltipMapping(tooltip2, [xField, yField, seriesField]), fields = _a2.fields, formatter = _a2.formatter;
  return area2 ? geometry$x(deepAssign({}, params, {
    options: {
      type: "area",
      colorField: seriesField,
      tooltipFields: fields,
      mapping: __assign$4({ shape: smooth ? "smooth" : "area", tooltip: formatter }, area2),
      args: { useDeferredLabel }
    }
  })) : params;
}
function line(params) {
  var options = params.options;
  var line2 = options.line, stepType = options.stepType, xField = options.xField, yField = options.yField, seriesField = options.seriesField, smooth = options.smooth, connectNulls = options.connectNulls, tooltip2 = options.tooltip, useDeferredLabel = options.useDeferredLabel;
  var _a2 = getTooltipMapping(tooltip2, [xField, yField, seriesField]), fields = _a2.fields, formatter = _a2.formatter;
  return line2 ? geometry$x(deepAssign({}, params, {
    options: {
      type: "line",
      colorField: seriesField,
      tooltipFields: fields,
      mapping: deepMix({
        shape: stepType || (smooth ? "smooth" : "line"),
        tooltip: formatter
      }, line2),
      args: { connectNulls, useDeferredLabel }
    }
  })) : params;
}
function point(params) {
  var options = params.options;
  var point2 = options.point, xField = options.xField, yField = options.yField, seriesField = options.seriesField, sizeField = options.sizeField, shapeField = options.shapeField, tooltip2 = options.tooltip, useDeferredLabel = options.useDeferredLabel;
  var _a2 = getTooltipMapping(tooltip2, [xField, yField, seriesField, sizeField, shapeField]), fields = _a2.fields, formatter = _a2.formatter;
  return point2 ? geometry$x(deepAssign({}, params, {
    options: {
      type: "point",
      colorField: seriesField,
      shapeField,
      tooltipFields: fields,
      mapping: __assign$4({ tooltip: formatter }, point2),
      args: { useDeferredLabel }
    }
  })) : params;
}
function otherAdaptor(params) {
  var chart = params.chart, options = params.options, ext = params.ext;
  var seriesField = options.seriesField, isGroup = options.isGroup, isStack = options.isStack, marginRatio = options.marginRatio, widthRatio = options.widthRatio, groupField = options.groupField, theme2 = options.theme;
  var adjust2 = [];
  if (seriesField) {
    if (isGroup) {
      adjust2.push({
        type: "dodge",
        dodgeBy: groupField || seriesField,
        marginRatio
      });
    }
    if (isStack) {
      adjust2.push({
        type: "stack",
        marginRatio
      });
    }
  }
  if (adjust2.length && (ext === null || ext === void 0 ? void 0 : ext.geometry)) {
    var g2 = ext === null || ext === void 0 ? void 0 : ext.geometry;
    g2.adjust(adjust2);
  }
  if (!isNil(widthRatio)) {
    chart.theme(deepAssign({}, isObject(theme2) ? theme2 : getTheme(theme2), {
      columnWidthRatio: widthRatio
    }));
  }
  return params;
}
function interval(params) {
  var options = params.options;
  var xField = options.xField, yField = options.yField, interval2 = options.interval, seriesField = options.seriesField, tooltip2 = options.tooltip, minColumnWidth = options.minColumnWidth, maxColumnWidth = options.maxColumnWidth, columnBackground = options.columnBackground, dodgePadding = options.dodgePadding, intervalPadding = options.intervalPadding, useDeferredLabel = options.useDeferredLabel;
  var _a2 = getTooltipMapping(tooltip2, [xField, yField, seriesField]), fields = _a2.fields, formatter = _a2.formatter;
  var ext = (interval2 ? geometry$x(deepAssign({}, params, {
    options: {
      type: "interval",
      colorField: seriesField,
      tooltipFields: fields,
      mapping: __assign$4({ tooltip: formatter }, interval2),
      args: {
        dodgePadding,
        intervalPadding,
        minColumnWidth,
        maxColumnWidth,
        background: columnBackground,
        useDeferredLabel
      }
    }
  })) : params).ext;
  return otherAdaptor(__assign$4(__assign$4({}, params), { ext }));
}
function polygon(params) {
  var options = params.options;
  var polygon2 = options.polygon, xField = options.xField, yField = options.yField, seriesField = options.seriesField, tooltip2 = options.tooltip, useDeferredLabel = options.useDeferredLabel;
  var _a2 = getTooltipMapping(tooltip2, [xField, yField, seriesField]), fields = _a2.fields, formatter = _a2.formatter;
  return polygon2 ? geometry$x(deepAssign({}, params, {
    options: {
      type: "polygon",
      colorField: seriesField,
      tooltipFields: fields,
      mapping: __assign$4({ tooltip: formatter }, polygon2),
      args: { useDeferredLabel }
    }
  })) : params;
}
function edge(params) {
  var options = params.options;
  var edge2 = options.edge, xField = options.xField, yField = options.yField, seriesField = options.seriesField, tooltip2 = options.tooltip, useDeferredLabel = options.useDeferredLabel;
  var _a2 = getTooltipMapping(tooltip2, [xField, yField, seriesField]), fields = _a2.fields, formatter = _a2.formatter;
  return edge2 ? geometry$x(deepAssign({}, params, {
    options: {
      type: "edge",
      colorField: seriesField,
      tooltipFields: fields,
      mapping: __assign$4({ tooltip: formatter }, edge2),
      args: { useDeferredLabel }
    }
  })) : params;
}
function schema(params) {
  var options = params.options;
  var schema2 = options.schema, xField = options.xField, yField = options.yField, seriesField = options.seriesField, tooltip2 = options.tooltip, useDeferredLabel = options.useDeferredLabel;
  var _a2 = getTooltipMapping(tooltip2, [xField, yField, seriesField]), fields = _a2.fields, formatter = _a2.formatter;
  return schema2 ? geometry$x(deepAssign({}, params, {
    options: {
      type: "schema",
      colorField: seriesField,
      tooltipFields: fields,
      mapping: __assign$4({ tooltip: formatter }, schema2),
      args: { useDeferredLabel }
    }
  })) : params;
}
function violin(params) {
  var options = params.options;
  var violin2 = options.violin, xField = options.xField, yField = options.yField, seriesField = options.seriesField, sizeField = options.sizeField, tooltip2 = options.tooltip;
  var _a2 = getTooltipMapping(tooltip2, [xField, yField, seriesField, sizeField]), fields = _a2.fields, formatter = _a2.formatter;
  return violin2 ? geometry$x(deepAssign({}, params, {
    options: {
      type: "violin",
      colorField: seriesField,
      tooltipFields: fields,
      mapping: __assign$4({ tooltip: formatter }, violin2)
    }
  })) : params;
}
function geometry$w(params) {
  var chart = params.chart, options = params.options;
  var data2 = options.data, color2 = options.color, lineStyle = options.lineStyle, lineShape = options.lineShape, pointMapping = options.point, areaMapping = options.area, seriesField = options.seriesField;
  var pointState = pointMapping === null || pointMapping === void 0 ? void 0 : pointMapping.state;
  var areaState = areaMapping === null || areaMapping === void 0 ? void 0 : areaMapping.state;
  chart.data(data2);
  var primary = deepAssign({}, params, {
    options: {
      shapeField: seriesField,
      line: {
        color: color2,
        style: lineStyle,
        shape: lineShape
      },
      point: pointMapping && __assign$4({ color: color2, shape: "circle" }, pointMapping),
      area: areaMapping && __assign$4({ color: color2 }, areaMapping),
      label: void 0
    }
  });
  var second = deepAssign({}, primary, { options: { tooltip: false, state: pointState } });
  var areaParams = deepAssign({}, primary, { options: { tooltip: false, state: areaState } });
  line(primary);
  point(second);
  area(areaParams);
  return params;
}
function meta$l(params) {
  var _a2, _b;
  var options = params.options;
  var xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField, yField = options.yField, data2 = options.data;
  return flow(scale$2((_a2 = {}, _a2[xField] = xAxis, _a2[yField] = yAxis, _a2), (_b = {}, _b[xField] = {
    type: "cat"
  }, _b[yField] = adjustYMetaByZero(data2, yField), _b)))(params);
}
function coordinate$9(params) {
  var chart = params.chart, options = params.options;
  var reflect = options.reflect;
  if (reflect) {
    var p2 = reflect;
    if (!isArray$1(p2)) {
      p2 = [p2];
    }
    var actions = p2.map(function(d2) {
      return ["reflect", d2];
    });
    chart.coordinate({ type: "rect", actions });
  }
  return params;
}
function axis$k(params) {
  var chart = params.chart, options = params.options;
  var xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField, yField = options.yField;
  if (xAxis === false) {
    chart.axis(xField, false);
  } else {
    chart.axis(xField, xAxis);
  }
  if (yAxis === false) {
    chart.axis(yField, false);
  } else {
    chart.axis(yField, yAxis);
  }
  return params;
}
function legend$f(params) {
  var chart = params.chart, options = params.options;
  var legend2 = options.legend, seriesField = options.seriesField;
  if (legend2 && seriesField) {
    chart.legend(seriesField, legend2);
  } else if (legend2 === false) {
    chart.legend(false);
  }
  return params;
}
function label$f(params) {
  var chart = params.chart, options = params.options;
  var label2 = options.label, yField = options.yField;
  var lineGeometry = findGeometry(chart, "line");
  if (!label2) {
    lineGeometry.label(false);
  } else {
    var callback = label2.callback, cfg = __rest$3(label2, ["callback"]);
    lineGeometry.label({
      fields: [yField],
      callback,
      cfg: __assign$4({ layout: [
        { type: "limit-in-plot" },
        { type: "path-adjust-position" },
        { type: "point-adjust-position" },
        { type: "limit-in-plot", cfg: { action: "hide" } }
      ] }, transformLabel(cfg))
    });
  }
  return params;
}
function adjust$1(params) {
  var chart = params.chart, options = params.options;
  var isStack = options.isStack;
  if (isStack) {
    each$1(chart.geometries, function(g2) {
      g2.adjust("stack");
    });
  }
  return params;
}
function adaptor$y(params) {
  return flow(geometry$w, meta$l, adjust$1, theme$2, coordinate$9, axis$k, legend$f, tooltip$9, label$f, slider$2, scrollbar, interaction$7, animation$5, annotation$2(), limitInPlot$2)(params);
}
var DEFAULT_OPTIONS$z = deepAssign({}, Plot.getDefaultOptions(), {
  tooltip: {
    shared: true,
    showMarkers: true,
    showCrosshairs: true,
    crosshairs: {
      type: "x"
    }
  },
  legend: {
    position: "top-left",
    radio: {}
  },
  isStack: false
});
var MarkerActiveAction = function(_super) {
  __extends$3(MarkerActiveAction2, _super);
  function MarkerActiveAction2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  MarkerActiveAction2.prototype.active = function() {
    var view = this.getView();
    var evt = this.context.event;
    if (evt.data) {
      var items_1 = evt.data.items;
      var points2 = view.geometries.filter(function(geom) {
        return geom.type === "point";
      });
      each$1(points2, function(point2) {
        each$1(point2.elements, function(element) {
          var active = findIndex(items_1, function(item) {
            return item.data === element.data;
          }) !== -1;
          element.setState("active", active);
        });
      });
    }
  };
  MarkerActiveAction2.prototype.reset = function() {
    var view = this.getView();
    var points2 = view.geometries.filter(function(geom) {
      return geom.type === "point";
    });
    each$1(points2, function(point2) {
      each$1(point2.elements, function(element) {
        element.setState("active", false);
      });
    });
  };
  MarkerActiveAction2.prototype.getView = function() {
    return this.context.view;
  };
  return MarkerActiveAction2;
}(Action);
registerAction("marker-active", MarkerActiveAction);
registerInteraction("marker-active", {
  start: [
    {
      trigger: "tooltip:show",
      action: "marker-active:active"
    }
  ],
  end: [
    {
      trigger: "tooltip:hide",
      action: "marker-active:reset"
    }
  ]
});
var Line$1 = function(_super) {
  __extends$3(Line2, _super);
  function Line2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "line";
    return _this;
  }
  Line2.getDefaultOptions = function() {
    return DEFAULT_OPTIONS$z;
  };
  Line2.prototype.changeData = function(data2) {
    this.updateOption({ data: data2 });
    var _a2 = this, chart = _a2.chart, options = _a2.options;
    meta$l({ chart, options });
    this.chart.changeData(data2);
  };
  Line2.prototype.getDefaultOptions = function() {
    return Line2.getDefaultOptions();
  };
  Line2.prototype.getSchemaAdaptor = function() {
    return adaptor$y;
  };
  return Line2;
}(Plot);
function percent(data2, measure, groupField, as) {
  var sumMap = reduce(data2, function(map2, datum) {
    var groupValue = datum[groupField];
    var sum = map2.has(groupValue) ? map2.get(groupValue) : 0;
    var v2 = datum[measure];
    sum = isRealNumber(v2) ? sum + v2 : sum;
    map2.set(groupValue, sum);
    return map2;
  }, /* @__PURE__ */ new Map());
  return map$2(data2, function(datum) {
    var _a2;
    var v2 = datum[measure];
    var groupValue = datum[groupField];
    var percentage = isRealNumber(v2) && sumMap.get(groupValue) !== 0 ? v2 / sumMap.get(groupValue) : 0;
    return __assign$4(__assign$4({}, datum), (_a2 = {}, _a2[as] = percentage, _a2));
  });
}
function getDeepPercent(data2, measure, fields, percent2) {
  var sumMap = reduce(data2, function(map2, datum) {
    var groupValue = reduce(fields, function(value2, field2) {
      return "" + value2 + datum[field2];
    }, "");
    var sum = map2.has(groupValue) ? map2.get(groupValue) : 0;
    var v2 = datum[measure];
    sum = isRealNumber(v2) ? sum + v2 : sum;
    map2.set(groupValue, sum);
    return map2;
  }, /* @__PURE__ */ new Map());
  return map$2(data2, function(datum) {
    var _a2;
    var v2 = datum[measure];
    var groupValue = reduce(fields, function(value2, field2) {
      return "" + value2 + datum[field2];
    }, "");
    var percentage = isRealNumber(v2) && sumMap.get(groupValue) !== 0 ? v2 / sumMap.get(groupValue) : 0;
    return __assign$4(__assign$4({}, datum), (_a2 = {}, _a2[percent2] = percentage, _a2));
  });
}
function getDataWhetherPercentage(data2, yField, groupField, asField, isPercent) {
  return !isPercent ? data2 : percent(data2, yField, groupField, asField);
}
function geometry$v(params) {
  var chart = params.chart, options = params.options;
  var data2 = options.data, areaStyle = options.areaStyle, color2 = options.color, pointMapping = options.point, lineMapping = options.line, isPercent = options.isPercent, xField = options.xField, yField = options.yField, tooltip2 = options.tooltip, seriesField = options.seriesField, startOnZero = options.startOnZero;
  var pointState = pointMapping === null || pointMapping === void 0 ? void 0 : pointMapping.state;
  var chartData = getDataWhetherPercentage(data2, yField, xField, yField, isPercent);
  chart.data(chartData);
  var tooltipOptions = isPercent ? __assign$4({ formatter: function(datum) {
    return {
      name: datum[seriesField] || datum[xField],
      value: (Number(datum[yField]) * 100).toFixed(2) + "%"
    };
  } }, tooltip2) : tooltip2;
  var primary = deepAssign({}, params, {
    options: {
      area: { color: color2, style: areaStyle },
      point: pointMapping && __assign$4({ color: color2 }, pointMapping),
      tooltip: tooltipOptions,
      label: void 0,
      args: {
        startOnZero
      }
    }
  });
  var lineParams = {
    chart,
    options: deepAssign({ line: { size: 2 } }, omit$1(options, ["state"]), {
      line: lineMapping && __assign$4({ color: color2 }, lineMapping),
      sizeField: seriesField,
      state: lineMapping === null || lineMapping === void 0 ? void 0 : lineMapping.state,
      tooltip: false,
      label: void 0,
      args: {
        startOnZero
      }
    })
  };
  var pointParams = deepAssign({}, primary, { options: { tooltip: false, state: pointState } });
  area(primary);
  line(lineParams);
  point(pointParams);
  return params;
}
function label$e(params) {
  var chart = params.chart, options = params.options;
  var label2 = options.label, yField = options.yField;
  var areaGeometry = findGeometry(chart, "area");
  if (!label2) {
    areaGeometry.label(false);
  } else {
    var callback = label2.callback, cfg = __rest$3(label2, ["callback"]);
    areaGeometry.label({
      fields: [yField],
      callback,
      cfg: __assign$4({ layout: [
        { type: "limit-in-plot" },
        { type: "path-adjust-position" },
        { type: "point-adjust-position" },
        { type: "limit-in-plot", cfg: { action: "hide" } }
      ] }, transformLabel(cfg))
    });
  }
  return params;
}
function adjust(params) {
  var chart = params.chart, options = params.options;
  var isStack = options.isStack, isPercent = options.isPercent, seriesField = options.seriesField;
  if ((isPercent || isStack) && seriesField) {
    each$1(chart.geometries, function(g2) {
      g2.adjust("stack");
    });
  }
  return params;
}
function adaptor$x(params) {
  return flow(theme$2, pattern("areaStyle"), transformations("rect"), geometry$v, meta$l, adjust, axis$k, legend$f, tooltip$9, label$e, slider$2, annotation$2(), interaction$7, animation$5, limitInPlot$2)(params);
}
var DEFAULT_OPTIONS$y = deepAssign({}, Plot.getDefaultOptions(), {
  tooltip: {
    shared: true,
    showMarkers: true,
    showCrosshairs: true,
    crosshairs: {
      type: "x"
    }
  },
  isStack: true,
  line: {},
  legend: {
    position: "top-left",
    radio: {}
  }
});
var Area = function(_super) {
  __extends$3(Area2, _super);
  function Area2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "area";
    return _this;
  }
  Area2.getDefaultOptions = function() {
    return DEFAULT_OPTIONS$y;
  };
  Area2.prototype.getDefaultOptions = function() {
    return Area2.getDefaultOptions();
  };
  Area2.prototype.changeData = function(data2) {
    this.updateOption({ data: data2 });
    var _a2 = this.options, isPercent = _a2.isPercent, xField = _a2.xField, yField = _a2.yField;
    var _b = this, chart = _b.chart, options = _b.options;
    meta$l({ chart, options });
    this.chart.changeData(getDataWhetherPercentage(data2, yField, xField, yField, isPercent));
  };
  Area2.prototype.getSchemaAdaptor = function() {
    return adaptor$x;
  };
  return Area2;
}(Plot);
function conversionTagFormatter(prev, next) {
  if (!isNumber$1(prev) || !isNumber$1(next)) {
    return "-";
  }
  if (prev === next) {
    return "100%";
  }
  if (prev === 0) {
    return "\u221E";
  }
  if (next === 0) {
    return "-\u221E";
  }
  return (100 * next / prev).toFixed(2) + "%";
}
function getConversionTagOptionsWithDefaults(options, horizontal) {
  return deepAssign({
    size: horizontal ? 32 : 80,
    spacing: horizontal ? 8 : 12,
    offset: horizontal ? 32 : 0,
    arrow: options.arrow !== false && {
      headSize: 12,
      style: {
        fill: "rgba(0, 0, 0, 0.05)"
      }
    },
    text: options.text !== false && {
      style: {
        fontSize: 12,
        fill: "rgba(0, 0, 0, 0.85)",
        textAlign: "center",
        textBaseline: "middle"
      },
      formatter: conversionTagFormatter
    }
  }, options);
}
function parsePoints(coordinate2, element) {
  return map$2(element.getModel().points, function(point2) {
    return coordinate2.convertPoint(point2);
  });
}
function renderArrowTag(config, elemPrev, elemNext) {
  var view = config.view, geometry2 = config.geometry, group2 = config.group, options = config.options, horizontal = config.horizontal;
  var offset3 = options.offset, size2 = options.size, arrow = options.arrow;
  var coordinate2 = view.getCoordinate();
  var pointPrev = parsePoints(coordinate2, elemPrev)[3];
  var pointNext = parsePoints(coordinate2, elemNext)[0];
  var totalHeight = pointNext.y - pointPrev.y;
  var totalWidth = pointNext.x - pointPrev.x;
  if (typeof arrow === "boolean") {
    return;
  }
  var headSize = arrow.headSize;
  var spacing = options.spacing;
  var points2;
  if (horizontal) {
    if ((totalWidth - headSize) / 2 < spacing) {
      spacing = Math.max(1, (totalWidth - headSize) / 2);
      points2 = [
        [pointPrev.x + spacing, pointPrev.y - offset3],
        [pointPrev.x + spacing, pointPrev.y - offset3 - size2],
        [pointNext.x - spacing, pointNext.y - offset3 - size2 / 2]
      ];
    } else {
      points2 = [
        [pointPrev.x + spacing, pointPrev.y - offset3],
        [pointPrev.x + spacing, pointPrev.y - offset3 - size2],
        [pointNext.x - spacing - headSize, pointNext.y - offset3 - size2],
        [pointNext.x - spacing, pointNext.y - offset3 - size2 / 2],
        [pointNext.x - spacing - headSize, pointNext.y - offset3]
      ];
    }
  } else {
    if ((totalHeight - headSize) / 2 < spacing) {
      spacing = Math.max(1, (totalHeight - headSize) / 2);
      points2 = [
        [pointPrev.x + offset3, pointPrev.y + spacing],
        [pointPrev.x + offset3 + size2, pointPrev.y + spacing],
        [pointNext.x + offset3 + size2 / 2, pointNext.y - spacing]
      ];
    } else {
      points2 = [
        [pointPrev.x + offset3, pointPrev.y + spacing],
        [pointPrev.x + offset3 + size2, pointPrev.y + spacing],
        [pointNext.x + offset3 + size2, pointNext.y - spacing - headSize],
        [pointNext.x + offset3 + size2 / 2, pointNext.y - spacing],
        [pointNext.x + offset3, pointNext.y - spacing - headSize]
      ];
    }
  }
  group2.addShape("polygon", {
    id: view.id + "-conversion-tag-arrow-" + geometry2.getElementId(elemPrev.getModel().mappingData),
    name: "conversion-tag-arrow",
    origin: {
      element: elemPrev,
      nextElement: elemNext
    },
    attrs: __assign$4(__assign$4({}, arrow.style || {}), { points: points2 })
  });
}
function renderTextTag(config, elemPrev, elemNext) {
  var _a2, _b, _c;
  var view = config.view, geometry2 = config.geometry, group2 = config.group, options = config.options, field2 = config.field, horizontal = config.horizontal;
  var offset3 = options.offset, size2 = options.size;
  if (typeof options.text === "boolean") {
    return;
  }
  var coordinate2 = view.getCoordinate();
  var text2 = ((_a2 = options.text) === null || _a2 === void 0 ? void 0 : _a2.formatter) && ((_b = options.text) === null || _b === void 0 ? void 0 : _b.formatter(elemPrev.getData()[field2], elemNext.getData()[field2]));
  var pointPrev = parsePoints(coordinate2, elemPrev)[horizontal ? 3 : 0];
  var pointNext = parsePoints(coordinate2, elemNext)[horizontal ? 0 : 3];
  var textShape = group2.addShape("text", {
    id: view.id + "-conversion-tag-text-" + geometry2.getElementId(elemPrev.getModel().mappingData),
    name: "conversion-tag-text",
    origin: {
      element: elemPrev,
      nextElement: elemNext
    },
    attrs: __assign$4(__assign$4({}, ((_c = options.text) === null || _c === void 0 ? void 0 : _c.style) || {}), { text: text2, x: horizontal ? (pointPrev.x + pointNext.x) / 2 : pointPrev.x + offset3 + size2 / 2, y: horizontal ? pointPrev.y - offset3 - size2 / 2 : (pointPrev.y + pointNext.y) / 2 })
  });
  if (horizontal) {
    var totalWidth = pointNext.x - pointPrev.x;
    var textWidth = textShape.getBBox().width;
    if (textWidth > totalWidth) {
      var cWidth = textWidth / text2.length;
      var cEnd = Math.max(1, Math.ceil(totalWidth / cWidth) - 1);
      var textAdjusted = text2.slice(0, cEnd) + "...";
      textShape.attr("text", textAdjusted);
    }
  }
}
function renderTag(options, elemPrev, elemNext) {
  renderArrowTag(options, elemPrev, elemNext);
  renderTextTag(options, elemPrev, elemNext);
}
function conversionTag$3(field2, horizontal, disabled) {
  if (horizontal === void 0) {
    horizontal = true;
  }
  if (disabled === void 0) {
    disabled = false;
  }
  return function(params) {
    var options = params.options, chart = params.chart;
    var conversionTag2 = options.conversionTag, theme2 = options.theme;
    if (conversionTag2 && !disabled) {
      chart.theme(deepAssign({}, isObject(theme2) ? theme2 : getTheme(theme2), {
        columnWidthRatio: 1 / 3
      }));
      chart.annotation().shape({
        render: function(container, view) {
          var group2 = container.addGroup({
            id: chart.id + "-conversion-tag-group",
            name: "conversion-tag-group"
          });
          var interval2 = find$1(chart.geometries, function(geom) {
            return geom.type === "interval";
          });
          var config = {
            view,
            geometry: interval2,
            group: group2,
            field: field2,
            horizontal,
            options: getConversionTagOptionsWithDefaults(conversionTag2, horizontal)
          };
          var elements = interval2.elements;
          each$1(elements, function(elem, idx) {
            if (idx > 0) {
              renderTag(config, elements[idx - 1], elem);
            }
          });
        }
      });
    }
    return params;
  };
}
var INTERACTION_MAP = {
  hover: "__interval-connected-area-hover__",
  click: "__interval-connected-area-click__"
};
var getStartStages = function(trigger, style2) {
  if (trigger === "hover") {
    return [
      {
        trigger: "interval:mouseenter",
        action: ["element-highlight-by-color:highlight", "element-link-by-color:link"],
        arg: [null, { style: style2 }]
      }
    ];
  }
  return [
    {
      trigger: "interval:click",
      action: [
        "element-highlight-by-color:clear",
        "element-highlight-by-color:highlight",
        "element-link-by-color:clear",
        "element-link-by-color:unlink",
        "element-link-by-color:link"
      ],
      arg: [null, null, null, null, { style: style2 }]
    }
  ];
};
registerInteraction(INTERACTION_MAP.hover, {
  start: getStartStages(INTERACTION_MAP.hover),
  end: [
    {
      trigger: "interval:mouseleave",
      action: ["element-highlight-by-color:reset", "element-link-by-color:unlink"]
    }
  ]
});
registerInteraction(INTERACTION_MAP.click, {
  start: getStartStages(INTERACTION_MAP.click),
  end: [
    {
      trigger: "document:mousedown",
      action: ["element-highlight-by-color:clear", "element-link-by-color:clear"]
    }
  ]
});
function connectedArea(disable) {
  if (disable === void 0) {
    disable = false;
  }
  return function(params) {
    var chart = params.chart, options = params.options;
    var connectedArea2 = options.connectedArea;
    var clear3 = function() {
      chart.removeInteraction(INTERACTION_MAP.hover);
      chart.removeInteraction(INTERACTION_MAP.click);
    };
    if (!disable && connectedArea2) {
      var trigger = connectedArea2.trigger || "hover";
      clear3();
      chart.interaction(INTERACTION_MAP[trigger], {
        start: getStartStages(trigger, connectedArea2.style)
      });
    } else {
      clear3();
    }
    return params;
  };
}
var PADDING_RIGHT = 10;
var PADDING_TOP$1 = 5;
var BUTTON_ACTION_CONFIG = {
  padding: [8, 10],
  text: "reset",
  textStyle: {
    default: {
      x: 0,
      y: 0,
      fontSize: 12,
      fill: "#333333",
      cursor: "pointer"
    }
  },
  buttonStyle: {
    default: {
      fill: "#f7f7f7",
      stroke: "#cccccc",
      cursor: "pointer"
    },
    active: {
      fill: "#e6e6e6"
    }
  }
};
var ButtonAction = function(_super) {
  __extends$3(ButtonAction2, _super);
  function ButtonAction2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.buttonGroup = null;
    _this.buttonCfg = __assign$4({ name: "button" }, BUTTON_ACTION_CONFIG);
    return _this;
  }
  ButtonAction2.prototype.getButtonCfg = function() {
    var view = this.context.view;
    var buttonCfg = get(view, ["interactions", "filter-action", "cfg", "buttonConfig"]);
    return deepAssign(this.buttonCfg, buttonCfg, this.cfg);
  };
  ButtonAction2.prototype.drawButton = function() {
    var config = this.getButtonCfg();
    var group2 = this.context.view.foregroundGroup.addGroup({
      name: config.name
    });
    var textShape = this.drawText(group2);
    this.drawBackground(group2, textShape.getBBox());
    this.buttonGroup = group2;
  };
  ButtonAction2.prototype.drawText = function(group2) {
    var _a2;
    var config = this.getButtonCfg();
    return group2.addShape({
      type: "text",
      name: "button-text",
      attrs: __assign$4({ text: config.text }, (_a2 = config.textStyle) === null || _a2 === void 0 ? void 0 : _a2.default)
    });
  };
  ButtonAction2.prototype.drawBackground = function(group2, bbox) {
    var _a2;
    var config = this.getButtonCfg();
    var padding2 = normalPadding(config.padding);
    var buttonShape = group2.addShape({
      type: "rect",
      name: "button-rect",
      attrs: __assign$4({ x: bbox.x - padding2[3], y: bbox.y - padding2[0], width: bbox.width + padding2[1] + padding2[3], height: bbox.height + padding2[0] + padding2[2] }, (_a2 = config.buttonStyle) === null || _a2 === void 0 ? void 0 : _a2.default)
    });
    buttonShape.toBack();
    group2.on("mouseenter", function() {
      var _a3;
      buttonShape.attr((_a3 = config.buttonStyle) === null || _a3 === void 0 ? void 0 : _a3.active);
    });
    group2.on("mouseleave", function() {
      var _a3;
      buttonShape.attr((_a3 = config.buttonStyle) === null || _a3 === void 0 ? void 0 : _a3.default);
    });
    return buttonShape;
  };
  ButtonAction2.prototype.resetPosition = function() {
    var view = this.context.view;
    var coord2 = view.getCoordinate();
    var point2 = coord2.convert({ x: 1, y: 1 });
    var buttonGroup = this.buttonGroup;
    var bbox = buttonGroup.getBBox();
    var matrix = Util.transform(null, [
      ["t", point2.x - bbox.width - PADDING_RIGHT, point2.y + bbox.height + PADDING_TOP$1]
    ]);
    buttonGroup.setMatrix(matrix);
  };
  ButtonAction2.prototype.show = function() {
    if (!this.buttonGroup) {
      this.drawButton();
    }
    this.resetPosition();
    this.buttonGroup.show();
  };
  ButtonAction2.prototype.hide = function() {
    if (this.buttonGroup) {
      this.buttonGroup.hide();
    }
  };
  ButtonAction2.prototype.destroy = function() {
    var buttonGroup = this.buttonGroup;
    if (buttonGroup) {
      buttonGroup.remove();
    }
    _super.prototype.destroy.call(this);
  };
  return ButtonAction2;
}(Action);
registerAction("brush-reset-button", ButtonAction, {
  name: "brush-reset-button"
});
registerInteraction("filter-action", {});
function isPointInView(context2) {
  return context2.isInPlot();
}
function getInteractionCfg(interactionType, brushType, options) {
  var _a2 = options || {}, mask = _a2.mask, isStartEnable = _a2.isStartEnable;
  var maskType = brushType || "rect";
  switch (interactionType) {
    case "brush":
      return {
        showEnable: [
          { trigger: "plot:mouseenter", action: "cursor:crosshair", isEnable: isStartEnable || function() {
            return true;
          } },
          { trigger: "plot:mouseleave", action: "cursor:default" }
        ],
        start: [
          {
            trigger: "mousedown",
            isEnable: isStartEnable || isPointInView,
            action: ["brush:start", maskType + "-mask:start", maskType + "-mask:show"],
            arg: [null, { maskStyle: mask === null || mask === void 0 ? void 0 : mask.style }]
          }
        ],
        processing: [
          {
            trigger: "mousemove",
            isEnable: isPointInView,
            action: [maskType + "-mask:resize"]
          }
        ],
        end: [
          {
            trigger: "mouseup",
            isEnable: isPointInView,
            action: [
              "brush:filter",
              "brush:end",
              maskType + "-mask:end",
              maskType + "-mask:hide",
              "brush-reset-button:show"
            ]
          }
        ],
        rollback: [
          {
            trigger: "brush-reset-button:click",
            action: ["brush:reset", "brush-reset-button:hide", "cursor:crosshair"]
          }
        ]
      };
    case "brush-highlight":
      return {
        showEnable: [
          { trigger: "plot:mouseenter", action: "cursor:crosshair", isEnable: isStartEnable || function() {
            return true;
          } },
          { trigger: "plot:mousemove", action: "cursor:crosshair", isEnable: isStartEnable || function() {
            return true;
          } },
          {
            trigger: "plot:mousemove",
            action: "cursor:default",
            isEnable: function(context2) {
              return isStartEnable ? !isStartEnable(context2) : false;
            }
          },
          { trigger: "mask:mouseenter", action: "cursor:move", isEnable: isStartEnable || function() {
            return true;
          } },
          { trigger: "plot:mouseleave", action: "cursor:default" },
          { trigger: "mask:mouseleave", action: "cursor:crosshair" }
        ],
        start: [
          {
            trigger: "plot:mousedown",
            isEnable: isStartEnable || function(context2) {
              return !context2.isInShape("mask");
            },
            action: [maskType + "-mask:start", maskType + "-mask:show"],
            arg: [{ maskStyle: mask === null || mask === void 0 ? void 0 : mask.style }]
          },
          {
            trigger: "mask:dragstart",
            action: [maskType + "-mask:moveStart"]
          }
        ],
        processing: [
          {
            trigger: "plot:mousemove",
            action: [maskType + "-mask:resize"]
          },
          {
            trigger: "mask:drag",
            action: [maskType + "-mask:move"]
          },
          {
            trigger: "mask:change",
            action: ["element-range-highlight:highlight"]
          }
        ],
        end: [
          { trigger: "plot:mouseup", action: [maskType + "-mask:end"] },
          { trigger: "mask:dragend", action: [maskType + "-mask:moveEnd"] },
          {
            trigger: "document:mouseup",
            isEnable: function(context2) {
              return !context2.isInPlot();
            },
            action: ["element-range-highlight:clear", maskType + "-mask:end", maskType + "-mask:hide"]
          }
        ],
        rollback: [{ trigger: "dblclick", action: ["element-range-highlight:clear", maskType + "-mask:hide"] }]
      };
    case "brush-x":
      return {
        showEnable: [
          { trigger: "plot:mouseenter", action: "cursor:crosshair", isEnable: isStartEnable || function() {
            return true;
          } },
          { trigger: "plot:mouseleave", action: "cursor:default" }
        ],
        start: [
          {
            trigger: "mousedown",
            isEnable: isStartEnable || isPointInView,
            action: ["brush-x:start", maskType + "-mask:start", maskType + "-mask:show"],
            arg: [null, { maskStyle: mask === null || mask === void 0 ? void 0 : mask.style }]
          }
        ],
        processing: [
          {
            trigger: "mousemove",
            isEnable: isPointInView,
            action: [maskType + "-mask:resize"]
          }
        ],
        end: [
          {
            trigger: "mouseup",
            isEnable: isPointInView,
            action: ["brush-x:filter", "brush-x:end", maskType + "-mask:end", maskType + "-mask:hide"]
          }
        ],
        rollback: [{ trigger: "dblclick", action: ["brush-x:reset"] }]
      };
    case "brush-x-highlight":
      return {
        showEnable: [
          { trigger: "plot:mouseenter", action: "cursor:crosshair", isEnable: isStartEnable || function() {
            return true;
          } },
          { trigger: "mask:mouseenter", action: "cursor:move", isEnable: isStartEnable || function() {
            return true;
          } },
          { trigger: "plot:mouseleave", action: "cursor:default" },
          { trigger: "mask:mouseleave", action: "cursor:crosshair" }
        ],
        start: [
          {
            trigger: "plot:mousedown",
            isEnable: isStartEnable || function(context2) {
              return !context2.isInShape("mask");
            },
            action: [maskType + "-mask:start", maskType + "-mask:show"],
            arg: [{ maskStyle: mask === null || mask === void 0 ? void 0 : mask.style }]
          },
          {
            trigger: "mask:dragstart",
            action: [maskType + "-mask:moveStart"]
          }
        ],
        processing: [
          {
            trigger: "plot:mousemove",
            action: [maskType + "-mask:resize"]
          },
          {
            trigger: "mask:drag",
            action: [maskType + "-mask:move"]
          },
          {
            trigger: "mask:change",
            action: ["element-range-highlight:highlight"]
          }
        ],
        end: [
          { trigger: "plot:mouseup", action: [maskType + "-mask:end"] },
          { trigger: "mask:dragend", action: [maskType + "-mask:moveEnd"] },
          {
            trigger: "document:mouseup",
            isEnable: function(context2) {
              return !context2.isInPlot();
            },
            action: ["element-range-highlight:clear", maskType + "-mask:end", maskType + "-mask:hide"]
          }
        ],
        rollback: [{ trigger: "dblclick", action: ["element-range-highlight:clear", maskType + "-mask:hide"] }]
      };
    case "brush-y":
      return {
        showEnable: [
          { trigger: "plot:mouseenter", action: "cursor:crosshair", isEnable: isStartEnable || function() {
            return true;
          } },
          { trigger: "plot:mouseleave", action: "cursor:default" }
        ],
        start: [
          {
            trigger: "mousedown",
            isEnable: isStartEnable || isPointInView,
            action: ["brush-y:start", maskType + "-mask:start", maskType + "-mask:show"],
            arg: [null, { maskStyle: mask === null || mask === void 0 ? void 0 : mask.style }]
          }
        ],
        processing: [
          {
            trigger: "mousemove",
            isEnable: isPointInView,
            action: [maskType + "-mask:resize"]
          }
        ],
        end: [
          {
            trigger: "mouseup",
            isEnable: isPointInView,
            action: ["brush-y:filter", "brush-y:end", maskType + "-mask:end", maskType + "-mask:hide"]
          }
        ],
        rollback: [{ trigger: "dblclick", action: ["brush-y:reset"] }]
      };
    case "brush-y-highlight":
      return {
        showEnable: [
          { trigger: "plot:mouseenter", action: "cursor:crosshair", isEnable: isStartEnable || function() {
            return true;
          } },
          { trigger: "mask:mouseenter", action: "cursor:move", isEnable: isStartEnable || function() {
            return true;
          } },
          { trigger: "plot:mouseleave", action: "cursor:default" },
          { trigger: "mask:mouseleave", action: "cursor:crosshair" }
        ],
        start: [
          {
            trigger: "plot:mousedown",
            isEnable: isStartEnable || function(context2) {
              return !context2.isInShape("mask");
            },
            action: [maskType + "-mask:start", maskType + "-mask:show"],
            arg: [{ maskStyle: mask === null || mask === void 0 ? void 0 : mask.style }]
          },
          {
            trigger: "mask:dragstart",
            action: [maskType + "-mask:moveStart"]
          }
        ],
        processing: [
          {
            trigger: "plot:mousemove",
            action: [maskType + "-mask:resize"]
          },
          {
            trigger: "mask:drag",
            action: [maskType + "-mask:move"]
          },
          {
            trigger: "mask:change",
            action: ["element-range-highlight:highlight"]
          }
        ],
        end: [
          { trigger: "plot:mouseup", action: [maskType + "-mask:end"] },
          { trigger: "mask:dragend", action: [maskType + "-mask:moveEnd"] },
          {
            trigger: "document:mouseup",
            isEnable: function(context2) {
              return !context2.isInPlot();
            },
            action: ["element-range-highlight:clear", maskType + "-mask:end", maskType + "-mask:hide"]
          }
        ],
        rollback: [{ trigger: "dblclick", action: ["element-range-highlight:clear", maskType + "-mask:hide"] }]
      };
    default:
      return {};
  }
}
registerInteraction("brush", getInteractionCfg("brush"));
registerInteraction("brush-highlight", getInteractionCfg("brush-highlight"));
registerInteraction("brush-x", getInteractionCfg("brush-x", "x-rect"));
registerInteraction("brush-y", getInteractionCfg("brush-y", "y-rect"));
registerInteraction("brush-x-highlight", getInteractionCfg("brush-x-highlight", "x-rect"));
registerInteraction("brush-y-highlight", getInteractionCfg("brush-y-highlight", "y-rect"));
var BRUSH_TYPES = ["brush", "brush-x", "brush-y", "brush-highlight", "brush-x-highlight", "brush-y-highlight"];
function brushInteraction(params) {
  var options = params.options;
  var brush = options.brush;
  var interactions = filter(options.interactions || [], function(i2) {
    return BRUSH_TYPES.indexOf(i2.type) === -1;
  });
  if (brush === null || brush === void 0 ? void 0 : brush.enabled) {
    BRUSH_TYPES.forEach(function(type4) {
      var enable = false;
      switch (brush.type) {
        case "x-rect":
          enable = type4 === (brush.action === "highlight" ? "brush-x-highlight" : "brush-x");
          break;
        case "y-rect":
          enable = type4 === (brush.action === "highlight" ? "brush-y-highlight" : "brush-y");
          break;
        default:
          enable = type4 === (brush.action === "highlight" ? "brush-highlight" : "brush");
          break;
      }
      var obj = { type: type4, enable };
      if (brush) {
        obj.cfg = getInteractionCfg(type4, brush.type, brush);
      }
      interactions.push(obj);
    });
    if ((brush === null || brush === void 0 ? void 0 : brush.action) !== "highlight") {
      interactions.push({
        type: "filter-action",
        cfg: {
          buttonConfig: brush.button
        }
      });
    }
  }
  return deepAssign({}, params, { options: { interactions } });
}
function defaultOptions$6(params) {
  var options = params.options;
  var legend2 = options.legend;
  var seriesField = options.seriesField, isStack = options.isStack;
  if (seriesField) {
    if (legend2 !== false) {
      legend2 = __assign$4({ position: isStack ? "right-top" : "top-left" }, legend2);
    }
  } else {
    legend2 = false;
  }
  params.options.legend = legend2;
  return params;
}
function geometry$u(params) {
  var chart = params.chart, options = params.options;
  var data2 = options.data, columnStyle = options.columnStyle, color2 = options.color, columnWidthRatio = options.columnWidthRatio, isPercent = options.isPercent, isGroup = options.isGroup, isStack = options.isStack, xField = options.xField, yField = options.yField, seriesField = options.seriesField, groupField = options.groupField, tooltip2 = options.tooltip, shape = options.shape;
  var percentData = isPercent && isGroup && isStack ? getDeepPercent(data2, yField, [xField, groupField], yField) : getDataWhetherPercentage(data2, yField, xField, yField, isPercent);
  var chartData = [];
  if (isStack && seriesField && !isGroup) {
    percentData.forEach(function(item) {
      var stackedItem = chartData.find(function(v2) {
        return v2[xField] === item[xField] && v2[seriesField] === item[seriesField];
      });
      if (stackedItem) {
        stackedItem[yField] += item[yField] || 0;
      } else {
        chartData.push(__assign$4({}, item));
      }
    });
  } else {
    chartData = percentData;
  }
  chart.data(chartData);
  var tooltipOptions = isPercent ? __assign$4({ formatter: function(datum) {
    return {
      name: isGroup && isStack ? datum[seriesField] + " - " + datum[groupField] : datum[seriesField] || datum[xField],
      value: (Number(datum[yField]) * 100).toFixed(2) + "%"
    };
  } }, tooltip2) : tooltip2;
  var p2 = deepAssign({}, params, {
    options: {
      data: chartData,
      widthRatio: columnWidthRatio,
      tooltip: tooltipOptions,
      interval: {
        shape,
        style: columnStyle,
        color: color2
      }
    }
  });
  interval(p2);
  return p2;
}
function meta$k(params) {
  var _a2, _b;
  var options = params.options;
  var xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField, yField = options.yField, data2 = options.data, isPercent = options.isPercent;
  var percentYMeta = isPercent ? { max: 1, min: 0, minLimit: 0, maxLimit: 1 } : {};
  return flow(scale$2((_a2 = {}, _a2[xField] = xAxis, _a2[yField] = yAxis, _a2), (_b = {}, _b[xField] = {
    type: "cat"
  }, _b[yField] = __assign$4(__assign$4({}, adjustYMetaByZero(data2, yField)), percentYMeta), _b)))(params);
}
function axis$j(params) {
  var chart = params.chart, options = params.options;
  var xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField, yField = options.yField;
  if (xAxis === false) {
    chart.axis(xField, false);
  } else {
    chart.axis(xField, xAxis);
  }
  if (yAxis === false) {
    chart.axis(yField, false);
  } else {
    chart.axis(yField, yAxis);
  }
  return params;
}
function legend$e(params) {
  var chart = params.chart, options = params.options;
  var legend2 = options.legend, seriesField = options.seriesField;
  if (legend2 && seriesField) {
    chart.legend(seriesField, legend2);
  } else if (legend2 === false) {
    chart.legend(false);
  }
  return params;
}
function label$d(params) {
  var chart = params.chart, options = params.options;
  var label2 = options.label, yField = options.yField, isRange = options.isRange;
  var geometry2 = findGeometry(chart, "interval");
  if (!label2) {
    geometry2.label(false);
  } else {
    var callback = label2.callback, cfg = __rest$3(label2, ["callback"]);
    geometry2.label({
      fields: [yField],
      callback,
      cfg: __assign$4({
        layout: (cfg === null || cfg === void 0 ? void 0 : cfg.position) ? void 0 : [
          { type: "interval-adjust-position" },
          { type: "interval-hide-overlap" },
          { type: "adjust-color" },
          { type: "limit-in-plot", cfg: { action: "hide" } }
        ]
      }, transformLabel(isRange ? __assign$4({ content: function(item) {
        var _a2;
        return (_a2 = item[yField]) === null || _a2 === void 0 ? void 0 : _a2.join("-");
      } }, cfg) : cfg))
    });
  }
  return params;
}
function columnTooltip(params) {
  var chart = params.chart, options = params.options;
  var tooltip2 = options.tooltip, isGroup = options.isGroup, isStack = options.isStack, groupField = options.groupField, data2 = options.data, xField = options.xField, yField = options.yField, seriesField = options.seriesField;
  if (tooltip2 === false) {
    chart.tooltip(false);
  } else {
    var tooltipOptions = tooltip2;
    if (isGroup && isStack) {
      var tooltipFormatter_1 = (tooltipOptions === null || tooltipOptions === void 0 ? void 0 : tooltipOptions.formatter) || function(datum) {
        return { name: datum[seriesField] + " - " + datum[groupField], value: datum[yField] };
      };
      tooltipOptions = __assign$4(__assign$4({}, tooltipOptions), { customItems: function(originalItems) {
        var items = [];
        each$1(originalItems, function(item) {
          var datas = filter(data2, function(d2) {
            return isMatch(d2, pick(item.data, [xField, seriesField]));
          });
          datas.forEach(function(datum) {
            items.push(__assign$4(__assign$4(__assign$4({}, item), { value: datum[yField], data: datum, mappingData: { _origin: datum } }), tooltipFormatter_1(datum)));
          });
        });
        return items;
      } });
    }
    chart.tooltip(tooltipOptions);
  }
  return params;
}
function adaptor$w(params, isBar) {
  if (isBar === void 0) {
    isBar = false;
  }
  var options = params.options;
  var seriesField = options.seriesField;
  return flow(
    defaultOptions$6,
    theme$2,
    pattern("columnStyle"),
    state,
    transformations("rect"),
    geometry$u,
    meta$k,
    axis$j,
    legend$e,
    columnTooltip,
    slider$2,
    scrollbar,
    label$d,
    brushInteraction,
    interaction$7,
    animation$5,
    annotation$2(),
    conversionTag$3(options.yField, !isBar, !!seriesField),
    connectedArea(!options.isStack),
    limitInPlot$2
  )(params);
}
var DEFAULT_OPTIONS$x = deepAssign({}, Plot.getDefaultOptions(), {
  columnWidthRatio: 0.6,
  marginRatio: 1 / 32,
  tooltip: {
    shared: true,
    showMarkers: false,
    offset: 20
  },
  legend: {
    radio: {}
  },
  interactions: [{ type: "active-region" }]
});
var Column = function(_super) {
  __extends$3(Column2, _super);
  function Column2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "column";
    return _this;
  }
  Column2.getDefaultOptions = function() {
    return DEFAULT_OPTIONS$x;
  };
  Column2.prototype.changeData = function(data2) {
    this.updateOption({ data: data2 });
    var _a2 = this.options, yField = _a2.yField, xField = _a2.xField, isPercent = _a2.isPercent;
    var _b = this, chart = _b.chart, options = _b.options;
    meta$k({ chart, options });
    this.chart.changeData(getDataWhetherPercentage(data2, yField, xField, yField, isPercent));
  };
  Column2.prototype.getDefaultOptions = function() {
    return Column2.getDefaultOptions();
  };
  Column2.prototype.getSchemaAdaptor = function() {
    return adaptor$w;
  };
  return Column2;
}(Plot);
function defaultOptions$5(params) {
  var options = params.options;
  var xField = options.xField, yField = options.yField, xAxis = options.xAxis, yAxis = options.yAxis;
  var position = {
    left: "bottom",
    right: "top",
    top: "left",
    bottom: "right"
  };
  var verticalAxis = yAxis !== false ? __assign$4({ position: position[(yAxis === null || yAxis === void 0 ? void 0 : yAxis.position) || "left"] }, yAxis) : false;
  var horizontalAxis = xAxis !== false ? __assign$4({ position: position[(xAxis === null || xAxis === void 0 ? void 0 : xAxis.position) || "bottom"] }, xAxis) : false;
  return __assign$4(__assign$4({}, params), { options: __assign$4(__assign$4({}, options), {
    xField: yField,
    yField: xField,
    xAxis: verticalAxis,
    yAxis: horizontalAxis
  }) });
}
function label$c(params) {
  var options = params.options;
  var label2 = options.label;
  if (label2 && !label2.position) {
    label2.position = "left";
    if (!label2.layout) {
      label2.layout = [
        { type: "interval-adjust-position" },
        { type: "interval-hide-overlap" },
        { type: "adjust-color" },
        { type: "limit-in-plot", cfg: { action: "hide" } }
      ];
    }
  }
  return deepAssign({}, params, { options: { label: label2 } });
}
function legend$d(params) {
  var options = params.options;
  var seriesField = options.seriesField, isStack = options.isStack;
  var legend2 = options.legend;
  if (seriesField) {
    if (legend2 !== false) {
      legend2 = __assign$4({ position: isStack ? "top-left" : "right-top" }, legend2 || {});
    }
  } else {
    legend2 = false;
  }
  return deepAssign({}, params, { options: { legend: legend2 } });
}
function coordinate$8(params) {
  var options = params.options;
  var coordinateOptions = [{ type: "transpose" }, { type: "reflectY" }].concat(options.coordinate || []);
  return deepAssign({}, params, { options: { coordinate: coordinateOptions } });
}
function geometry$t(params) {
  var chart = params.chart, options = params.options;
  var barStyle = options.barStyle, barWidthRatio = options.barWidthRatio, minBarWidth = options.minBarWidth, maxBarWidth = options.maxBarWidth, barBackground = options.barBackground;
  return adaptor$w({
    chart,
    options: __assign$4(__assign$4({}, options), {
      columnStyle: barStyle,
      columnWidthRatio: barWidthRatio,
      minColumnWidth: minBarWidth,
      maxColumnWidth: maxBarWidth,
      columnBackground: barBackground
    })
  }, true);
}
function adaptor$v(params) {
  return flow(defaultOptions$5, label$c, legend$d, tooltip$9, coordinate$8, geometry$t)(params);
}
var DEFAULT_OPTIONS$w = deepAssign({}, Plot.getDefaultOptions(), {
  barWidthRatio: 0.6,
  marginRatio: 1 / 32,
  tooltip: {
    shared: true,
    showMarkers: false,
    offset: 20
  },
  legend: {
    radio: {}
  },
  interactions: [{ type: "active-region" }]
});
var Bar = function(_super) {
  __extends$3(Bar2, _super);
  function Bar2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "bar";
    return _this;
  }
  Bar2.getDefaultOptions = function() {
    return DEFAULT_OPTIONS$w;
  };
  Bar2.prototype.changeData = function(data2) {
    var _a2, _b;
    this.updateOption({ data: data2 });
    var _c = this, chart = _c.chart, options = _c.options;
    var isPercent = options.isPercent;
    var xField = options.xField, yField = options.yField, xAxis = options.xAxis, yAxis = options.yAxis;
    _a2 = [yField, xField], xField = _a2[0], yField = _a2[1];
    _b = [yAxis, xAxis], xAxis = _b[0], yAxis = _b[1];
    var switchedFieldOptions = __assign$4(__assign$4({}, options), { xField, yField, yAxis, xAxis });
    meta$k({ chart, options: switchedFieldOptions });
    chart.changeData(getDataWhetherPercentage(data2, xField, yField, xField, isPercent));
  };
  Bar2.prototype.getDefaultOptions = function() {
    return Bar2.getDefaultOptions();
  };
  Bar2.prototype.getSchemaAdaptor = function() {
    return adaptor$v;
  };
  return Bar2;
}(Plot);
var DEFAULT_OPTIONS$v = deepAssign({}, Plot.getDefaultOptions(), {
  legend: {
    position: "right",
    radio: {}
  },
  tooltip: {
    shared: false,
    showTitle: false,
    showMarkers: false
  },
  label: {
    layout: { type: "limit-in-plot", cfg: { action: "ellipsis" } }
  },
  pieStyle: {
    stroke: "white",
    lineWidth: 1
  },
  statistic: {
    title: {
      style: { fontWeight: 300, color: "#4B535E", textAlign: "center", fontSize: "20px", lineHeight: 1 }
    },
    content: {
      style: {
        fontWeight: "bold",
        color: "rgba(44,53,66,0.85)",
        textAlign: "center",
        fontSize: "32px",
        lineHeight: 1
      }
    }
  },
  theme: {
    components: {
      annotation: {
        text: {
          animate: false
        }
      }
    }
  }
});
function getTotalValue(data2, field2) {
  var total = null;
  each$1(data2, function(item) {
    if (typeof item[field2] === "number") {
      total += item[field2];
    }
  });
  return total;
}
function adaptOffset(type4, offset3) {
  var defaultOffset;
  switch (type4) {
    case "inner":
      defaultOffset = "-30%";
      if (isString(offset3) && offset3.endsWith("%")) {
        return parseFloat(offset3) * 0.01 > 0 ? defaultOffset : offset3;
      }
      return offset3 < 0 ? offset3 : defaultOffset;
    case "outer":
      defaultOffset = 12;
      if (isString(offset3) && offset3.endsWith("%")) {
        return parseFloat(offset3) * 0.01 < 0 ? defaultOffset : offset3;
      }
      return offset3 > 0 ? offset3 : defaultOffset;
    default:
      return offset3;
  }
}
function isAllZero(data2, angleField) {
  return every(processIllegalData(data2, angleField), function(d2) {
    return d2[angleField] === 0;
  });
}
var ORIGIN_MATRIX = [1, 0, 0, 0, 1, 0, 0, 0, 1];
function transform$2(actions, matrix) {
  var ulMatrix = matrix ? __spreadArrays(matrix) : __spreadArrays(ORIGIN_MATRIX);
  return Util.transform(ulMatrix, actions);
}
var PieLegendAction = function(_super) {
  __extends$3(PieLegendAction2, _super);
  function PieLegendAction2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  PieLegendAction2.prototype.getActiveElements = function() {
    var delegateObject = Util.getDelegationObject(this.context);
    if (delegateObject) {
      var view = this.context.view;
      var component2 = delegateObject.component, item_1 = delegateObject.item;
      var field_1 = component2.get("field");
      if (field_1) {
        var elements = view.geometries[0].elements;
        return elements.filter(function(ele) {
          return ele.getModel().data[field_1] === item_1.value;
        });
      }
    }
    return [];
  };
  PieLegendAction2.prototype.getActiveElementLabels = function() {
    var view = this.context.view;
    var elements = this.getActiveElements();
    var labels = view.geometries[0].labelsContainer.getChildren();
    return labels.filter(function(label2) {
      return elements.find(function(ele) {
        return isEqual$1(ele.getData(), label2.get("data"));
      });
    });
  };
  PieLegendAction2.prototype.transfrom = function(offset3) {
    if (offset3 === void 0) {
      offset3 = 7.5;
    }
    var elements = this.getActiveElements();
    var elementLabels = this.getActiveElementLabels();
    elements.forEach(function(element, idx) {
      var labelShape = elementLabels[idx];
      var coordinate2 = element.geometry.coordinate;
      if (coordinate2.isPolar && coordinate2.isTransposed) {
        var _a2 = Util.getAngle(element.getModel(), coordinate2), startAngle = _a2.startAngle, endAngle = _a2.endAngle;
        var middleAngle = (startAngle + endAngle) / 2;
        var r2 = offset3;
        var x2 = r2 * Math.cos(middleAngle);
        var y2 = r2 * Math.sin(middleAngle);
        element.shape.setMatrix(transform$2([["t", x2, y2]]));
        labelShape.setMatrix(transform$2([["t", x2, y2]]));
      }
    });
  };
  PieLegendAction2.prototype.active = function() {
    this.transfrom();
  };
  PieLegendAction2.prototype.reset = function() {
    this.transfrom(0);
  };
  return PieLegendAction2;
}(Action);
function getCurrentElement(context2) {
  var event = context2.event;
  var element;
  var target = event.target;
  if (target) {
    element = target.get("element");
  }
  return element;
}
var StatisticAction = function(_super) {
  __extends$3(StatisticAction2, _super);
  function StatisticAction2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  StatisticAction2.prototype.getAnnotations = function(_view) {
    var view = _view || this.context.view;
    return view.getController("annotation").option;
  };
  StatisticAction2.prototype.getInitialAnnotation = function() {
    return this.initialAnnotation;
  };
  StatisticAction2.prototype.init = function() {
    var _this = this;
    var view = this.context.view;
    view.removeInteraction("tooltip");
    view.on("afterchangesize", function() {
      var annotations = _this.getAnnotations(view);
      _this.initialAnnotation = annotations;
    });
  };
  StatisticAction2.prototype.change = function(arg) {
    var _a2 = this.context, view = _a2.view, event = _a2.event;
    if (!this.initialAnnotation) {
      this.initialAnnotation = this.getAnnotations();
    }
    var data2 = get(event, ["data", "data"]);
    if (event.type.match("legend-item")) {
      var delegateObject = Util.getDelegationObject(this.context);
      var colorField_1 = view.getGroupedFields()[0];
      if (delegateObject && colorField_1) {
        var item_1 = delegateObject.item;
        data2 = view.getData().find(function(d2) {
          return d2[colorField_1] === item_1.value;
        });
      }
    }
    if (data2) {
      var annotations = get(arg, "annotations", []);
      var statistic2 = get(arg, "statistic", {});
      view.getController("annotation").clear(true);
      each$1(annotations, function(annotation2) {
        if (typeof annotation2 === "object") {
          view.annotation()[annotation2.type](annotation2);
        }
      });
      renderStatistic(view, { statistic: statistic2, plotType: "pie" }, data2);
      view.render(true);
    }
    var ele = getCurrentElement(this.context);
    if (ele) {
      ele.shape.toFront();
    }
  };
  StatisticAction2.prototype.reset = function() {
    var view = this.context.view;
    var annotationController = view.getController("annotation");
    annotationController.clear(true);
    var initialStatistic = this.getInitialAnnotation();
    each$1(initialStatistic, function(a2) {
      view.annotation()[a2.type](a2);
    });
    view.render(true);
  };
  return StatisticAction2;
}(Action);
var PIE_STATISTIC = "pie-statistic";
registerAction(PIE_STATISTIC, StatisticAction);
registerInteraction("pie-statistic-active", {
  start: [{ trigger: "element:mouseenter", action: "pie-statistic:change" }],
  end: [{ trigger: "element:mouseleave", action: "pie-statistic:reset" }]
});
registerAction("pie-legend", PieLegendAction);
registerInteraction("pie-legend-active", {
  start: [{ trigger: "legend-item:mouseenter", action: "pie-legend:active" }],
  end: [{ trigger: "legend-item:mouseleave", action: "pie-legend:reset" }]
});
function geometry$s(params) {
  var chart = params.chart, options = params.options;
  var data2 = options.data, angleField = options.angleField, colorField = options.colorField, color2 = options.color, pieStyle = options.pieStyle;
  var processData2 = processIllegalData(data2, angleField);
  if (isAllZero(processData2, angleField)) {
    var percentageField_1 = "$$percentage$$";
    processData2 = processData2.map(function(d2) {
      var _a2;
      return __assign$4(__assign$4({}, d2), (_a2 = {}, _a2[percentageField_1] = 1 / processData2.length, _a2));
    });
    chart.data(processData2);
    var p2 = deepAssign({}, params, {
      options: {
        xField: "1",
        yField: percentageField_1,
        seriesField: colorField,
        isStack: true,
        interval: {
          color: color2,
          style: pieStyle
        },
        args: {
          zIndexReversed: true,
          sortZIndex: true
        }
      }
    });
    interval(p2);
  } else {
    chart.data(processData2);
    var p2 = deepAssign({}, params, {
      options: {
        xField: "1",
        yField: angleField,
        seriesField: colorField,
        isStack: true,
        interval: {
          color: color2,
          style: pieStyle
        },
        args: {
          zIndexReversed: true,
          sortZIndex: true
        }
      }
    });
    interval(p2);
  }
  return params;
}
function meta$j(params) {
  var _a2;
  var chart = params.chart, options = params.options;
  var meta2 = options.meta, colorField = options.colorField;
  var scales = deepAssign({}, meta2);
  chart.scale(scales, (_a2 = {}, _a2[colorField] = { type: "cat" }, _a2));
  return params;
}
function coordinate$7(params) {
  var chart = params.chart, options = params.options;
  var radius = options.radius, innerRadius = options.innerRadius, startAngle = options.startAngle, endAngle = options.endAngle;
  chart.coordinate({
    type: "theta",
    cfg: {
      radius,
      innerRadius,
      startAngle,
      endAngle
    }
  });
  return params;
}
function label$b(params) {
  var chart = params.chart, options = params.options;
  var label2 = options.label, colorField = options.colorField, angleField = options.angleField;
  var geometry2 = chart.geometries[0];
  if (!label2) {
    geometry2.label(false);
  } else {
    var callback = label2.callback, cfg = __rest$3(label2, ["callback"]);
    var labelCfg = transformLabel(cfg);
    if (labelCfg.content) {
      var content_1 = labelCfg.content;
      labelCfg.content = function(data2, dataum, index2) {
        var name = data2[colorField];
        var value2 = data2[angleField];
        var angleScale = chart.getScaleByField(angleField);
        var percent2 = angleScale === null || angleScale === void 0 ? void 0 : angleScale.scale(value2);
        return isFunction(content_1) ? content_1(__assign$4(__assign$4({}, data2), { percent: percent2 }), dataum, index2) : isString(content_1) ? template(content_1, {
          value: value2,
          name,
          percentage: isNumber$1(percent2) && !isNil(value2) ? (percent2 * 100).toFixed(2) + "%" : null
        }) : content_1;
      };
    }
    var LABEL_LAYOUT_TYPE_MAP = {
      inner: "",
      outer: "pie-outer",
      spider: "pie-spider"
    };
    var labelLayoutType = labelCfg.type ? LABEL_LAYOUT_TYPE_MAP[labelCfg.type] : "pie-outer";
    var labelLayoutCfg = labelCfg.layout ? !isArray$1(labelCfg.layout) ? [labelCfg.layout] : labelCfg.layout : [];
    labelCfg.layout = (labelLayoutType ? [{ type: labelLayoutType }] : []).concat(labelLayoutCfg);
    geometry2.label({
      fields: colorField ? [angleField, colorField] : [angleField],
      callback,
      cfg: __assign$4(__assign$4({}, labelCfg), { offset: adaptOffset(labelCfg.type, labelCfg.offset), type: "pie" })
    });
  }
  return params;
}
function transformStatisticOptions(options) {
  var innerRadius = options.innerRadius, statistic2 = options.statistic, angleField = options.angleField, colorField = options.colorField, meta2 = options.meta, locale2 = options.locale;
  var i18n = getLocale(locale2);
  if (innerRadius && statistic2) {
    var _a2 = deepAssign({}, DEFAULT_OPTIONS$v.statistic, statistic2), titleOpt_1 = _a2.title, contentOpt_1 = _a2.content;
    if (titleOpt_1 !== false) {
      titleOpt_1 = deepAssign({}, {
        formatter: function(datum) {
          var text2 = datum ? datum[colorField] : !isNil(titleOpt_1.content) ? titleOpt_1.content : i18n.get(["statistic", "total"]);
          var metaFormatter = get(meta2, [colorField, "formatter"]) || function(v2) {
            return v2;
          };
          return metaFormatter(text2);
        }
      }, titleOpt_1);
    }
    if (contentOpt_1 !== false) {
      contentOpt_1 = deepAssign({}, {
        formatter: function(datum, data2) {
          var dataValue = datum ? datum[angleField] : getTotalValue(data2, angleField);
          var metaFormatter = get(meta2, [angleField, "formatter"]) || function(v2) {
            return v2;
          };
          if (datum) {
            return metaFormatter(dataValue);
          }
          return !isNil(contentOpt_1.content) ? contentOpt_1.content : metaFormatter(dataValue);
        }
      }, contentOpt_1);
    }
    return deepAssign({}, { statistic: { title: titleOpt_1, content: contentOpt_1 } }, options);
  }
  return options;
}
function pieAnnotation(params) {
  var chart = params.chart, options = params.options;
  var _a2 = transformStatisticOptions(options), innerRadius = _a2.innerRadius, statistic2 = _a2.statistic;
  chart.getController("annotation").clear(true);
  flow(annotation$2())(params);
  if (innerRadius && statistic2) {
    renderStatistic(chart, { statistic: statistic2, plotType: "pie" });
  }
  return params;
}
function tooltip$8(params) {
  var chart = params.chart, options = params.options;
  var tooltip2 = options.tooltip, colorField = options.colorField, angleField = options.angleField, data2 = options.data;
  if (tooltip2 === false) {
    chart.tooltip(tooltip2);
  } else {
    chart.tooltip(deepAssign({}, tooltip2, { shared: false }));
    if (isAllZero(data2, angleField)) {
      var fields = get(tooltip2, "fields");
      var formatter = get(tooltip2, "formatter");
      if (isEmpty(get(tooltip2, "fields"))) {
        fields = [colorField, angleField];
        formatter = formatter || function(datum) {
          return { name: datum[colorField], value: toString$2(datum[angleField]) };
        };
      }
      chart.geometries[0].tooltip(fields.join("*"), getMappingFunction(fields, formatter));
    }
  }
  return params;
}
function interaction$6(params) {
  var chart = params.chart, options = params.options;
  var _a2 = transformStatisticOptions(options), interactions = _a2.interactions, statistic2 = _a2.statistic, annotations = _a2.annotations;
  each$1(interactions, function(i2) {
    var _a3, _b;
    if (i2.enable === false) {
      chart.removeInteraction(i2.type);
    } else if (i2.type === "pie-statistic-active") {
      var startStages_1 = [];
      if (!((_a3 = i2.cfg) === null || _a3 === void 0 ? void 0 : _a3.start)) {
        startStages_1 = [
          {
            trigger: "element:mouseenter",
            action: PIE_STATISTIC + ":change",
            arg: { statistic: statistic2, annotations }
          }
        ];
      }
      each$1((_b = i2.cfg) === null || _b === void 0 ? void 0 : _b.start, function(stage) {
        startStages_1.push(__assign$4(__assign$4({}, stage), { arg: { statistic: statistic2, annotations } }));
      });
      chart.interaction(i2.type, deepAssign({}, i2.cfg, { start: startStages_1 }));
    } else {
      chart.interaction(i2.type, i2.cfg || {});
    }
  });
  return params;
}
function adaptor$u(params) {
  return flow(
    pattern("pieStyle"),
    geometry$s,
    meta$j,
    theme$2,
    coordinate$7,
    legend$g,
    tooltip$8,
    label$b,
    state,
    pieAnnotation,
    interaction$6,
    animation$5
  )(params);
}
var Pie = function(_super) {
  __extends$3(Pie2, _super);
  function Pie2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "pie";
    return _this;
  }
  Pie2.getDefaultOptions = function() {
    return DEFAULT_OPTIONS$v;
  };
  Pie2.prototype.changeData = function(data2) {
    this.chart.emit(VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, Event.fromData(this.chart, VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, null));
    var prevOptions = this.options;
    var angleField = this.options.angleField;
    var prevData = processIllegalData(prevOptions.data, angleField);
    var curData = processIllegalData(data2, angleField);
    if (isAllZero(prevData, angleField) || isAllZero(curData, angleField)) {
      this.update({ data: data2 });
    } else {
      this.updateOption({ data: data2 });
      this.chart.data(curData);
      pieAnnotation({ chart: this.chart, options: this.options });
      this.chart.render(true);
    }
    this.chart.emit(VIEW_LIFE_CIRCLE.AFTER_CHANGE_DATA, Event.fromData(this.chart, VIEW_LIFE_CIRCLE.AFTER_CHANGE_DATA, null));
  };
  Pie2.prototype.getDefaultOptions = function() {
    return Pie2.getDefaultOptions();
  };
  Pie2.prototype.getSchemaAdaptor = function() {
    return adaptor$u;
  };
  return Pie2;
}(Plot);
function geometry$r(params) {
  var chart = params.chart, options = params.options;
  var data2 = options.data, sectorStyle = options.sectorStyle, color2 = options.color;
  chart.data(data2);
  flow(interval)(deepAssign({}, params, {
    options: {
      marginRatio: 1,
      interval: {
        style: sectorStyle,
        color: color2
      }
    }
  }));
  return params;
}
function label$a(params) {
  var chart = params.chart, options = params.options;
  var label2 = options.label, xField = options.xField;
  var geometry2 = findGeometry(chart, "interval");
  if (label2 === false) {
    geometry2.label(false);
  } else if (isObject(label2)) {
    var callback = label2.callback, fields = label2.fields, cfg = __rest$3(label2, ["callback", "fields"]);
    var offset3 = cfg.offset;
    var layout2 = cfg.layout;
    if (offset3 === void 0 || offset3 >= 0) {
      layout2 = layout2 ? isArray$1(layout2) ? layout2 : [layout2] : [];
      cfg.layout = filter(layout2, function(v2) {
        return v2.type !== "limit-in-shape";
      });
      cfg.layout.length || delete cfg.layout;
    }
    geometry2.label({
      fields: fields || [xField],
      callback,
      cfg: transformLabel(cfg)
    });
  } else {
    log(LEVEL.WARN, label2 === null, "the label option must be an Object.");
    geometry2.label({ fields: [xField] });
  }
  return params;
}
function legend$c(params) {
  var chart = params.chart, options = params.options;
  var legend2 = options.legend, seriesField = options.seriesField;
  if (legend2 === false) {
    chart.legend(false);
  } else if (seriesField) {
    chart.legend(seriesField, legend2);
  }
  return params;
}
function coordinate$6(params) {
  var chart = params.chart, options = params.options;
  var radius = options.radius, innerRadius = options.innerRadius, startAngle = options.startAngle, endAngle = options.endAngle;
  chart.coordinate({
    type: "polar",
    cfg: {
      radius,
      innerRadius,
      startAngle,
      endAngle
    }
  });
  return params;
}
function meta$i(params) {
  var _a2;
  var options = params.options;
  var xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField, yField = options.yField;
  return flow(scale$2((_a2 = {}, _a2[xField] = xAxis, _a2[yField] = yAxis, _a2)))(params);
}
function axis$i(params) {
  var chart = params.chart, options = params.options;
  var xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField, yField = options.yField;
  if (!xAxis) {
    chart.axis(xField, false);
  } else {
    chart.axis(xField, xAxis);
  }
  if (!yAxis) {
    chart.axis(yField, false);
  } else {
    chart.axis(yField, yAxis);
  }
  return params;
}
function adaptor$t(params) {
  flow(pattern("sectorStyle"), geometry$r, meta$i, label$a, coordinate$6, axis$i, legend$c, tooltip$9, interaction$7, animation$5, theme$2, annotation$2(), state)(params);
}
var DEFAULT_OPTIONS$u = deepAssign({}, Plot.getDefaultOptions(), {
  xAxis: false,
  yAxis: false,
  legend: {
    position: "right",
    radio: {}
  },
  sectorStyle: {
    stroke: "#fff",
    lineWidth: 1
  },
  label: {
    layout: {
      type: "limit-in-shape"
    }
  },
  tooltip: {
    shared: true,
    showMarkers: false
  },
  interactions: [{ type: "active-region" }]
});
(function(_super) {
  __extends$3(Rose, _super);
  function Rose() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "rose";
    return _this;
  }
  Rose.getDefaultOptions = function() {
    return DEFAULT_OPTIONS$u;
  };
  Rose.prototype.changeData = function(data2) {
    this.updateOption({ data: data2 });
    this.chart.changeData(data2);
  };
  Rose.prototype.getDefaultOptions = function() {
    return Rose.getDefaultOptions();
  };
  Rose.prototype.getSchemaAdaptor = function() {
    return adaptor$t;
  };
  return Rose;
})(Plot);
var DEFAULT_OPTIONS$t = {
  font: function() {
    return "serif";
  },
  padding: 1,
  size: [500, 500],
  spiral: "archimedean",
  timeInterval: 3e3
};
function wordCloud(words, options) {
  options = mix({}, DEFAULT_OPTIONS$t, options);
  return transform$1(words, options);
}
function transform$1(words, options) {
  var layout2 = tagCloud();
  ["font", "fontSize", "fontWeight", "padding", "rotate", "size", "spiral", "timeInterval", "random"].forEach(function(key2) {
    if (!isNil(options[key2])) {
      layout2[key2](options[key2]);
    }
  });
  layout2.words(words);
  if (options.imageMask) {
    layout2.createMask(options.imageMask);
  }
  var result = layout2.start();
  var tags = result._tags;
  tags.forEach(function(tag) {
    tag.x += options.size[0] / 2;
    tag.y += options.size[1] / 2;
  });
  var _a2 = options.size, w2 = _a2[0], h2 = _a2[1];
  tags.push({
    text: "",
    value: 0,
    x: 0,
    y: 0,
    opacity: 0
  });
  tags.push({
    text: "",
    value: 0,
    x: w2,
    y: h2,
    opacity: 0
  });
  return tags;
}
var cloudRadians = Math.PI / 180, cw = 1 << 11 >> 5, ch = 1 << 11;
function cloudText(d2) {
  return d2.text;
}
function cloudFont() {
  return "serif";
}
function cloudFontNormal() {
  return "normal";
}
function cloudFontSize(d2) {
  return d2.value;
}
function cloudRotate() {
  return ~~(Math.random() * 2) * 90;
}
function cloudPadding() {
  return 1;
}
function cloudSprite(contextAndRatio, d2, data2, di2) {
  if (d2.sprite)
    return;
  var c2 = contextAndRatio.context, ratio = contextAndRatio.ratio;
  c2.clearRect(0, 0, (cw << 5) / ratio, ch / ratio);
  var x2 = 0, y2 = 0, maxh = 0;
  var n2 = data2.length;
  --di2;
  while (++di2 < n2) {
    d2 = data2[di2];
    c2.save();
    c2.font = d2.style + " " + d2.weight + " " + ~~((d2.size + 1) / ratio) + "px " + d2.font;
    var w2 = c2.measureText(d2.text + "m").width * ratio, h2 = d2.size << 1;
    if (d2.rotate) {
      var sr = Math.sin(d2.rotate * cloudRadians), cr = Math.cos(d2.rotate * cloudRadians), wcr = w2 * cr, wsr = w2 * sr, hcr = h2 * cr, hsr = h2 * sr;
      w2 = Math.max(Math.abs(wcr + hsr), Math.abs(wcr - hsr)) + 31 >> 5 << 5;
      h2 = ~~Math.max(Math.abs(wsr + hcr), Math.abs(wsr - hcr));
    } else {
      w2 = w2 + 31 >> 5 << 5;
    }
    if (h2 > maxh)
      maxh = h2;
    if (x2 + w2 >= cw << 5) {
      x2 = 0;
      y2 += maxh;
      maxh = 0;
    }
    if (y2 + h2 >= ch)
      break;
    c2.translate((x2 + (w2 >> 1)) / ratio, (y2 + (h2 >> 1)) / ratio);
    if (d2.rotate)
      c2.rotate(d2.rotate * cloudRadians);
    c2.fillText(d2.text, 0, 0);
    if (d2.padding) {
      c2.lineWidth = 2 * d2.padding;
      c2.strokeText(d2.text, 0, 0);
    }
    c2.restore();
    d2.width = w2;
    d2.height = h2;
    d2.xoff = x2;
    d2.yoff = y2;
    d2.x1 = w2 >> 1;
    d2.y1 = h2 >> 1;
    d2.x0 = -d2.x1;
    d2.y0 = -d2.y1;
    d2.hasText = true;
    x2 += w2;
  }
  var pixels = c2.getImageData(0, 0, (cw << 5) / ratio, ch / ratio).data, sprite = [];
  while (--di2 >= 0) {
    d2 = data2[di2];
    if (!d2.hasText)
      continue;
    var w2 = d2.width, w32 = w2 >> 5;
    var h2 = d2.y1 - d2.y0;
    for (var i2 = 0; i2 < h2 * w32; i2++)
      sprite[i2] = 0;
    x2 = d2.xoff;
    if (x2 == null)
      return;
    y2 = d2.yoff;
    var seen = 0, seenRow = -1;
    for (var j2 = 0; j2 < h2; j2++) {
      for (var i2 = 0; i2 < w2; i2++) {
        var k2 = w32 * j2 + (i2 >> 5), m2 = pixels[(y2 + j2) * (cw << 5) + (x2 + i2) << 2] ? 1 << 31 - i2 % 32 : 0;
        sprite[k2] |= m2;
        seen |= m2;
      }
      if (seen)
        seenRow = j2;
      else {
        d2.y0++;
        h2--;
        j2--;
        y2++;
      }
    }
    d2.y1 = d2.y0 + seenRow;
    d2.sprite = sprite.slice(0, (d2.y1 - d2.y0) * w32);
  }
}
function cloudCollide(tag, board, sw) {
  sw >>= 5;
  var sprite = tag.sprite, w2 = tag.width >> 5, lx = tag.x - (w2 << 4), sx = lx & 127, msx = 32 - sx, h2 = tag.y1 - tag.y0;
  var x2 = (tag.y + tag.y0) * sw + (lx >> 5), last2;
  for (var j2 = 0; j2 < h2; j2++) {
    last2 = 0;
    for (var i2 = 0; i2 <= w2; i2++) {
      if ((last2 << msx | (i2 < w2 ? (last2 = sprite[j2 * w2 + i2]) >>> sx : 0)) & board[x2 + i2])
        return true;
    }
    x2 += sw;
  }
  return false;
}
function cloudBounds(bounds, d2) {
  var b02 = bounds[0], b12 = bounds[1];
  if (d2.x + d2.x0 < b02.x)
    b02.x = d2.x + d2.x0;
  if (d2.y + d2.y0 < b02.y)
    b02.y = d2.y + d2.y0;
  if (d2.x + d2.x1 > b12.x)
    b12.x = d2.x + d2.x1;
  if (d2.y + d2.y1 > b12.y)
    b12.y = d2.y + d2.y1;
}
function collideRects(a2, b10) {
  return a2.x + a2.x1 > b10[0].x && a2.x + a2.x0 < b10[1].x && a2.y + a2.y1 > b10[0].y && a2.y + a2.y0 < b10[1].y;
}
function archimedeanSpiral(size2) {
  var e3 = size2[0] / size2[1];
  return function(t2) {
    return [e3 * (t2 *= 0.1) * Math.cos(t2), t2 * Math.sin(t2)];
  };
}
function rectangularSpiral(size2) {
  var dy = 4, dx = dy * size2[0] / size2[1];
  var x2 = 0, y2 = 0;
  return function(t2) {
    var sign = t2 < 0 ? -1 : 1;
    switch (Math.sqrt(1 + 4 * sign * t2) - sign & 3) {
      case 0:
        x2 += dx;
        break;
      case 1:
        y2 += dy;
        break;
      case 2:
        x2 -= dx;
        break;
      default:
        y2 -= dy;
        break;
    }
    return [x2, y2];
  };
}
function zeroArray(n2) {
  var a2 = [];
  var i2 = -1;
  while (++i2 < n2)
    a2[i2] = 0;
  return a2;
}
function cloudCanvas() {
  return document.createElement("canvas");
}
function functor(d2) {
  return isFunction(d2) ? d2 : function() {
    return d2;
  };
}
var spirals = {
  archimedean: archimedeanSpiral,
  rectangular: rectangularSpiral
};
function tagCloud() {
  var size2 = [256, 256], font = cloudFont, fontSize = cloudFontSize, fontWeight = cloudFontNormal, rotate2 = cloudRotate, padding2 = cloudPadding, spiral = archimedeanSpiral, random = Math.random, words = [], timeInterval = Infinity;
  var text2 = cloudText;
  var fontStyle = cloudFontNormal;
  var canvas = cloudCanvas;
  var cloud = {};
  cloud.start = function() {
    var width = size2[0], height = size2[1];
    var contextAndRatio = getContext(canvas()), board = cloud.board ? cloud.board : zeroArray((size2[0] >> 5) * size2[1]), n2 = words.length, tags = [], data2 = words.map(function(d2, i3, data3) {
      d2.text = text2.call(this, d2, i3, data3);
      d2.font = font.call(this, d2, i3, data3);
      d2.style = fontStyle.call(this, d2, i3, data3);
      d2.weight = fontWeight.call(this, d2, i3, data3);
      d2.rotate = rotate2.call(this, d2, i3, data3);
      d2.size = ~~fontSize.call(this, d2, i3, data3);
      d2.padding = padding2.call(this, d2, i3, data3);
      return d2;
    }).sort(function(a2, b10) {
      return b10.size - a2.size;
    });
    var i2 = -1, bounds = !cloud.board ? null : [
      {
        x: 0,
        y: 0
      },
      {
        x: width,
        y: height
      }
    ];
    step();
    function step() {
      var start = Date.now();
      while (Date.now() - start < timeInterval && ++i2 < n2) {
        var d2 = data2[i2];
        d2.x = width * (random() + 0.5) >> 1;
        d2.y = height * (random() + 0.5) >> 1;
        cloudSprite(contextAndRatio, d2, data2, i2);
        if (d2.hasText && place2(board, d2, bounds)) {
          tags.push(d2);
          if (bounds) {
            if (!cloud.hasImage) {
              cloudBounds(bounds, d2);
            }
          } else {
            bounds = [
              { x: d2.x + d2.x0, y: d2.y + d2.y0 },
              { x: d2.x + d2.x1, y: d2.y + d2.y1 }
            ];
          }
          d2.x -= size2[0] >> 1;
          d2.y -= size2[1] >> 1;
        }
      }
      cloud._tags = tags;
      cloud._bounds = bounds;
    }
    return cloud;
  };
  function getContext(canvas2) {
    canvas2.width = canvas2.height = 1;
    var ratio = Math.sqrt(canvas2.getContext("2d").getImageData(0, 0, 1, 1).data.length >> 2);
    canvas2.width = (cw << 5) / ratio;
    canvas2.height = ch / ratio;
    var context2 = canvas2.getContext("2d");
    context2.fillStyle = context2.strokeStyle = "red";
    context2.textAlign = "center";
    return { context: context2, ratio };
  }
  function place2(board, tag, bounds) {
    var startX = tag.x, startY = tag.y, maxDelta = Math.sqrt(size2[0] * size2[0] + size2[1] * size2[1]), s2 = spiral(size2), dt = random() < 0.5 ? 1 : -1;
    var dxdy, t2 = -dt, dx, dy;
    while (dxdy = s2(t2 += dt)) {
      dx = ~~dxdy[0];
      dy = ~~dxdy[1];
      if (Math.min(Math.abs(dx), Math.abs(dy)) >= maxDelta)
        break;
      tag.x = startX + dx;
      tag.y = startY + dy;
      if (tag.x + tag.x0 < 0 || tag.y + tag.y0 < 0 || tag.x + tag.x1 > size2[0] || tag.y + tag.y1 > size2[1])
        continue;
      if (!bounds || !cloudCollide(tag, board, size2[0])) {
        if (!bounds || collideRects(tag, bounds)) {
          var sprite = tag.sprite, w2 = tag.width >> 5, sw = size2[0] >> 5, lx = tag.x - (w2 << 4), sx = lx & 127, msx = 32 - sx, h2 = tag.y1 - tag.y0;
          var last2 = void 0, x2 = (tag.y + tag.y0) * sw + (lx >> 5);
          for (var j2 = 0; j2 < h2; j2++) {
            last2 = 0;
            for (var i2 = 0; i2 <= w2; i2++) {
              board[x2 + i2] |= last2 << msx | (i2 < w2 ? (last2 = sprite[j2 * w2 + i2]) >>> sx : 0);
            }
            x2 += sw;
          }
          delete tag.sprite;
          return true;
        }
      }
    }
    return false;
  }
  cloud.createMask = function(img) {
    var can = document.createElement("canvas");
    var width = size2[0], height = size2[1];
    if (!width || !height) {
      return;
    }
    var w32 = width >> 5;
    var board = zeroArray((width >> 5) * height);
    can.width = width;
    can.height = height;
    var cxt = can.getContext("2d");
    cxt.drawImage(img, 0, 0, img.width, img.height, 0, 0, width, height);
    var imageData = cxt.getImageData(0, 0, width, height).data;
    for (var j2 = 0; j2 < height; j2++) {
      for (var i2 = 0; i2 < width; i2++) {
        var k2 = w32 * j2 + (i2 >> 5);
        var tmp = j2 * width + i2 << 2;
        var flag = imageData[tmp] >= 250 && imageData[tmp + 1] >= 250 && imageData[tmp + 2] >= 250;
        var m2 = flag ? 1 << 31 - i2 % 32 : 0;
        board[k2] |= m2;
      }
    }
    cloud.board = board;
    cloud.hasImage = true;
  };
  cloud.timeInterval = function(_2) {
    timeInterval = _2 == null ? Infinity : _2;
  };
  cloud.words = function(_2) {
    words = _2;
  };
  cloud.size = function(_2) {
    size2 = [+_2[0], +_2[1]];
  };
  cloud.font = function(_2) {
    font = functor(_2);
  };
  cloud.fontWeight = function(_2) {
    fontWeight = functor(_2);
  };
  cloud.rotate = function(_2) {
    rotate2 = functor(_2);
  };
  cloud.spiral = function(_2) {
    spiral = spirals[_2] || _2;
  };
  cloud.fontSize = function(_2) {
    fontSize = functor(_2);
  };
  cloud.padding = function(_2) {
    padding2 = functor(_2);
  };
  cloud.random = function(_2) {
    random = functor(_2);
  };
  return cloud;
}
function transform(params) {
  var rawOptions = params.options, chart = params.chart;
  var _a2 = chart, width = _a2.width, height = _a2.height, chartPadding = _a2.padding, appendPadding = _a2.appendPadding, ele = _a2.ele;
  var data2 = rawOptions.data, imageMask = rawOptions.imageMask, wordField = rawOptions.wordField, weightField = rawOptions.weightField, colorField = rawOptions.colorField, wordStyle = rawOptions.wordStyle, timeInterval = rawOptions.timeInterval, random = rawOptions.random, spiral = rawOptions.spiral, _b = rawOptions.autoFit, autoFit = _b === void 0 ? true : _b, placementStrategy = rawOptions.placementStrategy;
  if (!data2 || !data2.length) {
    return [];
  }
  var fontFamily = wordStyle.fontFamily, fontWeight = wordStyle.fontWeight, padding2 = wordStyle.padding, fontSize = wordStyle.fontSize;
  var arr = getSingleKeyValues(data2, weightField);
  var range3 = [min(arr), max(arr)];
  var words = data2.map(function(datum) {
    return {
      text: datum[wordField],
      value: datum[weightField],
      color: datum[colorField],
      datum
    };
  });
  var options = {
    imageMask,
    font: fontFamily,
    fontSize: getFontSizeMapping(fontSize, range3),
    fontWeight,
    size: getSize({
      width,
      height,
      padding: chartPadding,
      appendPadding,
      autoFit,
      container: ele
    }),
    padding: padding2,
    timeInterval,
    random,
    spiral,
    rotate: getRotate(rawOptions)
  };
  if (isFunction(placementStrategy)) {
    var result = words.map(function(word2, index2, words2) {
      return __assign$4(__assign$4(__assign$4({}, word2), { hasText: !!word2.text, font: functor(options.font)(word2, index2, words2), weight: functor(options.fontWeight)(word2, index2, words2), rotate: functor(options.rotate)(word2, index2, words2), size: functor(options.fontSize)(word2, index2, words2), style: "normal" }), placementStrategy.call(chart, word2, index2, words2));
    });
    result.push({
      text: "",
      value: 0,
      x: 0,
      y: 0,
      opacity: 0
    });
    result.push({
      text: "",
      value: 0,
      x: options.size[0],
      y: options.size[1],
      opacity: 0
    });
    return result;
  }
  return wordCloud(words, options);
}
function getSize(options) {
  var width = options.width, height = options.height;
  var container = options.container, autoFit = options.autoFit, padding2 = options.padding, appendPadding = options.appendPadding;
  if (autoFit) {
    var containerSize = getContainerSize(container);
    width = containerSize.width;
    height = containerSize.height;
  }
  width = width || 400;
  height = height || 400;
  var _a2 = resolvePadding({ padding: padding2, appendPadding }), top = _a2[0], right2 = _a2[1], bottom = _a2[2], left2 = _a2[3];
  var result = [width - (left2 + right2), height - (top + bottom)];
  return result;
}
function resolvePadding(options) {
  var padding2 = normalPadding(options.padding);
  var appendPadding = normalPadding(options.appendPadding);
  var top = padding2[0] + appendPadding[0];
  var right2 = padding2[1] + appendPadding[1];
  var bottom = padding2[2] + appendPadding[2];
  var left2 = padding2[3] + appendPadding[3];
  return [top, right2, bottom, left2];
}
function processImageMask(img) {
  return new Promise(function(res, rej) {
    if (img instanceof HTMLImageElement) {
      res(img);
      return;
    }
    if (isString(img)) {
      var image_1 = new Image();
      image_1.crossOrigin = "anonymous";
      image_1.src = img;
      image_1.onload = function() {
        res(image_1);
      };
      image_1.onerror = function() {
        log(LEVEL.ERROR, false, "image %s load failed !!!", img);
        rej();
      };
      return;
    }
    log(LEVEL.WARN, img === void 0, "The type of imageMask option must be String or HTMLImageElement.");
    rej();
  });
}
function getFontSizeMapping(fontSize, range3) {
  if (isFunction(fontSize)) {
    return fontSize;
  }
  if (isArray$1(fontSize)) {
    var fMin_1 = fontSize[0], fMax_1 = fontSize[1];
    if (!range3) {
      return function() {
        return (fMax_1 + fMin_1) / 2;
      };
    }
    var min_1 = range3[0], max_1 = range3[1];
    if (max_1 === min_1) {
      return function() {
        return (fMax_1 + fMin_1) / 2;
      };
    }
    return function fontSize2(_a2) {
      var value2 = _a2.value;
      return (fMax_1 - fMin_1) / (max_1 - min_1) * (value2 - min_1) + fMin_1;
    };
  }
  return function() {
    return fontSize;
  };
}
function getSingleKeyValues(data2, key2) {
  return data2.map(function(v2) {
    return v2[key2];
  }).filter(function(v2) {
    if (typeof v2 === "number" && !isNaN(v2))
      return true;
    return false;
  });
}
function getRotate(options) {
  var _a2 = resolveRotate(options), rotation = _a2.rotation, rotationSteps = _a2.rotationSteps;
  if (!isArray$1(rotation))
    return rotation;
  var min2 = rotation[0];
  var max2 = rotation[1];
  var perSize = rotationSteps === 1 ? 0 : (max2 - min2) / (rotationSteps - 1);
  return function rotate2() {
    if (max2 === min2)
      return max2;
    return Math.floor(Math.random() * rotationSteps) * perSize;
  };
}
function resolveRotate(options) {
  var rotationSteps = options.wordStyle.rotationSteps;
  if (rotationSteps < 1) {
    log(LEVEL.WARN, false, "The rotationSteps option must be greater than or equal to 1.");
    rotationSteps = 1;
  }
  return {
    rotation: options.wordStyle.rotation,
    rotationSteps
  };
}
function min(numbers) {
  return Math.min.apply(Math, numbers);
}
function max(numbers) {
  return Math.max.apply(Math, numbers);
}
var WORD_CLOUD_COLOR_FIELD = "color";
var DEFAULT_OPTIONS$s = deepAssign({}, Plot.getDefaultOptions(), {
  timeInterval: 2e3,
  legend: false,
  tooltip: {
    showTitle: false,
    showMarkers: false,
    showCrosshairs: false,
    fields: ["text", "value", WORD_CLOUD_COLOR_FIELD],
    formatter: function(datum) {
      return { name: datum.text, value: datum.value };
    }
  },
  wordStyle: {
    fontFamily: "Verdana",
    fontWeight: "normal",
    padding: 1,
    fontSize: [12, 60],
    rotation: [0, 90],
    rotationSteps: 2,
    rotateRatio: 0.5
  }
});
function geometry$q(params) {
  var chart = params.chart, options = params.options;
  var colorField = options.colorField, color2 = options.color;
  var data2 = transform(params);
  chart.data(data2);
  var p2 = deepAssign({}, params, {
    options: {
      xField: "x",
      yField: "y",
      seriesField: colorField && WORD_CLOUD_COLOR_FIELD,
      rawFields: isFunction(color2) && __spreadArrays(get(options, "rawFields", []), ["datum"]),
      point: {
        color: color2,
        shape: "word-cloud"
      }
    }
  });
  var ext = point(p2).ext;
  ext.geometry.label(false);
  chart.coordinate().reflect("y");
  chart.axis(false);
  return params;
}
function meta$h(params) {
  return flow(scale$2({
    x: { nice: false },
    y: { nice: false }
  }))(params);
}
function legend$b(params) {
  var chart = params.chart, options = params.options;
  var legend2 = options.legend, colorField = options.colorField;
  if (legend2 === false) {
    chart.legend(false);
  } else if (colorField) {
    chart.legend(WORD_CLOUD_COLOR_FIELD, legend2);
  }
  return params;
}
function adaptor$s(params) {
  flow(geometry$q, meta$h, tooltip$9, legend$b, interaction$7, animation$5, theme$2, state)(params);
}
registerShape("point", "word-cloud", {
  draw: function(cfg, group2) {
    var cx = cfg.x;
    var cy = cfg.y;
    var shape = group2.addShape("text", {
      attrs: __assign$4(__assign$4({}, getTextAttrs(cfg)), { x: cx, y: cy })
    });
    var rotate2 = cfg.data.rotate;
    if (typeof rotate2 === "number") {
      Util.rotate(shape, rotate2 * Math.PI / 180);
    }
    return shape;
  }
});
function getTextAttrs(cfg) {
  return {
    fontSize: cfg.data.size,
    text: cfg.data.text,
    textAlign: "center",
    fontFamily: cfg.data.font,
    fontWeight: cfg.data.weight,
    fill: cfg.color || cfg.defaultStyle.stroke,
    textBaseline: "alphabetic"
  };
}
(function(_super) {
  __extends$3(WordCloud, _super);
  function WordCloud() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "word-cloud";
    return _this;
  }
  WordCloud.getDefaultOptions = function() {
    return DEFAULT_OPTIONS$s;
  };
  WordCloud.prototype.changeData = function(data2) {
    this.updateOption({ data: data2 });
    if (this.options.imageMask) {
      this.render();
    } else {
      this.chart.changeData(transform({ chart: this.chart, options: this.options }));
    }
  };
  WordCloud.prototype.getDefaultOptions = function() {
    return WordCloud.getDefaultOptions();
  };
  WordCloud.prototype.render = function() {
    var _this = this;
    return new Promise(function(res) {
      var imageMask = _this.options.imageMask;
      if (!imageMask) {
        _super.prototype.render.call(_this);
        res();
        return;
      }
      var handler = function(img) {
        _this.options = __assign$4(__assign$4({}, _this.options), { imageMask: img || null });
        _super.prototype.render.call(_this);
        res();
      };
      processImageMask(imageMask).then(handler).catch(handler);
    });
  };
  WordCloud.prototype.getSchemaAdaptor = function() {
    return adaptor$s;
  };
  WordCloud.prototype.triggerResize = function() {
    var _this = this;
    if (!this.chart.destroyed) {
      this.execAdaptor();
      window.setTimeout(function() {
        _super.prototype.triggerResize.call(_this);
      });
    }
  };
  return WordCloud;
})(Plot);
function _slicedToArray(arr, i2) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i2) || _nonIterableRest();
}
function _arrayWithHoles(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _iterableToArrayLimit(arr, i2) {
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = void 0;
  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i2 && _arr.length === i2)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}
function points(data2, x2, y2, sort) {
  data2 = data2.filter(function(d3, i3) {
    var u2 = x2(d3, i3), v2 = y2(d3, i3);
    return u2 != null && isFinite(u2) && v2 != null && isFinite(v2);
  });
  if (sort) {
    data2.sort(function(a2, b10) {
      return x2(a2) - x2(b10);
    });
  }
  var n2 = data2.length, X2 = new Float64Array(n2), Y2 = new Float64Array(n2);
  var ux = 0, uy = 0, xv, yv, d2;
  for (var i2 = 0; i2 < n2; ) {
    d2 = data2[i2];
    X2[i2] = xv = +x2(d2, i2, data2);
    Y2[i2] = yv = +y2(d2, i2, data2);
    ++i2;
    ux += (xv - ux) / i2;
    uy += (yv - uy) / i2;
  }
  for (var _i = 0; _i < n2; ++_i) {
    X2[_i] -= ux;
    Y2[_i] -= uy;
  }
  return [X2, Y2, ux, uy];
}
function visitPoints(data2, x2, y2, cb2) {
  var iterations = 0;
  for (var i2 = 0, n2 = data2.length; i2 < n2; i2++) {
    var d2 = data2[i2], dx = +x2(d2, i2, data2), dy = +y2(d2, i2, data2);
    if (dx != null && isFinite(dx) && dy != null && isFinite(dy)) {
      cb2(dx, dy, iterations++);
    }
  }
}
function determination(data2, x2, y2, uY, predict) {
  var SSE = 0, SST = 0;
  visitPoints(data2, x2, y2, function(dx, dy) {
    var sse = dy - predict(dx), sst = dy - uY;
    SSE += sse * sse;
    SST += sst * sst;
  });
  return 1 - SSE / SST;
}
function angle(line2) {
  return Math.atan2(line2[1][1] - line2[0][1], line2[1][0] - line2[0][0]) * 180 / Math.PI;
}
function midpoint(line2) {
  return [(line2[0][0] + line2[1][0]) / 2, (line2[0][1] + line2[1][1]) / 2];
}
function interpose(xmin, xmax, predict) {
  var l2 = Math.log(xmax - xmin) * Math.LOG10E + 1 | 0;
  var precision = 1 * Math.pow(10, -l2 / 2 - 1), maxIter = 1e4;
  var points2 = [px(xmin), px(xmax)], iter = 0;
  while (find2(points2) && iter < maxIter) {
  }
  return points2;
  function px(x2) {
    return [x2, predict(x2)];
  }
  function find2(points3) {
    iter++;
    var n2 = points3.length;
    var found = false;
    for (var i2 = 0; i2 < n2 - 1; i2++) {
      var p0 = points3[i2], p1 = points3[i2 + 1], m2 = midpoint([p0, p1]), mp = px(m2[0]), a0 = angle([p0, m2]), a1 = angle([p0, mp]), a2 = Math.abs(a0 - a1);
      if (a2 > precision) {
        points3.splice(i2 + 1, 0, mp);
        found = true;
      }
    }
    return found;
  }
}
function ols(uX, uY, uXY, uX2) {
  var delta = uX2 - uX * uX, slope = Math.abs(delta) < 1e-24 ? 0 : (uXY - uX * uY) / delta, intercept = uY - slope * uX;
  return [intercept, slope];
}
function exponential() {
  var x2 = function x3(d2) {
    return d2[0];
  }, y2 = function y3(d2) {
    return d2[1];
  }, domain;
  function exponential2(data2) {
    var n2 = 0, Y2 = 0, YL = 0, XY = 0, XYL = 0, X2Y = 0, xmin = domain ? +domain[0] : Infinity, xmax = domain ? +domain[1] : -Infinity;
    visitPoints(data2, x2, y2, function(dx, dy) {
      var ly = Math.log(dy), xy = dx * dy;
      ++n2;
      Y2 += (dy - Y2) / n2;
      XY += (xy - XY) / n2;
      X2Y += (dx * xy - X2Y) / n2;
      YL += (dy * ly - YL) / n2;
      XYL += (xy * ly - XYL) / n2;
      if (!domain) {
        if (dx < xmin)
          xmin = dx;
        if (dx > xmax)
          xmax = dx;
      }
    });
    var _ols = ols(XY / Y2, YL / Y2, XYL / Y2, X2Y / Y2), _ols2 = _slicedToArray(_ols, 2), a2 = _ols2[0], b10 = _ols2[1];
    a2 = Math.exp(a2);
    var fn2 = function fn3(x3) {
      return a2 * Math.exp(b10 * x3);
    }, out = interpose(xmin, xmax, fn2);
    out.a = a2;
    out.b = b10;
    out.predict = fn2;
    out.rSquared = determination(data2, x2, y2, Y2, fn2);
    return out;
  }
  exponential2.domain = function(arr) {
    return arguments.length ? (domain = arr, exponential2) : domain;
  };
  exponential2.x = function(fn2) {
    return arguments.length ? (x2 = fn2, exponential2) : x2;
  };
  exponential2.y = function(fn2) {
    return arguments.length ? (y2 = fn2, exponential2) : y2;
  };
  return exponential2;
}
function linear() {
  var x2 = function x3(d2) {
    return d2[0];
  }, y2 = function y3(d2) {
    return d2[1];
  }, domain;
  function linear2(data2) {
    var n2 = 0, X2 = 0, Y2 = 0, XY = 0, X22 = 0, xmin = domain ? +domain[0] : Infinity, xmax = domain ? +domain[1] : -Infinity;
    visitPoints(data2, x2, y2, function(dx, dy) {
      ++n2;
      X2 += (dx - X2) / n2;
      Y2 += (dy - Y2) / n2;
      XY += (dx * dy - XY) / n2;
      X22 += (dx * dx - X22) / n2;
      if (!domain) {
        if (dx < xmin)
          xmin = dx;
        if (dx > xmax)
          xmax = dx;
      }
    });
    var _ols = ols(X2, Y2, XY, X22), _ols2 = _slicedToArray(_ols, 2), intercept = _ols2[0], slope = _ols2[1], fn2 = function fn3(x3) {
      return slope * x3 + intercept;
    }, out = [[xmin, fn2(xmin)], [xmax, fn2(xmax)]];
    out.a = slope;
    out.b = intercept;
    out.predict = fn2;
    out.rSquared = determination(data2, x2, y2, Y2, fn2);
    return out;
  }
  linear2.domain = function(arr) {
    return arguments.length ? (domain = arr, linear2) : domain;
  };
  linear2.x = function(fn2) {
    return arguments.length ? (x2 = fn2, linear2) : x2;
  };
  linear2.y = function(fn2) {
    return arguments.length ? (y2 = fn2, linear2) : y2;
  };
  return linear2;
}
function median(arr) {
  arr.sort(function(a2, b10) {
    return a2 - b10;
  });
  var i2 = arr.length / 2;
  return i2 % 1 === 0 ? (arr[i2 - 1] + arr[i2]) / 2 : arr[Math.floor(i2)];
}
var maxiters = 2, epsilon = 1e-12;
function loess() {
  var x2 = function x3(d2) {
    return d2[0];
  }, y2 = function y3(d2) {
    return d2[1];
  }, bandwidth = 0.3;
  function loess2(data2) {
    var _points = points(data2, x2, y2, true), _points2 = _slicedToArray(_points, 4), xv = _points2[0], yv = _points2[1], ux = _points2[2], uy = _points2[3], n2 = xv.length, bw = Math.max(2, ~~(bandwidth * n2)), yhat = new Float64Array(n2), residuals = new Float64Array(n2), robustWeights = new Float64Array(n2).fill(1);
    for (var iter = -1; ++iter <= maxiters; ) {
      var interval2 = [0, bw - 1];
      for (var i2 = 0; i2 < n2; ++i2) {
        var dx = xv[i2], i0 = interval2[0], i1 = interval2[1], edge2 = dx - xv[i0] > xv[i1] - dx ? i0 : i1;
        var W2 = 0, X2 = 0, Y2 = 0, XY = 0, X22 = 0, denom = 1 / Math.abs(xv[edge2] - dx || 1);
        for (var k2 = i0; k2 <= i1; ++k2) {
          var xk2 = xv[k2], yk2 = yv[k2], w2 = tricube(Math.abs(dx - xk2) * denom) * robustWeights[k2], xkw = xk2 * w2;
          W2 += w2;
          X2 += xkw;
          Y2 += yk2 * w2;
          XY += yk2 * xkw;
          X22 += xk2 * xkw;
        }
        var _ols = ols(X2 / W2, Y2 / W2, XY / W2, X22 / W2), _ols2 = _slicedToArray(_ols, 2), a2 = _ols2[0], b10 = _ols2[1];
        yhat[i2] = a2 + b10 * dx;
        residuals[i2] = Math.abs(yv[i2] - yhat[i2]);
        updateInterval(xv, i2 + 1, interval2);
      }
      if (iter === maxiters) {
        break;
      }
      var medianResidual = median(residuals);
      if (Math.abs(medianResidual) < epsilon)
        break;
      for (var _i = 0, arg, _w; _i < n2; ++_i) {
        arg = residuals[_i] / (6 * medianResidual);
        robustWeights[_i] = arg >= 1 ? epsilon : (_w = 1 - arg * arg) * _w;
      }
    }
    return output(xv, yhat, ux, uy);
  }
  loess2.bandwidth = function(bw) {
    return arguments.length ? (bandwidth = bw, loess2) : bandwidth;
  };
  loess2.x = function(fn2) {
    return arguments.length ? (x2 = fn2, loess2) : x2;
  };
  loess2.y = function(fn2) {
    return arguments.length ? (y2 = fn2, loess2) : y2;
  };
  return loess2;
}
function tricube(x2) {
  return (x2 = 1 - x2 * x2 * x2) * x2 * x2;
}
function updateInterval(xv, i2, interval2) {
  var val = xv[i2], left2 = interval2[0], right2 = interval2[1] + 1;
  if (right2 >= xv.length)
    return;
  while (i2 > left2 && xv[right2] - val <= val - xv[left2]) {
    interval2[0] = ++left2;
    interval2[1] = right2;
    ++right2;
  }
}
function output(xv, yhat, ux, uy) {
  var n2 = xv.length, out = [];
  var i2 = 0, cnt = 0, prev = [], v2;
  for (; i2 < n2; ++i2) {
    v2 = xv[i2] + ux;
    if (prev[0] === v2) {
      prev[1] += (yhat[i2] - prev[1]) / ++cnt;
    } else {
      cnt = 0;
      prev[1] += uy;
      prev = [v2, yhat[i2]];
      out.push(prev);
    }
  }
  prev[1] += uy;
  return out;
}
function logarithmic() {
  var x2 = function x3(d2) {
    return d2[0];
  }, y2 = function y3(d2) {
    return d2[1];
  }, base = Math.E, domain;
  function logarithmic2(data2) {
    var n2 = 0, X2 = 0, Y2 = 0, XY = 0, X22 = 0, xmin = domain ? +domain[0] : Infinity, xmax = domain ? +domain[1] : -Infinity, lb2 = Math.log(base);
    visitPoints(data2, x2, y2, function(dx, dy) {
      var lx = Math.log(dx) / lb2;
      ++n2;
      X2 += (lx - X2) / n2;
      Y2 += (dy - Y2) / n2;
      XY += (lx * dy - XY) / n2;
      X22 += (lx * lx - X22) / n2;
      if (!domain) {
        if (dx < xmin)
          xmin = dx;
        if (dx > xmax)
          xmax = dx;
      }
    });
    var _ols = ols(X2, Y2, XY, X22), _ols2 = _slicedToArray(_ols, 2), intercept = _ols2[0], slope = _ols2[1], fn2 = function fn3(x3) {
      return slope * Math.log(x3) / lb2 + intercept;
    }, out = interpose(xmin, xmax, fn2);
    out.a = slope;
    out.b = intercept;
    out.predict = fn2;
    out.rSquared = determination(data2, x2, y2, Y2, fn2);
    return out;
  }
  logarithmic2.domain = function(arr) {
    return arguments.length ? (domain = arr, logarithmic2) : domain;
  };
  logarithmic2.x = function(fn2) {
    return arguments.length ? (x2 = fn2, logarithmic2) : x2;
  };
  logarithmic2.y = function(fn2) {
    return arguments.length ? (y2 = fn2, logarithmic2) : y2;
  };
  logarithmic2.base = function(n2) {
    return arguments.length ? (base = n2, logarithmic2) : base;
  };
  return logarithmic2;
}
function quad() {
  var x2 = function x3(d2) {
    return d2[0];
  }, y2 = function y3(d2) {
    return d2[1];
  }, domain;
  function quadratic(data2) {
    var _points = points(data2, x2, y2), _points2 = _slicedToArray(_points, 4), xv = _points2[0], yv = _points2[1], ux = _points2[2], uy = _points2[3], n2 = xv.length;
    var X2 = 0, X3 = 0, X4 = 0, XY = 0, X2Y = 0, i2, dx, dy, x22;
    for (i2 = 0; i2 < n2; ) {
      dx = xv[i2];
      dy = yv[i2++];
      x22 = dx * dx;
      X2 += (x22 - X2) / i2;
      X3 += (x22 * dx - X3) / i2;
      X4 += (x22 * x22 - X4) / i2;
      XY += (dx * dy - XY) / i2;
      X2Y += (x22 * dy - X2Y) / i2;
    }
    var Y2 = 0, n0 = 0, xmin = domain ? +domain[0] : Infinity, xmax = domain ? +domain[1] : -Infinity;
    visitPoints(data2, x2, y2, function(dx2, dy2) {
      n0++;
      Y2 += (dy2 - Y2) / n0;
      if (!domain) {
        if (dx2 < xmin)
          xmin = dx2;
        if (dx2 > xmax)
          xmax = dx2;
      }
    });
    var X2X2 = X4 - X2 * X2, d2 = X2 * X2X2 - X3 * X3, a2 = (X2Y * X2 - XY * X3) / d2, b10 = (XY * X2X2 - X2Y * X3) / d2, c2 = -a2 * X2, fn2 = function fn3(x3) {
      x3 = x3 - ux;
      return a2 * x3 * x3 + b10 * x3 + c2 + uy;
    };
    var out = interpose(xmin, xmax, fn2);
    out.a = a2;
    out.b = b10 - 2 * a2 * ux;
    out.c = c2 - b10 * ux + a2 * ux * ux + uy;
    out.predict = fn2;
    out.rSquared = determination(data2, x2, y2, Y2, fn2);
    return out;
  }
  quadratic.domain = function(arr) {
    return arguments.length ? (domain = arr, quadratic) : domain;
  };
  quadratic.x = function(fn2) {
    return arguments.length ? (x2 = fn2, quadratic) : x2;
  };
  quadratic.y = function(fn2) {
    return arguments.length ? (y2 = fn2, quadratic) : y2;
  };
  return quadratic;
}
function polynomial() {
  var x2 = function x3(d2) {
    return d2[0];
  }, y2 = function y3(d2) {
    return d2[1];
  }, order = 3, domain;
  function polynomial2(data2) {
    if (order === 1) {
      var o2 = linear().x(x2).y(y2).domain(domain)(data2);
      o2.coefficients = [o2.b, o2.a];
      delete o2.a;
      delete o2.b;
      return o2;
    }
    if (order === 2) {
      var _o = quad().x(x2).y(y2).domain(domain)(data2);
      _o.coefficients = [_o.c, _o.b, _o.a];
      delete _o.a;
      delete _o.b;
      delete _o.c;
      return _o;
    }
    var _points = points(data2, x2, y2), _points2 = _slicedToArray(_points, 4), xv = _points2[0], yv = _points2[1], ux = _points2[2], uy = _points2[3], n2 = xv.length, lhs = [], rhs = [], k2 = order + 1;
    var Y2 = 0, n0 = 0, xmin = domain ? +domain[0] : Infinity, xmax = domain ? +domain[1] : -Infinity;
    visitPoints(data2, x2, y2, function(dx, dy) {
      ++n0;
      Y2 += (dy - Y2) / n0;
      if (!domain) {
        if (dx < xmin)
          xmin = dx;
        if (dx > xmax)
          xmax = dx;
      }
    });
    var i2, j2, l2, v2, c2;
    for (i2 = 0; i2 < k2; ++i2) {
      for (l2 = 0, v2 = 0; l2 < n2; ++l2) {
        v2 += Math.pow(xv[l2], i2) * yv[l2];
      }
      lhs.push(v2);
      c2 = new Float64Array(k2);
      for (j2 = 0; j2 < k2; ++j2) {
        for (l2 = 0, v2 = 0; l2 < n2; ++l2) {
          v2 += Math.pow(xv[l2], i2 + j2);
        }
        c2[j2] = v2;
      }
      rhs.push(c2);
    }
    rhs.push(lhs);
    var coef = gaussianElimination(rhs), fn2 = function fn3(x3) {
      x3 -= ux;
      var y3 = uy + coef[0] + coef[1] * x3 + coef[2] * x3 * x3;
      for (i2 = 3; i2 < k2; ++i2) {
        y3 += coef[i2] * Math.pow(x3, i2);
      }
      return y3;
    }, out = interpose(xmin, xmax, fn2);
    out.coefficients = uncenter(k2, coef, -ux, uy);
    out.predict = fn2;
    out.rSquared = determination(data2, x2, y2, Y2, fn2);
    return out;
  }
  polynomial2.domain = function(arr) {
    return arguments.length ? (domain = arr, polynomial2) : domain;
  };
  polynomial2.x = function(fn2) {
    return arguments.length ? (x2 = fn2, polynomial2) : x2;
  };
  polynomial2.y = function(fn2) {
    return arguments.length ? (y2 = fn2, polynomial2) : y2;
  };
  polynomial2.order = function(n2) {
    return arguments.length ? (order = n2, polynomial2) : order;
  };
  return polynomial2;
}
function uncenter(k2, a2, x2, y2) {
  var z2 = Array(k2);
  var i2, j2, v2, c2;
  for (i2 = 0; i2 < k2; ++i2) {
    z2[i2] = 0;
  }
  for (i2 = k2 - 1; i2 >= 0; --i2) {
    v2 = a2[i2];
    c2 = 1;
    z2[i2] += v2;
    for (j2 = 1; j2 <= i2; ++j2) {
      c2 *= (i2 + 1 - j2) / j2;
      z2[i2 - j2] += v2 * Math.pow(x2, j2) * c2;
    }
  }
  z2[0] += y2;
  return z2;
}
function gaussianElimination(matrix) {
  var n2 = matrix.length - 1, coef = [];
  var i2, j2, k2, r2, t2;
  for (i2 = 0; i2 < n2; ++i2) {
    r2 = i2;
    for (j2 = i2 + 1; j2 < n2; ++j2) {
      if (Math.abs(matrix[i2][j2]) > Math.abs(matrix[i2][r2])) {
        r2 = j2;
      }
    }
    for (k2 = i2; k2 < n2 + 1; ++k2) {
      t2 = matrix[k2][i2];
      matrix[k2][i2] = matrix[k2][r2];
      matrix[k2][r2] = t2;
    }
    for (j2 = i2 + 1; j2 < n2; ++j2) {
      for (k2 = n2; k2 >= i2; k2--) {
        matrix[k2][j2] -= matrix[k2][i2] * matrix[i2][j2] / matrix[i2][i2];
      }
    }
  }
  for (j2 = n2 - 1; j2 >= 0; --j2) {
    t2 = 0;
    for (k2 = j2 + 1; k2 < n2; ++k2) {
      t2 += matrix[k2][j2] * coef[k2];
    }
    coef[j2] = (matrix[n2][j2] - t2) / matrix[j2][j2];
  }
  return coef;
}
function power() {
  var x2 = function x3(d2) {
    return d2[0];
  }, y2 = function y3(d2) {
    return d2[1];
  }, domain;
  function power2(data2) {
    var n2 = 0, X2 = 0, Y2 = 0, XY = 0, X22 = 0, YS = 0, xmin = domain ? +domain[0] : Infinity, xmax = domain ? +domain[1] : -Infinity;
    visitPoints(data2, x2, y2, function(dx, dy) {
      var lx = Math.log(dx), ly = Math.log(dy);
      ++n2;
      X2 += (lx - X2) / n2;
      Y2 += (ly - Y2) / n2;
      XY += (lx * ly - XY) / n2;
      X22 += (lx * lx - X22) / n2;
      YS += (dy - YS) / n2;
      if (!domain) {
        if (dx < xmin)
          xmin = dx;
        if (dx > xmax)
          xmax = dx;
      }
    });
    var _ols = ols(X2, Y2, XY, X22), _ols2 = _slicedToArray(_ols, 2), a2 = _ols2[0], b10 = _ols2[1];
    a2 = Math.exp(a2);
    var fn2 = function fn3(x3) {
      return a2 * Math.pow(x3, b10);
    }, out = interpose(xmin, xmax, fn2);
    out.a = a2;
    out.b = b10;
    out.predict = fn2;
    out.rSquared = determination(data2, x2, y2, YS, fn2);
    return out;
  }
  power2.domain = function(arr) {
    return arguments.length ? (domain = arr, power2) : domain;
  };
  power2.x = function(fn2) {
    return arguments.length ? (x2 = fn2, power2) : x2;
  };
  power2.y = function(fn2) {
    return arguments.length ? (y2 = fn2, power2) : y2;
  };
  return power2;
}
var REGRESSION_MAP = {
  exp: exponential,
  linear,
  loess,
  log: logarithmic,
  poly: polynomial,
  pow: power,
  quad
};
function getQuadrantDefaultConfig(xBaseline, yBaseline) {
  var textOffset = 10;
  var defaultConfig = {
    regionStyle: [
      {
        position: {
          start: [xBaseline, "max"],
          end: ["max", yBaseline]
        },
        style: {
          fill: "#d8d0c0",
          opacity: 0.4
        }
      },
      {
        position: {
          start: ["min", "max"],
          end: [xBaseline, yBaseline]
        },
        style: {
          fill: "#a3dda1",
          opacity: 0.4
        }
      },
      {
        position: {
          start: ["min", yBaseline],
          end: [xBaseline, "min"]
        },
        style: {
          fill: "#d8d0c0",
          opacity: 0.4
        }
      },
      {
        position: {
          start: [xBaseline, yBaseline],
          end: ["max", "min"]
        },
        style: {
          fill: "#a3dda1",
          opacity: 0.4
        }
      }
    ],
    lineStyle: {
      stroke: "#9ba29a",
      lineWidth: 1
    },
    labelStyle: [
      {
        position: ["max", yBaseline],
        offsetX: -textOffset,
        offsetY: -textOffset,
        style: {
          textAlign: "right",
          textBaseline: "bottom",
          fontSize: 14,
          fill: "#ccc"
        }
      },
      {
        position: ["min", yBaseline],
        offsetX: textOffset,
        offsetY: -textOffset,
        style: {
          textAlign: "left",
          textBaseline: "bottom",
          fontSize: 14,
          fill: "#ccc"
        }
      },
      {
        position: ["min", yBaseline],
        offsetX: textOffset,
        offsetY: textOffset,
        style: {
          textAlign: "left",
          textBaseline: "top",
          fontSize: 14,
          fill: "#ccc"
        }
      },
      {
        position: ["max", yBaseline],
        offsetX: -textOffset,
        offsetY: textOffset,
        style: {
          textAlign: "right",
          textBaseline: "top",
          fontSize: 14,
          fill: "#ccc"
        }
      }
    ]
  };
  return defaultConfig;
}
var splinePath = function(data2, config) {
  var view = config.view, _a2 = config.options, xField = _a2.xField, yField = _a2.yField;
  var xScaleView = view.getScaleByField(xField);
  var yScaleView = view.getScaleByField(yField);
  var pathData = data2.map(function(d2) {
    return view.getCoordinate().convert({ x: xScaleView.scale(d2[0]), y: yScaleView.scale(d2[1]) });
  });
  return getSplinePath(pathData, false);
};
var getPath = function(config) {
  var options = config.options;
  var xField = options.xField, yField = options.yField, data2 = options.data, regressionLine2 = options.regressionLine;
  var _a2 = regressionLine2.type, type4 = _a2 === void 0 ? "linear" : _a2, algorithm = regressionLine2.algorithm;
  var pathData;
  if (algorithm) {
    pathData = isArray$1(algorithm) ? algorithm : algorithm(data2);
  } else {
    var reg = REGRESSION_MAP[type4]().x(function(d2) {
      return d2[xField];
    }).y(function(d2) {
      return d2[yField];
    });
    pathData = reg(data2);
  }
  return splinePath(pathData, config);
};
var getMeta = function(options) {
  var _a2;
  var _b = options.meta, meta2 = _b === void 0 ? {} : _b, xField = options.xField, yField = options.yField, data2 = options.data;
  var xFieldValue = data2[0][xField];
  var yFieldValue = data2[0][yField];
  var xIsPositiveNumber = xFieldValue > 0;
  var yIsPositiveNumber = yFieldValue > 0;
  function getMetaMinMax(field2, axis2) {
    var fieldMeta = get(meta2, [field2]);
    function getCustomValue(type4) {
      return get(fieldMeta, type4);
    }
    var range3 = {};
    if (axis2 === "x") {
      if (isNumber$1(xFieldValue)) {
        if (!isNumber$1(getCustomValue("min"))) {
          range3["min"] = xIsPositiveNumber ? 0 : xFieldValue * 2;
        }
        if (!isNumber$1(getCustomValue("max"))) {
          range3["max"] = xIsPositiveNumber ? xFieldValue * 2 : 0;
        }
      }
      return range3;
    }
    if (isNumber$1(yFieldValue)) {
      if (!isNumber$1(getCustomValue("min"))) {
        range3["min"] = yIsPositiveNumber ? 0 : yFieldValue * 2;
      }
      if (!isNumber$1(getCustomValue("max"))) {
        range3["max"] = yIsPositiveNumber ? yFieldValue * 2 : 0;
      }
    }
    return range3;
  }
  return __assign$4(__assign$4({}, meta2), (_a2 = {}, _a2[xField] = __assign$4(__assign$4({}, meta2[xField]), getMetaMinMax(xField, "x")), _a2[yField] = __assign$4(__assign$4({}, meta2[yField]), getMetaMinMax(yField, "y")), _a2));
};
function transformOptions$1(options) {
  var _a2 = options.data, data2 = _a2 === void 0 ? [] : _a2, xField = options.xField, yField = options.yField;
  if (data2.length) {
    var isOneX = true;
    var isOneY = true;
    var prev = data2[0];
    var curr = void 0;
    for (var i2 = 1; i2 < data2.length; i2++) {
      curr = data2[i2];
      if (prev[xField] !== curr[xField]) {
        isOneX = false;
      }
      if (prev[yField] !== curr[yField]) {
        isOneY = false;
      }
      if (!isOneX && !isOneY) {
        break;
      }
      prev = curr;
    }
    var keys2 = [];
    isOneX && keys2.push(xField);
    isOneY && keys2.push(yField);
    var meta_1 = pick(getMeta(options), keys2);
    return deepAssign({}, options, { meta: meta_1 });
  }
  return options;
}
function geometry$p(params) {
  var chart = params.chart, options = params.options;
  var data2 = options.data, type4 = options.type, color2 = options.color, shape = options.shape, pointStyle = options.pointStyle, shapeField = options.shapeField, colorField = options.colorField, xField = options.xField, yField = options.yField, sizeField = options.sizeField;
  var size2 = options.size;
  var tooltip2 = options.tooltip;
  if (sizeField) {
    if (!size2) {
      size2 = [2, 8];
    }
    if (isNumber$1(size2)) {
      size2 = [size2, size2];
    }
  }
  if (tooltip2 && !tooltip2.fields) {
    tooltip2 = __assign$4(__assign$4({}, tooltip2), { fields: [xField, yField, colorField, sizeField, shapeField] });
  }
  chart.data(data2);
  point(deepAssign({}, params, {
    options: {
      seriesField: colorField,
      point: {
        color: color2,
        shape,
        size: size2,
        style: pointStyle
      },
      tooltip: tooltip2
    }
  }));
  var geometry2 = findGeometry(chart, "point");
  if (type4) {
    geometry2.adjust(type4);
  }
  return params;
}
function meta$g(params) {
  var _a2;
  var options = params.options;
  var xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField, yField = options.yField;
  var newOptions = transformOptions$1(options);
  return flow(scale$2((_a2 = {}, _a2[xField] = xAxis, _a2[yField] = yAxis, _a2)))(deepAssign({}, params, { options: newOptions }));
}
function axis$h(params) {
  var chart = params.chart, options = params.options;
  var xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField, yField = options.yField;
  chart.axis(xField, xAxis);
  chart.axis(yField, yAxis);
  return params;
}
function legend$a(params) {
  var chart = params.chart, options = params.options;
  var legend2 = options.legend, colorField = options.colorField, shapeField = options.shapeField, sizeField = options.sizeField, shapeLegend = options.shapeLegend, sizeLegend = options.sizeLegend;
  var showLegend = legend2 !== false;
  if (colorField) {
    chart.legend(colorField, showLegend ? legend2 : false);
  }
  if (shapeField) {
    if (shapeLegend) {
      chart.legend(shapeField, shapeLegend);
    } else {
      chart.legend(shapeField, shapeLegend === false ? false : legend2);
    }
  }
  if (sizeField) {
    chart.legend(sizeField, sizeLegend ? sizeLegend : false);
  }
  if (!showLegend && !shapeLegend && !sizeLegend) {
    chart.legend(false);
  }
  return params;
}
function label$9(params) {
  var chart = params.chart, options = params.options;
  var label2 = options.label, yField = options.yField;
  var scatterGeometry = findGeometry(chart, "point");
  if (!label2) {
    scatterGeometry.label(false);
  } else {
    var callback = label2.callback, cfg = __rest$3(label2, ["callback"]);
    scatterGeometry.label({
      fields: [yField],
      callback,
      cfg: transformLabel(cfg)
    });
  }
  return params;
}
function scatterAnnotation(params) {
  var options = params.options;
  var quadrant = options.quadrant;
  var annotationOptions = [];
  if (quadrant) {
    var _a2 = quadrant.xBaseline, xBaseline = _a2 === void 0 ? 0 : _a2, _b = quadrant.yBaseline, yBaseline = _b === void 0 ? 0 : _b, labels_1 = quadrant.labels, regionStyle_1 = quadrant.regionStyle, lineStyle = quadrant.lineStyle;
    var defaultConfig_1 = getQuadrantDefaultConfig(xBaseline, yBaseline);
    var quadrants = new Array(4).join(",").split(",");
    quadrants.forEach(function(_2, index2) {
      annotationOptions.push(__assign$4(__assign$4({ type: "region", top: false }, defaultConfig_1.regionStyle[index2].position), { style: deepAssign({}, defaultConfig_1.regionStyle[index2].style, regionStyle_1 === null || regionStyle_1 === void 0 ? void 0 : regionStyle_1[index2]) }), __assign$4({ type: "text", top: true }, deepAssign({}, defaultConfig_1.labelStyle[index2], labels_1 === null || labels_1 === void 0 ? void 0 : labels_1[index2])));
    });
    annotationOptions.push({
      type: "line",
      top: false,
      start: ["min", yBaseline],
      end: ["max", yBaseline],
      style: deepAssign({}, defaultConfig_1.lineStyle, lineStyle)
    }, {
      type: "line",
      top: false,
      start: [xBaseline, "min"],
      end: [xBaseline, "max"],
      style: deepAssign({}, defaultConfig_1.lineStyle, lineStyle)
    });
  }
  return flow(annotation$2(annotationOptions))(params);
}
function regressionLine(params) {
  var options = params.options, chart = params.chart;
  var regressionLine2 = options.regressionLine;
  if (regressionLine2) {
    var style_1 = regressionLine2.style, _a2 = regressionLine2.top, top_1 = _a2 === void 0 ? false : _a2;
    var defaultStyle_1 = {
      stroke: "#9ba29a",
      lineWidth: 2,
      opacity: 0.5
    };
    chart.annotation().shape({
      top: top_1,
      render: function(container, view) {
        var group2 = container.addGroup({
          id: chart.id + "-regression-line",
          name: "regression-line-group"
        });
        var path2 = getPath({
          view,
          options
        });
        group2.addShape("path", {
          name: "regression-line",
          attrs: __assign$4(__assign$4({ path: path2 }, defaultStyle_1), style_1)
        });
      }
    });
  }
  return params;
}
function tooltip$7(params) {
  var chart = params.chart, options = params.options;
  var tooltip2 = options.tooltip;
  if (tooltip2) {
    chart.tooltip(tooltip2);
  } else if (tooltip2 === false) {
    chart.tooltip(false);
  }
  return params;
}
function adaptor$r(params) {
  return flow(
    geometry$p,
    meta$g,
    axis$h,
    legend$a,
    tooltip$7,
    label$9,
    brushInteraction,
    slider$2,
    scrollbar,
    interaction$7,
    scatterAnnotation,
    animation$5,
    theme$2,
    regressionLine
  )(params);
}
var DEFAULT_OPTIONS$r = deepAssign({}, Plot.getDefaultOptions(), {
  size: 4,
  tooltip: {
    showTitle: false,
    showMarkers: false,
    showCrosshairs: true,
    crosshairs: {
      type: "xy"
    }
  }
});
registerInteraction("drag-move", {
  start: [{ trigger: "plot:mousedown", action: "scale-translate:start" }],
  processing: [
    {
      trigger: "plot:mousemove",
      action: "scale-translate:translate",
      throttle: { wait: 100, leading: true, trailing: false }
    }
  ],
  end: [{ trigger: "plot:mouseup", action: "scale-translate:end" }]
});
var Scatter = function(_super) {
  __extends$3(Scatter2, _super);
  function Scatter2(container, options) {
    var _this = _super.call(this, container, options) || this;
    _this.type = "scatter";
    _this.on(VIEW_LIFE_CIRCLE.BEFORE_RENDER, function(evt) {
      var _a2, _b;
      var _c = _this, options2 = _c.options, chart = _c.chart;
      if (((_a2 = evt.data) === null || _a2 === void 0 ? void 0 : _a2.source) === EVENTS.FILTER) {
        var filteredData = _this.chart.filterData(_this.chart.getData());
        meta$g({ chart, options: __assign$4(__assign$4({}, options2), { data: filteredData }) });
      }
      if (((_b = evt.data) === null || _b === void 0 ? void 0 : _b.source) === EVENTS.RESET) {
        meta$g({ chart, options: options2 });
      }
    });
    return _this;
  }
  Scatter2.getDefaultOptions = function() {
    return DEFAULT_OPTIONS$r;
  };
  Scatter2.prototype.changeData = function(data2) {
    this.updateOption(transformOptions$1(deepAssign({}, this.options, { data: data2 })));
    var _a2 = this, options = _a2.options, chart = _a2.chart;
    meta$g({ chart, options });
    this.chart.changeData(data2);
  };
  Scatter2.prototype.getSchemaAdaptor = function() {
    return adaptor$r;
  };
  Scatter2.prototype.getDefaultOptions = function() {
    return Scatter2.getDefaultOptions();
  };
  return Scatter2;
}(Plot);
function geometry$o(params) {
  var chart = params.chart, options = params.options;
  var data2 = options.data, lineStyle = options.lineStyle, color2 = options.color, pointOptions = options.point, areaOptions = options.area;
  chart.data(data2);
  var primary = deepAssign({}, params, {
    options: {
      line: {
        style: lineStyle,
        color: color2
      },
      point: pointOptions ? __assign$4({ color: color2 }, pointOptions) : pointOptions,
      area: areaOptions ? __assign$4({ color: color2 }, areaOptions) : areaOptions,
      label: void 0
    }
  });
  var second = deepAssign({}, primary, {
    options: {
      tooltip: false
    }
  });
  var pointState = (pointOptions === null || pointOptions === void 0 ? void 0 : pointOptions.state) || options.state;
  var pointParams = deepAssign({}, primary, { options: { tooltip: false, state: pointState } });
  line(primary);
  point(pointParams);
  area(second);
  return params;
}
function meta$f(params) {
  var _a2;
  var options = params.options;
  var xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField, yField = options.yField;
  return flow(scale$2((_a2 = {}, _a2[xField] = xAxis, _a2[yField] = yAxis, _a2)))(params);
}
function coord(params) {
  var chart = params.chart, options = params.options;
  var radius = options.radius, startAngle = options.startAngle, endAngle = options.endAngle;
  chart.coordinate("polar", {
    radius,
    startAngle,
    endAngle
  });
  return params;
}
function axis$g(params) {
  var chart = params.chart, options = params.options;
  var xField = options.xField, xAxis = options.xAxis, yField = options.yField, yAxis = options.yAxis;
  chart.axis(xField, xAxis);
  chart.axis(yField, yAxis);
  return params;
}
function label$8(params) {
  var chart = params.chart, options = params.options;
  var label2 = options.label, yField = options.yField;
  var geometry2 = findGeometry(chart, "line");
  if (!label2) {
    geometry2.label(false);
  } else {
    var callback = label2.callback, cfg = __rest$3(label2, ["callback"]);
    geometry2.label({
      fields: [yField],
      callback,
      cfg: transformLabel(cfg)
    });
  }
  return params;
}
function adaptor$q(params) {
  return flow(geometry$o, meta$f, theme$2, coord, axis$g, legend$g, tooltip$9, label$8, interaction$7, animation$5, annotation$2())(params);
}
var RadarTooltipController = function(_super) {
  __extends$3(RadarTooltipController2, _super);
  function RadarTooltipController2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Object.defineProperty(RadarTooltipController2.prototype, "name", {
    get: function() {
      return "radar-tooltip";
    },
    enumerable: false,
    configurable: true
  });
  RadarTooltipController2.prototype.getTooltipItems = function(point2) {
    var _a2 = this.getTooltipCfg(), shared = _a2.shared, cfgTitle = _a2.title;
    var hintItems = _super.prototype.getTooltipItems.call(this, point2);
    if (hintItems.length > 0) {
      var geometry_1 = this.view.geometries[0];
      var dataArray = geometry_1.dataArray;
      var title_1 = hintItems[0].name;
      var result_1 = [];
      dataArray.forEach(function(mappingData) {
        mappingData.forEach(function(d2) {
          var items = Util.getTooltipItems(d2, geometry_1);
          var item = items[0];
          if (!shared && item && item.name === title_1) {
            var displayTitle = isNil(cfgTitle) ? title_1 : cfgTitle;
            result_1.push(__assign$4(__assign$4({}, item), { name: item.title, title: displayTitle }));
          } else if (shared && item) {
            var displayTitle = isNil(cfgTitle) ? item.name || title_1 : cfgTitle;
            result_1.push(__assign$4(__assign$4({}, item), { name: item.title, title: displayTitle }));
          }
        });
      });
      return result_1;
    }
    return [];
  };
  return RadarTooltipController2;
}(Tooltip);
registerComponentController("radar-tooltip", RadarTooltipController);
var RadarTooltipAction = function(_super) {
  __extends$3(RadarTooltipAction2, _super);
  function RadarTooltipAction2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  RadarTooltipAction2.prototype.init = function() {
    var view = this.context.view;
    view.removeInteraction("tooltip");
  };
  RadarTooltipAction2.prototype.show = function() {
    var event = this.context.event;
    var controller = this.getTooltipController();
    controller.showTooltip({ x: event.x, y: event.y });
  };
  RadarTooltipAction2.prototype.hide = function() {
    var controller = this.getTooltipController();
    controller.hideTooltip();
  };
  RadarTooltipAction2.prototype.getTooltipController = function() {
    var view = this.context.view;
    return view.getController("radar-tooltip");
  };
  return RadarTooltipAction2;
}(Action);
registerAction("radar-tooltip", RadarTooltipAction);
registerInteraction("radar-tooltip", {
  start: [{ trigger: "plot:mousemove", action: "radar-tooltip:show" }],
  end: [{ trigger: "plot:mouseleave", action: "radar-tooltip:hide" }]
});
(function(_super) {
  __extends$3(Radar, _super);
  function Radar() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "radar";
    return _this;
  }
  Radar.prototype.changeData = function(data2) {
    this.updateOption({ data: data2 });
    this.chart.changeData(data2);
  };
  Radar.prototype.getDefaultOptions = function() {
    return deepAssign({}, _super.prototype.getDefaultOptions.call(this), {
      xAxis: {
        label: {
          offset: 15
        },
        grid: {
          line: {
            type: "line"
          }
        }
      },
      yAxis: {
        grid: {
          line: {
            type: "circle"
          }
        }
      },
      legend: {
        position: "top"
      },
      tooltip: {
        shared: true,
        showCrosshairs: true,
        showMarkers: true,
        crosshairs: {
          type: "xy",
          line: {
            style: {
              stroke: "#565656",
              lineDash: [4]
            }
          },
          follow: true
        }
      }
    });
  };
  Radar.prototype.getSchemaAdaptor = function() {
    return adaptor$q;
  };
  return Radar;
})(Plot);
var AxisType;
(function(AxisType2) {
  AxisType2["Left"] = "Left";
  AxisType2["Right"] = "Right";
})(AxisType || (AxisType = {}));
var DualAxesGeometry;
(function(DualAxesGeometry2) {
  DualAxesGeometry2["Line"] = "line";
  DualAxesGeometry2["Column"] = "column";
})(DualAxesGeometry || (DualAxesGeometry = {}));
var LEFT_AXES_VIEW = "left-axes-view";
var RIGHT_AXES_VIEW = "right-axes-view";
var DEFAULT_YAXIS_CONFIG = {
  nice: true,
  label: {
    autoHide: true,
    autoRotate: false
  }
};
var DEFAULT_LEFT_YAXIS_CONFIG = __assign$4(__assign$4({}, DEFAULT_YAXIS_CONFIG), { position: "left" });
var DEFAULT_RIGHT_YAXIS_CONFIG = __assign$4(__assign$4({}, DEFAULT_YAXIS_CONFIG), { position: "right", grid: null });
function isLine(geometryOption) {
  return get(geometryOption, "geometry") === DualAxesGeometry.Line;
}
function isColumn(geometryOption) {
  return get(geometryOption, "geometry") === DualAxesGeometry.Column;
}
function getGeometryOption(xField, yField, geometryOption) {
  return isColumn(geometryOption) ? deepAssign({}, {
    geometry: DualAxesGeometry.Column,
    label: geometryOption.label && geometryOption.isRange ? {
      content: function(item) {
        var _a2;
        return (_a2 = item[yField]) === null || _a2 === void 0 ? void 0 : _a2.join("-");
      }
    } : void 0
  }, geometryOption) : __assign$4({ geometry: DualAxesGeometry.Line }, geometryOption);
}
function transformObjectToArray(yField, transformAttribute) {
  var y1 = yField[0], y2 = yField[1];
  if (isArray$1(transformAttribute)) {
    var a1_1 = transformAttribute[0], a2_1 = transformAttribute[1];
    return [a1_1, a2_1];
  }
  var a1 = get(transformAttribute, y1);
  var a2 = get(transformAttribute, y2);
  return [a1, a2];
}
function getYAxisWithDefault(yAxis, axisType) {
  if (axisType === AxisType.Left) {
    return yAxis === false ? false : deepAssign({}, DEFAULT_LEFT_YAXIS_CONFIG, yAxis);
  } else if (axisType === AxisType.Right) {
    return yAxis === false ? false : deepAssign({}, DEFAULT_RIGHT_YAXIS_CONFIG, yAxis);
  }
  return yAxis;
}
function getViewLegendItems(params) {
  var view = params.view, geometryOption = params.geometryOption, yField = params.yField, legend2 = params.legend;
  var userMarker = get(legend2, "marker");
  var geometry2 = findGeometry(view, isLine(geometryOption) ? "line" : "interval");
  if (!geometryOption.seriesField) {
    var legendItemName = get(view, "options.scales." + yField + ".alias") || yField;
    var colorAttribute = geometry2.getAttribute("color");
    var color2 = view.getTheme().defaultColor;
    if (colorAttribute) {
      color2 = Util.getMappingValue(colorAttribute, legendItemName, get(colorAttribute, ["values", 0], color2));
    }
    var marker = (isFunction(userMarker) ? userMarker : !isEmpty(userMarker) && deepAssign({}, {
      style: {
        stroke: color2,
        fill: color2
      }
    }, userMarker)) || (isLine(geometryOption) ? {
      symbol: function(x2, y2, r2) {
        return [
          ["M", x2 - r2, y2],
          ["L", x2 + r2, y2]
        ];
      },
      style: {
        lineWidth: 2,
        r: 6,
        stroke: color2
      }
    } : {
      symbol: "square",
      style: {
        fill: color2
      }
    });
    return [
      {
        value: yField,
        name: legendItemName,
        marker,
        isGeometry: true,
        viewId: view.id
      }
    ];
  }
  var attributes2 = geometry2.getGroupAttributes();
  return reduce(attributes2, function(items, attr) {
    var attrItems = Util.getLegendItems(view, geometry2, attr, view.getTheme(), userMarker);
    return items.concat(attrItems);
  }, []);
}
function drawSingleGeometry(params) {
  var options = params.options, chart = params.chart;
  var geometryOption = options.geometryOption;
  var isStack = geometryOption.isStack, color2 = geometryOption.color, seriesField = geometryOption.seriesField, groupField = geometryOption.groupField, isGroup = geometryOption.isGroup;
  var FIELD_KEY = ["xField", "yField"];
  if (isLine(geometryOption)) {
    line(deepAssign({}, params, {
      options: __assign$4(__assign$4(__assign$4({}, pick(options, FIELD_KEY)), geometryOption), { line: {
        color: geometryOption.color,
        style: geometryOption.lineStyle
      } })
    }));
    point(deepAssign({}, params, {
      options: __assign$4(__assign$4(__assign$4({}, pick(options, FIELD_KEY)), geometryOption), { point: geometryOption.point && __assign$4({ color: color2, shape: "circle" }, geometryOption.point) })
    }));
    var adjust_1 = [];
    if (isGroup) {
      adjust_1.push({
        type: "dodge",
        dodgeBy: groupField || seriesField,
        customOffset: 0
      });
    }
    if (isStack) {
      adjust_1.push({
        type: "stack"
      });
    }
    if (adjust_1.length) {
      each$1(chart.geometries, function(g2) {
        g2.adjust(adjust_1);
      });
    }
  }
  if (isColumn(geometryOption)) {
    adaptor$w(deepAssign({}, params, {
      options: __assign$4(__assign$4(__assign$4({}, pick(options, FIELD_KEY)), geometryOption), { widthRatio: geometryOption.columnWidthRatio, interval: __assign$4(__assign$4({}, pick(geometryOption, ["color"])), { style: geometryOption.columnStyle }) })
    }));
  }
  return params;
}
var doSliderFilter = function(view, sliderValue) {
  var min2 = sliderValue[0], max2 = sliderValue[1];
  var data2 = view.getOptions().data;
  var xScale = view.getXScale();
  var dataSize = size(data2);
  if (!xScale || !dataSize) {
    return;
  }
  var values2 = valuesOfKey(data2, xScale.field);
  var xValues = values2;
  var xTickCount = size(xValues);
  var minIndex = Math.floor(min2 * (xTickCount - 1));
  var maxIndex = Math.floor(max2 * (xTickCount - 1));
  view.filter(xScale.field, function(value2) {
    var idx = xValues.indexOf(value2);
    return idx > -1 ? isBetween(idx, minIndex, maxIndex) : true;
  });
  view.getRootView().render(true);
};
function transformOptions(params) {
  var _a2;
  var options = params.options;
  var _b = options.geometryOptions, geometryOptions = _b === void 0 ? [] : _b, xField = options.xField, yField = options.yField;
  var allLine = every(geometryOptions, function(_a3) {
    var geometry2 = _a3.geometry;
    return geometry2 === DualAxesGeometry.Line || geometry2 === void 0;
  });
  return deepAssign({}, {
    options: {
      geometryOptions: [],
      meta: (_a2 = {}, _a2[xField] = {
        type: "cat",
        sync: true,
        range: allLine ? [0, 1] : void 0
      }, _a2),
      tooltip: {
        showMarkers: allLine,
        showCrosshairs: allLine,
        shared: true,
        crosshairs: {
          type: "x"
        }
      },
      interactions: !allLine ? [{ type: "legend-visible-filter" }, { type: "active-region" }] : [{ type: "legend-visible-filter" }],
      legend: {
        position: "top-left"
      }
    }
  }, params, {
    options: {
      yAxis: transformObjectToArray(yField, options.yAxis),
      geometryOptions: [
        getGeometryOption(xField, yField[0], geometryOptions[0]),
        getGeometryOption(xField, yField[1], geometryOptions[1])
      ],
      annotations: transformObjectToArray(yField, options.annotations)
    }
  });
}
function createViews(params) {
  var _a2, _b;
  var chart = params.chart, options = params.options;
  var geometryOptions = options.geometryOptions;
  var SORT_MAP = { line: 0, column: 1 };
  var geometries = [
    { type: (_a2 = geometryOptions[0]) === null || _a2 === void 0 ? void 0 : _a2.geometry, id: LEFT_AXES_VIEW },
    { type: (_b = geometryOptions[1]) === null || _b === void 0 ? void 0 : _b.geometry, id: RIGHT_AXES_VIEW }
  ];
  geometries.sort(function(a2, b10) {
    return -SORT_MAP[a2.type] + SORT_MAP[b10.type];
  }).forEach(function(g2) {
    return chart.createView({ id: g2.id });
  });
  return params;
}
function geometry$n(params) {
  var chart = params.chart, options = params.options;
  var xField = options.xField, yField = options.yField, geometryOptions = options.geometryOptions, data2 = options.data, tooltip2 = options.tooltip;
  var geometries = [
    __assign$4(__assign$4({}, geometryOptions[0]), { id: LEFT_AXES_VIEW, data: data2[0], yField: yField[0] }),
    __assign$4(__assign$4({}, geometryOptions[1]), { id: RIGHT_AXES_VIEW, data: data2[1], yField: yField[1] })
  ];
  geometries.forEach(function(geometry2) {
    var id2 = geometry2.id, data3 = geometry2.data, yField2 = geometry2.yField;
    var isPercent = isColumn(geometry2) && geometry2.isPercent;
    var formatData = isPercent ? percent(data3, yField2, xField, yField2) : data3;
    var view = findViewById(chart, id2).data(formatData);
    var tooltipOptions = isPercent ? __assign$4({ formatter: function(datum) {
      return {
        name: datum[geometry2.seriesField] || yField2,
        value: (Number(datum[yField2]) * 100).toFixed(2) + "%"
      };
    } }, tooltip2) : tooltip2;
    drawSingleGeometry({
      chart: view,
      options: {
        xField,
        yField: yField2,
        tooltip: tooltipOptions,
        geometryOption: geometry2
      }
    });
  });
  return params;
}
function color(params) {
  var _a2;
  var chart = params.chart, options = params.options;
  var geometryOptions = options.geometryOptions;
  var themeColor = ((_a2 = chart.getTheme()) === null || _a2 === void 0 ? void 0 : _a2.colors10) || [];
  var start = 0;
  chart.once("beforepaint", function() {
    each$1(geometryOptions, function(geometryOption, index2) {
      var view = findViewById(chart, index2 === 0 ? LEFT_AXES_VIEW : RIGHT_AXES_VIEW);
      if (geometryOption.color)
        return;
      var groupScale = view.getGroupScales();
      var count2 = get(groupScale, [0, "values", "length"], 1);
      var color2 = themeColor.slice(start, start + count2).concat(index2 === 0 ? [] : themeColor);
      view.geometries.forEach(function(geometry2) {
        if (geometryOption.seriesField) {
          geometry2.color(geometryOption.seriesField, color2);
        } else {
          geometry2.color(color2[0]);
        }
      });
      start += count2;
    });
    chart.render(true);
  });
  return params;
}
function meta$e(params) {
  var _a2, _b;
  var chart = params.chart, options = params.options;
  var xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField, yField = options.yField;
  scale$2((_a2 = {}, _a2[xField] = xAxis, _a2[yField[0]] = yAxis[0], _a2))(deepAssign({}, params, { chart: findViewById(chart, LEFT_AXES_VIEW) }));
  scale$2((_b = {}, _b[xField] = xAxis, _b[yField[1]] = yAxis[1], _b))(deepAssign({}, params, { chart: findViewById(chart, RIGHT_AXES_VIEW) }));
  return params;
}
function axis$f(params) {
  var chart = params.chart, options = params.options;
  var leftView = findViewById(chart, LEFT_AXES_VIEW);
  var rightView = findViewById(chart, RIGHT_AXES_VIEW);
  var xField = options.xField, yField = options.yField, xAxis = options.xAxis, yAxis = options.yAxis;
  chart.axis(xField, false);
  chart.axis(yField[0], false);
  chart.axis(yField[1], false);
  leftView.axis(xField, xAxis);
  leftView.axis(yField[0], getYAxisWithDefault(yAxis[0], AxisType.Left));
  rightView.axis(xField, false);
  rightView.axis(yField[1], getYAxisWithDefault(yAxis[1], AxisType.Right));
  return params;
}
function tooltip$6(params) {
  var chart = params.chart, options = params.options;
  var tooltip2 = options.tooltip;
  var leftView = findViewById(chart, LEFT_AXES_VIEW);
  var rightView = findViewById(chart, RIGHT_AXES_VIEW);
  chart.tooltip(tooltip2);
  leftView.tooltip({
    shared: true
  });
  rightView.tooltip({
    shared: true
  });
  return params;
}
function interaction$5(params) {
  var chart = params.chart;
  interaction$7(deepAssign({}, params, { chart: findViewById(chart, LEFT_AXES_VIEW) }));
  interaction$7(deepAssign({}, params, { chart: findViewById(chart, RIGHT_AXES_VIEW) }));
  return params;
}
function annotation$1(params) {
  var chart = params.chart, options = params.options;
  var annotations = options.annotations;
  var a1 = get(annotations, [0]);
  var a2 = get(annotations, [1]);
  annotation$2(a1)(deepAssign({}, params, {
    chart: findViewById(chart, LEFT_AXES_VIEW),
    options: {
      annotations: a1
    }
  }));
  annotation$2(a2)(deepAssign({}, params, {
    chart: findViewById(chart, RIGHT_AXES_VIEW),
    options: {
      annotations: a2
    }
  }));
  return params;
}
function theme$1(params) {
  var chart = params.chart;
  theme$2(deepAssign({}, params, { chart: findViewById(chart, LEFT_AXES_VIEW) }));
  theme$2(deepAssign({}, params, { chart: findViewById(chart, RIGHT_AXES_VIEW) }));
  theme$2(params);
  return params;
}
function animation$4(params) {
  var chart = params.chart;
  animation$5(deepAssign({}, params, { chart: findViewById(chart, LEFT_AXES_VIEW) }));
  animation$5(deepAssign({}, params, { chart: findViewById(chart, RIGHT_AXES_VIEW) }));
  return params;
}
function limitInPlot$1(params) {
  var chart = params.chart, options = params.options;
  var yAxis = options.yAxis;
  limitInPlot$2(deepAssign({}, params, {
    chart: findViewById(chart, LEFT_AXES_VIEW),
    options: {
      yAxis: yAxis[0]
    }
  }));
  limitInPlot$2(deepAssign({}, params, {
    chart: findViewById(chart, RIGHT_AXES_VIEW),
    options: {
      yAxis: yAxis[1]
    }
  }));
  return params;
}
function legend$9(params) {
  var chart = params.chart, options = params.options;
  var legend2 = options.legend, geometryOptions = options.geometryOptions, yField = options.yField, data2 = options.data;
  var leftView = findViewById(chart, LEFT_AXES_VIEW);
  var rightView = findViewById(chart, RIGHT_AXES_VIEW);
  if (legend2 === false) {
    chart.legend(false);
  } else if (isObject(legend2) && legend2.custom === true) {
    chart.legend(legend2);
  } else {
    var leftLegend_1 = get(geometryOptions, [0, "legend"], legend2);
    var rightLegend_1 = get(geometryOptions, [1, "legend"], legend2);
    chart.once("beforepaint", function() {
      var leftItems = data2[0].length ? getViewLegendItems({
        view: leftView,
        geometryOption: geometryOptions[0],
        yField: yField[0],
        legend: leftLegend_1
      }) : [];
      var rightItems = data2[1].length ? getViewLegendItems({
        view: rightView,
        geometryOption: geometryOptions[1],
        yField: yField[1],
        legend: rightLegend_1
      }) : [];
      chart.legend(deepAssign({}, legend2, {
        custom: true,
        items: leftItems.concat(rightItems)
      }));
    });
    if (geometryOptions[0].seriesField) {
      leftView.legend(geometryOptions[0].seriesField, leftLegend_1);
    }
    if (geometryOptions[1].seriesField) {
      rightView.legend(geometryOptions[1].seriesField, rightLegend_1);
    }
    chart.on("legend-item:click", function(evt) {
      var delegateObject = get(evt, "gEvent.delegateObject", {});
      if (delegateObject && delegateObject.item) {
        var _a2 = delegateObject.item, field_1 = _a2.value, isGeometry = _a2.isGeometry, viewId = _a2.viewId;
        if (isGeometry) {
          var idx = findIndex(yField, function(yF) {
            return yF === field_1;
          });
          if (idx > -1) {
            var geometries = get(findViewById(chart, viewId), "geometries");
            each$1(geometries, function(g2) {
              g2.changeVisible(!delegateObject.item.unchecked);
            });
          }
        } else {
          var legendItem_1 = get(chart.getController("legend"), "option.items", []);
          each$1(chart.views, function(view) {
            var groupScale = view.getGroupScales();
            each$1(groupScale, function(scale2) {
              if (scale2.values && scale2.values.indexOf(field_1) > -1) {
                view.filter(scale2.field, function(value2) {
                  var curLegendItem = find$1(legendItem_1, function(item) {
                    return item.value === value2;
                  });
                  return !curLegendItem.unchecked;
                });
              }
            });
            chart.render(true);
          });
        }
      }
    });
  }
  return params;
}
function slider$1(params) {
  var chart = params.chart, options = params.options;
  var slider2 = options.slider;
  var leftView = findViewById(chart, LEFT_AXES_VIEW);
  var rightView = findViewById(chart, RIGHT_AXES_VIEW);
  if (slider2) {
    leftView.option("slider", slider2);
    leftView.on("slider:valuechanged", function(evt) {
      var _a2 = evt.event, value2 = _a2.value, originValue = _a2.originValue;
      if (isEqual$1(value2, originValue)) {
        return;
      }
      doSliderFilter(rightView, value2);
    });
    chart.once("afterpaint", function() {
      if (!isBoolean(slider2)) {
        var start = slider2.start, end = slider2.end;
        if (start || end) {
          doSliderFilter(rightView, [start, end]);
        }
      }
    });
  }
  return params;
}
function adaptor$p(params) {
  return flow(
    transformOptions,
    createViews,
    theme$1,
    geometry$n,
    meta$e,
    axis$f,
    limitInPlot$1,
    tooltip$6,
    interaction$5,
    annotation$1,
    animation$4,
    color,
    legend$9,
    slider$1
  )(params);
}
(function(_super) {
  __extends$3(DualAxes, _super);
  function DualAxes() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "dual-axes";
    return _this;
  }
  DualAxes.prototype.getDefaultOptions = function() {
    return deepAssign({}, _super.prototype.getDefaultOptions.call(this), {
      yAxis: [],
      syncViewPadding: true
    });
  };
  DualAxes.prototype.getSchemaAdaptor = function() {
    return adaptor$p;
  };
  return DualAxes;
})(Plot);
var X_FIELD$3 = "x";
var Y_FIELD$4 = "y";
var DEFAULT_TOOLTIP_OPTIONS$2 = {
  showTitle: false,
  shared: true,
  showMarkers: false,
  customContent: function(x2, data2) {
    return "" + get(data2, [0, "data", "y"], 0);
  },
  containerTpl: '<div class="g2-tooltip"><div class="g2-tooltip-list"></div></div>',
  itemTpl: "<span>{value}</span>",
  domStyles: {
    "g2-tooltip": {
      padding: "2px 4px",
      fontSize: "10px"
    }
  },
  showCrosshairs: true,
  crosshairs: {
    type: "x"
  }
};
var DEFAULT_OPTIONS$q = {
  appendPadding: 2,
  tooltip: __assign$4({}, DEFAULT_TOOLTIP_OPTIONS$2),
  animation: {}
};
function getTinyData(data2) {
  return map$2(data2 || [], function(y2, x2) {
    return { x: "" + x2, y: y2 };
  });
}
function geometry$m(params) {
  var chart = params.chart, options = params.options;
  var data2 = options.data, color2 = options.color, areaStyle = options.areaStyle, pointOptions = options.point, lineOptions = options.line;
  var pointState = pointOptions === null || pointOptions === void 0 ? void 0 : pointOptions.state;
  var seriesData = getTinyData(data2);
  chart.data(seriesData);
  var primary = deepAssign({}, params, {
    options: {
      xField: X_FIELD$3,
      yField: Y_FIELD$4,
      area: { color: color2, style: areaStyle },
      line: lineOptions,
      point: pointOptions
    }
  });
  var second = deepAssign({}, primary, { options: { tooltip: false } });
  var pointParams = deepAssign({}, primary, { options: { tooltip: false, state: pointState } });
  area(primary);
  line(second);
  point(pointParams);
  chart.axis(false);
  chart.legend(false);
  return params;
}
function meta$d(params) {
  var _a2, _b;
  var options = params.options;
  var xAxis = options.xAxis, yAxis = options.yAxis, data2 = options.data;
  var seriesData = getTinyData(data2);
  return flow(scale$2((_a2 = {}, _a2[X_FIELD$3] = xAxis, _a2[Y_FIELD$4] = yAxis, _a2), (_b = {}, _b[X_FIELD$3] = {
    type: "cat"
  }, _b[Y_FIELD$4] = adjustYMetaByZero(seriesData, Y_FIELD$4), _b)))(params);
}
function adaptor$o(params) {
  return flow(pattern("areaStyle"), geometry$m, meta$d, tooltip$9, theme$2, animation$5, annotation$2())(params);
}
function geometry$l(params) {
  var chart = params.chart, options = params.options;
  var data2 = options.data, color2 = options.color, lineStyle = options.lineStyle, pointMapping = options.point;
  var pointState = pointMapping === null || pointMapping === void 0 ? void 0 : pointMapping.state;
  var seriesData = getTinyData(data2);
  chart.data(seriesData);
  var primary = deepAssign({}, params, {
    options: {
      xField: X_FIELD$3,
      yField: Y_FIELD$4,
      line: {
        color: color2,
        style: lineStyle
      },
      point: pointMapping
    }
  });
  var pointParams = deepAssign({}, primary, { options: { tooltip: false, state: pointState } });
  line(primary);
  point(pointParams);
  chart.axis(false);
  chart.legend(false);
  return params;
}
function adaptor$n(params) {
  return flow(geometry$l, meta$d, theme$2, tooltip$9, animation$5, annotation$2())(params);
}
var TinyLine = function(_super) {
  __extends$3(TinyLine2, _super);
  function TinyLine2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "tiny-line";
    return _this;
  }
  TinyLine2.getDefaultOptions = function() {
    return DEFAULT_OPTIONS$q;
  };
  TinyLine2.prototype.changeData = function(data2) {
    this.updateOption({ data: data2 });
    var _a2 = this, chart = _a2.chart, options = _a2.options;
    meta$d({ chart, options });
    chart.changeData(getTinyData(data2));
  };
  TinyLine2.prototype.getDefaultOptions = function() {
    return TinyLine2.getDefaultOptions();
  };
  TinyLine2.prototype.getSchemaAdaptor = function() {
    return adaptor$n;
  };
  return TinyLine2;
}(Plot);
function geometry$k(params) {
  var chart = params.chart, options = params.options;
  var data2 = options.data, color2 = options.color, columnStyle = options.columnStyle, columnWidthRatio = options.columnWidthRatio;
  var seriesData = getTinyData(data2);
  chart.data(seriesData);
  var p2 = deepAssign({}, params, {
    options: {
      xField: X_FIELD$3,
      yField: Y_FIELD$4,
      widthRatio: columnWidthRatio,
      interval: {
        style: columnStyle,
        color: color2
      }
    }
  });
  interval(p2);
  chart.axis(false);
  chart.legend(false);
  chart.interaction("element-active");
  return params;
}
function adaptor$m(params) {
  return flow(theme$2, pattern("columnStyle"), geometry$k, meta$d, tooltip$9, animation$5, annotation$2())(params);
}
var DEFAULT_TOOLTIP_OPTIONS$1 = {
  showTitle: false,
  shared: true,
  showMarkers: false,
  customContent: function(x2, data2) {
    return "" + get(data2, [0, "data", "y"], 0);
  },
  containerTpl: '<div class="g2-tooltip"><div class="g2-tooltip-list"></div></div>',
  itemTpl: "<span>{value}</span>",
  domStyles: {
    "g2-tooltip": {
      padding: "2px 4px",
      fontSize: "10px"
    }
  }
};
var DEFAULT_OPTIONS$p = {
  appendPadding: 2,
  tooltip: __assign$4({}, DEFAULT_TOOLTIP_OPTIONS$1),
  animation: {}
};
var TinyColumn = function(_super) {
  __extends$3(TinyColumn2, _super);
  function TinyColumn2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "tiny-column";
    return _this;
  }
  TinyColumn2.getDefaultOptions = function() {
    return DEFAULT_OPTIONS$p;
  };
  TinyColumn2.prototype.changeData = function(data2) {
    this.updateOption({ data: data2 });
    var _a2 = this, chart = _a2.chart, options = _a2.options;
    meta$d({ chart, options });
    chart.changeData(getTinyData(data2));
  };
  TinyColumn2.prototype.getDefaultOptions = function() {
    return TinyColumn2.getDefaultOptions();
  };
  TinyColumn2.prototype.getSchemaAdaptor = function() {
    return adaptor$m;
  };
  return TinyColumn2;
}(Plot);
var DEFAULT_OPTIONS$o = {
  appendPadding: 2,
  tooltip: __assign$4({}, DEFAULT_TOOLTIP_OPTIONS$2),
  color: "l(90) 0:#E5EDFE 1:#ffffff",
  areaStyle: {
    fillOpacity: 0.6
  },
  line: {
    size: 1,
    color: "#5B8FF9"
  },
  animation: {}
};
var TinyArea = function(_super) {
  __extends$3(TinyArea2, _super);
  function TinyArea2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "tiny-area";
    return _this;
  }
  TinyArea2.getDefaultOptions = function() {
    return DEFAULT_OPTIONS$o;
  };
  TinyArea2.prototype.changeData = function(data2) {
    this.updateOption({ data: data2 });
    var _a2 = this, chart = _a2.chart, options = _a2.options;
    meta$d({ chart, options });
    chart.changeData(getTinyData(data2));
  };
  TinyArea2.prototype.getDefaultOptions = function() {
    return TinyArea2.getDefaultOptions();
  };
  TinyArea2.prototype.getSchemaAdaptor = function() {
    return adaptor$o;
  };
  return TinyArea2;
}(Plot);
function getBinKey(value2, binWidth, binNumber) {
  if (binNumber === 1) {
    return [0, binWidth];
  }
  var index2 = Math.floor(value2 / binWidth);
  return [binWidth * index2, binWidth * (index2 + 1)];
}
function sturges(values2) {
  return Math.ceil(Math.log(values2.length) / Math.LN2) + 1;
}
function binHistogram(data2, binField, binWidth, binNumber, stackField) {
  var originData_copy = clone$1(data2);
  sortBy(originData_copy, binField);
  var values2 = valuesOfKey(originData_copy, binField);
  var range3 = getRange(values2);
  var rangeWidth = range3.max - range3.min;
  var _binWidth = binWidth;
  if (!binWidth && binNumber) {
    _binWidth = binNumber > 1 ? rangeWidth / (binNumber - 1) : range3.max;
  }
  if (!binWidth && !binNumber) {
    var _defaultBinNumber = sturges(values2);
    _binWidth = rangeWidth / _defaultBinNumber;
  }
  var bins = {};
  var groups = groupBy(originData_copy, stackField);
  if (isEmpty(groups)) {
    each$1(originData_copy, function(data3) {
      var value2 = data3[binField];
      var bin = getBinKey(value2, _binWidth, binNumber);
      var binKey = bin[0] + "-" + bin[1];
      if (!has(bins, binKey)) {
        bins[binKey] = { range: bin, count: 0 };
      }
      bins[binKey].count += 1;
    });
  } else {
    Object.keys(groups).forEach(function(groupKey) {
      each$1(groups[groupKey], function(data3) {
        var value2 = data3[binField];
        var bin = getBinKey(value2, _binWidth, binNumber);
        var binKey = bin[0] + "-" + bin[1];
        var groupKeyBinKey = binKey + "-" + groupKey;
        if (!has(bins, groupKeyBinKey)) {
          bins[groupKeyBinKey] = { range: bin, count: 0 };
          bins[groupKeyBinKey][stackField] = groupKey;
        }
        bins[groupKeyBinKey].count += 1;
      });
    });
  }
  var plotData = [];
  each$1(bins, function(bin) {
    plotData.push(bin);
  });
  return plotData;
}
var HISTOGRAM_X_FIELD = "range";
var HISTOGRAM_Y_FIELD = "count";
var DEFAULT_OPTIONS$n = deepAssign({}, Plot.getDefaultOptions(), {
  columnStyle: {
    stroke: "#FFFFFF"
  },
  tooltip: {
    shared: true,
    showMarkers: false
  },
  interactions: [{ type: "active-region" }]
});
function geometry$j(params) {
  var chart = params.chart, options = params.options;
  var data2 = options.data, binField = options.binField, binNumber = options.binNumber, binWidth = options.binWidth, color2 = options.color, stackField = options.stackField, legend2 = options.legend, columnStyle = options.columnStyle;
  var plotData = binHistogram(data2, binField, binWidth, binNumber, stackField);
  chart.data(plotData);
  var p2 = deepAssign({}, params, {
    options: {
      xField: HISTOGRAM_X_FIELD,
      yField: HISTOGRAM_Y_FIELD,
      seriesField: stackField,
      isStack: true,
      interval: {
        color: color2,
        style: columnStyle
      }
    }
  });
  interval(p2);
  if (legend2 && stackField) {
    chart.legend(stackField, legend2);
  }
  return params;
}
function meta$c(params) {
  var _a2;
  var options = params.options;
  var xAxis = options.xAxis, yAxis = options.yAxis;
  return flow(scale$2((_a2 = {}, _a2[HISTOGRAM_X_FIELD] = xAxis, _a2[HISTOGRAM_Y_FIELD] = yAxis, _a2)))(params);
}
function axis$e(params) {
  var chart = params.chart, options = params.options;
  var xAxis = options.xAxis, yAxis = options.yAxis;
  if (xAxis === false) {
    chart.axis(HISTOGRAM_X_FIELD, false);
  } else {
    chart.axis(HISTOGRAM_X_FIELD, xAxis);
  }
  if (yAxis === false) {
    chart.axis(HISTOGRAM_Y_FIELD, false);
  } else {
    chart.axis(HISTOGRAM_Y_FIELD, yAxis);
  }
  return params;
}
function label$7(params) {
  var chart = params.chart, options = params.options;
  var label2 = options.label;
  var geometry2 = findGeometry(chart, "interval");
  if (!label2) {
    geometry2.label(false);
  } else {
    var callback = label2.callback, cfg = __rest$3(label2, ["callback"]);
    geometry2.label({
      fields: [HISTOGRAM_Y_FIELD],
      callback,
      cfg: transformLabel(cfg)
    });
  }
  return params;
}
function adaptor$l(params) {
  return flow(theme$2, pattern("columnStyle"), geometry$j, meta$c, axis$e, state, label$7, tooltip$9, interaction$7, animation$5)(params);
}
var Histogram = function(_super) {
  __extends$3(Histogram2, _super);
  function Histogram2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "histogram";
    return _this;
  }
  Histogram2.getDefaultOptions = function() {
    return DEFAULT_OPTIONS$n;
  };
  Histogram2.prototype.changeData = function(data2) {
    this.updateOption({ data: data2 });
    var _a2 = this.options, binField = _a2.binField, binNumber = _a2.binNumber, binWidth = _a2.binWidth, stackField = _a2.stackField;
    this.chart.changeData(binHistogram(data2, binField, binWidth, binNumber, stackField));
  };
  Histogram2.prototype.getDefaultOptions = function() {
    return Histogram2.getDefaultOptions();
  };
  Histogram2.prototype.getSchemaAdaptor = function() {
    return adaptor$l;
  };
  return Histogram2;
}(Plot);
var DEFAULT_COLOR$1 = ["#FAAD14", "#E8EDF3"];
var DEFAULT_OPTIONS$m = {
  percent: 0.2,
  color: DEFAULT_COLOR$1,
  animation: {}
};
function getProgressData(percent2) {
  var clampPercent = clamp(isRealNumber(percent2) ? percent2 : 0, 0, 1);
  return [
    {
      type: "current",
      percent: clampPercent
    },
    {
      type: "target",
      percent: 1 - clampPercent
    }
  ];
}
function geometry$i(params) {
  var chart = params.chart, options = params.options;
  var percent2 = options.percent, progressStyle = options.progressStyle, color2 = options.color, barWidthRatio = options.barWidthRatio;
  chart.data(getProgressData(percent2));
  var p2 = deepAssign({}, params, {
    options: {
      xField: "1",
      yField: "percent",
      seriesField: "type",
      isStack: true,
      widthRatio: barWidthRatio,
      interval: {
        style: progressStyle,
        color: isString(color2) ? [color2, DEFAULT_COLOR$1[1]] : color2
      },
      args: {
        zIndexReversed: true,
        sortZIndex: true
      }
    }
  });
  interval(p2);
  chart.tooltip(false);
  chart.axis(false);
  chart.legend(false);
  return params;
}
function coordinate$5(params) {
  var chart = params.chart;
  chart.coordinate("rect").transpose();
  return params;
}
function adaptor$k(params) {
  return flow(geometry$i, scale$2({}), coordinate$5, animation$5, theme$2, annotation$2())(params);
}
var Progress = function(_super) {
  __extends$3(Progress2, _super);
  function Progress2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "process";
    return _this;
  }
  Progress2.getDefaultOptions = function() {
    return DEFAULT_OPTIONS$m;
  };
  Progress2.prototype.changeData = function(percent2) {
    this.updateOption({ percent: percent2 });
    this.chart.changeData(getProgressData(percent2));
  };
  Progress2.prototype.getDefaultOptions = function() {
    return Progress2.getDefaultOptions();
  };
  Progress2.prototype.getSchemaAdaptor = function() {
    return adaptor$k;
  };
  return Progress2;
}(Plot);
function coordinate$4(params) {
  var chart = params.chart, options = params.options;
  var innerRadius = options.innerRadius, radius = options.radius;
  chart.coordinate("theta", {
    innerRadius,
    radius
  });
  return params;
}
function statistic$2(params, updated) {
  var chart = params.chart, options = params.options;
  var innerRadius = options.innerRadius, statistic2 = options.statistic, percent2 = options.percent, meta2 = options.meta;
  chart.getController("annotation").clear(true);
  if (innerRadius && statistic2) {
    var metaFormatter = get(meta2, ["percent", "formatter"]) || function(v2) {
      return (v2 * 100).toFixed(2) + "%";
    };
    var contentOpt = statistic2.content;
    if (contentOpt) {
      contentOpt = deepAssign({}, contentOpt, {
        content: !isNil(contentOpt.content) ? contentOpt.content : metaFormatter(percent2)
      });
    }
    renderStatistic(chart, { statistic: __assign$4(__assign$4({}, statistic2), { content: contentOpt }), plotType: "ring-progress" }, { percent: percent2 });
  }
  if (updated) {
    chart.render(true);
  }
  return params;
}
function adaptor$j(params) {
  return flow(geometry$i, scale$2({}), coordinate$4, statistic$2, animation$5, theme$2, annotation$2())(params);
}
var DEFAULT_OPTIONS$l = {
  percent: 0.2,
  innerRadius: 0.8,
  radius: 0.98,
  color: ["#FAAD14", "#E8EDF3"],
  statistic: {
    title: false,
    content: {
      style: {
        fontSize: "14px",
        fontWeight: 300,
        fill: "#4D4D4D",
        textAlign: "center",
        textBaseline: "middle"
      }
    }
  },
  animation: {}
};
var RingProgress = function(_super) {
  __extends$3(RingProgress2, _super);
  function RingProgress2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "ring-process";
    return _this;
  }
  RingProgress2.getDefaultOptions = function() {
    return DEFAULT_OPTIONS$l;
  };
  RingProgress2.prototype.changeData = function(percent2) {
    this.chart.emit(VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, Event.fromData(this.chart, VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, null));
    this.updateOption({ percent: percent2 });
    this.chart.data(getProgressData(percent2));
    statistic$2({ chart: this.chart, options: this.options }, true);
    this.chart.emit(VIEW_LIFE_CIRCLE.AFTER_CHANGE_DATA, Event.fromData(this.chart, VIEW_LIFE_CIRCLE.AFTER_CHANGE_DATA, null));
  };
  RingProgress2.prototype.getDefaultOptions = function() {
    return RingProgress2.getDefaultOptions();
  };
  RingProgress2.prototype.getSchemaAdaptor = function() {
    return adaptor$j;
  };
  return RingProgress2;
}(Plot);
function geometry$h(params) {
  var chart = params.chart, options = params.options;
  var data2 = options.data, type4 = options.type, xField = options.xField, yField = options.yField, colorField = options.colorField, sizeField = options.sizeField, sizeRatio = options.sizeRatio, shape = options.shape, color2 = options.color, tooltip2 = options.tooltip, heatmapStyle = options.heatmapStyle;
  chart.data(data2);
  var geometryType = "polygon";
  if (type4 === "density") {
    geometryType = "heatmap";
  }
  var _a2 = getTooltipMapping(tooltip2, [xField, yField, colorField]), fields = _a2.fields, formatter = _a2.formatter;
  var checkedSizeRatio = 1;
  if (sizeRatio || sizeRatio === 0) {
    if (!shape && !sizeField) {
      console.warn("sizeRatio is not in effect: Must define shape or sizeField first");
    } else if (sizeRatio < 0 || sizeRatio > 1) {
      console.warn("sizeRatio is not in effect: It must be a number in [0,1]");
    } else {
      checkedSizeRatio = sizeRatio;
    }
  }
  geometry$x(deepAssign({}, params, {
    options: {
      type: geometryType,
      colorField,
      tooltipFields: fields,
      shapeField: sizeField || "",
      label: void 0,
      mapping: {
        tooltip: formatter,
        shape: shape && (sizeField ? function(dautm) {
          var field2 = data2.map(function(row) {
            return row[sizeField];
          });
          var min2 = Math.min.apply(Math, field2);
          var max2 = Math.max.apply(Math, field2);
          return [shape, (get(dautm, sizeField) - min2) / (max2 - min2), checkedSizeRatio];
        } : function() {
          return [shape, 1, checkedSizeRatio];
        }),
        color: color2 || colorField && chart.getTheme().sequenceColors.join("-"),
        style: heatmapStyle
      }
    }
  }));
  return params;
}
function meta$b(params) {
  var _a2;
  var options = params.options;
  var xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField, yField = options.yField;
  return flow(scale$2((_a2 = {}, _a2[xField] = xAxis, _a2[yField] = yAxis, _a2)))(params);
}
function axis$d(params) {
  var chart = params.chart, options = params.options;
  var xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField, yField = options.yField;
  if (xAxis === false) {
    chart.axis(xField, false);
  } else {
    chart.axis(xField, xAxis);
  }
  if (yAxis === false) {
    chart.axis(yField, false);
  } else {
    chart.axis(yField, yAxis);
  }
  return params;
}
function legend$8(params) {
  var chart = params.chart, options = params.options;
  var legend2 = options.legend, colorField = options.colorField, sizeField = options.sizeField, sizeLegend = options.sizeLegend;
  var showLegend = legend2 !== false;
  if (colorField) {
    chart.legend(colorField, showLegend ? legend2 : false);
  }
  if (sizeField) {
    chart.legend(sizeField, sizeLegend === void 0 ? legend2 : sizeLegend);
  }
  if (!showLegend && !sizeLegend) {
    chart.legend(false);
  }
  return params;
}
function label$6(params) {
  var chart = params.chart, options = params.options;
  var label2 = options.label, colorField = options.colorField, type4 = options.type;
  var geometry2 = findGeometry(chart, type4 === "density" ? "heatmap" : "polygon");
  if (!label2) {
    geometry2.label(false);
  } else if (colorField) {
    var callback = label2.callback, cfg = __rest$3(label2, ["callback"]);
    geometry2.label({
      fields: [colorField],
      callback,
      cfg: transformLabel(cfg)
    });
  }
  return params;
}
function coordinate$3(params) {
  var chart = params.chart, options = params.options;
  var coordinate2 = options.coordinate, reflect = options.reflect;
  if (coordinate2) {
    chart.coordinate({
      type: coordinate2.type || "rect",
      cfg: coordinate2.cfg
    });
  }
  if (reflect) {
    chart.coordinate().reflect(reflect);
  }
  return params;
}
function adaptor$i(params) {
  return flow(theme$2, pattern("heatmapStyle"), meta$b, coordinate$3, geometry$h, axis$d, legend$8, tooltip$9, label$6, annotation$2(), interaction$7, animation$5, state)(params);
}
var DEFAULT_OPTIONS$k = deepAssign({}, Plot.getDefaultOptions(), {
  type: "polygon",
  legend: false,
  coordinate: {
    type: "rect"
  },
  xAxis: {
    tickLine: null,
    line: null,
    grid: {
      alignTick: false,
      line: {
        style: {
          lineWidth: 1,
          lineDash: null,
          stroke: "#f0f0f0"
        }
      }
    }
  },
  yAxis: {
    grid: {
      alignTick: false,
      line: {
        style: {
          lineWidth: 1,
          lineDash: null,
          stroke: "#f0f0f0"
        }
      }
    }
  }
});
registerShape("polygon", "circle", {
  draw: function(cfg, group2) {
    var _a2, _b;
    var cx = cfg.x;
    var cy = cfg.y;
    var points2 = this.parsePoints(cfg.points);
    var width = Math.abs(points2[2].x - points2[1].x);
    var height = Math.abs(points2[1].y - points2[0].y);
    var maxRadius = Math.min(width, height) / 2;
    var value2 = Number(cfg.shape[1]);
    var sizeRatio = Number(cfg.shape[2]);
    var radiusRatio = Math.sqrt(sizeRatio);
    var radius = maxRadius * radiusRatio * Math.sqrt(value2);
    var fill = ((_a2 = cfg.style) === null || _a2 === void 0 ? void 0 : _a2.fill) || cfg.color || ((_b = cfg.defaultStyle) === null || _b === void 0 ? void 0 : _b.fill);
    var polygon2 = group2.addShape("circle", {
      attrs: __assign$4(__assign$4(__assign$4({ x: cx, y: cy, r: radius }, cfg.defaultStyle), cfg.style), { fill })
    });
    return polygon2;
  }
});
registerShape("polygon", "square", {
  draw: function(cfg, group2) {
    var _a2, _b;
    var cx = cfg.x;
    var cy = cfg.y;
    var points2 = this.parsePoints(cfg.points);
    var width = Math.abs(points2[2].x - points2[1].x);
    var height = Math.abs(points2[1].y - points2[0].y);
    var maxSideLength = Math.min(width, height);
    var value2 = Number(cfg.shape[1]);
    var sizeRatio = Number(cfg.shape[2]);
    var lenRatio = Math.sqrt(sizeRatio);
    var sideLength = maxSideLength * lenRatio * Math.sqrt(value2);
    var fill = ((_a2 = cfg.style) === null || _a2 === void 0 ? void 0 : _a2.fill) || cfg.color || ((_b = cfg.defaultStyle) === null || _b === void 0 ? void 0 : _b.fill);
    var polygon2 = group2.addShape("rect", {
      attrs: __assign$4(__assign$4(__assign$4({ x: cx - sideLength / 2, y: cy - sideLength / 2, width: sideLength, height: sideLength }, cfg.defaultStyle), cfg.style), { fill })
    });
    return polygon2;
  }
});
(function(_super) {
  __extends$3(Heatmap2, _super);
  function Heatmap2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "heatmap";
    return _this;
  }
  Heatmap2.getDefaultOptions = function() {
    return DEFAULT_OPTIONS$k;
  };
  Heatmap2.prototype.getSchemaAdaptor = function() {
    return adaptor$i;
  };
  Heatmap2.prototype.getDefaultOptions = function() {
    return Heatmap2.getDefaultOptions();
  };
  return Heatmap2;
})(Plot);
var _a$2;
var BOX_RANGE = "$$range$$";
var BOX_RANGE_ALIAS = "low-q1-median-q3-high";
var BOX_SYNC_NAME = "$$y_outliers$$";
var OUTLIERS_VIEW_ID = "outliers_view";
var DEFAULT_OPTIONS$j = deepAssign({}, Plot.getDefaultOptions(), {
  meta: (_a$2 = {}, _a$2[BOX_RANGE] = { min: 0, alias: BOX_RANGE_ALIAS }, _a$2),
  interactions: [{ type: "active-region" }],
  tooltip: {
    showMarkers: false,
    shared: true
  },
  boxStyle: {
    lineWidth: 1
  }
});
var transformData$8 = function(data2, yField) {
  var newData = data2;
  if (Array.isArray(yField)) {
    var low_1 = yField[0], q1_1 = yField[1], median_1 = yField[2], q3_1 = yField[3], high_1 = yField[4];
    newData = map$2(data2, function(obj) {
      obj[BOX_RANGE] = [obj[low_1], obj[q1_1], obj[median_1], obj[q3_1], obj[high_1]];
      return obj;
    });
  }
  return newData;
};
function field$4(params) {
  var chart = params.chart, options = params.options;
  var xField = options.xField, yField = options.yField, groupField = options.groupField, color2 = options.color, tooltip2 = options.tooltip, boxStyle = options.boxStyle;
  chart.data(transformData$8(options.data, yField));
  var yFieldName = isArray$1(yField) ? BOX_RANGE : yField;
  var rawFields = yField ? isArray$1(yField) ? yField : [yField] : [];
  var tooltipOptions = tooltip2;
  if (tooltipOptions !== false) {
    tooltipOptions = deepAssign({}, { fields: isArray$1(yField) ? yField : [] }, tooltipOptions);
  }
  var ext = schema(deepAssign({}, params, {
    options: {
      xField,
      yField: yFieldName,
      seriesField: groupField,
      tooltip: tooltipOptions,
      rawFields,
      label: false,
      schema: {
        shape: "box",
        color: color2,
        style: boxStyle
      }
    }
  })).ext;
  if (groupField) {
    ext.geometry.adjust("dodge");
  }
  return params;
}
function outliersPoint(params) {
  var chart = params.chart, options = params.options;
  var xField = options.xField, data2 = options.data, outliersField = options.outliersField, outliersStyle = options.outliersStyle, padding2 = options.padding, label2 = options.label;
  if (!outliersField)
    return params;
  var outliersView = chart.createView({ padding: padding2, id: OUTLIERS_VIEW_ID });
  var outliersViewData = data2.reduce(function(ret, datum) {
    var outliersData = datum[outliersField];
    outliersData.forEach(function(d2) {
      var _a2;
      return ret.push(__assign$4(__assign$4({}, datum), (_a2 = {}, _a2[outliersField] = d2, _a2)));
    });
    return ret;
  }, []);
  outliersView.data(outliersViewData);
  point({
    chart: outliersView,
    options: {
      xField,
      yField: outliersField,
      point: { shape: "circle", style: outliersStyle },
      label: label2
    }
  });
  outliersView.axis(false);
  return params;
}
function meta$a(params) {
  var _a2, _b;
  var chart = params.chart, options = params.options;
  var meta2 = options.meta, xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField, yField = options.yField, outliersField = options.outliersField;
  var yFieldName = Array.isArray(yField) ? BOX_RANGE : yField;
  var baseMeta = {};
  if (outliersField) {
    var syncName = BOX_SYNC_NAME;
    baseMeta = (_a2 = {}, _a2[outliersField] = { sync: syncName, nice: true }, _a2[yFieldName] = { sync: syncName, nice: true }, _a2);
  }
  var scales = deepAssign(baseMeta, meta2, (_b = {}, _b[xField] = pick(xAxis, AXIS_META_CONFIG_KEYS), _b[yFieldName] = pick(yAxis, AXIS_META_CONFIG_KEYS), _b));
  chart.scale(scales);
  return params;
}
function axis$c(params) {
  var chart = params.chart, options = params.options;
  var xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField, yField = options.yField;
  var yFieldName = Array.isArray(yField) ? BOX_RANGE : yField;
  if (xAxis === false) {
    chart.axis(xField, false);
  } else {
    chart.axis(xField, xAxis);
  }
  if (yAxis === false) {
    chart.axis(BOX_RANGE, false);
  } else {
    chart.axis(yFieldName, yAxis);
  }
  return params;
}
function legend$7(params) {
  var chart = params.chart, options = params.options;
  var legend2 = options.legend, groupField = options.groupField;
  if (groupField) {
    if (legend2) {
      chart.legend(groupField, legend2);
    } else {
      chart.legend(groupField, { position: "bottom" });
    }
  } else {
    chart.legend(false);
  }
  return params;
}
function adaptor$h(params) {
  return flow(field$4, outliersPoint, meta$a, axis$c, legend$7, tooltip$9, interaction$7, animation$5, theme$2)(params);
}
(function(_super) {
  __extends$3(Box, _super);
  function Box() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "box";
    return _this;
  }
  Box.getDefaultOptions = function() {
    return DEFAULT_OPTIONS$j;
  };
  Box.prototype.changeData = function(data2) {
    this.updateOption({ data: data2 });
    var yField = this.options.yField;
    var outliersView = this.chart.views.find(function(v2) {
      return v2.id === OUTLIERS_VIEW_ID;
    });
    if (outliersView) {
      outliersView.data(data2);
    }
    this.chart.changeData(transformData$8(data2, yField));
  };
  Box.prototype.getDefaultOptions = function() {
    return Box.getDefaultOptions();
  };
  Box.prototype.getSchemaAdaptor = function() {
    return adaptor$h;
  };
  return Box;
})(Plot);
var src = { exports: {} };
var helper = { exports: {} };
(function(module) {
  var self2 = module.exports;
  module.exports.isNumber = function(x2) {
    return typeof x2 === "number";
  };
  module.exports.findMin = function(arr) {
    if (arr.length === 0) {
      return Infinity;
    }
    var curr = arr[0];
    for (var i2 = 1; i2 < arr.length; i2++) {
      curr = Math.min(curr, arr[i2]);
    }
    return curr;
  };
  module.exports.findMax = function(arr) {
    if (arr.length === 0) {
      return -Infinity;
    }
    var curr = arr[0];
    for (var i2 = 1; i2 < arr.length; i2++) {
      curr = Math.max(curr, arr[i2]);
    }
    return curr;
  };
  module.exports.findMinMulti = function(arr) {
    var curr = self2.findMin(arr[0]);
    for (var i2 = 1; i2 < arr.length; i2++) {
      curr = Math.min(curr, self2.findMin(arr[i2]));
    }
    return curr;
  };
  module.exports.findMaxMulti = function(arr) {
    var curr = self2.findMax(arr[0]);
    for (var i2 = 1; i2 < arr.length; i2++) {
      curr = Math.max(curr, self2.findMax(arr[i2]));
    }
    return curr;
  };
  module.exports.inside = function(min2, max2, x2) {
    return min2 <= x2 && x2 <= max2;
  };
})(helper);
(function(module) {
  var DEFAULT_SIZE2 = 50;
  var DEFAULT_WIDTH = 2;
  var LN_2 = Math.log(2);
  var self2 = module.exports;
  var helper$1 = helper.exports;
  function kernel(x2) {
    return 1 - Math.abs(x2);
  }
  module.exports.getUnifiedMinMax = function(arr, options) {
    return self2.getUnifiedMinMaxMulti([arr], options);
  };
  module.exports.getUnifiedMinMaxMulti = function(arrMulti, options) {
    options = options || {};
    var relaxMin = false;
    var relaxMax = false;
    var width = helper$1.isNumber(options.width) ? options.width : DEFAULT_WIDTH;
    var size2 = helper$1.isNumber(options.size) ? options.size : DEFAULT_SIZE2;
    var min2 = helper$1.isNumber(options.min) ? options.min : (relaxMin = true, helper$1.findMinMulti(arrMulti));
    var max2 = helper$1.isNumber(options.max) ? options.max : (relaxMax = true, helper$1.findMaxMulti(arrMulti));
    var range3 = max2 - min2;
    var step = range3 / (size2 - 1);
    if (relaxMin) {
      min2 = min2 - 2 * width * step;
    }
    if (relaxMax) {
      max2 = max2 + 2 * width * step;
    }
    return {
      min: min2,
      max: max2
    };
  };
  module.exports.create = function(arr, options) {
    options = options || {};
    if (!arr || arr.length === 0) {
      return [];
    }
    var size2 = helper$1.isNumber(options.size) ? options.size : DEFAULT_SIZE2;
    var width = helper$1.isNumber(options.width) ? options.width : DEFAULT_WIDTH;
    var normalizedMinMax = self2.getUnifiedMinMax(arr, {
      size: size2,
      width,
      min: options.min,
      max: options.max
    });
    var min2 = normalizedMinMax.min;
    var max2 = normalizedMinMax.max;
    var range3 = max2 - min2;
    var step = range3 / (size2 - 1);
    if (range3 === 0) {
      return [{ x: min2, y: 1 }];
    }
    var buckets = [];
    for (var i2 = 0; i2 < size2; i2++) {
      buckets.push({
        x: min2 + i2 * step,
        y: 0
      });
    }
    var xToBucket = function(x2) {
      return Math.floor((x2 - min2) / step);
    };
    var partialArea = generatePartialAreas(kernel, width);
    var fullArea = partialArea[width];
    var c2 = partialArea[width - 1] - partialArea[width - 2];
    var initalValue = 0;
    arr.forEach(function(x2) {
      var bucket = xToBucket(x2);
      if (bucket + width < 0 || bucket - width >= buckets.length) {
        return;
      }
      var start = Math.max(bucket - width, 0);
      var mid2 = bucket;
      var end = Math.min(bucket + width, buckets.length - 1);
      var leftBlockCount = start - (bucket - width);
      var rightBlockCount = bucket + width - end;
      var spilledAreaLeft = partialArea[-width - 1 + leftBlockCount] || 0;
      var spilledAreaRight = partialArea[-width - 1 + rightBlockCount] || 0;
      var weight = fullArea / (fullArea - spilledAreaLeft - spilledAreaRight);
      if (leftBlockCount > 0) {
        initalValue += weight * (leftBlockCount - 1) * c2;
      }
      var startGradPos = Math.max(0, bucket - width + 1);
      if (helper$1.inside(0, buckets.length - 1, startGradPos)) {
        buckets[startGradPos].y += weight * 1 * c2;
      }
      if (helper$1.inside(0, buckets.length - 1, mid2 + 1)) {
        buckets[mid2 + 1].y -= weight * 2 * c2;
      }
      if (helper$1.inside(0, buckets.length - 1, end + 1)) {
        buckets[end + 1].y += weight * 1 * c2;
      }
    });
    var accumulator = initalValue;
    var gradAccumulator = 0;
    var area2 = 0;
    buckets.forEach(function(bucket) {
      gradAccumulator += bucket.y;
      accumulator += gradAccumulator;
      bucket.y = accumulator;
      area2 += accumulator;
    });
    if (area2 > 0) {
      buckets.forEach(function(bucket) {
        bucket.y /= area2;
      });
    }
    return buckets;
  };
  function generatePartialAreas(kernel2, width) {
    var partialAreas = {};
    var accumulator = 0;
    for (var i2 = -width; i2 <= width; i2++) {
      accumulator += kernel2(i2 / width);
      partialAreas[i2] = accumulator;
    }
    return partialAreas;
  }
  module.exports.getExpectedValueFromPdf = function(pdf2) {
    if (!pdf2 || pdf2.length === 0) {
      return void 0;
    }
    var expected = 0;
    pdf2.forEach(function(obj) {
      expected += obj.x * obj.y;
    });
    return expected;
  };
  module.exports.getXWithLeftTailArea = function(pdf2, area2) {
    if (!pdf2 || pdf2.length === 0) {
      return void 0;
    }
    var accumulator = 0;
    var last2 = 0;
    for (var i2 = 0; i2 < pdf2.length; i2++) {
      last2 = i2;
      accumulator += pdf2[i2].y;
      if (accumulator >= area2) {
        break;
      }
    }
    return pdf2[last2].x;
  };
  module.exports.getPerplexity = function(pdf2) {
    if (!pdf2 || pdf2.length === 0) {
      return void 0;
    }
    var entropy = 0;
    pdf2.forEach(function(obj) {
      var ln = Math.log(obj.y);
      if (isFinite(ln)) {
        entropy += obj.y * ln;
      }
    });
    entropy = -entropy / LN_2;
    return Math.pow(2, entropy);
  };
})(src);
var pdf = src.exports;
function quantileSorted(x2, p2) {
  var idx = x2.length * p2;
  if (x2.length === 0) {
    throw new Error("quantile requires at least one data point.");
  } else if (p2 < 0 || p2 > 1) {
    throw new Error("quantiles must be between 0 and 1");
  } else if (p2 === 1) {
    return x2[x2.length - 1];
  } else if (p2 === 0) {
    return x2[0];
  } else if (idx % 1 !== 0) {
    return x2[Math.ceil(idx) - 1];
  } else if (x2.length % 2 === 0) {
    return (x2[idx - 1] + x2[idx]) / 2;
  } else {
    return x2[idx];
  }
}
function swap(arr, i2, j2) {
  var tmp = arr[i2];
  arr[i2] = arr[j2];
  arr[j2] = tmp;
}
function quickselect(arr, k2, left2, right2) {
  left2 = left2 || 0;
  right2 = right2 || arr.length - 1;
  while (right2 > left2) {
    if (right2 - left2 > 600) {
      var n2 = right2 - left2 + 1;
      var m2 = k2 - left2 + 1;
      var z2 = Math.log(n2);
      var s2 = 0.5 * Math.exp(2 * z2 / 3);
      var sd2 = 0.5 * Math.sqrt(z2 * s2 * (n2 - s2) / n2);
      if (m2 - n2 / 2 < 0)
        sd2 *= -1;
      var newLeft = Math.max(left2, Math.floor(k2 - m2 * s2 / n2 + sd2));
      var newRight = Math.min(right2, Math.floor(k2 + (n2 - m2) * s2 / n2 + sd2));
      quickselect(arr, k2, newLeft, newRight);
    }
    var t2 = arr[k2];
    var i2 = left2;
    var j2 = right2;
    swap(arr, left2, k2);
    if (arr[right2] > t2)
      swap(arr, left2, right2);
    while (i2 < j2) {
      swap(arr, i2, j2);
      i2++;
      j2--;
      while (arr[i2] < t2)
        i2++;
      while (arr[j2] > t2)
        j2--;
    }
    if (arr[left2] === t2)
      swap(arr, left2, j2);
    else {
      j2++;
      swap(arr, j2, right2);
    }
    if (j2 <= k2)
      left2 = j2 + 1;
    if (k2 <= j2)
      right2 = j2 - 1;
  }
}
function quantile(x2, p2) {
  var copy = x2.slice();
  if (Array.isArray(p2)) {
    multiQuantileSelect(copy, p2);
    var results = [];
    for (var i2 = 0; i2 < p2.length; i2++) {
      results[i2] = quantileSorted(copy, p2[i2]);
    }
    return results;
  } else {
    var idx = quantileIndex(copy.length, p2);
    quantileSelect(copy, idx, 0, copy.length - 1);
    return quantileSorted(copy, p2);
  }
}
function quantileSelect(arr, k2, left2, right2) {
  if (k2 % 1 === 0) {
    quickselect(arr, k2, left2, right2);
  } else {
    k2 = Math.floor(k2);
    quickselect(arr, k2, left2, right2);
    quickselect(arr, k2 + 1, k2 + 1, right2);
  }
}
function multiQuantileSelect(arr, p2) {
  var indices = [0];
  for (var i2 = 0; i2 < p2.length; i2++) {
    indices.push(quantileIndex(arr.length, p2[i2]));
  }
  indices.push(arr.length - 1);
  indices.sort(compare);
  var stack = [0, indices.length - 1];
  while (stack.length) {
    var r2 = Math.ceil(stack.pop());
    var l2 = Math.floor(stack.pop());
    if (r2 - l2 <= 1)
      continue;
    var m2 = Math.floor((l2 + r2) / 2);
    quantileSelect(arr, indices[m2], Math.floor(indices[l2]), Math.ceil(indices[r2]));
    stack.push(l2, m2, m2, r2);
  }
}
function compare(a2, b10) {
  return a2 - b10;
}
function quantileIndex(len, p2) {
  var idx = len * p2;
  if (p2 === 1) {
    return len - 1;
  } else if (p2 === 0) {
    return 0;
  } else if (idx % 1 !== 0) {
    return Math.ceil(idx) - 1;
  } else if (len % 2 === 0) {
    return idx - 0.5;
  } else {
    return idx;
  }
}
var toBoxValue = function(values2) {
  return {
    low: min$2(values2),
    high: max$2(values2),
    q1: quantile(values2, 0.25),
    q3: quantile(values2, 0.75),
    median: quantile(values2, [0.5]),
    minMax: [min$2(values2), max$2(values2)],
    quantile: [quantile(values2, 0.25), quantile(values2, 0.75)]
  };
};
var toViolinValue = function(values2, pdfOptions) {
  var pdfResults = pdf.create(values2, pdfOptions);
  return {
    violinSize: pdfResults.map(function(result) {
      return result.y;
    }),
    violinY: pdfResults.map(function(result) {
      return result.x;
    })
  };
};
var transformViolinData = function(options) {
  var xField = options.xField, yField = options.yField, seriesField = options.seriesField, data2 = options.data, kde = options.kde;
  var pdfOptions = {
    min: kde.min,
    max: kde.max,
    size: kde.sampleSize,
    width: kde.width
  };
  if (!seriesField) {
    var group_1 = groupBy(data2, xField);
    return Object.keys(group_1).map(function(x2) {
      var records = group_1[x2];
      var values2 = records.map(function(record) {
        return record[yField];
      });
      return __assign$4(__assign$4({ x: x2 }, toViolinValue(values2, pdfOptions)), toBoxValue(values2));
    });
  }
  var resultList = [];
  var seriesGroup = groupBy(data2, seriesField);
  Object.keys(seriesGroup).forEach(function(series) {
    var group2 = groupBy(seriesGroup[series], xField);
    return Object.keys(group2).forEach(function(key2) {
      var _a2;
      var records = group2[key2];
      var values2 = records.map(function(record) {
        return record[yField];
      });
      resultList.push(__assign$4(__assign$4((_a2 = { x: key2 }, _a2[seriesField] = series, _a2), toViolinValue(values2, pdfOptions)), toBoxValue(values2)));
    });
  });
  return resultList;
};
var X_FIELD$2 = "x";
var VIOLIN_Y_FIELD = "violinY";
var VIOLIN_SIZE_FIELD = "violinSize";
var MIN_MAX_FIELD = "minMax";
var QUANTILE_FIELD = "quantile";
var MEDIAN_FIELD = "median";
var VIOLIN_VIEW_ID = "violin_view";
var MIN_MAX_VIEW_ID = "min_max_view";
var QUANTILE_VIEW_ID = "quantile_view";
var MEDIAN_VIEW_ID = "median_view";
var DEFAULT_OPTIONS$i = deepAssign({}, Plot.getDefaultOptions(), {
  syncViewPadding: true,
  kde: {
    type: "triangular",
    sampleSize: 32,
    width: 3
  },
  violinStyle: {
    lineWidth: 1,
    fillOpacity: 0.3,
    strokeOpacity: 0.75
  },
  xAxis: {
    grid: {
      line: null
    },
    tickLine: {
      alignTick: false
    }
  },
  yAxis: {
    grid: {
      line: {
        style: {
          lineWidth: 0.5,
          lineDash: [4, 4]
        }
      }
    }
  },
  legend: {
    position: "top-left"
  },
  tooltip: {
    showMarkers: false
  }
});
var TOOLTIP_FIELDS = ["low", "high", "q1", "q3", "median"];
var adjustCfg = [
  {
    type: "dodge",
    marginRatio: 1 / 32
  }
];
function data$1(params) {
  var chart = params.chart, options = params.options;
  chart.data(transformViolinData(options));
  return params;
}
function violinView(params) {
  var chart = params.chart, options = params.options;
  var seriesField = options.seriesField, color2 = options.color, _a2 = options.shape, shape = _a2 === void 0 ? "violin" : _a2, violinStyle = options.violinStyle, tooltip2 = options.tooltip, state2 = options.state;
  var view = chart.createView({ id: VIOLIN_VIEW_ID });
  violin({
    chart: view,
    options: {
      xField: X_FIELD$2,
      yField: VIOLIN_Y_FIELD,
      seriesField: seriesField ? seriesField : X_FIELD$2,
      sizeField: VIOLIN_SIZE_FIELD,
      tooltip: __assign$4({ fields: TOOLTIP_FIELDS }, tooltip2),
      violin: {
        style: violinStyle,
        color: color2,
        shape
      },
      state: state2
    }
  });
  view.geometries[0].adjust(adjustCfg);
  return params;
}
function boxView(params) {
  var chart = params.chart, options = params.options;
  var seriesField = options.seriesField, color2 = options.color, tooltip2 = options.tooltip, box2 = options.box;
  if (box2 === false)
    return params;
  var minMaxView = chart.createView({ id: MIN_MAX_VIEW_ID });
  interval({
    chart: minMaxView,
    options: {
      xField: X_FIELD$2,
      yField: MIN_MAX_FIELD,
      seriesField: seriesField ? seriesField : X_FIELD$2,
      tooltip: __assign$4({ fields: TOOLTIP_FIELDS }, tooltip2),
      state: typeof box2 === "object" ? box2.state : {},
      interval: {
        color: color2,
        size: 1,
        style: {
          lineWidth: 0
        }
      }
    }
  });
  minMaxView.geometries[0].adjust(adjustCfg);
  var quantileView = chart.createView({ id: QUANTILE_VIEW_ID });
  interval({
    chart: quantileView,
    options: {
      xField: X_FIELD$2,
      yField: QUANTILE_FIELD,
      seriesField: seriesField ? seriesField : X_FIELD$2,
      tooltip: __assign$4({ fields: TOOLTIP_FIELDS }, tooltip2),
      state: typeof box2 === "object" ? box2.state : {},
      interval: {
        color: color2,
        size: 8,
        style: {
          fillOpacity: 1
        }
      }
    }
  });
  quantileView.geometries[0].adjust(adjustCfg);
  var medianView = chart.createView({ id: MEDIAN_VIEW_ID });
  point({
    chart: medianView,
    options: {
      xField: X_FIELD$2,
      yField: MEDIAN_FIELD,
      seriesField: seriesField ? seriesField : X_FIELD$2,
      tooltip: __assign$4({ fields: TOOLTIP_FIELDS }, tooltip2),
      state: typeof box2 === "object" ? box2.state : {},
      point: {
        color: color2,
        size: 1,
        style: {
          fill: "white",
          lineWidth: 0
        }
      }
    }
  });
  medianView.geometries[0].adjust(adjustCfg);
  quantileView.axis(false);
  minMaxView.axis(false);
  medianView.axis(false);
  medianView.legend(false);
  minMaxView.legend(false);
  quantileView.legend(false);
  return params;
}
function meta$9(params) {
  var _a2;
  var chart = params.chart, options = params.options;
  var meta2 = options.meta, xAxis = options.xAxis, yAxis = options.yAxis;
  var baseMeta = {};
  var scales = deepAssign(baseMeta, meta2, (_a2 = {}, _a2[X_FIELD$2] = __assign$4(__assign$4({ sync: true }, pick(xAxis, AXIS_META_CONFIG_KEYS)), {
    type: "cat"
  }), _a2[VIOLIN_Y_FIELD] = __assign$4({ sync: true }, pick(yAxis, AXIS_META_CONFIG_KEYS)), _a2[MIN_MAX_FIELD] = __assign$4({ sync: VIOLIN_Y_FIELD }, pick(yAxis, AXIS_META_CONFIG_KEYS)), _a2[QUANTILE_FIELD] = __assign$4({ sync: VIOLIN_Y_FIELD }, pick(yAxis, AXIS_META_CONFIG_KEYS)), _a2[MEDIAN_FIELD] = __assign$4({ sync: VIOLIN_Y_FIELD }, pick(yAxis, AXIS_META_CONFIG_KEYS)), _a2));
  chart.scale(scales);
  return params;
}
function axis$b(params) {
  var chart = params.chart, options = params.options;
  var xAxis = options.xAxis, yAxis = options.yAxis;
  var view = findViewById(chart, VIOLIN_VIEW_ID);
  if (xAxis === false) {
    view.axis(X_FIELD$2, false);
  } else {
    view.axis(X_FIELD$2, xAxis);
  }
  if (yAxis === false) {
    view.axis(VIOLIN_Y_FIELD, false);
  } else {
    view.axis(VIOLIN_Y_FIELD, yAxis);
  }
  chart.axis(false);
  return params;
}
function legend$6(params) {
  var chart = params.chart, options = params.options;
  var legend2 = options.legend, seriesField = options.seriesField, shape = options.shape;
  if (legend2 === false) {
    chart.legend(false);
  } else {
    var legendField_1 = seriesField ? seriesField : X_FIELD$2;
    var legendOptions = omit$1(legend2, ["selected"]);
    if (!shape || !shape.startsWith("hollow")) {
      if (!get(legendOptions, ["marker", "style", "lineWidth"])) {
        set(legendOptions, ["marker", "style", "lineWidth"], 0);
      }
    }
    chart.legend(legendField_1, legendOptions);
    if (get(legend2, "selected")) {
      each$1(chart.views, function(view) {
        return view.legend(legendField_1, legend2);
      });
    }
  }
  return params;
}
function annotation(params) {
  var chart = params.chart;
  var violinView2 = findViewById(chart, VIOLIN_VIEW_ID);
  annotation$2()(__assign$4(__assign$4({}, params), { chart: violinView2 }));
  return params;
}
function animation$3(params) {
  var chart = params.chart, options = params.options;
  var animation2 = options.animation;
  each$1(chart.views, function(view) {
    if (typeof animation2 === "boolean") {
      view.animate(animation2);
    } else {
      view.animate(true);
    }
    each$1(view.geometries, function(g2) {
      g2.animate(animation2);
    });
  });
  return params;
}
function adaptor$g(params) {
  return flow(theme$2, data$1, violinView, boxView, meta$9, tooltip$9, axis$b, legend$6, interaction$7, annotation, animation$3)(params);
}
(function(_super) {
  __extends$3(Violin2, _super);
  function Violin2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "violin";
    return _this;
  }
  Violin2.getDefaultOptions = function() {
    return DEFAULT_OPTIONS$i;
  };
  Violin2.prototype.changeData = function(data2) {
    this.updateOption({ data: data2 });
    this.chart.changeData(transformViolinData(this.options));
  };
  Violin2.prototype.getDefaultOptions = function() {
    return Violin2.getDefaultOptions();
  };
  Violin2.prototype.getSchemaAdaptor = function() {
    return adaptor$g;
  };
  return Violin2;
})(Plot);
var each = function(f2) {
  return function(c0, c1) {
    var out = [];
    out[0] = f2(c0[0], c1[0]);
    out[1] = f2(c0[1], c1[1]);
    out[2] = f2(c0[2], c1[2]);
    return out;
  };
};
var blendObject = {
  normal: function(a2) {
    return a2;
  },
  multiply: function(a2, b10) {
    return a2 * b10 / 255;
  },
  screen: function(a2, b10) {
    return 255 * (1 - (1 - a2 / 255) * (1 - b10 / 255));
  },
  overlay: function(a2, b10) {
    return b10 < 128 ? 2 * a2 * b10 / 255 : 255 * (1 - 2 * (1 - a2 / 255) * (1 - b10 / 255));
  },
  darken: function(a2, b10) {
    return a2 > b10 ? b10 : a2;
  },
  lighten: function(a2, b10) {
    return a2 > b10 ? a2 : b10;
  },
  dodge: function(a2, b10) {
    if (a2 === 255)
      return 255;
    a2 = 255 * (b10 / 255) / (1 - a2 / 255);
    return a2 > 255 ? 255 : a2;
  },
  burn: function(a2, b10) {
    if (b10 === 255)
      return 255;
    else if (a2 === 0)
      return 0;
    else
      return 255 * (1 - Math.min(1, (1 - b10 / 255) / (a2 / 255)));
  }
};
var innerBlend = function(mode) {
  if (!blendObject[mode]) {
    throw new Error("unknown blend mode " + mode);
  }
  return blendObject[mode];
};
function blend(c0, c1, mode) {
  if (mode === void 0) {
    mode = "normal";
  }
  var blendRgbArr = each(innerBlend(mode))(colorToArr(c0), colorToArr(c1));
  var _a2 = colorToArr(c0), r0 = _a2[0], g0 = _a2[1], b02 = _a2[2], a0 = _a2[3];
  var _b = colorToArr(c1), r1 = _b[0], g1 = _b[1], b12 = _b[2], a1 = _b[3];
  var a2 = Number((a0 + a1 * (1 - a0)).toFixed(2));
  var r2 = Math.round((a0 * (1 - a1) * (r0 / 255) + a0 * a1 * (blendRgbArr[0] / 255) + (1 - a0) * a1 * (r1 / 255)) / a2 * 255);
  var g2 = Math.round((a0 * (1 - a1) * (g0 / 255) + a0 * a1 * (blendRgbArr[1] / 255) + (1 - a0) * a1 * (g1 / 255)) / a2 * 255);
  var b10 = Math.round((a0 * (1 - a1) * (b02 / 255) + a0 * a1 * (blendRgbArr[2] / 255) + (1 - a0) * a1 * (b12 / 255)) / a2 * 255);
  return "rgba(" + r2 + ", " + g2 + ", " + b10 + ", " + a2 + ")";
}
function colorToArr(c2) {
  var color2 = c2.replace("/s+/g", "");
  var rgbaArr;
  if (typeof color2 === "string" && !color2.startsWith("rgba") && !color2.startsWith("#")) {
    return rgbaArr = colorUtil.rgb2arr(colorUtil.toRGB(color2)).concat([1]);
  }
  if (color2.startsWith("rgba"))
    rgbaArr = color2.replace("rgba(", "").replace(")", "").split(",");
  if (color2.startsWith("#"))
    rgbaArr = colorUtil.rgb2arr(color2).concat([1]);
  return rgbaArr.map(function(item, index2) {
    return index2 === 3 ? Number(item) : item | 0;
  });
}
function bisect(f2, a2, b10, parameters) {
  parameters = parameters || {};
  var maxIterations = parameters.maxIterations || 100, tolerance2 = parameters.tolerance || 1e-10, fA = f2(a2), fB = f2(b10), delta = b10 - a2;
  if (fA * fB > 0) {
    throw "Initial bisect points must have opposite signs";
  }
  if (fA === 0)
    return a2;
  if (fB === 0)
    return b10;
  for (var i2 = 0; i2 < maxIterations; ++i2) {
    delta /= 2;
    var mid2 = a2 + delta, fMid = f2(mid2);
    if (fMid * fA >= 0) {
      a2 = mid2;
    }
    if (Math.abs(delta) < tolerance2 || fMid === 0) {
      return mid2;
    }
  }
  return a2 + delta;
}
function zeros(x2) {
  var r2 = new Array(x2);
  for (var i2 = 0; i2 < x2; ++i2) {
    r2[i2] = 0;
  }
  return r2;
}
function zerosM(x2, y2) {
  return zeros(x2).map(function() {
    return zeros(y2);
  });
}
function dot(a2, b10) {
  var ret = 0;
  for (var i2 = 0; i2 < a2.length; ++i2) {
    ret += a2[i2] * b10[i2];
  }
  return ret;
}
function norm2(a2) {
  return Math.sqrt(dot(a2, a2));
}
function scale$1(ret, value2, c2) {
  for (var i2 = 0; i2 < value2.length; ++i2) {
    ret[i2] = value2[i2] * c2;
  }
}
function weightedSum(ret, w1, v1, w2, v2) {
  for (var j2 = 0; j2 < ret.length; ++j2) {
    ret[j2] = w1 * v1[j2] + w2 * v2[j2];
  }
}
function nelderMead(f2, x0, parameters) {
  parameters = parameters || {};
  var maxIterations = parameters.maxIterations || x0.length * 200, nonZeroDelta = parameters.nonZeroDelta || 1.05, zeroDelta = parameters.zeroDelta || 1e-3, minErrorDelta = parameters.minErrorDelta || 1e-6, minTolerance = parameters.minErrorDelta || 1e-5, rho = parameters.rho !== void 0 ? parameters.rho : 1, chi = parameters.chi !== void 0 ? parameters.chi : 2, psi = parameters.psi !== void 0 ? parameters.psi : -0.5, sigma = parameters.sigma !== void 0 ? parameters.sigma : 0.5, maxDiff;
  var N2 = x0.length, simplex = new Array(N2 + 1);
  simplex[0] = x0;
  simplex[0].fx = f2(x0);
  simplex[0].id = 0;
  for (var i2 = 0; i2 < N2; ++i2) {
    var point2 = x0.slice();
    point2[i2] = point2[i2] ? point2[i2] * nonZeroDelta : zeroDelta;
    simplex[i2 + 1] = point2;
    simplex[i2 + 1].fx = f2(point2);
    simplex[i2 + 1].id = i2 + 1;
  }
  function updateSimplex(value2) {
    for (var i3 = 0; i3 < value2.length; i3++) {
      simplex[N2][i3] = value2[i3];
    }
    simplex[N2].fx = value2.fx;
  }
  var sortOrder = function(a2, b10) {
    return a2.fx - b10.fx;
  };
  var centroid = x0.slice(), reflected = x0.slice(), contracted = x0.slice(), expanded = x0.slice();
  for (var iteration = 0; iteration < maxIterations; ++iteration) {
    simplex.sort(sortOrder);
    if (parameters.history) {
      var sortedSimplex = simplex.map(function(x2) {
        var state2 = x2.slice();
        state2.fx = x2.fx;
        state2.id = x2.id;
        return state2;
      });
      sortedSimplex.sort(function(a2, b10) {
        return a2.id - b10.id;
      });
      parameters.history.push({
        x: simplex[0].slice(),
        fx: simplex[0].fx,
        simplex: sortedSimplex
      });
    }
    maxDiff = 0;
    for (i2 = 0; i2 < N2; ++i2) {
      maxDiff = Math.max(maxDiff, Math.abs(simplex[0][i2] - simplex[1][i2]));
    }
    if (Math.abs(simplex[0].fx - simplex[N2].fx) < minErrorDelta && maxDiff < minTolerance) {
      break;
    }
    for (i2 = 0; i2 < N2; ++i2) {
      centroid[i2] = 0;
      for (var j2 = 0; j2 < N2; ++j2) {
        centroid[i2] += simplex[j2][i2];
      }
      centroid[i2] /= N2;
    }
    var worst = simplex[N2];
    weightedSum(reflected, 1 + rho, centroid, -rho, worst);
    reflected.fx = f2(reflected);
    if (reflected.fx < simplex[0].fx) {
      weightedSum(expanded, 1 + chi, centroid, -chi, worst);
      expanded.fx = f2(expanded);
      if (expanded.fx < reflected.fx) {
        updateSimplex(expanded);
      } else {
        updateSimplex(reflected);
      }
    } else if (reflected.fx >= simplex[N2 - 1].fx) {
      var shouldReduce = false;
      if (reflected.fx > worst.fx) {
        weightedSum(contracted, 1 + psi, centroid, -psi, worst);
        contracted.fx = f2(contracted);
        if (contracted.fx < worst.fx) {
          updateSimplex(contracted);
        } else {
          shouldReduce = true;
        }
      } else {
        weightedSum(contracted, 1 - psi * rho, centroid, psi * rho, worst);
        contracted.fx = f2(contracted);
        if (contracted.fx < reflected.fx) {
          updateSimplex(contracted);
        } else {
          shouldReduce = true;
        }
      }
      if (shouldReduce) {
        if (sigma >= 1)
          break;
        for (i2 = 1; i2 < simplex.length; ++i2) {
          weightedSum(simplex[i2], 1 - sigma, simplex[0], sigma, simplex[i2]);
          simplex[i2].fx = f2(simplex[i2]);
        }
      }
    } else {
      updateSimplex(reflected);
    }
  }
  simplex.sort(sortOrder);
  return {
    fx: simplex[0].fx,
    x: simplex[0]
  };
}
function wolfeLineSearch(f2, pk2, current, next, a2, c1, c2) {
  var phi0 = current.fx, phiPrime0 = dot(current.fxprime, pk2), phi2 = phi0, phi_old = phi0, phiPrime = phiPrime0, a0 = 0;
  a2 = a2 || 1;
  c1 = c1 || 1e-6;
  c2 = c2 || 0.1;
  function zoom2(a_lo, a_high, phi_lo) {
    for (var iteration2 = 0; iteration2 < 16; ++iteration2) {
      a2 = (a_lo + a_high) / 2;
      weightedSum(next.x, 1, current.x, a2, pk2);
      phi2 = next.fx = f2(next.x, next.fxprime);
      phiPrime = dot(next.fxprime, pk2);
      if (phi2 > phi0 + c1 * a2 * phiPrime0 || phi2 >= phi_lo) {
        a_high = a2;
      } else {
        if (Math.abs(phiPrime) <= -c2 * phiPrime0) {
          return a2;
        }
        if (phiPrime * (a_high - a_lo) >= 0) {
          a_high = a_lo;
        }
        a_lo = a2;
        phi_lo = phi2;
      }
    }
    return 0;
  }
  for (var iteration = 0; iteration < 10; ++iteration) {
    weightedSum(next.x, 1, current.x, a2, pk2);
    phi2 = next.fx = f2(next.x, next.fxprime);
    phiPrime = dot(next.fxprime, pk2);
    if (phi2 > phi0 + c1 * a2 * phiPrime0 || iteration && phi2 >= phi_old) {
      return zoom2(a0, a2, phi_old);
    }
    if (Math.abs(phiPrime) <= -c2 * phiPrime0) {
      return a2;
    }
    if (phiPrime >= 0) {
      return zoom2(a2, a0, phi2);
    }
    phi_old = phi2;
    a0 = a2;
    a2 *= 2;
  }
  return a2;
}
function conjugateGradient(f2, initial, params) {
  var current = { x: initial.slice(), fx: 0, fxprime: initial.slice() }, next = { x: initial.slice(), fx: 0, fxprime: initial.slice() }, yk2 = initial.slice(), pk2, temp, a2 = 1, maxIterations;
  params = params || {};
  maxIterations = params.maxIterations || initial.length * 20;
  current.fx = f2(current.x, current.fxprime);
  pk2 = current.fxprime.slice();
  scale$1(pk2, current.fxprime, -1);
  for (var i2 = 0; i2 < maxIterations; ++i2) {
    a2 = wolfeLineSearch(f2, pk2, current, next, a2);
    if (params.history) {
      params.history.push({
        x: current.x.slice(),
        fx: current.fx,
        fxprime: current.fxprime.slice(),
        alpha: a2
      });
    }
    if (!a2) {
      scale$1(pk2, current.fxprime, -1);
    } else {
      weightedSum(yk2, 1, next.fxprime, -1, current.fxprime);
      var delta_k = dot(current.fxprime, current.fxprime), beta_k = Math.max(0, dot(yk2, next.fxprime) / delta_k);
      weightedSum(pk2, beta_k, pk2, -1, next.fxprime);
      temp = current;
      current = next;
      next = temp;
    }
    if (norm2(current.fxprime) <= 1e-5) {
      break;
    }
  }
  if (params.history) {
    params.history.push({
      x: current.x.slice(),
      fx: current.fx,
      fxprime: current.fxprime.slice(),
      alpha: a2
    });
  }
  return current;
}
var SMALL$1 = 1e-10;
function intersectionArea(circles, stats) {
  var intersectionPoints = getIntersectionPoints(circles);
  var innerPoints = intersectionPoints.filter(function(p3) {
    return containedInCircles(p3, circles);
  });
  var arcArea = 0, polygonArea = 0, i2;
  var arcs = [];
  if (innerPoints.length > 1) {
    var center2 = getCenter(innerPoints);
    for (i2 = 0; i2 < innerPoints.length; ++i2) {
      var p2 = innerPoints[i2];
      p2.angle = Math.atan2(p2.x - center2.x, p2.y - center2.y);
    }
    innerPoints.sort(function(a4, b10) {
      return b10.angle - a4.angle;
    });
    var p22 = innerPoints[innerPoints.length - 1];
    for (i2 = 0; i2 < innerPoints.length; ++i2) {
      var p1 = innerPoints[i2];
      polygonArea += (p22.x + p1.x) * (p1.y - p22.y);
      var midPoint = { x: (p1.x + p22.x) / 2, y: (p1.y + p22.y) / 2 };
      var arc2 = null;
      for (var j2 = 0; j2 < p1.parentIndex.length; ++j2) {
        if (p22.parentIndex.indexOf(p1.parentIndex[j2]) > -1) {
          var circle2 = circles[p1.parentIndex[j2]], a1 = Math.atan2(p1.x - circle2.x, p1.y - circle2.y), a2 = Math.atan2(p22.x - circle2.x, p22.y - circle2.y);
          var angleDiff = a2 - a1;
          if (angleDiff < 0) {
            angleDiff += 2 * Math.PI;
          }
          var a3 = a2 - angleDiff / 2;
          var width = distance(midPoint, {
            x: circle2.x + circle2.radius * Math.sin(a3),
            y: circle2.y + circle2.radius * Math.cos(a3)
          });
          if (width > circle2.radius * 2) {
            width = circle2.radius * 2;
          }
          if (arc2 === null || arc2.width > width) {
            arc2 = { circle: circle2, width, p1, p2: p22 };
          }
        }
      }
      if (arc2 !== null) {
        arcs.push(arc2);
        arcArea += circleArea(arc2.circle.radius, arc2.width);
        p22 = p1;
      }
    }
  } else {
    var smallest = circles[0];
    for (i2 = 1; i2 < circles.length; ++i2) {
      if (circles[i2].radius < smallest.radius) {
        smallest = circles[i2];
      }
    }
    var disjoint = false;
    for (i2 = 0; i2 < circles.length; ++i2) {
      if (distance(circles[i2], smallest) > Math.abs(smallest.radius - circles[i2].radius)) {
        disjoint = true;
        break;
      }
    }
    if (disjoint) {
      arcArea = polygonArea = 0;
    } else {
      arcArea = smallest.radius * smallest.radius * Math.PI;
      arcs.push({
        circle: smallest,
        p1: { x: smallest.x, y: smallest.y + smallest.radius },
        p2: { x: smallest.x - SMALL$1, y: smallest.y + smallest.radius },
        width: smallest.radius * 2
      });
    }
  }
  polygonArea /= 2;
  if (stats) {
    stats.area = arcArea + polygonArea;
    stats.arcArea = arcArea;
    stats.polygonArea = polygonArea;
    stats.arcs = arcs;
    stats.innerPoints = innerPoints;
    stats.intersectionPoints = intersectionPoints;
  }
  return arcArea + polygonArea;
}
function containedInCircles(point2, circles) {
  for (var i2 = 0; i2 < circles.length; ++i2) {
    if (distance(point2, circles[i2]) > circles[i2].radius + SMALL$1) {
      return false;
    }
  }
  return true;
}
function getIntersectionPoints(circles) {
  var ret = [];
  for (var i2 = 0; i2 < circles.length; ++i2) {
    for (var j2 = i2 + 1; j2 < circles.length; ++j2) {
      var intersect2 = circleCircleIntersection(circles[i2], circles[j2]);
      for (var k2 = 0; k2 < intersect2.length; ++k2) {
        var p2 = intersect2[k2];
        p2.parentIndex = [i2, j2];
        ret.push(p2);
      }
    }
  }
  return ret;
}
function circleArea(r2, width) {
  return r2 * r2 * Math.acos(1 - width / r2) - (r2 - width) * Math.sqrt(width * (2 * r2 - width));
}
function distance(p1, p2) {
  return Math.sqrt((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y));
}
function circleOverlap(r1, r2, d2) {
  if (d2 >= r1 + r2) {
    return 0;
  }
  if (d2 <= Math.abs(r1 - r2)) {
    return Math.PI * Math.min(r1, r2) * Math.min(r1, r2);
  }
  var w1 = r1 - (d2 * d2 - r2 * r2 + r1 * r1) / (2 * d2), w2 = r2 - (d2 * d2 - r1 * r1 + r2 * r2) / (2 * d2);
  return circleArea(r1, w1) + circleArea(r2, w2);
}
function circleCircleIntersection(p1, p2) {
  var d2 = distance(p1, p2), r1 = p1.radius, r2 = p2.radius;
  if (d2 >= r1 + r2 || d2 <= Math.abs(r1 - r2)) {
    return [];
  }
  var a2 = (r1 * r1 - r2 * r2 + d2 * d2) / (2 * d2), h2 = Math.sqrt(r1 * r1 - a2 * a2), x0 = p1.x + a2 * (p2.x - p1.x) / d2, y0 = p1.y + a2 * (p2.y - p1.y) / d2, rx = -(p2.y - p1.y) * (h2 / d2), ry = -(p2.x - p1.x) * (h2 / d2);
  return [
    { x: x0 + rx, y: y0 - ry },
    { x: x0 - rx, y: y0 + ry }
  ];
}
function getCenter(points2) {
  var center2 = { x: 0, y: 0 };
  for (var i2 = 0; i2 < points2.length; ++i2) {
    center2.x += points2[i2].x;
    center2.y += points2[i2].y;
  }
  center2.x /= points2.length;
  center2.y /= points2.length;
  return center2;
}
function venn(areas, parameters) {
  parameters = parameters || {};
  parameters.maxIterations = parameters.maxIterations || 500;
  var initialLayout = parameters.initialLayout || bestInitialLayout;
  var loss = parameters.lossFunction || lossFunction;
  areas = addMissingAreas(areas);
  var circles = initialLayout(areas, parameters);
  var initial = [], setids = [];
  var setid;
  for (setid in circles) {
    if (circles.hasOwnProperty(setid)) {
      initial.push(circles[setid].x);
      initial.push(circles[setid].y);
      setids.push(setid);
    }
  }
  var solution = nelderMead(function(values2) {
    var current = {};
    for (var i3 = 0; i3 < setids.length; ++i3) {
      var setid_1 = setids[i3];
      current[setid_1] = {
        x: values2[2 * i3],
        y: values2[2 * i3 + 1],
        radius: circles[setid_1].radius
      };
    }
    return loss(current, areas);
  }, initial, parameters);
  var positions = solution.x;
  for (var i2 = 0; i2 < setids.length; ++i2) {
    setid = setids[i2];
    circles[setid].x = positions[2 * i2];
    circles[setid].y = positions[2 * i2 + 1];
  }
  return circles;
}
var SMALL = 1e-10;
function distanceFromIntersectArea(r1, r2, overlap2) {
  if (Math.min(r1, r2) * Math.min(r1, r2) * Math.PI <= overlap2 + SMALL) {
    return Math.abs(r1 - r2);
  }
  return bisect(function(distance2) {
    return circleOverlap(r1, r2, distance2) - overlap2;
  }, 0, r1 + r2);
}
function addMissingAreas(areas) {
  areas = areas.slice();
  var ids2 = [], pairs = {};
  var i2, j2, a2, b10;
  for (i2 = 0; i2 < areas.length; ++i2) {
    var area2 = areas[i2];
    if (area2.sets.length == 1) {
      ids2.push(area2.sets[0]);
    } else if (area2.sets.length == 2) {
      a2 = area2.sets[0];
      b10 = area2.sets[1];
      pairs[[a2, b10]] = true;
      pairs[[b10, a2]] = true;
    }
  }
  ids2.sort(function(a3, b11) {
    return a3 > b11 ? 1 : -1;
  });
  for (i2 = 0; i2 < ids2.length; ++i2) {
    a2 = ids2[i2];
    for (j2 = i2 + 1; j2 < ids2.length; ++j2) {
      b10 = ids2[j2];
      if (!([a2, b10] in pairs)) {
        areas.push({ sets: [a2, b10], size: 0 });
      }
    }
  }
  return areas;
}
function getDistanceMatrices(areas, sets, setids) {
  var distances = zerosM(sets.length, sets.length), constraints = zerosM(sets.length, sets.length);
  areas.filter(function(x2) {
    return x2.sets.length == 2;
  }).map(function(current) {
    var left2 = setids[current.sets[0]], right2 = setids[current.sets[1]], r1 = Math.sqrt(sets[left2].size / Math.PI), r2 = Math.sqrt(sets[right2].size / Math.PI), distance2 = distanceFromIntersectArea(r1, r2, current.size);
    distances[left2][right2] = distances[right2][left2] = distance2;
    var c2 = 0;
    if (current.size + 1e-10 >= Math.min(sets[left2].size, sets[right2].size)) {
      c2 = 1;
    } else if (current.size <= 1e-10) {
      c2 = -1;
    }
    constraints[left2][right2] = constraints[right2][left2] = c2;
  });
  return { distances, constraints };
}
function constrainedMDSGradient(x2, fxprime, distances, constraints) {
  var loss = 0, i2;
  for (i2 = 0; i2 < fxprime.length; ++i2) {
    fxprime[i2] = 0;
  }
  for (i2 = 0; i2 < distances.length; ++i2) {
    var xi2 = x2[2 * i2], yi2 = x2[2 * i2 + 1];
    for (var j2 = i2 + 1; j2 < distances.length; ++j2) {
      var xj2 = x2[2 * j2], yj2 = x2[2 * j2 + 1], dij = distances[i2][j2], constraint = constraints[i2][j2];
      var squaredDistance = (xj2 - xi2) * (xj2 - xi2) + (yj2 - yi2) * (yj2 - yi2), distance_1 = Math.sqrt(squaredDistance), delta = squaredDistance - dij * dij;
      if (constraint > 0 && distance_1 <= dij || constraint < 0 && distance_1 >= dij) {
        continue;
      }
      loss += 2 * delta * delta;
      fxprime[2 * i2] += 4 * delta * (xi2 - xj2);
      fxprime[2 * i2 + 1] += 4 * delta * (yi2 - yj2);
      fxprime[2 * j2] += 4 * delta * (xj2 - xi2);
      fxprime[2 * j2 + 1] += 4 * delta * (yj2 - yi2);
    }
  }
  return loss;
}
function bestInitialLayout(areas, params) {
  var initial = greedyLayout(areas, params);
  var loss = params.lossFunction || lossFunction;
  if (areas.length >= 8) {
    var constrained = constrainedMDSLayout(areas, params), constrainedLoss = loss(constrained, areas), greedyLoss = loss(initial, areas);
    if (constrainedLoss + 1e-8 < greedyLoss) {
      initial = constrained;
    }
  }
  return initial;
}
function constrainedMDSLayout(areas, params) {
  params = params || {};
  var restarts = params.restarts || 10;
  var sets = [], setids = {};
  var i2;
  for (i2 = 0; i2 < areas.length; ++i2) {
    var area2 = areas[i2];
    if (area2.sets.length == 1) {
      setids[area2.sets[0]] = sets.length;
      sets.push(area2);
    }
  }
  var matrices = getDistanceMatrices(areas, sets, setids);
  var distances = matrices.distances;
  var constraints = matrices.constraints;
  var norm = norm2(distances.map(norm2)) / distances.length;
  distances = distances.map(function(row) {
    return row.map(function(value2) {
      return value2 / norm;
    });
  });
  var obj = function(x2, fxprime) {
    return constrainedMDSGradient(x2, fxprime, distances, constraints);
  };
  var best, current;
  for (i2 = 0; i2 < restarts; ++i2) {
    var initial = zeros(distances.length * 2).map(Math.random);
    current = conjugateGradient(obj, initial, params);
    if (!best || current.fx < best.fx) {
      best = current;
    }
  }
  var positions = best.x;
  var circles = {};
  for (i2 = 0; i2 < sets.length; ++i2) {
    var set2 = sets[i2];
    circles[set2.sets[0]] = {
      x: positions[2 * i2] * norm,
      y: positions[2 * i2 + 1] * norm,
      radius: Math.sqrt(set2.size / Math.PI)
    };
  }
  if (params.history) {
    for (i2 = 0; i2 < params.history.length; ++i2) {
      scale$1(params.history[i2].x, norm);
    }
  }
  return circles;
}
function greedyLayout(areas, params) {
  var loss = params && params.lossFunction ? params.lossFunction : lossFunction;
  var circles = {}, setOverlaps = {};
  var set2;
  for (var i2 = 0; i2 < areas.length; ++i2) {
    var area2 = areas[i2];
    if (area2.sets.length == 1) {
      set2 = area2.sets[0];
      circles[set2] = {
        x: 1e10,
        y: 1e10,
        rowid: Object.keys(circles).length,
        size: area2.size,
        radius: Math.sqrt(area2.size / Math.PI)
      };
      setOverlaps[set2] = [];
    }
  }
  areas = areas.filter(function(a2) {
    return a2.sets.length == 2;
  });
  for (var i2 = 0; i2 < areas.length; ++i2) {
    var current = areas[i2];
    var weight = current.hasOwnProperty("weight") ? current.weight : 1;
    var left2 = current.sets[0], right2 = current.sets[1];
    if (current.size + SMALL >= Math.min(circles[left2].size, circles[right2].size)) {
      weight = 0;
    }
    setOverlaps[left2].push({ set: right2, size: current.size, weight });
    setOverlaps[right2].push({ set: left2, size: current.size, weight });
  }
  var mostOverlapped = [];
  for (set2 in setOverlaps) {
    if (setOverlaps.hasOwnProperty(set2)) {
      var size2 = 0;
      for (var i2 = 0; i2 < setOverlaps[set2].length; ++i2) {
        size2 += setOverlaps[set2][i2].size * setOverlaps[set2][i2].weight;
      }
      mostOverlapped.push({ set: set2, size: size2 });
    }
  }
  function sortOrder(a2, b10) {
    return b10.size - a2.size;
  }
  mostOverlapped.sort(sortOrder);
  var positioned = {};
  function isPositioned(element) {
    return element.set in positioned;
  }
  function positionSet(point2, index2) {
    circles[index2].x = point2.x;
    circles[index2].y = point2.y;
    positioned[index2] = true;
  }
  positionSet({ x: 0, y: 0 }, mostOverlapped[0].set);
  for (var i2 = 1; i2 < mostOverlapped.length; ++i2) {
    var setIndex = mostOverlapped[i2].set, overlap2 = setOverlaps[setIndex].filter(isPositioned);
    set2 = circles[setIndex];
    overlap2.sort(sortOrder);
    if (overlap2.length === 0) {
      throw "ERROR: missing pairwise overlap information";
    }
    var points2 = [];
    for (var j2 = 0; j2 < overlap2.length; ++j2) {
      var p1 = circles[overlap2[j2].set], d1 = distanceFromIntersectArea(set2.radius, p1.radius, overlap2[j2].size);
      points2.push({ x: p1.x + d1, y: p1.y });
      points2.push({ x: p1.x - d1, y: p1.y });
      points2.push({ y: p1.y + d1, x: p1.x });
      points2.push({ y: p1.y - d1, x: p1.x });
      for (var k2 = j2 + 1; k2 < overlap2.length; ++k2) {
        var p2 = circles[overlap2[k2].set], d2 = distanceFromIntersectArea(set2.radius, p2.radius, overlap2[k2].size);
        var extraPoints = circleCircleIntersection({ x: p1.x, y: p1.y, radius: d1 }, { x: p2.x, y: p2.y, radius: d2 });
        for (var l2 = 0; l2 < extraPoints.length; ++l2) {
          points2.push(extraPoints[l2]);
        }
      }
    }
    var bestLoss = 1e50, bestPoint = points2[0];
    for (var j2 = 0; j2 < points2.length; ++j2) {
      circles[setIndex].x = points2[j2].x;
      circles[setIndex].y = points2[j2].y;
      var localLoss = loss(circles, areas);
      if (localLoss < bestLoss) {
        bestLoss = localLoss;
        bestPoint = points2[j2];
      }
    }
    positionSet(bestPoint, setIndex);
  }
  return circles;
}
function lossFunction(sets, overlaps) {
  var output2 = 0;
  function getCircles(indices) {
    return indices.map(function(i3) {
      return sets[i3];
    });
  }
  for (var i2 = 0; i2 < overlaps.length; ++i2) {
    var area2 = overlaps[i2];
    var overlap2 = void 0;
    if (area2.sets.length == 1) {
      continue;
    } else if (area2.sets.length == 2) {
      var left2 = sets[area2.sets[0]], right2 = sets[area2.sets[1]];
      overlap2 = circleOverlap(left2.radius, right2.radius, distance(left2, right2));
    } else {
      overlap2 = intersectionArea(getCircles(area2.sets));
    }
    var weight = area2.hasOwnProperty("weight") ? area2.weight : 1;
    output2 += weight * (overlap2 - area2.size) * (overlap2 - area2.size);
  }
  return output2;
}
function getBoundingBox(circles) {
  var minMax = function(d2) {
    var hi2 = Math.max.apply(null, circles.map(function(c2) {
      return c2[d2] + c2.radius;
    })), lo = Math.min.apply(null, circles.map(function(c2) {
      return c2[d2] - c2.radius;
    }));
    return { max: hi2, min: lo };
  };
  return { xRange: minMax("x"), yRange: minMax("y") };
}
function scaleSolution(solution, width, height, padding2) {
  var circles = [], setids = [];
  for (var setid in solution) {
    if (solution.hasOwnProperty(setid)) {
      setids.push(setid);
      circles.push(solution[setid]);
    }
  }
  width -= 2 * padding2;
  height -= 2 * padding2;
  var bounds = getBoundingBox(circles), xRange = bounds.xRange, yRange = bounds.yRange;
  if (xRange.max == xRange.min || yRange.max == yRange.min) {
    console.log("not scaling solution: zero size detected");
    return solution;
  }
  var xScaling = width / (xRange.max - xRange.min), yScaling = height / (yRange.max - yRange.min), scaling = Math.min(yScaling, xScaling), xOffset = (width - (xRange.max - xRange.min) * scaling) / 2, yOffset = (height - (yRange.max - yRange.min) * scaling) / 2;
  var scaled = {};
  for (var i2 = 0; i2 < circles.length; ++i2) {
    var circle2 = circles[i2];
    scaled[setids[i2]] = {
      radius: scaling * circle2.radius,
      x: padding2 + xOffset + (circle2.x - xRange.min) * scaling,
      y: padding2 + yOffset + (circle2.y - yRange.min) * scaling
    };
  }
  return scaled;
}
function circleMargin(current, interior, exterior) {
  var margin = interior[0].radius - distance(interior[0], current), i2, m2;
  for (i2 = 1; i2 < interior.length; ++i2) {
    m2 = interior[i2].radius - distance(interior[i2], current);
    if (m2 <= margin) {
      margin = m2;
    }
  }
  for (i2 = 0; i2 < exterior.length; ++i2) {
    m2 = distance(exterior[i2], current) - exterior[i2].radius;
    if (m2 <= margin) {
      margin = m2;
    }
  }
  return margin;
}
function computeTextCentre(interior, exterior) {
  var points2 = [];
  var i2;
  for (i2 = 0; i2 < interior.length; ++i2) {
    var c2 = interior[i2];
    points2.push({ x: c2.x, y: c2.y });
    points2.push({ x: c2.x + c2.radius / 2, y: c2.y });
    points2.push({ x: c2.x - c2.radius / 2, y: c2.y });
    points2.push({ x: c2.x, y: c2.y + c2.radius / 2 });
    points2.push({ x: c2.x, y: c2.y - c2.radius / 2 });
  }
  var initial = points2[0], margin = circleMargin(points2[0], interior, exterior);
  for (i2 = 1; i2 < points2.length; ++i2) {
    var m2 = circleMargin(points2[i2], interior, exterior);
    if (m2 >= margin) {
      initial = points2[i2];
      margin = m2;
    }
  }
  var solution = nelderMead(function(p2) {
    return -1 * circleMargin({ x: p2[0], y: p2[1] }, interior, exterior);
  }, [initial.x, initial.y], { maxIterations: 500, minErrorDelta: 1e-10 }).x;
  var ret = { x: solution[0], y: solution[1] };
  var valid = true;
  for (i2 = 0; i2 < interior.length; ++i2) {
    if (distance(ret, interior[i2]) > interior[i2].radius) {
      valid = false;
      break;
    }
  }
  for (i2 = 0; i2 < exterior.length; ++i2) {
    if (distance(ret, exterior[i2]) < exterior[i2].radius) {
      valid = false;
      break;
    }
  }
  if (!valid) {
    if (interior.length == 1) {
      ret = { x: interior[0].x, y: interior[0].y };
    } else {
      var areaStats = {};
      intersectionArea(interior, areaStats);
      if (areaStats.arcs.length === 0) {
        ret = { x: 0, y: -1e3, disjoint: true };
      } else if (areaStats.arcs.length == 1) {
        ret = { x: areaStats.arcs[0].circle.x, y: areaStats.arcs[0].circle.y };
      } else if (exterior.length) {
        ret = computeTextCentre(interior, []);
      } else {
        ret = getCenter(areaStats.arcs.map(function(a2) {
          return a2.p1;
        }));
      }
    }
  }
  return ret;
}
function getOverlappingCircles(circles) {
  var ret = {}, circleids = [];
  for (var circleid in circles) {
    circleids.push(circleid);
    ret[circleid] = [];
  }
  for (var i2 = 0; i2 < circleids.length; i2++) {
    var a2 = circles[circleids[i2]];
    for (var j2 = i2 + 1; j2 < circleids.length; ++j2) {
      var b10 = circles[circleids[j2]], d2 = distance(a2, b10);
      if (d2 + b10.radius <= a2.radius + 1e-10) {
        ret[circleids[j2]].push(circleids[i2]);
      } else if (d2 + a2.radius <= b10.radius + 1e-10) {
        ret[circleids[i2]].push(circleids[j2]);
      }
    }
  }
  return ret;
}
function computeTextCentres(circles, areas) {
  var ret = {}, overlapped = getOverlappingCircles(circles);
  for (var i2 = 0; i2 < areas.length; ++i2) {
    var area2 = areas[i2].sets, areaids = {}, exclude = {};
    for (var j2 = 0; j2 < area2.length; ++j2) {
      areaids[area2[j2]] = true;
      var overlaps = overlapped[area2[j2]];
      for (var k2 = 0; k2 < overlaps.length; ++k2) {
        exclude[overlaps[k2]] = true;
      }
    }
    var interior = [], exterior = [];
    for (var setid in circles) {
      if (setid in areaids) {
        interior.push(circles[setid]);
      } else if (!(setid in exclude)) {
        exterior.push(circles[setid]);
      }
    }
    var centre = computeTextCentre(interior, exterior);
    ret[area2] = centre;
    if (centre.disjoint && areas[i2].size > 0) {
      console.log("WARNING: area " + area2 + " not represented on screen");
    }
  }
  return ret;
}
function circlePath(x2, y2, r2) {
  var ret = [];
  var x0 = x2 - r2;
  var y0 = y2;
  ret.push("M", x0, y0);
  ret.push("A", r2, r2, 0, 1, 0, x0 + 2 * r2, y0);
  ret.push("A", r2, r2, 0, 1, 0, x0, y0);
  return ret.join(" ");
}
function intersectionAreaPath(circles) {
  var stats = {};
  intersectionArea(circles, stats);
  var arcs = stats.arcs;
  if (arcs.length === 0) {
    return "M 0 0";
  } else if (arcs.length == 1) {
    var circle2 = arcs[0].circle;
    return circlePath(circle2.x, circle2.y, circle2.radius);
  } else {
    var ret = ["\nM", arcs[0].p2.x, arcs[0].p2.y];
    for (var i2 = 0; i2 < arcs.length; ++i2) {
      var arc2 = arcs[i2], r2 = arc2.circle.radius, wide = arc2.width > r2;
      ret.push("\nA", r2, r2, 0, wide ? 1 : 0, 1, arc2.p1.x, arc2.p1.y);
    }
    return ret.join(" ");
  }
}
var ID_FIELD = "id";
var PATH_FIELD = "path";
var DEFAULT_OPTIONS$h = {
  appendPadding: [10, 0, 20, 0],
  blendMode: "multiply",
  tooltip: {
    showTitle: false,
    showMarkers: false,
    fields: ["id", "size"],
    formatter: function(datum) {
      return { name: datum.id, value: datum.size };
    }
  },
  legend: { position: "top-left" },
  label: {
    style: {
      textAlign: "center",
      fill: "#fff"
    }
  },
  interactions: [{ type: "legend-filter", enable: false }],
  state: {
    active: {
      style: {
        stroke: "#000"
      }
    },
    selected: {
      style: {
        stroke: "#000",
        lineWidth: 2
      }
    },
    inactive: {
      style: {
        fillOpacity: 0.3,
        strokeOpacity: 0.3
      }
    }
  },
  defaultInteractions: ["tooltip", "venn-legend-active"]
};
var getColorMap = memoize(function(colorPalette, data2, blendMode, setsField) {
  var colorMap2 = /* @__PURE__ */ new Map();
  var colorPaletteLen = colorPalette.length;
  data2.forEach(function(d2, idx) {
    if (d2[setsField].length === 1) {
      colorMap2.set(d2[ID_FIELD], colorPalette[(idx + colorPaletteLen) % colorPaletteLen]);
    } else {
      var colorArr = d2[setsField].map(function(id2) {
        return colorMap2.get(id2);
      });
      colorMap2.set(d2[ID_FIELD], colorArr.slice(1).reduce(function(a2, b10) {
        return blend(a2, b10, blendMode);
      }, colorArr[0]));
    }
  });
  return colorMap2;
}, function() {
  var params = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    params[_i] = arguments[_i];
  }
  return JSON.stringify(params);
});
function layoutVennData(options, width, height, padding2) {
  if (padding2 === void 0) {
    padding2 = 0;
  }
  var data2 = options.data, setsField = options.setsField, sizeField = options.sizeField;
  if (data2.length === 0) {
    log(LEVEL.WARN, false, "warn: %s", "\u6570\u636E\u4E0D\u80FD\u4E3A\u7A7A");
    return [];
  }
  var vennData = data2.map(function(d2) {
    var _a2;
    return __assign$4(__assign$4({}, d2), (_a2 = { sets: d2[setsField] || [], size: d2[sizeField] }, _a2[PATH_FIELD] = "", _a2[ID_FIELD] = "", _a2));
  });
  vennData.sort(function(a2, b10) {
    return a2.sets.length - b10.sets.length;
  });
  var solution = venn(vennData);
  var circles = scaleSolution(solution, width, height, padding2);
  var textCenters = computeTextCentres(circles, vennData);
  vennData.forEach(function(row) {
    var sets = row.sets;
    var id2 = sets.join(",");
    row[ID_FIELD] = id2;
    var setCircles = sets.map(function(set2) {
      return circles[set2];
    });
    var path2 = intersectionAreaPath(setCircles);
    if (!/[zZ]$/.test(path2)) {
      path2 += " Z";
    }
    row[PATH_FIELD] = path2;
    var center2 = textCenters[id2] || { x: 0, y: 0 };
    mix(row, center2);
  });
  return vennData;
}
function islegalSets(legalArr, testArr) {
  for (var i2 = 0; i2 < testArr.length; i2++) {
    if (!legalArr.includes(testArr[i2])) {
      return false;
    }
  }
  return true;
}
function getFillAttrs$2(cfg) {
  return deepAssign({}, cfg.defaultStyle, { fill: cfg.color }, cfg.style);
}
registerShape("schema", "venn", {
  draw: function(cfg, container) {
    var data2 = cfg.data;
    var segments = parsePathString(data2[PATH_FIELD]);
    var fillAttrs = getFillAttrs$2(cfg);
    var group2 = container.addGroup({ name: "venn-shape" });
    group2.addShape("path", {
      attrs: __assign$4(__assign$4({}, fillAttrs), { path: segments }),
      name: "venn-path"
    });
    var _a2 = cfg.customInfo, offsetX = _a2.offsetX, offsetY = _a2.offsetY;
    var matrix = Util.transform(null, [["t", offsetX, offsetY]]);
    group2.setMatrix(matrix);
    return group2;
  },
  getMarker: function(markerCfg) {
    var color2 = markerCfg.color;
    return {
      symbol: "circle",
      style: {
        lineWidth: 0,
        stroke: color2,
        fill: color2,
        r: 4
      }
    };
  }
});
var VennLabel = function(_super) {
  __extends$3(VennLabel2, _super);
  function VennLabel2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  VennLabel2.prototype.getLabelPoint = function(labelCfg, mappingData, index2) {
    var _a2 = labelCfg.data, x2 = _a2.x, y2 = _a2.y;
    var _b = labelCfg.customLabelInfo, offsetX = _b.offsetX, offsetY = _b.offsetY;
    return {
      content: labelCfg.content[index2],
      x: x2 + offsetX,
      y: y2 + offsetY
    };
  };
  return VennLabel2;
}(GeometryLabel);
registerGeometryLabel("venn", VennLabel);
function placeElementsOrdered(view) {
  if (!view) {
    return;
  }
  var elements = view.geometries[0].elements;
  elements.forEach(function(elem) {
    elem.shape.toFront();
  });
}
var ElementActiveAction = getActionClass("element-active");
var VennElementActive = function(_super) {
  __extends$3(VennElementActive2, _super);
  function VennElementActive2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  VennElementActive2.prototype.syncElementsPos = function() {
    placeElementsOrdered(this.context.view);
  };
  VennElementActive2.prototype.active = function() {
    _super.prototype.active.call(this);
    this.syncElementsPos();
  };
  VennElementActive2.prototype.toggle = function() {
    _super.prototype.toggle.call(this);
    this.syncElementsPos();
  };
  VennElementActive2.prototype.reset = function() {
    _super.prototype.reset.call(this);
    this.syncElementsPos();
  };
  return VennElementActive2;
}(ElementActiveAction);
var ElementHighlightAction = getActionClass("element-highlight");
var VennElementHighlight = function(_super) {
  __extends$3(VennElementHighlight2, _super);
  function VennElementHighlight2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  VennElementHighlight2.prototype.syncElementsPos = function() {
    placeElementsOrdered(this.context.view);
  };
  VennElementHighlight2.prototype.highlight = function() {
    _super.prototype.highlight.call(this);
    this.syncElementsPos();
  };
  VennElementHighlight2.prototype.toggle = function() {
    _super.prototype.toggle.call(this);
    this.syncElementsPos();
  };
  VennElementHighlight2.prototype.clear = function() {
    _super.prototype.clear.call(this);
    this.syncElementsPos();
  };
  VennElementHighlight2.prototype.reset = function() {
    _super.prototype.reset.call(this);
    this.syncElementsPos();
  };
  return VennElementHighlight2;
}(ElementHighlightAction);
var ElementSelectedAction = getActionClass("element-selected");
var ElementSingleSelectedAction = getActionClass("element-single-selected");
var VennElementSelected = function(_super) {
  __extends$3(VennElementSelected2, _super);
  function VennElementSelected2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  VennElementSelected2.prototype.syncElementsPos = function() {
    placeElementsOrdered(this.context.view);
  };
  VennElementSelected2.prototype.selected = function() {
    _super.prototype.selected.call(this);
    this.syncElementsPos();
  };
  VennElementSelected2.prototype.toggle = function() {
    _super.prototype.toggle.call(this);
    this.syncElementsPos();
  };
  VennElementSelected2.prototype.reset = function() {
    _super.prototype.reset.call(this);
    this.syncElementsPos();
  };
  return VennElementSelected2;
}(ElementSelectedAction);
var VennElementSingleSelected = function(_super) {
  __extends$3(VennElementSingleSelected2, _super);
  function VennElementSingleSelected2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  VennElementSingleSelected2.prototype.syncElementsPos = function() {
    placeElementsOrdered(this.context.view);
  };
  VennElementSingleSelected2.prototype.selected = function() {
    _super.prototype.selected.call(this);
    this.syncElementsPos();
  };
  VennElementSingleSelected2.prototype.toggle = function() {
    _super.prototype.toggle.call(this);
    this.syncElementsPos();
  };
  VennElementSingleSelected2.prototype.reset = function() {
    _super.prototype.reset.call(this);
    this.syncElementsPos();
  };
  return VennElementSingleSelected2;
}(ElementSingleSelectedAction);
registerAction("venn-element-active", VennElementActive);
registerAction("venn-element-highlight", VennElementHighlight);
registerAction("venn-element-selected", VennElementSelected);
registerAction("venn-element-single-selected", VennElementSingleSelected);
registerInteraction("venn-element-active", {
  start: [{ trigger: "element:mouseenter", action: "venn-element-active:active" }],
  end: [{ trigger: "element:mouseleave", action: "venn-element-active:reset" }]
});
registerInteraction("venn-element-highlight", {
  start: [{ trigger: "element:mouseenter", action: "venn-element-highlight:highlight" }],
  end: [{ trigger: "element:mouseleave", action: "venn-element-highlight:reset" }]
});
registerInteraction("venn-element-selected", {
  start: [{ trigger: "element:click", action: "venn-element-selected:toggle" }],
  rollback: [{ trigger: "dblclick", action: ["venn-element-selected:reset"] }]
});
registerInteraction("venn-element-single-selected", {
  start: [{ trigger: "element:click", action: "venn-element-single-selected:toggle" }],
  rollback: [{ trigger: "dblclick", action: ["venn-element-single-selected:reset"] }]
});
registerInteraction("venn-legend-active", {
  start: [{ trigger: "legend-item:mouseenter", action: ["list-active:active", "venn-element-active:active"] }],
  end: [{ trigger: "legend-item:mouseleave", action: ["list-active:reset", "venn-element-active:reset"] }]
});
registerInteraction("venn-legend-highlight", {
  start: [
    {
      trigger: "legend-item:mouseenter",
      action: ["legend-item-highlight:highlight", "venn-element-highlight:highlight"]
    }
  ],
  end: [{ trigger: "legend-item:mouseleave", action: ["legend-item-highlight:reset", "venn-element-highlight:reset"] }]
});
var LEGEND_SPACE = 40;
function colorMap(params, data2, colorPalette) {
  var chart = params.chart, options = params.options;
  var blendMode = options.blendMode, setsField = options.setsField;
  var _a2 = chart.getTheme(), colors10 = _a2.colors10, colors20 = _a2.colors20;
  var palette = colorPalette;
  if (!isArray$1(palette)) {
    palette = data2.filter(function(d2) {
      return d2[setsField].length === 1;
    }).length <= 10 ? colors10 : colors20;
  }
  var map2 = getColorMap(palette, data2, blendMode, setsField);
  return function(id2) {
    return map2.get(id2) || palette[0];
  };
}
function transformColor(params, data2) {
  var options = params.options;
  var color2 = options.color;
  if (typeof color2 !== "function") {
    var colorPalette = typeof color2 === "string" ? [color2] : color2;
    var map_1 = colorMap(params, data2, colorPalette);
    return function(datum) {
      return map_1(datum[ID_FIELD]);
    };
  }
  return color2;
}
function padding$1(params) {
  var chart = params.chart, options = params.options;
  var legend2 = options.legend, appendPadding = options.appendPadding, padding2 = options.padding;
  var tempPadding = normalPadding(appendPadding);
  if (legend2 !== false) {
    tempPadding = getAdjustAppendPadding(appendPadding, get(legend2, "position"), LEGEND_SPACE);
  }
  chart.appendPadding = resolveAllPadding([tempPadding, padding2]);
  return params;
}
function data(params) {
  var options = params.options;
  var data2 = options["data"];
  if (!data2) {
    log(LEVEL.WARN, false, "warn: %s", "\u6570\u636E\u4E0D\u80FD\u4E3A\u7A7A");
    data2 = [];
  }
  var currSets = data2.filter(function(datum) {
    return datum.sets.length === 1;
  }).map(function(datum) {
    return datum.sets[0];
  });
  var filterSets = data2.filter(function(datum) {
    var sets = datum.sets;
    return islegalSets(currSets, sets);
  });
  if (!isEqual$1(filterSets, data2))
    log(LEVEL.WARN, false, "warn: %s", "\u4EA4\u96C6\u4E2D\u4E0D\u80FD\u51FA\u73B0\u4E0D\u5B58\u5728\u7684\u96C6\u5408, \u8BF7\u8F93\u5165\u5408\u6CD5\u6570\u636E");
  return deepMix({}, params, {
    options: {
      data: filterSets
    }
  });
}
function geometry$g(params) {
  var chart = params.chart, options = params.options;
  var pointStyle = options.pointStyle, setsField = options.setsField, sizeField = options.sizeField;
  var _a2 = normalPadding(chart.appendPadding), t2 = _a2[0], r2 = _a2[1], b10 = _a2[2], l2 = _a2[3];
  var customInfo = { offsetX: l2, offsetY: t2 };
  var _b = chart.viewBBox, width = _b.width, height = _b.height;
  var vennData = layoutVennData(options, Math.max(width - (r2 + l2), 0), Math.max(height - (t2 + b10), 0), 0);
  chart.data(vennData);
  var ext = schema(deepAssign({}, params, {
    options: {
      xField: "x",
      yField: "y",
      sizeField,
      seriesField: ID_FIELD,
      rawFields: [setsField, sizeField],
      schema: {
        shape: "venn",
        style: pointStyle
      }
    }
  })).ext;
  var geometry2 = ext.geometry;
  geometry2.customInfo(customInfo);
  var colorOptions = transformColor(params, vennData);
  if (typeof colorOptions === "function") {
    geometry2.color(ID_FIELD, function(id2) {
      var datum = vennData.find(function(d2) {
        return d2[ID_FIELD] === id2;
      });
      var defaultColor = colorMap(params, vennData)(id2);
      return colorOptions(datum, defaultColor);
    });
  }
  return params;
}
function label$5(params) {
  var chart = params.chart, options = params.options;
  var label2 = options.label;
  var _a2 = normalPadding(chart.appendPadding), t2 = _a2[0], l2 = _a2[3];
  var customLabelInfo = { offsetX: l2, offsetY: t2 };
  var geometry2 = findGeometry(chart, "schema");
  if (!label2) {
    geometry2.label(false);
  } else {
    var callback = label2.callback, cfg = __rest$3(label2, ["callback"]);
    geometry2.label({
      fields: ["id"],
      callback,
      cfg: deepMix({}, transformLabel(cfg), {
        type: "venn",
        customLabelInfo
      })
    });
  }
  return params;
}
function legend$5(params) {
  var chart = params.chart, options = params.options;
  var legend2 = options.legend, sizeField = options.sizeField;
  chart.legend(ID_FIELD, legend2);
  chart.legend(sizeField, false);
  return params;
}
function axis$a(params) {
  var chart = params.chart;
  chart.axis(false);
  return params;
}
function vennInteraction(params) {
  var options = params.options, chart = params.chart;
  var interactions = options.interactions;
  if (interactions) {
    var MAP_1 = {
      "legend-active": "venn-legend-active",
      "legend-highlight": "venn-legend-highlight"
    };
    interaction$7(deepAssign({}, params, {
      options: {
        interactions: interactions.map(function(i2) {
          return __assign$4(__assign$4({}, i2), { type: MAP_1[i2.type] || i2.type });
        })
      }
    }));
  }
  chart.removeInteraction("legend-active");
  chart.removeInteraction("legend-highlight");
  return params;
}
function adaptor$f(params) {
  return flow(
    padding$1,
    theme$2,
    data,
    geometry$g,
    label$5,
    scale$2({}),
    legend$5,
    axis$a,
    tooltip$9,
    vennInteraction,
    animation$5
  )(params);
}
(function(_super) {
  __extends$3(Venn, _super);
  function Venn() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "venn";
    return _this;
  }
  Venn.getDefaultOptions = function() {
    return DEFAULT_OPTIONS$h;
  };
  Venn.prototype.getDefaultOptions = function() {
    return Venn.getDefaultOptions();
  };
  Venn.prototype.getSchemaAdaptor = function() {
    return adaptor$f;
  };
  Venn.prototype.triggerResize = function() {
    if (!this.chart.destroyed) {
      this.chart.forceFit();
      this.chart.clear();
      this.execAdaptor();
      this.chart.render(true);
    }
  };
  return Venn;
})(Plot);
var Y_FIELD$3 = "$$stock-range$$";
var TREND_FIELD = "trend";
var TREND_UP = "up";
var TREND_DOWN = "down";
var DEFAULT_TOOLTIP_OPTIONS = {
  showMarkers: false,
  showCrosshairs: true,
  shared: true,
  crosshairs: {
    type: "xy",
    follow: true,
    text: function(type4, defaultContent, items) {
      var textContent;
      if (type4 === "x") {
        var item = items[0];
        textContent = item ? item.title : defaultContent;
      } else {
        textContent = defaultContent;
      }
      return {
        position: type4 === "y" ? "start" : "end",
        content: textContent,
        style: {
          fill: "#dfdfdf"
        }
      };
    },
    textBackground: {
      padding: [2, 4],
      style: {
        fill: "#666"
      }
    }
  }
};
var DEFAULT_OPTIONS$g = deepAssign({}, Plot.getDefaultOptions(), {
  tooltip: DEFAULT_TOOLTIP_OPTIONS,
  interactions: [{ type: "tooltip" }],
  legend: {
    position: "top-left"
  },
  risingFill: "#ef5350",
  fallingFill: "#26a69a"
});
function getStockData(data2, yField) {
  return map$2(data2, function(obj) {
    if (isArray$1(yField)) {
      var open_1 = yField[0], close_1 = yField[1], high = yField[2], low = yField[3];
      obj[TREND_FIELD] = obj[open_1] <= obj[close_1] ? TREND_UP : TREND_DOWN;
      obj[Y_FIELD$3] = [obj[open_1], obj[close_1], obj[high], obj[low]];
    }
    return obj;
  });
}
function geometry$f(params) {
  var chart = params.chart, options = params.options;
  var yField = options.yField;
  var data2 = options.data, risingFill = options.risingFill, fallingFill = options.fallingFill, tooltip2 = options.tooltip, stockStyle = options.stockStyle;
  chart.data(getStockData(data2, yField));
  var tooltipOptions = tooltip2;
  if (tooltipOptions !== false) {
    tooltipOptions = deepAssign({}, { fields: yField }, tooltipOptions);
  }
  schema(deepAssign({}, params, {
    options: {
      schema: {
        shape: "candle",
        color: [risingFill, fallingFill],
        style: stockStyle
      },
      yField: Y_FIELD$3,
      seriesField: TREND_FIELD,
      rawFields: yField,
      tooltip: tooltipOptions
    }
  }));
  return params;
}
function meta$8(params) {
  var _a2, _b;
  var chart = params.chart, options = params.options;
  var meta2 = options.meta, xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField;
  var baseMeta = (_a2 = {}, _a2[xField] = {
    type: "timeCat",
    tickCount: 6
  }, _a2[TREND_FIELD] = {
    values: [TREND_UP, TREND_DOWN]
  }, _a2);
  var scales = deepAssign(baseMeta, meta2, (_b = {}, _b[xField] = pick(xAxis, AXIS_META_CONFIG_KEYS), _b[Y_FIELD$3] = pick(yAxis, AXIS_META_CONFIG_KEYS), _b));
  chart.scale(scales);
  return params;
}
function axis$9(params) {
  var chart = params.chart, options = params.options;
  var xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField;
  if (xAxis === false) {
    chart.axis(xField, false);
  } else {
    chart.axis(xField, xAxis);
  }
  if (yAxis === false) {
    chart.axis(Y_FIELD$3, false);
  } else {
    chart.axis(Y_FIELD$3, yAxis);
  }
  return params;
}
function tooltip$5(params) {
  var chart = params.chart, options = params.options;
  var tooltip2 = options.tooltip;
  if (tooltip2 !== false) {
    chart.tooltip(tooltip2);
  } else {
    chart.tooltip(false);
  }
  return params;
}
function legend$4(params) {
  var chart = params.chart, options = params.options;
  var legend2 = options.legend;
  if (legend2) {
    chart.legend(TREND_FIELD, legend2);
  } else if (legend2 === false) {
    chart.legend(false);
  }
  return params;
}
function adaptor$e(params) {
  flow(theme$2, geometry$f, meta$8, axis$9, tooltip$5, legend$4, interaction$7, animation$5, annotation$2(), slider$2)(params);
}
var Stock = function(_super) {
  __extends$3(Stock2, _super);
  function Stock2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "stock";
    return _this;
  }
  Stock2.getDefaultOptions = function() {
    return DEFAULT_OPTIONS$g;
  };
  Stock2.prototype.getDefaultOptions = function() {
    return Stock2.getDefaultOptions();
  };
  Stock2.prototype.getSchemaAdaptor = function() {
    return adaptor$e;
  };
  Stock2.prototype.changeData = function(data2) {
    this.updateOption({ data: data2 });
    var yField = this.options.yField;
    this.chart.changeData(getStockData(data2, yField));
  };
  return Stock2;
}(Plot);
var _a$1;
var FUNNEL_PERCENT = "$$percentage$$";
var FUNNEL_MAPPING_VALUE = "$$mappingValue$$";
var FUNNEL_CONVERSATION = "$$conversion$$";
var FUNNEL_TOTAL_PERCENT = "$$totalPercentage$$";
var PLOYGON_X = "$$x$$";
var PLOYGON_Y = "$$y$$";
var DEFAULT_OPTIONS$f = {
  appendPadding: [0, 80],
  minSize: 0,
  maxSize: 1,
  meta: (_a$1 = {}, _a$1[FUNNEL_MAPPING_VALUE] = {
    min: 0,
    max: 1,
    nice: false
  }, _a$1),
  label: {
    style: {
      fill: "#fff",
      fontSize: 12
    }
  },
  tooltip: {
    showTitle: false,
    showMarkers: false,
    shared: false
  },
  conversionTag: {
    offsetX: 10,
    offsetY: 0,
    style: {
      fontSize: 12,
      fill: "rgba(0,0,0,0.45)"
    }
  }
};
function transformData$7(data2, originData, options) {
  var formatData = [];
  var yField = options.yField, maxSize = options.maxSize, minSize = options.minSize;
  var maxYFieldValue = get(maxBy(originData, yField), [yField]);
  var max2 = isNumber$1(maxSize) ? maxSize : 1;
  var min2 = isNumber$1(minSize) ? minSize : 0;
  formatData = map$2(data2, function(row, index2) {
    var percent2 = (row[yField] || 0) / maxYFieldValue;
    row[FUNNEL_PERCENT] = percent2;
    row[FUNNEL_MAPPING_VALUE] = (max2 - min2) * percent2 + min2;
    row[FUNNEL_CONVERSATION] = [get(data2, [index2 - 1, yField]), row[yField]];
    return row;
  });
  return formatData;
}
function conversionTagComponent(getLineCoordinate) {
  return function(params) {
    var chart = params.chart, options = params.options;
    var conversionTag2 = options.conversionTag;
    var data2 = chart.getOptions().data;
    if (conversionTag2) {
      var formatter_1 = conversionTag2.formatter;
      data2.forEach(function(obj, index2) {
        if (index2 <= 0 || Number.isNaN(obj[FUNNEL_MAPPING_VALUE]))
          return;
        var lineOption = getLineCoordinate(obj, index2, data2, {
          top: true,
          text: {
            content: isFunction(formatter_1) ? formatter_1(obj, data2) : formatter_1,
            offsetX: conversionTag2.offsetX,
            offsetY: conversionTag2.offsetY,
            position: "end",
            autoRotate: false,
            style: __assign$4({ textAlign: "start", textBaseline: "middle" }, conversionTag2.style)
          }
        });
        chart.annotation().line(lineOption);
      });
    }
    return params;
  };
}
function field$3(params) {
  var chart = params.chart, options = params.options;
  var _a2 = options.data, data2 = _a2 === void 0 ? [] : _a2, yField = options.yField, maxSize = options.maxSize, minSize = options.minSize;
  var formatData = transformData$7(data2, data2, {
    yField,
    maxSize,
    minSize
  });
  chart.data(formatData);
  return params;
}
function geometry$e(params) {
  var chart = params.chart, options = params.options;
  var xField = options.xField, yField = options.yField, color2 = options.color, tooltip2 = options.tooltip, label2 = options.label, _a2 = options.shape, shape = _a2 === void 0 ? "funnel" : _a2, funnelStyle = options.funnelStyle, state2 = options.state;
  var _b = getTooltipMapping(tooltip2, [xField, yField]), fields = _b.fields, formatter = _b.formatter;
  geometry$x({
    chart,
    options: {
      type: "interval",
      xField,
      yField: FUNNEL_MAPPING_VALUE,
      colorField: xField,
      tooltipFields: isArray$1(fields) && fields.concat([FUNNEL_PERCENT, FUNNEL_CONVERSATION]),
      mapping: {
        shape,
        tooltip: formatter,
        color: color2,
        style: funnelStyle
      },
      label: label2,
      state: state2
    }
  });
  var geo = findGeometry(params.chart, "interval");
  geo.adjust("symmetric");
  return params;
}
function transpose$1(params) {
  var chart = params.chart, options = params.options;
  var isTransposed = options.isTransposed;
  chart.coordinate({
    type: "rect",
    actions: !isTransposed ? [["transpose"], ["scale", 1, -1]] : []
  });
  return params;
}
function conversionTag$2(params) {
  var options = params.options;
  var maxSize = options.maxSize;
  var getLineCoordinate = function(datum, datumIndex, data2, initLineOption) {
    var percent2 = maxSize - (maxSize - datum[FUNNEL_MAPPING_VALUE]) / 2;
    return __assign$4(__assign$4({}, initLineOption), { start: [datumIndex - 0.5, percent2], end: [datumIndex - 0.5, percent2 + 0.05] });
  };
  conversionTagComponent(getLineCoordinate)(params);
  return params;
}
function basicFunnel(params) {
  return flow(field$3, geometry$e, transpose$1, conversionTag$2)(params);
}
function field$2(params) {
  var _a2;
  var chart = params.chart, options = params.options;
  var _b = options.data, data2 = _b === void 0 ? [] : _b, yField = options.yField;
  chart.data(data2);
  chart.scale((_a2 = {}, _a2[yField] = {
    sync: true
  }, _a2));
  return params;
}
function geometry$d(params) {
  var chart = params.chart, options = params.options;
  var data2 = options.data, xField = options.xField, yField = options.yField, color2 = options.color, compareField = options.compareField, isTransposed = options.isTransposed, tooltip2 = options.tooltip, maxSize = options.maxSize, minSize = options.minSize, label2 = options.label, funnelStyle = options.funnelStyle, state2 = options.state, showFacetTitle = options.showFacetTitle;
  chart.facet("mirror", {
    fields: [compareField],
    transpose: !isTransposed,
    padding: isTransposed ? 0 : [32, 0, 0, 0],
    showTitle: showFacetTitle,
    eachView: function(view, facet) {
      var index2 = isTransposed ? facet.rowIndex : facet.columnIndex;
      if (!isTransposed) {
        view.coordinate({
          type: "rect",
          actions: [["transpose"], ["scale", index2 === 0 ? -1 : 1, -1]]
        });
      }
      var formatterData = transformData$7(facet.data, data2, {
        yField,
        maxSize,
        minSize
      });
      view.data(formatterData);
      var _a2 = getTooltipMapping(tooltip2, [xField, yField, compareField]), fields = _a2.fields, formatter = _a2.formatter;
      var defaultFacetLabel = isTransposed ? {
        offset: index2 === 0 ? 10 : -23,
        position: index2 === 0 ? "bottom" : "top"
      } : {
        offset: 10,
        position: "left",
        style: {
          textAlign: index2 === 0 ? "end" : "start"
        }
      };
      geometry$x({
        chart: view,
        options: {
          type: "interval",
          xField,
          yField: FUNNEL_MAPPING_VALUE,
          colorField: xField,
          tooltipFields: isArray$1(fields) && fields.concat([FUNNEL_PERCENT, FUNNEL_CONVERSATION]),
          mapping: {
            shape: "funnel",
            tooltip: formatter,
            color: color2,
            style: funnelStyle
          },
          label: label2 === false ? false : deepAssign({}, defaultFacetLabel, label2),
          state: state2
        }
      });
    }
  });
  return params;
}
function conversionTag$1(params) {
  var chart = params.chart, options = params.options;
  var conversionTag2 = options.conversionTag, isTransposed = options.isTransposed;
  chart.once("beforepaint", function() {
    chart.views.forEach(function(view, viewIndex) {
      var getLineCoordinate = function(datum, datumIndex, data2, initLineOption) {
        var ratio = viewIndex === 0 ? -1 : 1;
        return deepAssign({}, initLineOption, {
          start: [datumIndex - 0.5, datum[FUNNEL_MAPPING_VALUE]],
          end: [datumIndex - 0.5, datum[FUNNEL_MAPPING_VALUE] + 0.05],
          text: isTransposed ? {
            style: {
              textAlign: "start"
            }
          } : {
            offsetX: conversionTag2 !== false ? ratio * conversionTag2.offsetX : 0,
            style: {
              textAlign: viewIndex === 0 ? "end" : "start"
            }
          }
        });
      };
      conversionTagComponent(getLineCoordinate)(deepAssign({}, {
        chart: view,
        options
      }));
    });
  });
  return params;
}
function compareFunnel(params) {
  return flow(field$2, geometry$d, conversionTag$1)(params);
}
function field$1(params) {
  var _a2;
  var chart = params.chart, options = params.options;
  var _b = options.data, data2 = _b === void 0 ? [] : _b, yField = options.yField;
  chart.data(data2);
  chart.scale((_a2 = {}, _a2[yField] = {
    sync: true
  }, _a2));
  return params;
}
function geometry$c(params) {
  var chart = params.chart, options = params.options;
  var seriesField = options.seriesField, isTransposed = options.isTransposed, showFacetTitle = options.showFacetTitle;
  chart.facet("rect", {
    fields: [seriesField],
    padding: [isTransposed ? 0 : 32, 10, 0, 10],
    showTitle: showFacetTitle,
    eachView: function(view, facet) {
      basicFunnel(deepAssign({}, params, {
        chart: view,
        options: {
          data: facet.data
        }
      }));
    }
  });
  return params;
}
function facetFunnel(params) {
  return flow(field$1, geometry$c)(params);
}
function field(params) {
  var chart = params.chart, options = params.options;
  var _a2 = options.data, data2 = _a2 === void 0 ? [] : _a2, yField = options.yField;
  var sum = reduce(data2, function(total, item) {
    return total + (item[yField] || 0);
  }, 0);
  var max2 = maxBy(data2, yField)[yField];
  var formatData = map$2(data2, function(row, index2) {
    var x2 = [];
    var y2 = [];
    row[FUNNEL_TOTAL_PERCENT] = (row[yField] || 0) / sum;
    if (index2) {
      var preItemX = data2[index2 - 1][PLOYGON_X];
      var preItemY = data2[index2 - 1][PLOYGON_Y];
      x2[0] = preItemX[3];
      y2[0] = preItemY[3];
      x2[1] = preItemX[2];
      y2[1] = preItemY[2];
    } else {
      x2[0] = -0.5;
      y2[0] = 1;
      x2[1] = 0.5;
      y2[1] = 1;
    }
    y2[2] = y2[1] - row[FUNNEL_TOTAL_PERCENT];
    x2[2] = (y2[2] + 1) / 4;
    y2[3] = y2[2];
    x2[3] = -x2[2];
    row[PLOYGON_X] = x2;
    row[PLOYGON_Y] = y2;
    row[FUNNEL_PERCENT] = (row[yField] || 0) / max2;
    row[FUNNEL_CONVERSATION] = [get(data2, [index2 - 1, yField]), row[yField]];
    return row;
  });
  chart.data(formatData);
  return params;
}
function geometry$b(params) {
  var chart = params.chart, options = params.options;
  var xField = options.xField, yField = options.yField, color2 = options.color, tooltip2 = options.tooltip, label2 = options.label, funnelStyle = options.funnelStyle, state2 = options.state;
  var _a2 = getTooltipMapping(tooltip2, [xField, yField]), fields = _a2.fields, formatter = _a2.formatter;
  geometry$x({
    chart,
    options: {
      type: "polygon",
      xField: PLOYGON_X,
      yField: PLOYGON_Y,
      colorField: xField,
      tooltipFields: isArray$1(fields) && fields.concat([FUNNEL_PERCENT, FUNNEL_CONVERSATION]),
      label: label2,
      state: state2,
      mapping: {
        tooltip: formatter,
        color: color2,
        style: funnelStyle
      }
    }
  });
  return params;
}
function transpose(params) {
  var chart = params.chart, options = params.options;
  var isTransposed = options.isTransposed;
  chart.coordinate({
    type: "rect",
    actions: isTransposed ? [["transpose"], ["reflect", "x"]] : []
  });
  return params;
}
function conversionTag(params) {
  var getLineCoordinate = function(datum, datumIndex, data2, initLineOption) {
    return __assign$4(__assign$4({}, initLineOption), { start: [datum[PLOYGON_X][1], datum[PLOYGON_Y][1]], end: [datum[PLOYGON_X][1] + 0.05, datum[PLOYGON_Y][1]] });
  };
  conversionTagComponent(getLineCoordinate)(params);
  return params;
}
function dynamicHeightFunnel(params) {
  return flow(field, geometry$b, transpose, conversionTag)(params);
}
function defaultOptions$4(params) {
  var options = params.options;
  var compareField = options.compareField, xField = options.xField, yField = options.yField, locale2 = options.locale, funnelStyle = options.funnelStyle, data2 = options.data;
  var i18n = getLocale(locale2);
  var defaultOption = {
    label: compareField ? {
      fields: [xField, yField, compareField, FUNNEL_PERCENT, FUNNEL_CONVERSATION],
      formatter: function(datum) {
        return "" + datum[yField];
      }
    } : {
      fields: [xField, yField, FUNNEL_PERCENT, FUNNEL_CONVERSATION],
      offset: 0,
      position: "middle",
      formatter: function(datum) {
        return datum[xField] + " " + datum[yField];
      }
    },
    tooltip: {
      title: xField,
      formatter: function(datum) {
        return { name: datum[xField], value: datum[yField] };
      }
    },
    conversionTag: {
      formatter: function(datum) {
        return i18n.get(["conversionTag", "label"]) + ": " + conversionTagFormatter.apply(void 0, datum[FUNNEL_CONVERSATION]);
      }
    }
  };
  var style2;
  if (compareField || funnelStyle) {
    style2 = function(datum) {
      return deepAssign(
        {},
        compareField && { lineWidth: 1, stroke: "#fff" },
        isFunction(funnelStyle) ? funnelStyle(datum) : funnelStyle
      );
    };
  }
  return deepAssign({ options: defaultOption }, params, { options: { funnelStyle: style2, data: clone$1(data2) } });
}
function geometry$a(params) {
  var options = params.options;
  var compareField = options.compareField, dynamicHeight = options.dynamicHeight, seriesField = options.seriesField;
  if (seriesField) {
    return facetFunnel(params);
  }
  if (compareField) {
    return compareFunnel(params);
  }
  if (dynamicHeight) {
    return dynamicHeightFunnel(params);
  }
  return basicFunnel(params);
}
function meta$7(params) {
  var _a2;
  var options = params.options;
  var xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField, yField = options.yField;
  return flow(scale$2((_a2 = {}, _a2[xField] = xAxis, _a2[yField] = yAxis, _a2)))(params);
}
function axis$8(params) {
  var chart = params.chart;
  chart.axis(false);
  return params;
}
function legend$3(params) {
  var chart = params.chart, options = params.options;
  var legend2 = options.legend;
  if (legend2 === false) {
    chart.legend(false);
  } else {
    chart.legend(legend2);
  }
  return params;
}
function adaptor$d(params) {
  return flow(defaultOptions$4, geometry$a, meta$7, axis$8, tooltip$9, interaction$7, legend$3, animation$5, theme$2, annotation$2())(params);
}
var Funnel = function(_super) {
  __extends$3(Funnel2, _super);
  function Funnel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "funnel";
    return _this;
  }
  Funnel2.getDefaultOptions = function() {
    return DEFAULT_OPTIONS$f;
  };
  Funnel2.prototype.getDefaultOptions = function() {
    return Funnel2.getDefaultOptions();
  };
  Funnel2.prototype.getSchemaAdaptor = function() {
    return adaptor$d;
  };
  Funnel2.prototype.setState = function(type4, condition, status) {
    if (status === void 0) {
      status = true;
    }
    var elements = getAllElementsRecursively(this.chart);
    each$1(elements, function(ele) {
      if (condition(ele.getData())) {
        ele.setState(type4, status);
      }
    });
  };
  Funnel2.prototype.getStates = function() {
    var elements = getAllElementsRecursively(this.chart);
    var stateObjects = [];
    each$1(elements, function(element) {
      var data2 = element.getData();
      var states = element.getStates();
      each$1(states, function(state2) {
        stateObjects.push({ data: data2, state: state2, geometry: element.geometry, element });
      });
    });
    return stateObjects;
  };
  Funnel2.CONVERSATION_FIELD = FUNNEL_CONVERSATION;
  Funnel2.PERCENT_FIELD = FUNNEL_PERCENT;
  Funnel2.TOTAL_PERCENT_FIELD = FUNNEL_TOTAL_PERCENT;
  return Funnel2;
}(Plot);
var CAT_VALUE = "liquid";
function getLiquidData(percent2) {
  return [{ percent: percent2, type: CAT_VALUE }];
}
function geometry$9(params) {
  var chart = params.chart, options = params.options;
  var percent2 = options.percent, liquidStyle = options.liquidStyle, radius = options.radius, outline = options.outline, wave = options.wave, shape = options.shape, animation2 = options.animation;
  chart.scale({
    percent: {
      min: 0,
      max: 1
    }
  });
  chart.data(getLiquidData(percent2));
  var color2 = options.color || chart.getTheme().defaultColor;
  var p2 = deepAssign({}, params, {
    options: {
      xField: "type",
      yField: "percent",
      widthRatio: radius,
      interval: {
        color: color2,
        style: liquidStyle,
        shape: "liquid-fill-gauge"
      }
    }
  });
  var ext = interval(p2).ext;
  var geometry2 = ext.geometry;
  var background = chart.getTheme().background;
  var customInfo = {
    radius,
    outline,
    wave,
    shape,
    background,
    animation: animation2
  };
  geometry2.customInfo(customInfo);
  chart.legend(false);
  chart.axis(false);
  chart.tooltip(false);
  return params;
}
function statistic$1(params, updated) {
  var chart = params.chart, options = params.options;
  var statistic2 = options.statistic, percent2 = options.percent, meta2 = options.meta;
  chart.getController("annotation").clear(true);
  var metaFormatter = get(meta2, ["percent", "formatter"]) || function(v2) {
    return (v2 * 100).toFixed(2) + "%";
  };
  var contentOpt = statistic2.content;
  if (contentOpt) {
    contentOpt = deepAssign({}, contentOpt, {
      content: !isNil(contentOpt.content) ? contentOpt.content : metaFormatter(percent2)
    });
  }
  renderStatistic(chart, { statistic: __assign$4(__assign$4({}, statistic2), { content: contentOpt }), plotType: "liquid" }, { percent: percent2 });
  if (updated) {
    chart.render(true);
  }
  return params;
}
function adaptor$c(params) {
  return flow(theme$2, pattern("liquidStyle"), geometry$9, statistic$1, scale$2({}), animation$5, interaction$7)(params);
}
var DEFAULT_OPTIONS$e = {
  radius: 0.9,
  statistic: {
    title: false,
    content: {
      style: {
        opacity: 0.75,
        fontSize: "30px",
        lineHeight: "30px",
        textAlign: "center"
      }
    }
  },
  outline: {
    border: 2,
    distance: 0
  },
  wave: {
    count: 3,
    length: 192
  },
  shape: "circle"
};
var DURATION = 5e3;
function lerp(min2, max2, factor) {
  return min2 + (max2 - min2) * factor;
}
function getFillAttrs$1(cfg) {
  var attrs = __assign$4({ opacity: 1 }, cfg.style);
  if (cfg.color && !attrs.fill) {
    attrs.fill = cfg.color;
  }
  return attrs;
}
function getLineAttrs(cfg) {
  var defaultAttrs = {
    fill: "#fff",
    fillOpacity: 0,
    lineWidth: 4
  };
  var attrs = mix({}, defaultAttrs, cfg.style);
  if (cfg.color && !attrs.stroke) {
    attrs.stroke = cfg.color;
  }
  if (isNumber$1(cfg.opacity)) {
    attrs.opacity = attrs.strokeOpacity = cfg.opacity;
  }
  return attrs;
}
function getWaterWavePositions(x2, stage, waveLength, amplitude2) {
  if (stage === 0) {
    return [
      [x2 + 1 / 2 * waveLength / Math.PI / 2, amplitude2 / 2],
      [x2 + 1 / 2 * waveLength / Math.PI, amplitude2],
      [x2 + waveLength / 4, amplitude2]
    ];
  }
  if (stage === 1) {
    return [
      [x2 + 1 / 2 * waveLength / Math.PI / 2 * (Math.PI - 2), amplitude2],
      [x2 + 1 / 2 * waveLength / Math.PI / 2 * (Math.PI - 1), amplitude2 / 2],
      [x2 + waveLength / 4, 0]
    ];
  }
  if (stage === 2) {
    return [
      [x2 + 1 / 2 * waveLength / Math.PI / 2, -amplitude2 / 2],
      [x2 + 1 / 2 * waveLength / Math.PI, -amplitude2],
      [x2 + waveLength / 4, -amplitude2]
    ];
  }
  return [
    [x2 + 1 / 2 * waveLength / Math.PI / 2 * (Math.PI - 2), -amplitude2],
    [x2 + 1 / 2 * waveLength / Math.PI / 2 * (Math.PI - 1), -amplitude2 / 2],
    [x2 + waveLength / 4, 0]
  ];
}
function getWaterWavePath(radius, waterLevel, waveLength, phase, amplitude2, cx, cy) {
  var curves = Math.ceil(2 * radius / waveLength * 4) * 4;
  var path2 = [];
  var _phase = phase;
  while (_phase < -Math.PI * 2) {
    _phase += Math.PI * 2;
  }
  while (_phase > 0) {
    _phase -= Math.PI * 2;
  }
  _phase = _phase / Math.PI / 2 * waveLength;
  var left2 = cx - radius + _phase - radius * 2;
  path2.push(["M", left2, waterLevel]);
  var waveRight = 0;
  for (var c2 = 0; c2 < curves; ++c2) {
    var stage = c2 % 4;
    var pos = getWaterWavePositions(c2 * waveLength / 4, stage, waveLength, amplitude2);
    path2.push([
      "C",
      pos[0][0] + left2,
      -pos[0][1] + waterLevel,
      pos[1][0] + left2,
      -pos[1][1] + waterLevel,
      pos[2][0] + left2,
      -pos[2][1] + waterLevel
    ]);
    if (c2 === curves - 1) {
      waveRight = pos[2][0];
    }
  }
  path2.push(["L", waveRight + left2, cy + radius]);
  path2.push(["L", left2, cy + radius]);
  path2.push(["Z"]);
  return path2;
}
function addWaterWave(x2, y2, level, waveCount, waveAttrs, group2, clip, radius, waveLength, animation2) {
  var fill = waveAttrs.fill, opacity = waveAttrs.opacity;
  var bbox = clip.getBBox();
  var width = bbox.maxX - bbox.minX;
  var height = bbox.maxY - bbox.minY;
  for (var idx = 0; idx < waveCount; idx++) {
    var factor = waveCount <= 1 ? 0 : idx / (waveCount - 1);
    var wave = group2.addShape("path", {
      name: "waterwave-path",
      attrs: {
        path: getWaterWavePath(
          radius,
          bbox.minY + height * level,
          waveLength,
          0,
          width / 32,
          x2,
          y2
        ),
        fill,
        opacity: lerp(0.2, 0.9, factor) * opacity
      }
    });
    try {
      if (animation2 === false)
        return;
      var matrix = transform$2([["t", waveLength, 0]]);
      wave.stopAnimate();
      wave.animate({ matrix }, {
        duration: lerp(0.5 * DURATION, DURATION, factor),
        repeat: true
      });
    } catch (e3) {
      console.warn("off-screen group animate error!");
    }
  }
}
function pin(x2, y2, width, height) {
  var w2 = width * 2 / 3;
  var h2 = Math.max(w2, height);
  var r2 = w2 / 2;
  var cx = x2;
  var cy = r2 + y2 - h2 / 2;
  var theta = Math.asin(r2 / ((h2 - r2) * 0.85));
  var dy = Math.sin(theta) * r2;
  var dx = Math.cos(theta) * r2;
  var x0 = cx - dx;
  var y0 = cy + dy;
  var cpX = x2;
  var cpY = cy + r2 / Math.sin(theta);
  return "\n      M " + x0 + " " + y0 + "\n      A " + r2 + " " + r2 + " 0 1 1 " + (x0 + dx * 2) + " " + y0 + "\n      Q " + cpX + " " + cpY + " " + x2 + " " + (y2 + h2 / 2) + "\n      Q " + cpX + " " + cpY + " " + x0 + " " + y0 + "\n      Z \n    ";
}
function circle(x2, y2, width, height) {
  var rx = width / 2;
  var ry = height / 2;
  return "\n      M " + x2 + " " + (y2 - ry) + " \n      a " + rx + " " + ry + " 0 1 0 0 " + ry * 2 + "\n      a " + rx + " " + ry + " 0 1 0 0 " + -ry * 2 + "\n      Z\n    ";
}
function diamond(x2, y2, width, height) {
  var h2 = height / 2;
  var w2 = width / 2;
  return "\n      M " + x2 + " " + (y2 - h2) + "\n      L " + (x2 + w2) + " " + y2 + "\n      L " + x2 + " " + (y2 + h2) + "\n      L " + (x2 - w2) + " " + y2 + "\n      Z\n    ";
}
function triangle(x2, y2, width, height) {
  var h2 = height / 2;
  var w2 = width / 2;
  return "\n      M " + x2 + " " + (y2 - h2) + "\n      L " + (x2 + w2) + " " + (y2 + h2) + "\n      L " + (x2 - w2) + " " + (y2 + h2) + "\n      Z\n    ";
}
function rect(x2, y2, width, height) {
  var GOLDEN_SECTION_RATIO = 0.618;
  var h2 = height / 2;
  var w2 = width / 2 * GOLDEN_SECTION_RATIO;
  return "\n      M " + (x2 - w2) + " " + (y2 - h2) + "\n      L " + (x2 + w2) + " " + (y2 - h2) + "\n      L " + (x2 + w2) + " " + (y2 + h2) + "\n      L " + (x2 - w2) + " " + (y2 + h2) + "\n      Z\n    ";
}
var builtInShapeByName = {
  pin,
  circle,
  diamond,
  triangle,
  rect
};
registerShape("interval", "liquid-fill-gauge", {
  draw: function(cfg, container) {
    var cx = 0.5;
    var cy = 0.5;
    var customInfo = cfg.customInfo;
    var _a2 = customInfo, radio = _a2.radius, shape = _a2.shape, background = _a2.background, animation2 = _a2.animation;
    var outline = customInfo.outline;
    var wave = customInfo.wave;
    var border = outline.border, distance2 = outline.distance;
    var waveCount = wave.count, waveLength = wave.length;
    var minX = reduce(cfg.points, function(r2, p2) {
      return Math.min(r2, p2.x);
    }, Infinity);
    var center2 = this.parsePoint({ x: cx, y: cy });
    var minXPoint = this.parsePoint({ x: minX, y: cy });
    var halfWidth = center2.x - minXPoint.x;
    var radius = Math.min(halfWidth, minXPoint.y * radio);
    var waveAttrs = getFillAttrs$1(cfg);
    var outlineAttrs = getLineAttrs(mix({}, cfg, outline));
    var innerRadius = radius - border / 2;
    var buildPath = typeof shape === "function" ? shape : builtInShapeByName[shape] || builtInShapeByName["circle"];
    var shapePath = buildPath(center2.x, center2.y, innerRadius * 2, innerRadius * 2);
    var waves = container.addGroup({
      name: "waves"
    });
    var clipPath = waves.setClip({
      type: "path",
      attrs: {
        path: shapePath
      }
    });
    addWaterWave(center2.x, center2.y, 1 - cfg.points[1].y, waveCount, waveAttrs, waves, clipPath, radius * 2, waveLength, animation2);
    container.addShape("path", {
      name: "distance",
      attrs: {
        path: shapePath,
        fill: "transparent",
        lineWidth: border + distance2 * 2,
        stroke: background === "transparent" ? "#fff" : background
      }
    });
    container.addShape("path", {
      name: "wrap",
      attrs: mix(outlineAttrs, {
        path: shapePath,
        fill: "transparent",
        lineWidth: border
      })
    });
    return container;
  }
});
(function(_super) {
  __extends$3(Liquid, _super);
  function Liquid() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "liquid";
    return _this;
  }
  Liquid.getDefaultOptions = function() {
    return DEFAULT_OPTIONS$e;
  };
  Liquid.prototype.getDefaultOptions = function() {
    return Liquid.getDefaultOptions();
  };
  Liquid.prototype.changeData = function(percent2) {
    this.chart.emit(VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, Event.fromData(this.chart, VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, null));
    this.updateOption({ percent: percent2 });
    this.chart.data(getLiquidData(percent2));
    statistic$1({ chart: this.chart, options: this.options }, true);
    this.chart.emit(VIEW_LIFE_CIRCLE.AFTER_CHANGE_DATA, Event.fromData(this.chart, VIEW_LIFE_CIRCLE.AFTER_CHANGE_DATA, null));
  };
  Liquid.prototype.getSchemaAdaptor = function() {
    return adaptor$c;
  };
  return Liquid;
})(Plot);
function getSeriesFieldKey(values2, field2, index2) {
  return values2.length > 1 ? field2 + "_" + index2 : "" + field2;
}
function transformData$6(options) {
  var data2 = options.data, xField = options.xField, measureField = options.measureField, rangeField = options.rangeField, targetField = options.targetField, layout2 = options.layout;
  var ds = [];
  var scales = [];
  data2.forEach(function(item, index2) {
    var rangeValues = [item[rangeField]].flat();
    rangeValues.sort(function(a2, b10) {
      return a2 - b10;
    });
    rangeValues.forEach(function(d2, i2) {
      var _a2;
      var range3 = i2 === 0 ? d2 : rangeValues[i2] - rangeValues[i2 - 1];
      ds.push((_a2 = {
        rKey: rangeField + "_" + i2
      }, _a2[xField] = xField ? item[xField] : String(index2), _a2[rangeField] = range3, _a2));
    });
    var measureValues = [item[measureField]].flat();
    measureValues.forEach(function(d2, i2) {
      var _a2;
      ds.push((_a2 = {
        mKey: getSeriesFieldKey(measureValues, measureField, i2)
      }, _a2[xField] = xField ? item[xField] : String(index2), _a2[measureField] = d2, _a2));
    });
    var targetValues = [item[targetField]].flat();
    targetValues.forEach(function(d2, i2) {
      var _a2;
      ds.push((_a2 = {
        tKey: getSeriesFieldKey(targetValues, targetField, i2)
      }, _a2[xField] = xField ? item[xField] : String(index2), _a2[targetField] = d2, _a2));
    });
    scales.push(item[rangeField], item[measureField], item[targetField]);
  });
  var min2 = Math.min.apply(Math, scales.flat(Infinity));
  var max2 = Math.max.apply(Math, scales.flat(Infinity));
  min2 = min2 > 0 ? 0 : min2;
  if (layout2 === "vertical") {
    ds.reverse();
  }
  return { min: min2, max: max2, ds };
}
function geometry$8(params) {
  var chart = params.chart, options = params.options;
  var bulletStyle = options.bulletStyle, targetField = options.targetField, rangeField = options.rangeField, measureField = options.measureField, xField = options.xField, color2 = options.color, layout2 = options.layout, size2 = options.size, label2 = options.label;
  var _a2 = transformData$6(options), min2 = _a2.min, max2 = _a2.max, ds = _a2.ds;
  chart.data(ds);
  var r2 = deepAssign({}, params, {
    options: {
      xField,
      yField: rangeField,
      seriesField: "rKey",
      isStack: true,
      label: get(label2, "range"),
      interval: {
        color: get(color2, "range"),
        style: get(bulletStyle, "range"),
        size: get(size2, "range")
      }
    }
  });
  interval(r2);
  chart.geometries[0].tooltip(false);
  var m2 = deepAssign({}, params, {
    options: {
      xField,
      yField: measureField,
      seriesField: "mKey",
      isStack: true,
      label: get(label2, "measure"),
      interval: {
        color: get(color2, "measure"),
        style: get(bulletStyle, "measure"),
        size: get(size2, "measure")
      }
    }
  });
  interval(m2);
  var t2 = deepAssign({}, params, {
    options: {
      xField,
      yField: targetField,
      seriesField: "tKey",
      label: get(label2, "target"),
      point: {
        color: get(color2, "target"),
        style: get(bulletStyle, "target"),
        size: isFunction(get(size2, "target")) ? function(data2) {
          return get(size2, "target")(data2) / 2;
        } : get(size2, "target") / 2,
        shape: layout2 === "horizontal" ? "line" : "hyphen"
      }
    }
  });
  point(t2);
  if (layout2 === "horizontal") {
    chart.coordinate().transpose();
  }
  return __assign$4(__assign$4({}, params), { ext: { data: { min: min2, max: max2 } } });
}
function meta$6(params) {
  var _a2, _b;
  var options = params.options, ext = params.ext;
  var xAxis = options.xAxis, yAxis = options.yAxis, targetField = options.targetField, rangeField = options.rangeField, measureField = options.measureField, xField = options.xField;
  var extData = ext.data;
  return flow(scale$2((_a2 = {}, _a2[xField] = xAxis, _a2[measureField] = yAxis, _a2), (_b = {}, _b[measureField] = { min: extData === null || extData === void 0 ? void 0 : extData.min, max: extData === null || extData === void 0 ? void 0 : extData.max, sync: true }, _b[targetField] = {
    sync: "" + measureField
  }, _b[rangeField] = {
    sync: "" + measureField
  }, _b)))(params);
}
function axis$7(params) {
  var chart = params.chart, options = params.options;
  var xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField, measureField = options.measureField, rangeField = options.rangeField, targetField = options.targetField;
  chart.axis("" + rangeField, false);
  chart.axis("" + targetField, false);
  if (xAxis === false) {
    chart.axis("" + xField, false);
  } else {
    chart.axis("" + xField, xAxis);
  }
  if (yAxis === false) {
    chart.axis("" + measureField, false);
  } else {
    chart.axis("" + measureField, yAxis);
  }
  return params;
}
function legend$2(params) {
  var chart = params.chart, options = params.options;
  var legend2 = options.legend;
  chart.removeInteraction("legend-filter");
  chart.legend(legend2);
  chart.legend("rKey", false);
  chart.legend("mKey", false);
  chart.legend("tKey", false);
  return params;
}
function label$4(params) {
  var chart = params.chart, options = params.options;
  var label2 = options.label, measureField = options.measureField, targetField = options.targetField, rangeField = options.rangeField;
  var _a2 = chart.geometries, rangeGeometry = _a2[0], measureGeometry = _a2[1], targetGeometry = _a2[2];
  if (get(label2, "range")) {
    rangeGeometry.label("" + rangeField, __assign$4({ layout: [{ type: "limit-in-plot" }] }, transformLabel(label2.range)));
  } else {
    rangeGeometry.label(false);
  }
  if (get(label2, "measure")) {
    measureGeometry.label("" + measureField, __assign$4({ layout: [{ type: "limit-in-plot" }] }, transformLabel(label2.measure)));
  } else {
    measureGeometry.label(false);
  }
  if (get(label2, "target")) {
    targetGeometry.label("" + targetField, __assign$4({ layout: [{ type: "limit-in-plot" }] }, transformLabel(label2.target)));
  } else {
    targetGeometry.label(false);
  }
  return params;
}
function adaptor$b(params) {
  flow(geometry$8, meta$6, axis$7, legend$2, theme$2, label$4, tooltip$9, interaction$7, animation$5)(params);
}
var DEFAULT_OPTIONS$d = deepAssign({}, Plot.getDefaultOptions(), {
  layout: "horizontal",
  size: {
    range: 30,
    measure: 20,
    target: 20
  },
  xAxis: {
    tickLine: false,
    line: null
  },
  bulletStyle: {
    range: {
      fillOpacity: 0.5
    }
  },
  label: {
    measure: {
      position: "right"
    }
  },
  tooltip: {
    showMarkers: false
  }
});
(function(_super) {
  __extends$3(Bullet, _super);
  function Bullet() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "bullet";
    return _this;
  }
  Bullet.getDefaultOptions = function() {
    return DEFAULT_OPTIONS$d;
  };
  Bullet.prototype.changeData = function(data2) {
    this.updateOption({ data: data2 });
    var _a2 = transformData$6(this.options), min2 = _a2.min, max2 = _a2.max, ds = _a2.ds;
    meta$6({ options: this.options, ext: { data: { min: min2, max: max2 } }, chart: this.chart });
    this.chart.changeData(ds);
  };
  Bullet.prototype.getSchemaAdaptor = function() {
    return adaptor$b;
  };
  Bullet.prototype.getDefaultOptions = function() {
    return Bullet.getDefaultOptions();
  };
  return Bullet;
})(Plot);
var NODE_INDEX_FIELD = "nodeIndex";
var CHILD_NODE_COUNT = "childNodeCount";
var NODE_ANCESTORS_FIELD = "nodeAncestor";
var INVALID_FIELD_ERR_MSG = "Invalid field: it must be a string!";
function getField(options, defaultField) {
  var field2 = options.field, fields = options.fields;
  if (isString(field2)) {
    return field2;
  }
  if (isArray$1(field2)) {
    console.warn(INVALID_FIELD_ERR_MSG);
    return field2[0];
  }
  console.warn(INVALID_FIELD_ERR_MSG + " will try to get fields instead.");
  if (isString(fields)) {
    return fields;
  }
  if (isArray$1(fields) && fields.length) {
    return fields[0];
  }
  if (defaultField) {
    return defaultField;
  }
  throw new TypeError(INVALID_FIELD_ERR_MSG);
}
function getAllNodes(root2) {
  var nodes = [];
  if (root2 && root2.each) {
    var parent_1;
    var index_1;
    root2.each(function(node) {
      var _a2, _b;
      if (node.parent !== parent_1) {
        parent_1 = node.parent;
        index_1 = 0;
      } else {
        index_1 += 1;
      }
      var ancestors = filter((((_a2 = node.ancestors) === null || _a2 === void 0 ? void 0 : _a2.call(node)) || []).map(function(d2) {
        return nodes.find(function(n2) {
          return n2.name === d2.name;
        }) || d2;
      }), function(_a3) {
        var depth = _a3.depth;
        return depth > 0 && depth < node.depth;
      });
      node[NODE_ANCESTORS_FIELD] = ancestors;
      node[CHILD_NODE_COUNT] = ((_b = node.children) === null || _b === void 0 ? void 0 : _b.length) || 0;
      node[NODE_INDEX_FIELD] = index_1;
      nodes.push(node);
    });
  } else if (root2 && root2.eachNode) {
    root2.eachNode(function(node) {
      nodes.push(node);
    });
  }
  return nodes;
}
var SUNBURST_ANCESTOR_FIELD = "ancestor-node";
var SUNBURST_Y_FIELD = "value";
var SUNBURST_PATH_FIELD = "path";
var RAW_FIELDS$1 = [
  SUNBURST_PATH_FIELD,
  NODE_INDEX_FIELD,
  NODE_ANCESTORS_FIELD,
  CHILD_NODE_COUNT,
  "name",
  "depth",
  "height"
];
var DEFAULT_OPTIONS$c = deepAssign({}, Plot.getDefaultOptions(), {
  innerRadius: 0,
  radius: 0.85,
  hierarchyConfig: {
    field: "value"
  },
  tooltip: {
    shared: true,
    showMarkers: false,
    offset: 20,
    showTitle: false
  },
  legend: false,
  sunburstStyle: {
    lineWidth: 0.5,
    stroke: "#FFF"
  },
  drilldown: { enabled: true }
});
var PADDING = 4;
var PADDING_LEFT = 0;
var PADDING_TOP = 5;
var BREAD_CRUMB_NAME = "drilldown-bread-crumb";
var DEFAULT_BREAD_CRUMB_CONFIG = {
  position: "top-left",
  dividerText: "/",
  textStyle: {
    fontSize: 12,
    fill: "rgba(0, 0, 0, 0.65)",
    cursor: "pointer"
  },
  activeTextStyle: {
    fill: "#87B5FF"
  }
};
var HIERARCHY_DATA_TRANSFORM_PARAMS = "hierarchy-data-transform-params";
var DrillDownAction = function(_super) {
  __extends$3(DrillDownAction2, _super);
  function DrillDownAction2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.name = "drill-down";
    _this.historyCache = [];
    _this.breadCrumbGroup = null;
    _this.breadCrumbCfg = DEFAULT_BREAD_CRUMB_CONFIG;
    return _this;
  }
  DrillDownAction2.prototype.click = function() {
    var data2 = get(this.context, ["event", "data", "data"]);
    if (!data2)
      return false;
    this.drill(data2);
    this.drawBreadCrumb();
  };
  DrillDownAction2.prototype.resetPosition = function() {
    if (!this.breadCrumbGroup)
      return;
    var coordinate2 = this.context.view.getCoordinate();
    var breadCrumbGroup = this.breadCrumbGroup;
    var bbox = breadCrumbGroup.getBBox();
    var position = this.getButtonCfg().position;
    var point2 = { x: coordinate2.start.x, y: coordinate2.end.y - (bbox.height + PADDING_TOP * 2) };
    if (coordinate2.isPolar) {
      point2 = { x: 0, y: 0 };
    }
    if (position === "bottom-left") {
      point2 = { x: coordinate2.start.x, y: coordinate2.start.y };
    }
    var matrix = Util.transform(null, [["t", point2.x + PADDING_LEFT, point2.y + bbox.height + PADDING_TOP]]);
    breadCrumbGroup.setMatrix(matrix);
  };
  DrillDownAction2.prototype.back = function() {
    if (size(this.historyCache)) {
      this.backTo(this.historyCache.slice(0, -1));
    }
  };
  DrillDownAction2.prototype.reset = function() {
    if (this.historyCache[0]) {
      this.backTo(this.historyCache.slice(0, 1));
    }
    this.historyCache = [];
    this.hideCrumbGroup();
  };
  DrillDownAction2.prototype.drill = function(nodeInfo) {
    var view = this.context.view;
    var transformData2 = get(view, ["interactions", "drill-down", "cfg", "transformData"], function(v2) {
      return v2;
    });
    var drillData = transformData2(__assign$4({ data: nodeInfo.data }, nodeInfo[HIERARCHY_DATA_TRANSFORM_PARAMS]));
    view.changeData(drillData);
    var historyCache = [];
    var node = nodeInfo;
    while (node) {
      var nodeData = node.data;
      historyCache.unshift({
        id: nodeData.name + "_" + node.height + "_" + node.depth,
        name: nodeData.name,
        children: transformData2(__assign$4({ data: nodeData }, nodeInfo[HIERARCHY_DATA_TRANSFORM_PARAMS]))
      });
      node = node.parent;
    }
    this.historyCache = (this.historyCache || []).slice(0, -1).concat(historyCache);
  };
  DrillDownAction2.prototype.backTo = function(historyCache) {
    if (!historyCache || historyCache.length <= 0) {
      return;
    }
    var view = this.context.view;
    var data2 = last(historyCache).children;
    view.changeData(data2);
    if (historyCache.length > 1) {
      this.historyCache = historyCache;
      this.drawBreadCrumb();
    } else {
      this.historyCache = [];
      this.hideCrumbGroup();
    }
  };
  DrillDownAction2.prototype.getButtonCfg = function() {
    var view = this.context.view;
    var drillDownConfig = get(view, ["interactions", "drill-down", "cfg", "drillDownConfig"]);
    return deepAssign(this.breadCrumbCfg, drillDownConfig === null || drillDownConfig === void 0 ? void 0 : drillDownConfig.breadCrumb, this.cfg);
  };
  DrillDownAction2.prototype.drawBreadCrumb = function() {
    this.drawBreadCrumbGroup();
    this.resetPosition();
    this.breadCrumbGroup.show();
  };
  DrillDownAction2.prototype.drawBreadCrumbGroup = function() {
    var _this = this;
    var config = this.getButtonCfg();
    var cache2 = this.historyCache;
    if (!this.breadCrumbGroup) {
      this.breadCrumbGroup = this.context.view.foregroundGroup.addGroup({
        name: BREAD_CRUMB_NAME
      });
    } else {
      this.breadCrumbGroup.clear();
    }
    var left2 = 0;
    cache2.forEach(function(record, index2) {
      var textShape = _this.breadCrumbGroup.addShape({
        type: "text",
        id: record.id,
        name: BREAD_CRUMB_NAME + "_" + record.name + "_text",
        attrs: __assign$4(__assign$4({ text: index2 === 0 && !isNil(config.rootText) ? config.rootText : record.name }, config.textStyle), { x: left2, y: 0 })
      });
      var textShapeBox = textShape.getBBox();
      left2 += textShapeBox.width + PADDING;
      textShape.on("click", function(event) {
        var _a2;
        var targetId = event.target.get("id");
        if (targetId !== ((_a2 = last(cache2)) === null || _a2 === void 0 ? void 0 : _a2.id)) {
          var newHistoryCache = cache2.slice(0, cache2.findIndex(function(d2) {
            return d2.id === targetId;
          }) + 1);
          _this.backTo(newHistoryCache);
        }
      });
      textShape.on("mouseenter", function(event) {
        var _a2;
        var targetId = event.target.get("id");
        if (targetId !== ((_a2 = last(cache2)) === null || _a2 === void 0 ? void 0 : _a2.id)) {
          textShape.attr(config.activeTextStyle);
        } else {
          textShape.attr({ cursor: "default" });
        }
      });
      textShape.on("mouseleave", function() {
        textShape.attr(config.textStyle);
      });
      if (index2 < cache2.length - 1) {
        var dividerShape = _this.breadCrumbGroup.addShape({
          type: "text",
          name: config.name + "_" + record.name + "_divider",
          attrs: __assign$4(__assign$4({ text: config.dividerText }, config.textStyle), { x: left2, y: 0 })
        });
        var dividerBox = dividerShape.getBBox();
        left2 += dividerBox.width + PADDING;
      }
    });
  };
  DrillDownAction2.prototype.hideCrumbGroup = function() {
    if (this.breadCrumbGroup) {
      this.breadCrumbGroup.hide();
    }
  };
  DrillDownAction2.prototype.destroy = function() {
    if (this.breadCrumbGroup) {
      this.breadCrumbGroup.remove();
    }
    _super.prototype.destroy.call(this);
  };
  return DrillDownAction2;
}(Action);
function defaultSeparation$1(a2, b10) {
  return a2.parent === b10.parent ? 1 : 2;
}
function meanX(children) {
  return children.reduce(meanXReduce, 0) / children.length;
}
function meanXReduce(x2, c2) {
  return x2 + c2.x;
}
function maxY(children) {
  return 1 + children.reduce(maxYReduce, 0);
}
function maxYReduce(y2, c2) {
  return Math.max(y2, c2.y);
}
function leafLeft(node) {
  var children;
  while (children = node.children)
    node = children[0];
  return node;
}
function leafRight(node) {
  var children;
  while (children = node.children)
    node = children[children.length - 1];
  return node;
}
function cluster() {
  var separation = defaultSeparation$1, dx = 1, dy = 1, nodeSize = false;
  function cluster2(root2) {
    var previousNode, x2 = 0;
    root2.eachAfter(function(node) {
      var children = node.children;
      if (children) {
        node.x = meanX(children);
        node.y = maxY(children);
      } else {
        node.x = previousNode ? x2 += separation(node, previousNode) : 0;
        node.y = 0;
        previousNode = node;
      }
    });
    var left2 = leafLeft(root2), right2 = leafRight(root2), x0 = left2.x - separation(left2, right2) / 2, x1 = right2.x + separation(right2, left2) / 2;
    return root2.eachAfter(nodeSize ? function(node) {
      node.x = (node.x - root2.x) * dx;
      node.y = (root2.y - node.y) * dy;
    } : function(node) {
      node.x = (node.x - x0) / (x1 - x0) * dx;
      node.y = (1 - (root2.y ? node.y / root2.y : 1)) * dy;
    });
  }
  cluster2.separation = function(x2) {
    return arguments.length ? (separation = x2, cluster2) : separation;
  };
  cluster2.size = function(x2) {
    return arguments.length ? (nodeSize = false, dx = +x2[0], dy = +x2[1], cluster2) : nodeSize ? null : [dx, dy];
  };
  cluster2.nodeSize = function(x2) {
    return arguments.length ? (nodeSize = true, dx = +x2[0], dy = +x2[1], cluster2) : nodeSize ? [dx, dy] : null;
  };
  return cluster2;
}
function count(node) {
  var sum = 0, children = node.children, i2 = children && children.length;
  if (!i2)
    sum = 1;
  else
    while (--i2 >= 0)
      sum += children[i2].value;
  node.value = sum;
}
function node_count() {
  return this.eachAfter(count);
}
function node_each(callback, that) {
  let index2 = -1;
  for (const node of this) {
    callback.call(that, node, ++index2, this);
  }
  return this;
}
function node_eachBefore(callback, that) {
  var node = this, nodes = [node], children, i2, index2 = -1;
  while (node = nodes.pop()) {
    callback.call(that, node, ++index2, this);
    if (children = node.children) {
      for (i2 = children.length - 1; i2 >= 0; --i2) {
        nodes.push(children[i2]);
      }
    }
  }
  return this;
}
function node_eachAfter(callback, that) {
  var node = this, nodes = [node], next = [], children, i2, n2, index2 = -1;
  while (node = nodes.pop()) {
    next.push(node);
    if (children = node.children) {
      for (i2 = 0, n2 = children.length; i2 < n2; ++i2) {
        nodes.push(children[i2]);
      }
    }
  }
  while (node = next.pop()) {
    callback.call(that, node, ++index2, this);
  }
  return this;
}
function node_find(callback, that) {
  let index2 = -1;
  for (const node of this) {
    if (callback.call(that, node, ++index2, this)) {
      return node;
    }
  }
}
function node_sum(value2) {
  return this.eachAfter(function(node) {
    var sum = +value2(node.data) || 0, children = node.children, i2 = children && children.length;
    while (--i2 >= 0)
      sum += children[i2].value;
    node.value = sum;
  });
}
function node_sort(compare2) {
  return this.eachBefore(function(node) {
    if (node.children) {
      node.children.sort(compare2);
    }
  });
}
function node_path(end) {
  var start = this, ancestor = leastCommonAncestor(start, end), nodes = [start];
  while (start !== ancestor) {
    start = start.parent;
    nodes.push(start);
  }
  var k2 = nodes.length;
  while (end !== ancestor) {
    nodes.splice(k2, 0, end);
    end = end.parent;
  }
  return nodes;
}
function leastCommonAncestor(a2, b10) {
  if (a2 === b10)
    return a2;
  var aNodes = a2.ancestors(), bNodes = b10.ancestors(), c2 = null;
  a2 = aNodes.pop();
  b10 = bNodes.pop();
  while (a2 === b10) {
    c2 = a2;
    a2 = aNodes.pop();
    b10 = bNodes.pop();
  }
  return c2;
}
function node_ancestors() {
  var node = this, nodes = [node];
  while (node = node.parent) {
    nodes.push(node);
  }
  return nodes;
}
function node_descendants() {
  return Array.from(this);
}
function node_leaves() {
  var leaves = [];
  this.eachBefore(function(node) {
    if (!node.children) {
      leaves.push(node);
    }
  });
  return leaves;
}
function node_links() {
  var root2 = this, links = [];
  root2.each(function(node) {
    if (node !== root2) {
      links.push({ source: node.parent, target: node });
    }
  });
  return links;
}
function* node_iterator() {
  var node = this, current, next = [node], children, i2, n2;
  do {
    current = next.reverse(), next = [];
    while (node = current.pop()) {
      yield node;
      if (children = node.children) {
        for (i2 = 0, n2 = children.length; i2 < n2; ++i2) {
          next.push(children[i2]);
        }
      }
    }
  } while (next.length);
}
function hierarchy(data2, children) {
  if (data2 instanceof Map) {
    data2 = [void 0, data2];
    if (children === void 0)
      children = mapChildren;
  } else if (children === void 0) {
    children = objectChildren;
  }
  var root2 = new Node$2(data2), node, nodes = [root2], child, childs, i2, n2;
  while (node = nodes.pop()) {
    if ((childs = children(node.data)) && (n2 = (childs = Array.from(childs)).length)) {
      node.children = childs;
      for (i2 = n2 - 1; i2 >= 0; --i2) {
        nodes.push(child = childs[i2] = new Node$2(childs[i2]));
        child.parent = node;
        child.depth = node.depth + 1;
      }
    }
  }
  return root2.eachBefore(computeHeight);
}
function node_copy() {
  return hierarchy(this).eachBefore(copyData);
}
function objectChildren(d2) {
  return d2.children;
}
function mapChildren(d2) {
  return Array.isArray(d2) ? d2[1] : null;
}
function copyData(node) {
  if (node.data.value !== void 0)
    node.value = node.data.value;
  node.data = node.data.data;
}
function computeHeight(node) {
  var height = 0;
  do
    node.height = height;
  while ((node = node.parent) && node.height < ++height);
}
function Node$2(data2) {
  this.data = data2;
  this.depth = this.height = 0;
  this.parent = null;
}
Node$2.prototype = hierarchy.prototype = {
  constructor: Node$2,
  count: node_count,
  each: node_each,
  eachAfter: node_eachAfter,
  eachBefore: node_eachBefore,
  find: node_find,
  sum: node_sum,
  sort: node_sort,
  path: node_path,
  ancestors: node_ancestors,
  descendants: node_descendants,
  leaves: node_leaves,
  links: node_links,
  copy: node_copy,
  [Symbol.iterator]: node_iterator
};
function array(x2) {
  return typeof x2 === "object" && "length" in x2 ? x2 : Array.from(x2);
}
function shuffle(array4) {
  var m2 = array4.length, t2, i2;
  while (m2) {
    i2 = Math.random() * m2-- | 0;
    t2 = array4[m2];
    array4[m2] = array4[i2];
    array4[i2] = t2;
  }
  return array4;
}
function enclose(circles) {
  var i2 = 0, n2 = (circles = shuffle(Array.from(circles))).length, B2 = [], p2, e3;
  while (i2 < n2) {
    p2 = circles[i2];
    if (e3 && enclosesWeak(e3, p2))
      ++i2;
    else
      e3 = encloseBasis(B2 = extendBasis(B2, p2)), i2 = 0;
  }
  return e3;
}
function extendBasis(B2, p2) {
  var i2, j2;
  if (enclosesWeakAll(p2, B2))
    return [p2];
  for (i2 = 0; i2 < B2.length; ++i2) {
    if (enclosesNot(p2, B2[i2]) && enclosesWeakAll(encloseBasis2(B2[i2], p2), B2)) {
      return [B2[i2], p2];
    }
  }
  for (i2 = 0; i2 < B2.length - 1; ++i2) {
    for (j2 = i2 + 1; j2 < B2.length; ++j2) {
      if (enclosesNot(encloseBasis2(B2[i2], B2[j2]), p2) && enclosesNot(encloseBasis2(B2[i2], p2), B2[j2]) && enclosesNot(encloseBasis2(B2[j2], p2), B2[i2]) && enclosesWeakAll(encloseBasis3(B2[i2], B2[j2], p2), B2)) {
        return [B2[i2], B2[j2], p2];
      }
    }
  }
  throw new Error();
}
function enclosesNot(a2, b10) {
  var dr = a2.r - b10.r, dx = b10.x - a2.x, dy = b10.y - a2.y;
  return dr < 0 || dr * dr < dx * dx + dy * dy;
}
function enclosesWeak(a2, b10) {
  var dr = a2.r - b10.r + Math.max(a2.r, b10.r, 1) * 1e-9, dx = b10.x - a2.x, dy = b10.y - a2.y;
  return dr > 0 && dr * dr > dx * dx + dy * dy;
}
function enclosesWeakAll(a2, B2) {
  for (var i2 = 0; i2 < B2.length; ++i2) {
    if (!enclosesWeak(a2, B2[i2])) {
      return false;
    }
  }
  return true;
}
function encloseBasis(B2) {
  switch (B2.length) {
    case 1:
      return encloseBasis1(B2[0]);
    case 2:
      return encloseBasis2(B2[0], B2[1]);
    case 3:
      return encloseBasis3(B2[0], B2[1], B2[2]);
  }
}
function encloseBasis1(a2) {
  return {
    x: a2.x,
    y: a2.y,
    r: a2.r
  };
}
function encloseBasis2(a2, b10) {
  var x1 = a2.x, y1 = a2.y, r1 = a2.r, x2 = b10.x, y2 = b10.y, r2 = b10.r, x21 = x2 - x1, y21 = y2 - y1, r21 = r2 - r1, l2 = Math.sqrt(x21 * x21 + y21 * y21);
  return {
    x: (x1 + x2 + x21 / l2 * r21) / 2,
    y: (y1 + y2 + y21 / l2 * r21) / 2,
    r: (l2 + r1 + r2) / 2
  };
}
function encloseBasis3(a2, b10, c2) {
  var x1 = a2.x, y1 = a2.y, r1 = a2.r, x2 = b10.x, y2 = b10.y, r2 = b10.r, x3 = c2.x, y3 = c2.y, r3 = c2.r, a22 = x1 - x2, a3 = x1 - x3, b22 = y1 - y2, b32 = y1 - y3, c22 = r2 - r1, c3 = r3 - r1, d1 = x1 * x1 + y1 * y1 - r1 * r1, d2 = d1 - x2 * x2 - y2 * y2 + r2 * r2, d3 = d1 - x3 * x3 - y3 * y3 + r3 * r3, ab2 = a3 * b22 - a22 * b32, xa2 = (b22 * d3 - b32 * d2) / (ab2 * 2) - x1, xb2 = (b32 * c22 - b22 * c3) / ab2, ya2 = (a3 * d2 - a22 * d3) / (ab2 * 2) - y1, yb2 = (a22 * c3 - a3 * c22) / ab2, A2 = xb2 * xb2 + yb2 * yb2 - 1, B2 = 2 * (r1 + xa2 * xb2 + ya2 * yb2), C2 = xa2 * xa2 + ya2 * ya2 - r1 * r1, r4 = -(A2 ? (B2 + Math.sqrt(B2 * B2 - 4 * A2 * C2)) / (2 * A2) : C2 / B2);
  return {
    x: x1 + xa2 + xb2 * r4,
    y: y1 + ya2 + yb2 * r4,
    r: r4
  };
}
function place(b10, a2, c2) {
  var dx = b10.x - a2.x, x2, a22, dy = b10.y - a2.y, y2, b22, d2 = dx * dx + dy * dy;
  if (d2) {
    a22 = a2.r + c2.r, a22 *= a22;
    b22 = b10.r + c2.r, b22 *= b22;
    if (a22 > b22) {
      x2 = (d2 + b22 - a22) / (2 * d2);
      y2 = Math.sqrt(Math.max(0, b22 / d2 - x2 * x2));
      c2.x = b10.x - x2 * dx - y2 * dy;
      c2.y = b10.y - x2 * dy + y2 * dx;
    } else {
      x2 = (d2 + a22 - b22) / (2 * d2);
      y2 = Math.sqrt(Math.max(0, a22 / d2 - x2 * x2));
      c2.x = a2.x + x2 * dx - y2 * dy;
      c2.y = a2.y + x2 * dy + y2 * dx;
    }
  } else {
    c2.x = a2.x + c2.r;
    c2.y = a2.y;
  }
}
function intersects(a2, b10) {
  var dr = a2.r + b10.r - 1e-6, dx = b10.x - a2.x, dy = b10.y - a2.y;
  return dr > 0 && dr * dr > dx * dx + dy * dy;
}
function score(node) {
  var a2 = node._, b10 = node.next._, ab2 = a2.r + b10.r, dx = (a2.x * b10.r + b10.x * a2.r) / ab2, dy = (a2.y * b10.r + b10.y * a2.r) / ab2;
  return dx * dx + dy * dy;
}
function Node$1(circle2) {
  this._ = circle2;
  this.next = null;
  this.previous = null;
}
function packEnclose(circles) {
  if (!(n2 = (circles = array(circles)).length))
    return 0;
  var a2, b10, c2, n2, aa2, ca2, i2, j2, k2, sj2, sk2;
  a2 = circles[0], a2.x = 0, a2.y = 0;
  if (!(n2 > 1))
    return a2.r;
  b10 = circles[1], a2.x = -b10.r, b10.x = a2.r, b10.y = 0;
  if (!(n2 > 2))
    return a2.r + b10.r;
  place(b10, a2, c2 = circles[2]);
  a2 = new Node$1(a2), b10 = new Node$1(b10), c2 = new Node$1(c2);
  a2.next = c2.previous = b10;
  b10.next = a2.previous = c2;
  c2.next = b10.previous = a2;
  pack:
    for (i2 = 3; i2 < n2; ++i2) {
      place(a2._, b10._, c2 = circles[i2]), c2 = new Node$1(c2);
      j2 = b10.next, k2 = a2.previous, sj2 = b10._.r, sk2 = a2._.r;
      do {
        if (sj2 <= sk2) {
          if (intersects(j2._, c2._)) {
            b10 = j2, a2.next = b10, b10.previous = a2, --i2;
            continue pack;
          }
          sj2 += j2._.r, j2 = j2.next;
        } else {
          if (intersects(k2._, c2._)) {
            a2 = k2, a2.next = b10, b10.previous = a2, --i2;
            continue pack;
          }
          sk2 += k2._.r, k2 = k2.previous;
        }
      } while (j2 !== k2.next);
      c2.previous = a2, c2.next = b10, a2.next = b10.previous = b10 = c2;
      aa2 = score(a2);
      while ((c2 = c2.next) !== b10) {
        if ((ca2 = score(c2)) < aa2) {
          a2 = c2, aa2 = ca2;
        }
      }
      b10 = a2.next;
    }
  a2 = [b10._], c2 = b10;
  while ((c2 = c2.next) !== b10)
    a2.push(c2._);
  c2 = enclose(a2);
  for (i2 = 0; i2 < n2; ++i2)
    a2 = circles[i2], a2.x -= c2.x, a2.y -= c2.y;
  return c2.r;
}
function siblings(circles) {
  packEnclose(circles);
  return circles;
}
function optional(f2) {
  return f2 == null ? null : required(f2);
}
function required(f2) {
  if (typeof f2 !== "function")
    throw new Error();
  return f2;
}
function constantZero() {
  return 0;
}
function constant$1(x2) {
  return function() {
    return x2;
  };
}
function defaultRadius(d2) {
  return Math.sqrt(d2.value);
}
function index$b() {
  var radius = null, dx = 1, dy = 1, padding2 = constantZero;
  function pack2(root2) {
    root2.x = dx / 2, root2.y = dy / 2;
    if (radius) {
      root2.eachBefore(radiusLeaf(radius)).eachAfter(packChildren(padding2, 0.5)).eachBefore(translateChild(1));
    } else {
      root2.eachBefore(radiusLeaf(defaultRadius)).eachAfter(packChildren(constantZero, 1)).eachAfter(packChildren(padding2, root2.r / Math.min(dx, dy))).eachBefore(translateChild(Math.min(dx, dy) / (2 * root2.r)));
    }
    return root2;
  }
  pack2.radius = function(x2) {
    return arguments.length ? (radius = optional(x2), pack2) : radius;
  };
  pack2.size = function(x2) {
    return arguments.length ? (dx = +x2[0], dy = +x2[1], pack2) : [dx, dy];
  };
  pack2.padding = function(x2) {
    return arguments.length ? (padding2 = typeof x2 === "function" ? x2 : constant$1(+x2), pack2) : padding2;
  };
  return pack2;
}
function radiusLeaf(radius) {
  return function(node) {
    if (!node.children) {
      node.r = Math.max(0, +radius(node) || 0);
    }
  };
}
function packChildren(padding2, k2) {
  return function(node) {
    if (children = node.children) {
      var children, i2, n2 = children.length, r2 = padding2(node) * k2 || 0, e3;
      if (r2)
        for (i2 = 0; i2 < n2; ++i2)
          children[i2].r += r2;
      e3 = packEnclose(children);
      if (r2)
        for (i2 = 0; i2 < n2; ++i2)
          children[i2].r -= r2;
      node.r = e3 + r2;
    }
  };
}
function translateChild(k2) {
  return function(node) {
    var parent = node.parent;
    node.r *= k2;
    if (parent) {
      node.x = parent.x + k2 * node.x;
      node.y = parent.y + k2 * node.y;
    }
  };
}
function roundNode(node) {
  node.x0 = Math.round(node.x0);
  node.y0 = Math.round(node.y0);
  node.x1 = Math.round(node.x1);
  node.y1 = Math.round(node.y1);
}
function treemapDice(parent, x0, y0, x1, y1) {
  var nodes = parent.children, node, i2 = -1, n2 = nodes.length, k2 = parent.value && (x1 - x0) / parent.value;
  while (++i2 < n2) {
    node = nodes[i2], node.y0 = y0, node.y1 = y1;
    node.x0 = x0, node.x1 = x0 += node.value * k2;
  }
}
function partition$1() {
  var dx = 1, dy = 1, padding2 = 0, round2 = false;
  function partition2(root2) {
    var n2 = root2.height + 1;
    root2.x0 = root2.y0 = padding2;
    root2.x1 = dx;
    root2.y1 = dy / n2;
    root2.eachBefore(positionNode(dy, n2));
    if (round2)
      root2.eachBefore(roundNode);
    return root2;
  }
  function positionNode(dy2, n2) {
    return function(node) {
      if (node.children) {
        treemapDice(node, node.x0, dy2 * (node.depth + 1) / n2, node.x1, dy2 * (node.depth + 2) / n2);
      }
      var x0 = node.x0, y0 = node.y0, x1 = node.x1 - padding2, y1 = node.y1 - padding2;
      if (x1 < x0)
        x0 = x1 = (x0 + x1) / 2;
      if (y1 < y0)
        y0 = y1 = (y0 + y1) / 2;
      node.x0 = x0;
      node.y0 = y0;
      node.x1 = x1;
      node.y1 = y1;
    };
  }
  partition2.round = function(x2) {
    return arguments.length ? (round2 = !!x2, partition2) : round2;
  };
  partition2.size = function(x2) {
    return arguments.length ? (dx = +x2[0], dy = +x2[1], partition2) : [dx, dy];
  };
  partition2.padding = function(x2) {
    return arguments.length ? (padding2 = +x2, partition2) : padding2;
  };
  return partition2;
}
var preroot = { depth: -1 }, ambiguous = {};
function defaultId$1(d2) {
  return d2.id;
}
function defaultParentId(d2) {
  return d2.parentId;
}
function stratify() {
  var id2 = defaultId$1, parentId = defaultParentId;
  function stratify2(data2) {
    var nodes = Array.from(data2), n2 = nodes.length, d2, i2, root2, parent, node, nodeId, nodeKey, nodeByKey = /* @__PURE__ */ new Map();
    for (i2 = 0; i2 < n2; ++i2) {
      d2 = nodes[i2], node = nodes[i2] = new Node$2(d2);
      if ((nodeId = id2(d2, i2, data2)) != null && (nodeId += "")) {
        nodeKey = node.id = nodeId;
        nodeByKey.set(nodeKey, nodeByKey.has(nodeKey) ? ambiguous : node);
      }
      if ((nodeId = parentId(d2, i2, data2)) != null && (nodeId += "")) {
        node.parent = nodeId;
      }
    }
    for (i2 = 0; i2 < n2; ++i2) {
      node = nodes[i2];
      if (nodeId = node.parent) {
        parent = nodeByKey.get(nodeId);
        if (!parent)
          throw new Error("missing: " + nodeId);
        if (parent === ambiguous)
          throw new Error("ambiguous: " + nodeId);
        if (parent.children)
          parent.children.push(node);
        else
          parent.children = [node];
        node.parent = parent;
      } else {
        if (root2)
          throw new Error("multiple roots");
        root2 = node;
      }
    }
    if (!root2)
      throw new Error("no root");
    root2.parent = preroot;
    root2.eachBefore(function(node2) {
      node2.depth = node2.parent.depth + 1;
      --n2;
    }).eachBefore(computeHeight);
    root2.parent = null;
    if (n2 > 0)
      throw new Error("cycle");
    return root2;
  }
  stratify2.id = function(x2) {
    return arguments.length ? (id2 = required(x2), stratify2) : id2;
  };
  stratify2.parentId = function(x2) {
    return arguments.length ? (parentId = required(x2), stratify2) : parentId;
  };
  return stratify2;
}
function defaultSeparation(a2, b10) {
  return a2.parent === b10.parent ? 1 : 2;
}
function nextLeft(v2) {
  var children = v2.children;
  return children ? children[0] : v2.t;
}
function nextRight(v2) {
  var children = v2.children;
  return children ? children[children.length - 1] : v2.t;
}
function moveSubtree(wm, wp, shift) {
  var change = shift / (wp.i - wm.i);
  wp.c -= change;
  wp.s += shift;
  wm.c += change;
  wp.z += shift;
  wp.m += shift;
}
function executeShifts(v2) {
  var shift = 0, change = 0, children = v2.children, i2 = children.length, w2;
  while (--i2 >= 0) {
    w2 = children[i2];
    w2.z += shift;
    w2.m += shift;
    shift += w2.s + (change += w2.c);
  }
}
function nextAncestor(vim, v2, ancestor) {
  return vim.a.parent === v2.parent ? vim.a : ancestor;
}
function TreeNode(node, i2) {
  this._ = node;
  this.parent = null;
  this.children = null;
  this.A = null;
  this.a = this;
  this.z = 0;
  this.m = 0;
  this.c = 0;
  this.s = 0;
  this.t = null;
  this.i = i2;
}
TreeNode.prototype = Object.create(Node$2.prototype);
function treeRoot(root2) {
  var tree2 = new TreeNode(root2, 0), node, nodes = [tree2], child, children, i2, n2;
  while (node = nodes.pop()) {
    if (children = node._.children) {
      node.children = new Array(n2 = children.length);
      for (i2 = n2 - 1; i2 >= 0; --i2) {
        nodes.push(child = node.children[i2] = new TreeNode(children[i2], i2));
        child.parent = node;
      }
    }
  }
  (tree2.parent = new TreeNode(null, 0)).children = [tree2];
  return tree2;
}
function tree() {
  var separation = defaultSeparation, dx = 1, dy = 1, nodeSize = null;
  function tree2(root2) {
    var t2 = treeRoot(root2);
    t2.eachAfter(firstWalk), t2.parent.m = -t2.z;
    t2.eachBefore(secondWalk);
    if (nodeSize)
      root2.eachBefore(sizeNode);
    else {
      var left2 = root2, right2 = root2, bottom = root2;
      root2.eachBefore(function(node) {
        if (node.x < left2.x)
          left2 = node;
        if (node.x > right2.x)
          right2 = node;
        if (node.depth > bottom.depth)
          bottom = node;
      });
      var s2 = left2 === right2 ? 1 : separation(left2, right2) / 2, tx = s2 - left2.x, kx = dx / (right2.x + s2 + tx), ky = dy / (bottom.depth || 1);
      root2.eachBefore(function(node) {
        node.x = (node.x + tx) * kx;
        node.y = node.depth * ky;
      });
    }
    return root2;
  }
  function firstWalk(v2) {
    var children = v2.children, siblings2 = v2.parent.children, w2 = v2.i ? siblings2[v2.i - 1] : null;
    if (children) {
      executeShifts(v2);
      var midpoint2 = (children[0].z + children[children.length - 1].z) / 2;
      if (w2) {
        v2.z = w2.z + separation(v2._, w2._);
        v2.m = v2.z - midpoint2;
      } else {
        v2.z = midpoint2;
      }
    } else if (w2) {
      v2.z = w2.z + separation(v2._, w2._);
    }
    v2.parent.A = apportion(v2, w2, v2.parent.A || siblings2[0]);
  }
  function secondWalk(v2) {
    v2._.x = v2.z + v2.parent.m;
    v2.m += v2.parent.m;
  }
  function apportion(v2, w2, ancestor) {
    if (w2) {
      var vip = v2, vop = v2, vim = w2, vom = vip.parent.children[0], sip = vip.m, sop = vop.m, sim = vim.m, som = vom.m, shift;
      while (vim = nextRight(vim), vip = nextLeft(vip), vim && vip) {
        vom = nextLeft(vom);
        vop = nextRight(vop);
        vop.a = v2;
        shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);
        if (shift > 0) {
          moveSubtree(nextAncestor(vim, v2, ancestor), v2, shift);
          sip += shift;
          sop += shift;
        }
        sim += vim.m;
        sip += vip.m;
        som += vom.m;
        sop += vop.m;
      }
      if (vim && !nextRight(vop)) {
        vop.t = vim;
        vop.m += sim - sop;
      }
      if (vip && !nextLeft(vom)) {
        vom.t = vip;
        vom.m += sip - som;
        ancestor = v2;
      }
    }
    return ancestor;
  }
  function sizeNode(node) {
    node.x *= dx;
    node.y = node.depth * dy;
  }
  tree2.separation = function(x2) {
    return arguments.length ? (separation = x2, tree2) : separation;
  };
  tree2.size = function(x2) {
    return arguments.length ? (nodeSize = false, dx = +x2[0], dy = +x2[1], tree2) : nodeSize ? null : [dx, dy];
  };
  tree2.nodeSize = function(x2) {
    return arguments.length ? (nodeSize = true, dx = +x2[0], dy = +x2[1], tree2) : nodeSize ? [dx, dy] : null;
  };
  return tree2;
}
function treemapSlice(parent, x0, y0, x1, y1) {
  var nodes = parent.children, node, i2 = -1, n2 = nodes.length, k2 = parent.value && (y1 - y0) / parent.value;
  while (++i2 < n2) {
    node = nodes[i2], node.x0 = x0, node.x1 = x1;
    node.y0 = y0, node.y1 = y0 += node.value * k2;
  }
}
var phi = (1 + Math.sqrt(5)) / 2;
function squarifyRatio(ratio, parent, x0, y0, x1, y1) {
  var rows = [], nodes = parent.children, row, nodeValue, i0 = 0, i1 = 0, n2 = nodes.length, dx, dy, value2 = parent.value, sumValue, minValue, maxValue, newRatio, minRatio, alpha, beta;
  while (i0 < n2) {
    dx = x1 - x0, dy = y1 - y0;
    do
      sumValue = nodes[i1++].value;
    while (!sumValue && i1 < n2);
    minValue = maxValue = sumValue;
    alpha = Math.max(dy / dx, dx / dy) / (value2 * ratio);
    beta = sumValue * sumValue * alpha;
    minRatio = Math.max(maxValue / beta, beta / minValue);
    for (; i1 < n2; ++i1) {
      sumValue += nodeValue = nodes[i1].value;
      if (nodeValue < minValue)
        minValue = nodeValue;
      if (nodeValue > maxValue)
        maxValue = nodeValue;
      beta = sumValue * sumValue * alpha;
      newRatio = Math.max(maxValue / beta, beta / minValue);
      if (newRatio > minRatio) {
        sumValue -= nodeValue;
        break;
      }
      minRatio = newRatio;
    }
    rows.push(row = { value: sumValue, dice: dx < dy, children: nodes.slice(i0, i1) });
    if (row.dice)
      treemapDice(row, x0, y0, x1, value2 ? y0 += dy * sumValue / value2 : y1);
    else
      treemapSlice(row, x0, y0, value2 ? x0 += dx * sumValue / value2 : x1, y1);
    value2 -= sumValue, i0 = i1;
  }
  return rows;
}
var squarify = function custom10(ratio) {
  function squarify2(parent, x0, y0, x1, y1) {
    squarifyRatio(ratio, parent, x0, y0, x1, y1);
  }
  squarify2.ratio = function(x2) {
    return custom10((x2 = +x2) > 1 ? x2 : 1);
  };
  return squarify2;
}(phi);
function index$a() {
  var tile = squarify, round2 = false, dx = 1, dy = 1, paddingStack = [0], paddingInner = constantZero, paddingTop = constantZero, paddingRight = constantZero, paddingBottom = constantZero, paddingLeft = constantZero;
  function treemap2(root2) {
    root2.x0 = root2.y0 = 0;
    root2.x1 = dx;
    root2.y1 = dy;
    root2.eachBefore(positionNode);
    paddingStack = [0];
    if (round2)
      root2.eachBefore(roundNode);
    return root2;
  }
  function positionNode(node) {
    var p2 = paddingStack[node.depth], x0 = node.x0 + p2, y0 = node.y0 + p2, x1 = node.x1 - p2, y1 = node.y1 - p2;
    if (x1 < x0)
      x0 = x1 = (x0 + x1) / 2;
    if (y1 < y0)
      y0 = y1 = (y0 + y1) / 2;
    node.x0 = x0;
    node.y0 = y0;
    node.x1 = x1;
    node.y1 = y1;
    if (node.children) {
      p2 = paddingStack[node.depth + 1] = paddingInner(node) / 2;
      x0 += paddingLeft(node) - p2;
      y0 += paddingTop(node) - p2;
      x1 -= paddingRight(node) - p2;
      y1 -= paddingBottom(node) - p2;
      if (x1 < x0)
        x0 = x1 = (x0 + x1) / 2;
      if (y1 < y0)
        y0 = y1 = (y0 + y1) / 2;
      tile(node, x0, y0, x1, y1);
    }
  }
  treemap2.round = function(x2) {
    return arguments.length ? (round2 = !!x2, treemap2) : round2;
  };
  treemap2.size = function(x2) {
    return arguments.length ? (dx = +x2[0], dy = +x2[1], treemap2) : [dx, dy];
  };
  treemap2.tile = function(x2) {
    return arguments.length ? (tile = required(x2), treemap2) : tile;
  };
  treemap2.padding = function(x2) {
    return arguments.length ? treemap2.paddingInner(x2).paddingOuter(x2) : treemap2.paddingInner();
  };
  treemap2.paddingInner = function(x2) {
    return arguments.length ? (paddingInner = typeof x2 === "function" ? x2 : constant$1(+x2), treemap2) : paddingInner;
  };
  treemap2.paddingOuter = function(x2) {
    return arguments.length ? treemap2.paddingTop(x2).paddingRight(x2).paddingBottom(x2).paddingLeft(x2) : treemap2.paddingTop();
  };
  treemap2.paddingTop = function(x2) {
    return arguments.length ? (paddingTop = typeof x2 === "function" ? x2 : constant$1(+x2), treemap2) : paddingTop;
  };
  treemap2.paddingRight = function(x2) {
    return arguments.length ? (paddingRight = typeof x2 === "function" ? x2 : constant$1(+x2), treemap2) : paddingRight;
  };
  treemap2.paddingBottom = function(x2) {
    return arguments.length ? (paddingBottom = typeof x2 === "function" ? x2 : constant$1(+x2), treemap2) : paddingBottom;
  };
  treemap2.paddingLeft = function(x2) {
    return arguments.length ? (paddingLeft = typeof x2 === "function" ? x2 : constant$1(+x2), treemap2) : paddingLeft;
  };
  return treemap2;
}
function binary(parent, x0, y0, x1, y1) {
  var nodes = parent.children, i2, n2 = nodes.length, sum, sums = new Array(n2 + 1);
  for (sums[0] = sum = i2 = 0; i2 < n2; ++i2) {
    sums[i2 + 1] = sum += nodes[i2].value;
  }
  partition2(0, n2, parent.value, x0, y0, x1, y1);
  function partition2(i3, j2, value2, x02, y02, x12, y12) {
    if (i3 >= j2 - 1) {
      var node = nodes[i3];
      node.x0 = x02, node.y0 = y02;
      node.x1 = x12, node.y1 = y12;
      return;
    }
    var valueOffset = sums[i3], valueTarget = value2 / 2 + valueOffset, k2 = i3 + 1, hi2 = j2 - 1;
    while (k2 < hi2) {
      var mid2 = k2 + hi2 >>> 1;
      if (sums[mid2] < valueTarget)
        k2 = mid2 + 1;
      else
        hi2 = mid2;
    }
    if (valueTarget - sums[k2 - 1] < sums[k2] - valueTarget && i3 + 1 < k2)
      --k2;
    var valueLeft = sums[k2] - valueOffset, valueRight = value2 - valueLeft;
    if (x12 - x02 > y12 - y02) {
      var xk2 = value2 ? (x02 * valueRight + x12 * valueLeft) / value2 : x12;
      partition2(i3, k2, valueLeft, x02, y02, xk2, y12);
      partition2(k2, j2, valueRight, xk2, y02, x12, y12);
    } else {
      var yk2 = value2 ? (y02 * valueRight + y12 * valueLeft) / value2 : y12;
      partition2(i3, k2, valueLeft, x02, y02, x12, yk2);
      partition2(k2, j2, valueRight, x02, yk2, x12, y12);
    }
  }
}
function sliceDice(parent, x0, y0, x1, y1) {
  (parent.depth & 1 ? treemapSlice : treemapDice)(parent, x0, y0, x1, y1);
}
var resquarify = function custom11(ratio) {
  function resquarify2(parent, x0, y0, x1, y1) {
    if ((rows = parent._squarify) && rows.ratio === ratio) {
      var rows, row, nodes, i2, j2 = -1, n2, m2 = rows.length, value2 = parent.value;
      while (++j2 < m2) {
        row = rows[j2], nodes = row.children;
        for (i2 = row.value = 0, n2 = nodes.length; i2 < n2; ++i2)
          row.value += nodes[i2].value;
        if (row.dice)
          treemapDice(row, x0, y0, x1, value2 ? y0 += (y1 - y0) * row.value / value2 : y1);
        else
          treemapSlice(row, x0, y0, value2 ? x0 += (x1 - x0) * row.value / value2 : x1, y1);
        value2 -= row.value;
      }
    } else {
      parent._squarify = rows = squarifyRatio(ratio, parent, x0, y0, x1, y1);
      rows.ratio = ratio;
    }
  }
  resquarify2.ratio = function(x2) {
    return custom11((x2 = +x2) > 1 ? x2 : 1);
  };
  return resquarify2;
}(phi);
var d3Hierarchy = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  cluster,
  hierarchy,
  pack: index$b,
  packSiblings: siblings,
  packEnclose: enclose,
  partition: partition$1,
  stratify,
  tree,
  treemap: index$a,
  treemapBinary: binary,
  treemapDice,
  treemapSlice,
  treemapSliceDice: sliceDice,
  treemapSquarify: squarify,
  treemapResquarify: resquarify
}, Symbol.toStringTag, { value: "Module" }));
var DEFAULT_OPTIONS$b = {
  field: "value",
  size: [1, 1],
  round: false,
  padding: 0,
  sort: function(a2, b10) {
    return b10.value - a2.value;
  },
  as: ["x", "y"],
  ignoreParentValue: true
};
function partition(data2, options) {
  options = mix({}, DEFAULT_OPTIONS$b, options);
  var as = options.as;
  if (!isArray$1(as) || as.length !== 2) {
    throw new TypeError('Invalid as: it must be an array with 2 strings (e.g. [ "x", "y" ])!');
  }
  var field2;
  try {
    field2 = getField(options);
  } catch (e3) {
    console.warn(e3);
  }
  var partition2 = function(data3) {
    return partition$1().size(options.size).round(options.round).padding(options.padding)(
      hierarchy(data3).sum(function(d2) {
        return size(d2.children) ? options.ignoreParentValue ? 0 : d2[field2] - reduce(d2.children, function(a2, b10) {
          return a2 + b10[field2];
        }, 0) : d2[field2];
      }).sort(options.sort)
    );
  };
  var root2 = partition2(data2);
  var x2 = as[0];
  var y2 = as[1];
  root2.each(function(node) {
    var _a2, _b;
    node[x2] = [node.x0, node.x1, node.x1, node.x0];
    node[y2] = [node.y1, node.y1, node.y0, node.y0];
    node.name = node.name || ((_a2 = node.data) === null || _a2 === void 0 ? void 0 : _a2.name) || ((_b = node.data) === null || _b === void 0 ? void 0 : _b.label);
    node.data.name = node.name;
    ["x0", "x1", "y0", "y1"].forEach(function(prop) {
      if (as.indexOf(prop) === -1) {
        delete node[prop];
      }
    });
  });
  return getAllNodes(root2);
}
var DEFAULT_OPTIONS$a = {
  field: "value",
  tile: "treemapSquarify",
  size: [1, 1],
  round: false,
  ignoreParentValue: true,
  padding: 0,
  paddingInner: 0,
  paddingOuter: 0,
  paddingTop: 0,
  paddingRight: 0,
  paddingBottom: 0,
  paddingLeft: 0,
  as: ["x", "y"],
  sort: function(a2, b10) {
    return b10.value - a2.value;
  },
  ratio: 0.5 * (1 + Math.sqrt(5))
};
function getTileMethod(tile, ratio) {
  return tile === "treemapSquarify" ? d3Hierarchy[tile].ratio(ratio) : d3Hierarchy[tile];
}
function treemap(data2, options) {
  options = mix({}, DEFAULT_OPTIONS$a, options);
  var as = options.as;
  if (!isArray$1(as) || as.length !== 2) {
    throw new TypeError('Invalid as: it must be an array with 2 strings (e.g. [ "x", "y" ])!');
  }
  var field2;
  try {
    field2 = getField(options);
  } catch (e3) {
    console.warn(e3);
  }
  var tileMethod = getTileMethod(options.tile, options.ratio);
  var partition2 = function(data3) {
    return index$a().tile(tileMethod).size(options.size).round(options.round).padding(options.padding).paddingInner(options.paddingInner).paddingOuter(options.paddingOuter).paddingTop(options.paddingTop).paddingRight(options.paddingRight).paddingBottom(options.paddingBottom).paddingLeft(options.paddingLeft)(
      hierarchy(data3).sum(function(d2) {
        return options.ignoreParentValue && d2.children ? 0 : d2[field2];
      }).sort(options.sort)
    );
  };
  var root2 = partition2(data2);
  var x2 = as[0];
  var y2 = as[1];
  root2.each(function(node) {
    node[x2] = [node.x0, node.x1, node.x1, node.x0];
    node[y2] = [node.y1, node.y1, node.y0, node.y0];
    ["x0", "x1", "y0", "y1"].forEach(function(prop) {
      if (as.indexOf(prop) === -1) {
        delete node[prop];
      }
    });
  });
  return getAllNodes(root2);
}
function transformData$5(options) {
  var data2 = options.data, colorField = options.colorField, rawFields = options.rawFields, _a2 = options.hierarchyConfig, hierarchyConfig = _a2 === void 0 ? {} : _a2;
  var activeDepth = hierarchyConfig.activeDepth;
  var transform2 = {
    partition,
    treemap
  };
  var seriesField = options.seriesField;
  var type4 = options.type || "partition";
  var nodes = transform2[type4](data2, __assign$4(__assign$4({ field: seriesField || "value" }, omit$1(hierarchyConfig, ["activeDepth"])), {
    type: "hierarchy." + type4,
    as: ["x", "y"]
  }));
  var result = [];
  nodes.forEach(function(node) {
    var _a3;
    var _b, _c, _d, _e, _f;
    if (node.depth === 0) {
      return null;
    }
    if (activeDepth > 0 && node.depth > activeDepth) {
      return null;
    }
    var path2 = node.data.name;
    var ancestorNode = __assign$4({}, node);
    while (ancestorNode.depth > 1) {
      path2 = ((_b = ancestorNode.parent.data) === null || _b === void 0 ? void 0 : _b.name) + " / " + path2;
      ancestorNode = ancestorNode.parent;
    }
    var nodeInfo = __assign$4(__assign$4(__assign$4({}, pick(node.data, __spreadArrays(rawFields || [], [hierarchyConfig.field]))), (_a3 = {}, _a3[SUNBURST_PATH_FIELD] = path2, _a3[SUNBURST_ANCESTOR_FIELD] = ancestorNode.data.name, _a3)), node);
    if (seriesField) {
      nodeInfo[seriesField] = node.data[seriesField] || ((_d = (_c = node.parent) === null || _c === void 0 ? void 0 : _c.data) === null || _d === void 0 ? void 0 : _d[seriesField]);
    }
    if (colorField) {
      nodeInfo[colorField] = node.data[colorField] || ((_f = (_e = node.parent) === null || _e === void 0 ? void 0 : _e.data) === null || _f === void 0 ? void 0 : _f[colorField]);
    }
    nodeInfo.ext = hierarchyConfig;
    nodeInfo[HIERARCHY_DATA_TRANSFORM_PARAMS] = { hierarchyConfig, colorField, rawFields };
    result.push(nodeInfo);
  });
  return result;
}
function geometry$7(params) {
  var chart = params.chart, options = params.options;
  var color2 = options.color, _a2 = options.colorField, colorField = _a2 === void 0 ? SUNBURST_ANCESTOR_FIELD : _a2, sunburstStyle = options.sunburstStyle, _b = options.rawFields, rawFields = _b === void 0 ? [] : _b;
  var data2 = transformData$5(options);
  chart.data(data2);
  var style2;
  if (sunburstStyle) {
    style2 = function(datum) {
      return deepAssign({}, {
        fillOpacity: Math.pow(0.85, datum.depth)
      }, isFunction(sunburstStyle) ? sunburstStyle(datum) : sunburstStyle);
    };
  }
  polygon(deepAssign({}, params, {
    options: {
      xField: "x",
      yField: "y",
      seriesField: colorField,
      rawFields: uniq$2(__spreadArrays(RAW_FIELDS$1, rawFields)),
      polygon: {
        color: color2,
        style: style2
      }
    }
  }));
  return params;
}
function axis$6(params) {
  var chart = params.chart;
  chart.axis(false);
  return params;
}
function label$3(params) {
  var chart = params.chart, options = params.options;
  var label2 = options.label;
  var geometry2 = findGeometry(chart, "polygon");
  if (!label2) {
    geometry2.label(false);
  } else {
    var _a2 = label2.fields, fields = _a2 === void 0 ? ["name"] : _a2, callback = label2.callback, cfg = __rest$3(label2, ["fields", "callback"]);
    geometry2.label({
      fields,
      callback,
      cfg: transformLabel(cfg)
    });
  }
  return params;
}
function coordinate$2(params) {
  var chart = params.chart, options = params.options;
  var innerRadius = options.innerRadius, radius = options.radius, reflect = options.reflect;
  var coord2 = chart.coordinate({
    type: "polar",
    cfg: {
      innerRadius,
      radius
    }
  });
  if (reflect) {
    coord2.reflect(reflect);
  }
  return params;
}
function meta$5(params) {
  var _a2;
  var options = params.options;
  var hierarchyConfig = options.hierarchyConfig, meta2 = options.meta;
  return flow(scale$2({}, (_a2 = {}, _a2[SUNBURST_Y_FIELD] = get(meta2, get(hierarchyConfig, ["field"], "value")), _a2)))(params);
}
function tooltip$4(params) {
  var chart = params.chart, options = params.options;
  var tooltip2 = options.tooltip;
  if (tooltip2 === false) {
    chart.tooltip(false);
  } else {
    var tooltipOptions = tooltip2;
    if (!get(tooltip2, "fields")) {
      tooltipOptions = deepAssign({}, {
        customItems: function(items) {
          return items.map(function(item) {
            var scales = get(chart.getOptions(), "scales");
            var pathFormatter = get(scales, [SUNBURST_PATH_FIELD, "formatter"], function(v2) {
              return v2;
            });
            var valueFormatter = get(scales, [SUNBURST_Y_FIELD, "formatter"], function(v2) {
              return v2;
            });
            return __assign$4(__assign$4({}, item), { name: pathFormatter(item.data[SUNBURST_PATH_FIELD]), value: valueFormatter(item.data.value) });
          });
        }
      }, tooltipOptions);
    }
    chart.tooltip(tooltipOptions);
  }
  return params;
}
function adaptorInteraction$2(options) {
  var drilldown = options.drilldown, _a2 = options.interactions, interactions = _a2 === void 0 ? [] : _a2;
  if (drilldown === null || drilldown === void 0 ? void 0 : drilldown.enabled) {
    return deepAssign({}, options, {
      interactions: __spreadArrays(interactions, [
        {
          type: "drill-down",
          cfg: { drillDownConfig: drilldown, transformData: transformData$5 }
        }
      ])
    });
  }
  return options;
}
function interaction$4(params) {
  var chart = params.chart, options = params.options;
  var drilldown = options.drilldown;
  interaction$7({
    chart,
    options: adaptorInteraction$2(options)
  });
  if (drilldown === null || drilldown === void 0 ? void 0 : drilldown.enabled) {
    chart.appendPadding = getAdjustAppendPadding(chart.appendPadding, get(drilldown, ["breadCrumb", "position"]));
  }
  return params;
}
function adaptor$a(params) {
  return flow(theme$2, pattern("sunburstStyle"), geometry$7, axis$6, meta$5, legend$g, coordinate$2, tooltip$4, label$3, interaction$4, animation$5, annotation$2())(params);
}
function isParentNode(context2) {
  var data2 = get(context2, ["event", "data", "data"], {});
  return isArray$1(data2.children) && data2.children.length > 0;
}
function inCenter(context2) {
  var coordinate2 = context2.view.getCoordinate();
  var innerRadius = coordinate2.innerRadius;
  if (innerRadius) {
    var _a2 = context2.event, x2 = _a2.x, y2 = _a2.y;
    var _b = coordinate2.center, centerX = _b.x, centerY = _b.y;
    var r2 = coordinate2.getRadius() * innerRadius;
    var distance2 = Math.sqrt(Math.pow(centerX - x2, 2) + Math.pow(centerY - y2, 2));
    return distance2 < r2;
  }
  return false;
}
registerAction("drill-down-action", DrillDownAction);
registerInteraction("drill-down", {
  showEnable: [
    { trigger: "element:mouseenter", action: "cursor:pointer", isEnable: isParentNode },
    { trigger: "element:mouseleave", action: "cursor:default" },
    { trigger: "element:mouseleave", action: "cursor:pointer", isEnable: inCenter }
  ],
  start: [
    {
      trigger: "element:click",
      isEnable: isParentNode,
      action: ["drill-down-action:click"]
    },
    {
      trigger: "afterchangesize",
      action: ["drill-down-action:resetPosition"]
    },
    {
      trigger: "click",
      isEnable: inCenter,
      action: ["drill-down-action:back"]
    }
  ]
});
(function(_super) {
  __extends$3(Sunburst, _super);
  function Sunburst() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "sunburst";
    return _this;
  }
  Sunburst.getDefaultOptions = function() {
    return DEFAULT_OPTIONS$c;
  };
  Sunburst.prototype.getDefaultOptions = function() {
    return Sunburst.getDefaultOptions();
  };
  Sunburst.prototype.getSchemaAdaptor = function() {
    return adaptor$a;
  };
  Sunburst.SUNBURST_ANCESTOR_FIELD = SUNBURST_ANCESTOR_FIELD;
  Sunburst.SUNBURST_PATH_FIELD = SUNBURST_PATH_FIELD;
  Sunburst.NODE_ANCESTORS_FIELD = NODE_ANCESTORS_FIELD;
  return Sunburst;
})(Plot);
var _a;
var RANGE_VALUE = "range";
var RANGE_TYPE = "type";
var PERCENT = "percent";
var DEFAULT_COLOR = "#f0f0f0";
var INDICATEOR_VIEW_ID = "indicator-view";
var RANGE_VIEW_ID = "range-view";
var DEFAULT_OPTIONS$9 = {
  percent: 0,
  range: {
    ticks: []
  },
  innerRadius: 0.9,
  radius: 0.95,
  startAngle: -7 / 6 * Math.PI,
  endAngle: 1 / 6 * Math.PI,
  syncViewPadding: true,
  axis: {
    line: null,
    label: {
      offset: -24,
      style: {
        textAlign: "center",
        textBaseline: "middle"
      }
    },
    subTickLine: {
      length: -8
    },
    tickLine: {
      length: -12
    },
    grid: null
  },
  indicator: {
    pointer: {
      style: {
        lineWidth: 5,
        lineCap: "round"
      }
    },
    pin: {
      style: {
        r: 9.75,
        lineWidth: 4.5,
        fill: "#fff"
      }
    }
  },
  statistic: {
    title: false
  },
  meta: (_a = {}, _a[RANGE_VALUE] = {
    sync: "v"
  }, _a[PERCENT] = {
    sync: "v",
    tickCount: 5,
    tickInterval: 0.2
  }, _a),
  animation: false
};
function processRangeData(range3, percent2) {
  return range3.map(function(r2, idx) {
    var _a2;
    return _a2 = {}, _a2[RANGE_VALUE] = r2 - (range3[idx - 1] || 0), _a2[RANGE_TYPE] = "" + idx, _a2[PERCENT] = percent2, _a2;
  }).filter(function(d2) {
    return !!d2[RANGE_VALUE];
  });
}
function getIndicatorData(percent2) {
  var _a2;
  return [(_a2 = {}, _a2[PERCENT] = clamp(percent2, 0, 1), _a2)];
}
function getRangeData(percent2, range3) {
  var ticks = get(range3, ["ticks"], []);
  var clampTicks = size(ticks) ? ticks : [0, clamp(percent2, 0, 1), 1];
  return processRangeData(clampTicks, percent2);
}
function geometry$6(params) {
  var chart = params.chart, options = params.options;
  var percent2 = options.percent, range3 = options.range, radius = options.radius, innerRadius = options.innerRadius, startAngle = options.startAngle, endAngle = options.endAngle, axis2 = options.axis, indicator = options.indicator, gaugeStyle = options.gaugeStyle, type4 = options.type, meter = options.meter;
  var color2 = range3.color, rangeWidth = range3.width;
  if (indicator) {
    var indicatorData = getIndicatorData(percent2);
    var v1 = chart.createView({ id: INDICATEOR_VIEW_ID });
    v1.data(indicatorData);
    v1.point().position(PERCENT + "*1").shape(indicator.shape || "gauge-indicator").customInfo({
      defaultColor: chart.getTheme().defaultColor,
      indicator
    });
    v1.coordinate("polar", {
      startAngle,
      endAngle,
      radius: innerRadius * radius
    });
    v1.axis(PERCENT, axis2);
    v1.scale(PERCENT, pick(axis2, AXIS_META_CONFIG_KEYS));
  }
  var rangeData = getRangeData(percent2, options.range);
  var v2 = chart.createView({ id: RANGE_VIEW_ID });
  v2.data(rangeData);
  var rangeColor = isString(color2) ? [color2, DEFAULT_COLOR] : color2;
  var ext = interval({
    chart: v2,
    options: {
      xField: "1",
      yField: RANGE_VALUE,
      seriesField: RANGE_TYPE,
      rawFields: [PERCENT],
      isStack: true,
      interval: {
        color: rangeColor,
        style: gaugeStyle,
        shape: type4 === "meter" ? "meter-gauge" : null
      },
      args: {
        zIndexReversed: true,
        sortZIndex: true
      },
      minColumnWidth: rangeWidth,
      maxColumnWidth: rangeWidth
    }
  }).ext;
  var geometry2 = ext.geometry;
  geometry2.customInfo({ meter });
  v2.coordinate("polar", {
    innerRadius,
    radius,
    startAngle,
    endAngle
  }).transpose();
  return params;
}
function meta$4(params) {
  var _a2;
  return flow(scale$2((_a2 = {
    range: {
      min: 0,
      max: 1,
      maxLimit: 1,
      minLimit: 0
    }
  }, _a2[PERCENT] = {}, _a2)))(params);
}
function statistic(params, updated) {
  var chart = params.chart, options = params.options;
  var statistic2 = options.statistic, percent2 = options.percent;
  chart.getController("annotation").clear(true);
  if (statistic2) {
    var contentOption = statistic2.content;
    var transformContent = void 0;
    if (contentOption) {
      transformContent = deepAssign({}, {
        content: (percent2 * 100).toFixed(2) + "%",
        style: {
          opacity: 0.75,
          fontSize: "30px",
          lineHeight: 1,
          textAlign: "center",
          color: "rgba(44,53,66,0.85)"
        }
      }, contentOption);
    }
    renderGaugeStatistic(chart, { statistic: __assign$4(__assign$4({}, statistic2), { content: transformContent }) }, { percent: percent2 });
  }
  if (updated) {
    chart.render(true);
  }
  return params;
}
function tooltip$3(params) {
  var chart = params.chart, options = params.options;
  var tooltip2 = options.tooltip;
  if (tooltip2) {
    chart.tooltip(deepAssign({
      showTitle: false,
      showMarkers: false,
      containerTpl: '<div class="g2-tooltip"><div class="g2-tooltip-list"></div></div>',
      domStyles: {
        "g2-tooltip": {
          padding: "4px 8px",
          fontSize: "10px"
        }
      },
      customContent: function(x2, data2) {
        var percent2 = get(data2, [0, "data", PERCENT], 0);
        return (percent2 * 100).toFixed(2) + "%";
      }
    }, tooltip2));
  } else {
    chart.tooltip(false);
  }
  return params;
}
function other(params) {
  var chart = params.chart;
  chart.legend(false);
  return params;
}
function adaptor$9(params) {
  return flow(
    theme$2,
    animation$5,
    geometry$6,
    meta$4,
    tooltip$3,
    statistic,
    interaction$7,
    annotation$2(),
    other
  )(params);
}
registerShape("point", "gauge-indicator", {
  draw: function(cfg, container) {
    var _a2 = cfg.customInfo, indicator = _a2.indicator, defaultColor = _a2.defaultColor;
    var _b = indicator, pointer = _b.pointer, pin2 = _b.pin;
    var group2 = container.addGroup();
    var center2 = this.parsePoint({ x: 0, y: 0 });
    if (pointer) {
      group2.addShape("line", {
        name: "pointer",
        attrs: __assign$4({ x1: center2.x, y1: center2.y, x2: cfg.x, y2: cfg.y, stroke: defaultColor }, pointer.style)
      });
    }
    if (pin2) {
      group2.addShape("circle", {
        name: "pin",
        attrs: __assign$4({ x: center2.x, y: center2.y, stroke: defaultColor }, pin2.style)
      });
    }
    return group2;
  }
});
registerShape("interval", "meter-gauge", {
  draw: function(cfg, container) {
    var _a2 = cfg.customInfo.meter, meter = _a2 === void 0 ? {} : _a2;
    var _b = meter.steps, STEP = _b === void 0 ? 50 : _b, _c = meter.stepRatio, STEP_RATIO = _c === void 0 ? 0.5 : _c;
    STEP = STEP < 1 ? 1 : STEP;
    STEP_RATIO = clamp(STEP_RATIO, 0, 1);
    var _d = this.coordinate, COORD_START_ANGLE = _d.startAngle, COORD_END_ANGLE = _d.endAngle;
    var GAP2 = 0;
    if (STEP_RATIO > 0 && STEP_RATIO < 1) {
      var TOTAL = COORD_END_ANGLE - COORD_START_ANGLE;
      GAP2 = TOTAL / STEP / (STEP_RATIO / (1 - STEP_RATIO) + 1 - 1 / STEP);
    }
    var INTERVAL = GAP2 / (1 - STEP_RATIO) * STEP_RATIO;
    var group2 = container.addGroup();
    var center2 = this.coordinate.getCenter();
    var radius = this.coordinate.getRadius();
    var _e = Util.getAngle(cfg, this.coordinate), START_ANGLE = _e.startAngle, END_ANGLE = _e.endAngle;
    for (var startAngle = START_ANGLE; startAngle < END_ANGLE; ) {
      var endAngle = void 0;
      var r2 = (startAngle - COORD_START_ANGLE) % (INTERVAL + GAP2);
      if (r2 < INTERVAL) {
        endAngle = startAngle + (INTERVAL - r2);
      } else {
        startAngle += INTERVAL + GAP2 - r2;
        endAngle = startAngle + INTERVAL;
      }
      var path2 = Util.getSectorPath(center2.x, center2.y, radius, startAngle, Math.min(endAngle, END_ANGLE), radius * this.coordinate.innerRadius);
      group2.addShape("path", {
        name: "meter-gauge",
        attrs: {
          path: path2,
          fill: cfg.color,
          stroke: cfg.color,
          lineWidth: 0.5
        }
      });
      startAngle = endAngle + GAP2;
    }
    return group2;
  }
});
var Gauge = function(_super) {
  __extends$3(Gauge2, _super);
  function Gauge2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "gauge";
    return _this;
  }
  Gauge2.getDefaultOptions = function() {
    return DEFAULT_OPTIONS$9;
  };
  Gauge2.prototype.changeData = function(percent2) {
    this.chart.emit(VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, Event.fromData(this.chart, VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, null));
    this.updateOption({ percent: percent2 });
    var indicatorView = this.chart.views.find(function(v2) {
      return v2.id === INDICATEOR_VIEW_ID;
    });
    if (indicatorView) {
      indicatorView.data(getIndicatorData(percent2));
    }
    var rangeView = this.chart.views.find(function(v2) {
      return v2.id === RANGE_VIEW_ID;
    });
    if (rangeView) {
      rangeView.data(getRangeData(percent2, this.options.range));
    }
    statistic({ chart: this.chart, options: this.options }, true);
    this.chart.emit(VIEW_LIFE_CIRCLE.AFTER_CHANGE_DATA, Event.fromData(this.chart, VIEW_LIFE_CIRCLE.AFTER_CHANGE_DATA, null));
  };
  Gauge2.prototype.getDefaultOptions = function() {
    return Gauge2.getDefaultOptions();
  };
  Gauge2.prototype.getSchemaAdaptor = function() {
    return adaptor$9;
  };
  return Gauge2;
}(Plot);
var Y_FIELD$2 = "$$yField$$";
var DIFF_FIELD = "$$diffField$$";
var ABSOLUTE_FIELD = "$$absoluteField$$";
var IS_TOTAL = "$$isTotal$$";
var DEFAULT_OPTIONS$8 = {
  label: {},
  leaderLine: {
    style: {
      lineWidth: 1,
      stroke: "#8c8c8c",
      lineDash: [4, 2]
    }
  },
  total: {
    style: {
      fill: "rgba(0, 0, 0, 0.25)"
    }
  },
  interactions: [{ type: "element-active" }],
  risingFill: "#f4664a",
  fallingFill: "#30bf78",
  waterfallStyle: {
    fill: "rgba(0, 0, 0, 0.25)"
  },
  yAxis: {
    grid: {
      line: {
        style: {
          lineDash: [4, 2]
        }
      }
    }
  }
};
function processData(data2, xField, yField, newYField, total) {
  var _a2;
  var newData = [];
  reduce(data2, function(r2, d2) {
    var _a3;
    log(LEVEL.WARN, isNumber$1(d2[yField]), d2[yField] + " is not a valid number");
    var value2 = isUndefined(d2[yField]) ? null : d2[yField];
    newData.push(__assign$4(__assign$4({}, d2), (_a3 = {}, _a3[newYField] = [r2, r2 + value2], _a3)));
    return r2 + value2;
  }, 0);
  if (newData.length && total) {
    var sum = get(newData, [[data2.length - 1], newYField, [1]]);
    newData.push((_a2 = {}, _a2[xField] = total.label, _a2[yField] = sum, _a2[newYField] = [0, sum], _a2));
  }
  return newData;
}
function transformData$4(data2, xField, yField, total) {
  var processed = processData(data2, xField, yField, Y_FIELD$2, total);
  return processed.map(function(d2, dIdx) {
    var _a2;
    if (!isObject(d2)) {
      return d2;
    }
    return __assign$4(__assign$4({}, d2), (_a2 = {}, _a2[ABSOLUTE_FIELD] = d2[Y_FIELD$2][1], _a2[DIFF_FIELD] = d2[Y_FIELD$2][1] - d2[Y_FIELD$2][0], _a2[IS_TOTAL] = dIdx === data2.length, _a2));
  });
}
function getRectPath(points2) {
  var path2 = [];
  for (var i2 = 0; i2 < points2.length; i2++) {
    var point2 = points2[i2];
    if (point2) {
      var action = i2 === 0 ? "M" : "L";
      path2.push([action, point2.x, point2.y]);
    }
  }
  var first = points2[0];
  path2.push(["L", first.x, first.y]);
  path2.push(["z"]);
  return path2;
}
function getFillAttrs(cfg) {
  return deepAssign({}, cfg.defaultStyle, cfg.style, { fill: cfg.color });
}
registerShape("interval", "waterfall", {
  draw: function(cfg, container) {
    var customInfo = cfg.customInfo, points2 = cfg.points, nextPoints = cfg.nextPoints;
    var group2 = container.addGroup();
    var rectPath2 = this.parsePath(getRectPath(points2));
    var fillAttrs = getFillAttrs(cfg);
    group2.addShape("path", {
      attrs: __assign$4(__assign$4({}, fillAttrs), { path: rectPath2 })
    });
    var leaderLineCfg = get(customInfo, "leaderLine");
    if (leaderLineCfg && nextPoints) {
      var linkPath = [
        ["M", points2[2].x, points2[2].y],
        ["L", nextPoints[0].x, nextPoints[0].y]
      ];
      if (points2[2].y === nextPoints[1].y) {
        linkPath[1] = ["L", nextPoints[1].x, nextPoints[1].y];
      }
      linkPath = this.parsePath(linkPath);
      group2.addShape("path", {
        attrs: __assign$4({ path: linkPath }, leaderLineCfg.style || {})
      });
    }
    return group2;
  }
});
function defaultOptions$3(params) {
  var _a2 = params.options, locale2 = _a2.locale, total = _a2.total;
  var localeTotalLabel = getLocale(locale2).get(["waterfall", "total"]);
  if (total && typeof total.label !== "string" && localeTotalLabel) {
    params.options.total.label = localeTotalLabel;
  }
  return params;
}
function geometry$5(params) {
  var chart = params.chart, options = params.options;
  var data2 = options.data, xField = options.xField, yField = options.yField, total = options.total, leaderLine = options.leaderLine, columnWidthRatio = options.columnWidthRatio, waterfallStyle = options.waterfallStyle, risingFill = options.risingFill, fallingFill = options.fallingFill, color2 = options.color;
  chart.data(transformData$4(data2, xField, yField, total));
  var colorMapping = color2 || function(datum) {
    if (get(datum, [IS_TOTAL])) {
      return get(total, ["style", "fill"], "");
    }
    return get(datum, [Y_FIELD$2, 1]) - get(datum, [Y_FIELD$2, 0]) > 0 ? risingFill : fallingFill;
  };
  var p2 = deepAssign({}, params, {
    options: {
      xField,
      yField: Y_FIELD$2,
      seriesField: xField,
      rawFields: [yField, DIFF_FIELD, IS_TOTAL, Y_FIELD$2],
      widthRatio: columnWidthRatio,
      interval: {
        style: waterfallStyle,
        shape: "waterfall",
        color: colorMapping
      }
    }
  });
  var ext = interval(p2).ext;
  var geometry2 = ext.geometry;
  geometry2.customInfo({ leaderLine });
  return params;
}
function meta$3(params) {
  var _a2, _b;
  var options = params.options;
  var xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField, yField = options.yField, meta2 = options.meta;
  var Y_FIELD_META = deepAssign({}, { alias: yField }, get(meta2, yField));
  return flow(scale$2((_a2 = {}, _a2[xField] = xAxis, _a2[yField] = yAxis, _a2[Y_FIELD$2] = yAxis, _a2), deepAssign({}, meta2, (_b = {}, _b[Y_FIELD$2] = Y_FIELD_META, _b[DIFF_FIELD] = Y_FIELD_META, _b[ABSOLUTE_FIELD] = Y_FIELD_META, _b))))(params);
}
function axis$5(params) {
  var chart = params.chart, options = params.options;
  var xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField, yField = options.yField;
  if (xAxis === false) {
    chart.axis(xField, false);
  } else {
    chart.axis(xField, xAxis);
  }
  if (yAxis === false) {
    chart.axis(yField, false);
    chart.axis(Y_FIELD$2, false);
  } else {
    chart.axis(yField, yAxis);
    chart.axis(Y_FIELD$2, yAxis);
  }
  return params;
}
function legend$1(params) {
  var chart = params.chart, options = params.options;
  var legend2 = options.legend, total = options.total, risingFill = options.risingFill, fallingFill = options.fallingFill, locale2 = options.locale;
  var i18n = getLocale(locale2);
  if (legend2 === false) {
    chart.legend(false);
  } else {
    var items = [
      {
        name: i18n.get(["general", "increase"]),
        value: "increase",
        marker: { symbol: "square", style: { r: 5, fill: risingFill } }
      },
      {
        name: i18n.get(["general", "decrease"]),
        value: "decrease",
        marker: { symbol: "square", style: { r: 5, fill: fallingFill } }
      }
    ];
    if (total) {
      items.push({
        name: total.label || "",
        value: "total",
        marker: {
          symbol: "square",
          style: deepAssign({}, { r: 5 }, get(total, "style"))
        }
      });
    }
    chart.legend(deepAssign({}, {
      custom: true,
      position: "top",
      items
    }, legend2));
    chart.removeInteraction("legend-filter");
  }
  return params;
}
function label$2(params) {
  var chart = params.chart, options = params.options;
  var label2 = options.label, labelMode = options.labelMode, xField = options.xField;
  var geometry2 = findGeometry(chart, "interval");
  if (!label2) {
    geometry2.label(false);
  } else {
    var callback = label2.callback, cfg = __rest$3(label2, ["callback"]);
    geometry2.label({
      fields: labelMode === "absolute" ? [ABSOLUTE_FIELD, xField] : [DIFF_FIELD, xField],
      callback,
      cfg: transformLabel(cfg)
    });
  }
  return params;
}
function tooltip$2(params) {
  var chart = params.chart, options = params.options;
  var tooltip2 = options.tooltip, xField = options.xField, yField = options.yField;
  if (tooltip2 !== false) {
    chart.tooltip(__assign$4({
      showCrosshairs: false,
      showMarkers: false,
      shared: true,
      fields: [yField]
    }, tooltip2));
    var geometry_1 = chart.geometries[0];
    (tooltip2 === null || tooltip2 === void 0 ? void 0 : tooltip2.formatter) ? geometry_1.tooltip(xField + "*" + yField, tooltip2.formatter) : geometry_1.tooltip(yField);
  } else {
    chart.tooltip(false);
  }
  return params;
}
function adaptor$8(params) {
  return flow(defaultOptions$3, theme$2, geometry$5, meta$3, axis$5, legend$1, tooltip$2, label$2, state, interaction$7, animation$5, annotation$2())(params);
}
(function(_super) {
  __extends$3(Waterfall, _super);
  function Waterfall() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "waterfall";
    return _this;
  }
  Waterfall.getDefaultOptions = function() {
    return DEFAULT_OPTIONS$8;
  };
  Waterfall.prototype.changeData = function(data2) {
    var _a2 = this.options, xField = _a2.xField, yField = _a2.yField, total = _a2.total;
    this.updateOption({ data: data2 });
    this.chart.changeData(transformData$4(data2, xField, yField, total));
  };
  Waterfall.prototype.getSchemaAdaptor = function() {
    return adaptor$8;
  };
  Waterfall.prototype.getDefaultOptions = function() {
    return Waterfall.getDefaultOptions();
  };
  return Waterfall;
})(Plot);
function getScaleMax(maxAngle, yField, data2) {
  var yData = data2.map(function(item) {
    return item[yField];
  }).filter(function(v2) {
    return v2 !== void 0;
  });
  var maxValue = yData.length > 0 ? Math.max.apply(Math, yData) : 0;
  var formatRadian = Math.abs(maxAngle) % 360;
  if (!formatRadian) {
    return maxValue;
  }
  return maxValue * 360 / formatRadian;
}
function getStackedData(data2, xField, yField) {
  var stackedData = [];
  data2.forEach(function(item) {
    var valueItem = stackedData.find(function(v2) {
      return v2[xField] === item[xField];
    });
    if (valueItem) {
      valueItem[yField] += item[yField] || null;
    } else {
      stackedData.push(__assign$4({}, item));
    }
  });
  return stackedData;
}
function geometry$4(params) {
  var chart = params.chart, options = params.options;
  var style2 = options.barStyle, color2 = options.color, tooltip2 = options.tooltip, colorField = options.colorField, type4 = options.type, xField = options.xField, yField = options.yField, data2 = options.data;
  var processData2 = processIllegalData(data2, yField);
  chart.data(processData2);
  var p2 = deepAssign({}, params, {
    options: {
      tooltip: tooltip2,
      seriesField: colorField,
      interval: {
        style: style2,
        color: color2,
        shape: type4 === "line" ? "line" : "intervel"
      },
      minColumnWidth: options.minBarWidth,
      maxColumnWidth: options.maxBarWidth,
      columnBackground: options.barBackground
    }
  });
  interval(p2);
  if (type4 === "line") {
    point({
      chart,
      options: { xField, yField, seriesField: colorField, point: { shape: "circle", color: color2 } }
    });
  }
  return params;
}
function meta$2(params) {
  var _a2;
  var options = params.options;
  var yField = options.yField, xField = options.xField, data2 = options.data, isStack = options.isStack, isGroup = options.isGroup, colorField = options.colorField, maxAngle = options.maxAngle;
  var actualData = isStack && !isGroup && colorField ? getStackedData(data2, xField, yField) : data2;
  var processData2 = processIllegalData(actualData, yField);
  return flow(scale$2((_a2 = {}, _a2[yField] = {
    min: 0,
    max: getScaleMax(maxAngle, yField, processData2)
  }, _a2)))(params);
}
function coordinate$1(params) {
  var chart = params.chart, options = params.options;
  var radius = options.radius, innerRadius = options.innerRadius, startAngle = options.startAngle, endAngle = options.endAngle;
  chart.coordinate({
    type: "polar",
    cfg: {
      radius,
      innerRadius,
      startAngle,
      endAngle
    }
  }).transpose();
  return params;
}
function axis$4(params) {
  var chart = params.chart, options = params.options;
  var xField = options.xField, xAxis = options.xAxis;
  chart.axis(xField, xAxis);
  return params;
}
function label$1(params) {
  var chart = params.chart, options = params.options;
  var label2 = options.label, yField = options.yField;
  var intervalGeometry = findGeometry(chart, "interval");
  if (!label2) {
    intervalGeometry.label(false);
  } else {
    var callback = label2.callback, cfg = __rest$3(label2, ["callback"]);
    intervalGeometry.label({
      fields: [yField],
      callback,
      cfg: __assign$4(__assign$4({}, transformLabel(cfg)), { type: "polar" })
    });
  }
  return params;
}
function adaptor$7(params) {
  return flow(pattern("barStyle"), geometry$4, meta$2, axis$4, coordinate$1, interaction$7, animation$5, theme$2, tooltip$9, legend$g, annotation$2(), label$1)(params);
}
var DEFAULT_OPTIONS$7 = deepAssign({}, Plot.getDefaultOptions(), {
  interactions: [{ type: "element-active" }],
  legend: false,
  tooltip: {
    showMarkers: false
  },
  xAxis: {
    grid: null,
    tickLine: null,
    line: null
  },
  maxAngle: 240
});
(function(_super) {
  __extends$3(RadialBar, _super);
  function RadialBar() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "radial-bar";
    return _this;
  }
  RadialBar.getDefaultOptions = function() {
    return DEFAULT_OPTIONS$7;
  };
  RadialBar.prototype.changeData = function(data2) {
    this.updateOption({ data: data2 });
    meta$2({ chart: this.chart, options: this.options });
    this.chart.changeData(data2);
  };
  RadialBar.prototype.getDefaultOptions = function() {
    return RadialBar.getDefaultOptions();
  };
  RadialBar.prototype.getSchemaAdaptor = function() {
    return adaptor$7;
  };
  return RadialBar;
})(Plot);
var FIRST_AXES_VIEW = "first-axes-view";
var SECOND_AXES_VIEW = "second-axes-view";
var SERIES_FIELD_KEY = "series-field-key";
function transformData$3(xField, yField, seriesField, data2, reverse) {
  var hopeData = [];
  yField.forEach(function(d2) {
    data2.forEach(function(k2) {
      var _a3;
      var obj = (_a3 = {}, _a3[xField] = k2[xField], _a3[seriesField] = d2, _a3[d2] = k2[d2], _a3);
      hopeData.push(obj);
    });
  });
  var groupData = Object.values(groupBy(hopeData, seriesField));
  var _a2 = groupData[0], data1 = _a2 === void 0 ? [] : _a2, _b = groupData[1], data22 = _b === void 0 ? [] : _b;
  return reverse ? [data1.reverse(), data22.reverse()] : [data1, data22];
}
function isHorizontal(layout2) {
  return layout2 !== "vertical";
}
function syncViewPadding(chart, views, p2) {
  var v1 = views[0], v2 = views[1];
  var p1 = v1.autoPadding;
  var p22 = v2.autoPadding;
  var _a2 = chart.__axisPosition, layout2 = _a2.layout, position = _a2.position;
  if (isHorizontal(layout2) && position === "top") {
    v1.autoPadding = p2.instance(p1.top, 0, p1.bottom, p1.left);
    v2.autoPadding = p2.instance(p22.top, p1.left, p22.bottom, 0);
  }
  if (isHorizontal(layout2) && position === "bottom") {
    v1.autoPadding = p2.instance(p1.top, p1.right / 2 + 5, p1.bottom, p1.left);
    v2.autoPadding = p2.instance(p22.top, p22.right, p22.bottom, p1.right / 2 + 5);
  }
  if (!isHorizontal(layout2) && position === "bottom") {
    var left2 = p1.left >= p22.left ? p1.left : p22.left;
    v1.autoPadding = p2.instance(p1.top, p1.right, p1.bottom / 2 + 5, left2);
    v2.autoPadding = p2.instance(p1.bottom / 2 + 5, p22.right, p22.bottom, left2);
  }
  if (!isHorizontal(layout2) && position === "top") {
    var left2 = p1.left >= p22.left ? p1.left : p22.left;
    v1.autoPadding = p2.instance(p1.top, p1.right, 0, left2);
    v2.autoPadding = p2.instance(0, p22.right, p1.top, left2);
  }
}
function geometry$3(params) {
  var chart = params.chart, options = params.options;
  var data2 = options.data, xField = options.xField, yField = options.yField, color2 = options.color, barStyle = options.barStyle, widthRatio = options.widthRatio, legend2 = options.legend, layout2 = options.layout;
  var groupData = transformData$3(xField, yField, SERIES_FIELD_KEY, data2, isHorizontal(layout2));
  if (legend2) {
    chart.legend(SERIES_FIELD_KEY, legend2);
  } else if (legend2 === false) {
    chart.legend(false);
  }
  var firstView;
  var secondView;
  var firstViewData = groupData[0], secondViewData = groupData[1];
  if (isHorizontal(layout2)) {
    firstView = chart.createView({
      region: {
        start: { x: 0, y: 0 },
        end: { x: 0.5, y: 1 }
      },
      id: FIRST_AXES_VIEW
    });
    firstView.coordinate().transpose().reflect("x");
    secondView = chart.createView({
      region: {
        start: { x: 0.5, y: 0 },
        end: { x: 1, y: 1 }
      },
      id: SECOND_AXES_VIEW
    });
    secondView.coordinate().transpose();
    firstView.data(firstViewData);
    secondView.data(secondViewData);
  } else {
    firstView = chart.createView({
      region: {
        start: { x: 0, y: 0 },
        end: { x: 1, y: 0.5 }
      },
      id: FIRST_AXES_VIEW
    });
    secondView = chart.createView({
      region: {
        start: { x: 0, y: 0.5 },
        end: { x: 1, y: 1 }
      },
      id: SECOND_AXES_VIEW
    });
    secondView.coordinate().reflect("y");
    firstView.data(firstViewData);
    secondView.data(secondViewData);
  }
  var left2 = deepAssign({}, params, {
    chart: firstView,
    options: {
      widthRatio,
      xField,
      yField: yField[0],
      seriesField: SERIES_FIELD_KEY,
      interval: {
        color: color2,
        style: barStyle
      }
    }
  });
  interval(left2);
  var right2 = deepAssign({}, params, {
    chart: secondView,
    options: {
      xField,
      yField: yField[1],
      seriesField: SERIES_FIELD_KEY,
      widthRatio,
      interval: {
        color: color2,
        style: barStyle
      }
    }
  });
  interval(right2);
  return params;
}
function meta$1(params) {
  var _a2, _b, _c;
  var options = params.options, chart = params.chart;
  var xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField, yField = options.yField;
  var firstView = findViewById(chart, FIRST_AXES_VIEW);
  var secondView = findViewById(chart, SECOND_AXES_VIEW);
  var aliasMap = {};
  keys((options === null || options === void 0 ? void 0 : options.meta) || {}).map(function(metaKey) {
    if (get(options === null || options === void 0 ? void 0 : options.meta, [metaKey, "alias"])) {
      aliasMap[metaKey] = options.meta[metaKey].alias;
    }
  });
  chart.scale((_a2 = {}, _a2[SERIES_FIELD_KEY] = {
    sync: true,
    formatter: function(v2) {
      return get(aliasMap, v2, v2);
    }
  }, _a2));
  scale$2((_b = {}, _b[xField] = xAxis, _b[yField[0]] = yAxis[yField[0]], _b))(deepAssign({}, params, { chart: firstView }));
  scale$2((_c = {}, _c[xField] = xAxis, _c[yField[1]] = yAxis[yField[1]], _c))(deepAssign({}, params, { chart: secondView }));
  return params;
}
function axis$3(params) {
  var chart = params.chart, options = params.options;
  var xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField, yField = options.yField, layout2 = options.layout;
  var firstView = findViewById(chart, FIRST_AXES_VIEW);
  var secondView = findViewById(chart, SECOND_AXES_VIEW);
  if ((xAxis === null || xAxis === void 0 ? void 0 : xAxis.position) === "bottom") {
    secondView.axis(xField, __assign$4(__assign$4({}, xAxis), { label: { formatter: function() {
      return "";
    } } }));
  } else {
    secondView.axis(xField, false);
  }
  if (xAxis === false) {
    firstView.axis(xField, false);
  } else {
    firstView.axis(xField, __assign$4({
      position: isHorizontal(layout2) ? "top" : "bottom"
    }, xAxis));
  }
  if (yAxis === false) {
    firstView.axis(yField[0], false);
    secondView.axis(yField[1], false);
  } else {
    firstView.axis(yField[0], yAxis[yField[0]]);
    secondView.axis(yField[1], yAxis[yField[1]]);
  }
  chart.__axisPosition = {
    position: firstView.getOptions().axes[xField].position,
    layout: layout2
  };
  return params;
}
function interaction$3(params) {
  var chart = params.chart;
  interaction$7(deepAssign({}, params, { chart: findViewById(chart, FIRST_AXES_VIEW) }));
  interaction$7(deepAssign({}, params, { chart: findViewById(chart, SECOND_AXES_VIEW) }));
  return params;
}
function limitInPlot(params) {
  var chart = params.chart, options = params.options;
  var yField = options.yField, yAxis = options.yAxis;
  limitInPlot$2(deepAssign({}, params, {
    chart: findViewById(chart, FIRST_AXES_VIEW),
    options: {
      yAxis: yAxis[yField[0]]
    }
  }));
  limitInPlot$2(deepAssign({}, params, {
    chart: findViewById(chart, SECOND_AXES_VIEW),
    options: {
      yAxis: yAxis[yField[1]]
    }
  }));
  return params;
}
function theme(params) {
  var chart = params.chart;
  theme$2(deepAssign({}, params, { chart: findViewById(chart, FIRST_AXES_VIEW) }));
  theme$2(deepAssign({}, params, { chart: findViewById(chart, SECOND_AXES_VIEW) }));
  theme$2(params);
  return params;
}
function animation$2(params) {
  var chart = params.chart;
  animation$5(deepAssign({}, params, { chart: findViewById(chart, FIRST_AXES_VIEW) }));
  animation$5(deepAssign({}, params, { chart: findViewById(chart, SECOND_AXES_VIEW) }));
  return params;
}
function label(params) {
  var _this = this;
  var _a2, _b;
  var chart = params.chart, options = params.options;
  var label2 = options.label, yField = options.yField, layout2 = options.layout;
  var firstView = findViewById(chart, FIRST_AXES_VIEW);
  var secondView = findViewById(chart, SECOND_AXES_VIEW);
  var leftGeometry = findGeometry(firstView, "interval");
  var rightGeometry = findGeometry(secondView, "interval");
  if (!label2) {
    leftGeometry.label(false);
    rightGeometry.label(false);
  } else {
    var callback = label2.callback, cfg_1 = __rest$3(label2, ["callback"]);
    if (!cfg_1.position) {
      cfg_1.position = "middle";
    }
    if (cfg_1.offset === void 0) {
      cfg_1.offset = 2;
    }
    var leftLabelCfg = __assign$4({}, cfg_1);
    if (isHorizontal(layout2)) {
      var textAlign = ((_a2 = leftLabelCfg.style) === null || _a2 === void 0 ? void 0 : _a2.textAlign) || (cfg_1.position === "middle" ? "center" : "left");
      cfg_1.style = deepAssign({}, cfg_1.style, { textAlign });
      var textAlignMap = { left: "right", right: "left", center: "center" };
      leftLabelCfg.style = deepAssign({}, leftLabelCfg.style, { textAlign: textAlignMap[textAlign] });
    } else {
      var positionMap_1 = { top: "bottom", bottom: "top", middle: "middle" };
      if (typeof cfg_1.position === "string") {
        cfg_1.position = positionMap_1[cfg_1.position];
      } else if (typeof cfg_1.position === "function") {
        cfg_1.position = function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          return positionMap_1[cfg_1.position.apply(_this, args)];
        };
      }
      var textBaseline = ((_b = leftLabelCfg.style) === null || _b === void 0 ? void 0 : _b.textBaseline) || "bottom";
      leftLabelCfg.style = deepAssign({}, leftLabelCfg.style, { textBaseline });
      var textBaselineMap = { top: "bottom", bottom: "top", middle: "middle" };
      cfg_1.style = deepAssign({}, cfg_1.style, { textBaseline: textBaselineMap[textBaseline] });
    }
    leftGeometry.label({
      fields: [yField[0]],
      callback,
      cfg: transformLabel(leftLabelCfg)
    });
    rightGeometry.label({
      fields: [yField[1]],
      callback,
      cfg: transformLabel(cfg_1)
    });
  }
  return params;
}
function adaptor$6(params) {
  return flow(geometry$3, meta$1, axis$3, limitInPlot, theme, label, tooltip$9, interaction$3, animation$2)(params);
}
(function(_super) {
  __extends$3(BidirectionalBar, _super);
  function BidirectionalBar() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "bidirectional-bar";
    return _this;
  }
  BidirectionalBar.getDefaultOptions = function() {
    return deepAssign({}, _super.getDefaultOptions.call(this), {
      syncViewPadding
    });
  };
  BidirectionalBar.prototype.changeData = function(data2) {
    if (data2 === void 0) {
      data2 = [];
    }
    this.chart.emit(VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, Event.fromData(this.chart, VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, null));
    this.updateOption({ data: data2 });
    var _a2 = this.options, xField = _a2.xField, yField = _a2.yField, layout2 = _a2.layout;
    var groupData = transformData$3(xField, yField, SERIES_FIELD_KEY, data2, isHorizontal(layout2));
    var firstViewData = groupData[0], secondViewData = groupData[1];
    var firstView = findViewById(this.chart, FIRST_AXES_VIEW);
    var secondView = findViewById(this.chart, SECOND_AXES_VIEW);
    firstView.data(firstViewData);
    secondView.data(secondViewData);
    this.chart.render(true);
    this.chart.emit(VIEW_LIFE_CIRCLE.AFTER_CHANGE_DATA, Event.fromData(this.chart, VIEW_LIFE_CIRCLE.AFTER_CHANGE_DATA, null));
  };
  BidirectionalBar.prototype.getDefaultOptions = function() {
    return BidirectionalBar.getDefaultOptions();
  };
  BidirectionalBar.prototype.getSchemaAdaptor = function() {
    return adaptor$6;
  };
  BidirectionalBar.SERIES_FIELD_KEY = SERIES_FIELD_KEY;
  return BidirectionalBar;
})(Plot);
function findInteraction(interactions, interactionType) {
  if (!isArray$1(interactions))
    return void 0;
  return interactions.find(function(i2) {
    return i2.type === interactionType;
  });
}
function enableInteraction(interactions, interactionType) {
  var interaction2 = findInteraction(interactions, interactionType);
  return interaction2 && interaction2.enable !== false;
}
function enableDrillInteraction(options) {
  var interactions = options.interactions, drilldown = options.drilldown;
  return get(drilldown, "enabled") || enableInteraction(interactions, "treemap-drill-down");
}
function resetDrillDown(chart) {
  var drillDownInteraction = chart.interactions["drill-down"];
  if (!drillDownInteraction)
    return;
  var drillDownAction = drillDownInteraction.context.actions.find(function(i2) {
    return i2.name === "drill-down-action";
  });
  drillDownAction.reset();
}
function transformData$2(options) {
  var data2 = options.data, colorField = options.colorField, enableDrillDown = options.enableDrillDown, hierarchyConfig = options.hierarchyConfig;
  var nodes = treemap(data2, __assign$4(__assign$4({}, hierarchyConfig), {
    type: "hierarchy.treemap",
    field: "value",
    as: ["x", "y"]
  }));
  var result = [];
  nodes.forEach(function(node) {
    if (node.depth === 0) {
      return null;
    }
    if (enableDrillDown && node.depth !== 1) {
      return null;
    }
    if (!enableDrillDown && node.children) {
      return null;
    }
    var curPath = node.ancestors().map(function(n2) {
      return {
        data: n2.data,
        height: n2.height,
        value: n2.value
      };
    });
    var path2 = enableDrillDown && isArray$1(data2.path) ? curPath.concat(data2.path.slice(1)) : curPath;
    var nodeInfo = Object.assign({}, node.data, __assign$4({ x: node.x, y: node.y, depth: node.depth, value: node.value, path: path2 }, node));
    if (!node.data[colorField] && node.parent) {
      var ancestorNode = node.ancestors().find(function(n2) {
        return n2.data[colorField];
      });
      nodeInfo[colorField] = ancestorNode === null || ancestorNode === void 0 ? void 0 : ancestorNode.data[colorField];
    } else {
      nodeInfo[colorField] = node.data[colorField];
    }
    nodeInfo[HIERARCHY_DATA_TRANSFORM_PARAMS] = { hierarchyConfig, colorField, enableDrillDown };
    result.push(nodeInfo);
  });
  return result;
}
function defaultOptions$2(params) {
  var options = params.options;
  var colorField = options.colorField;
  return deepAssign({
    options: {
      rawFields: ["value"],
      tooltip: {
        fields: ["name", "value", colorField, "path"],
        formatter: function(data2) {
          return {
            name: data2.name,
            value: data2.value
          };
        }
      }
    }
  }, params);
}
function geometry$2(params) {
  var chart = params.chart, options = params.options;
  var color2 = options.color, colorField = options.colorField, rectStyle = options.rectStyle, hierarchyConfig = options.hierarchyConfig, rawFields = options.rawFields;
  var data2 = transformData$2({
    data: options.data,
    colorField: options.colorField,
    enableDrillDown: enableDrillInteraction(options),
    hierarchyConfig
  });
  chart.data(data2);
  polygon(deepAssign({}, params, {
    options: {
      xField: "x",
      yField: "y",
      seriesField: colorField,
      rawFields,
      polygon: {
        color: color2,
        style: rectStyle
      }
    }
  }));
  chart.coordinate().reflect("y");
  return params;
}
function axis$2(params) {
  var chart = params.chart;
  chart.axis(false);
  return params;
}
function adaptorInteraction$1(options) {
  var drilldown = options.drilldown, _a2 = options.interactions, interactions = _a2 === void 0 ? [] : _a2;
  var enableDrillDown = enableDrillInteraction(options);
  if (enableDrillDown) {
    return deepAssign({}, options, {
      interactions: __spreadArrays(interactions, [
        {
          type: "drill-down",
          cfg: { drillDownConfig: drilldown, transformData: transformData$2 }
        }
      ])
    });
  }
  return options;
}
function interaction$2(params) {
  var chart = params.chart, options = params.options;
  var interactions = options.interactions, drilldown = options.drilldown;
  interaction$7({
    chart,
    options: adaptorInteraction$1(options)
  });
  var viewZoomInteraction = findInteraction(interactions, "view-zoom");
  if (viewZoomInteraction) {
    if (viewZoomInteraction.enable !== false) {
      chart.getCanvas().on("mousewheel", function(ev) {
        ev.preventDefault();
      });
    } else {
      chart.getCanvas().off("mousewheel");
    }
  }
  var enableDrillDown = enableDrillInteraction(options);
  if (enableDrillDown) {
    chart.appendPadding = getAdjustAppendPadding(chart.appendPadding, get(drilldown, ["breadCrumb", "position"]));
  }
  return params;
}
function adaptor$5(params) {
  return flow(defaultOptions$2, theme$2, pattern("rectStyle"), geometry$2, axis$2, legend$g, tooltip$9, interaction$2, animation$5, annotation$2())(params);
}
var DEFAULT_OPTIONS$6 = {
  colorField: "name",
  rectStyle: {
    lineWidth: 1,
    stroke: "#fff"
  },
  hierarchyConfig: {
    tile: "treemapSquarify"
  },
  label: {
    fields: ["name"],
    layout: {
      type: "limit-in-shape"
    }
  },
  tooltip: {
    showMarkers: false,
    showTitle: false
  },
  drilldown: {
    enabled: false,
    breadCrumb: {
      position: "bottom-left",
      rootText: "\u521D\u59CB",
      dividerText: "/",
      textStyle: {
        fontSize: 12,
        fill: "rgba(0, 0, 0, 0.65)",
        cursor: "pointer"
      },
      activeTextStyle: {
        fill: "#87B5FF"
      }
    }
  }
};
(function(_super) {
  __extends$3(Treemap, _super);
  function Treemap() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "treemap";
    return _this;
  }
  Treemap.getDefaultOptions = function() {
    return DEFAULT_OPTIONS$6;
  };
  Treemap.prototype.changeData = function(data2) {
    var _a2 = this.options, colorField = _a2.colorField, interactions = _a2.interactions, hierarchyConfig = _a2.hierarchyConfig;
    this.updateOption({ data: data2 });
    var transData = transformData$2({
      data: data2,
      colorField,
      enableDrillDown: enableInteraction(interactions, "treemap-drill-down"),
      hierarchyConfig
    });
    this.chart.changeData(transData);
    resetDrillDown(this.chart);
  };
  Treemap.prototype.getDefaultOptions = function() {
    return Treemap.getDefaultOptions();
  };
  Treemap.prototype.getSchemaAdaptor = function() {
    return adaptor$5;
  };
  return Treemap;
})(Plot);
function targetDepth(d2) {
  return d2.target.depth;
}
function left(node) {
  return node.depth;
}
function right(node, n2) {
  return n2 - 1 - node.height;
}
function justify(node, n2) {
  return node.sourceLinks.length ? node.depth : n2 - 1;
}
function center(node) {
  return node.targetLinks.length ? node.depth : node.sourceLinks.length ? minBy(node.sourceLinks, targetDepth) - 1 : 0;
}
function constant(x2) {
  return function() {
    return x2;
  };
}
function sumBy(arr, func) {
  var r2 = 0;
  for (var i2 = 0; i2 < arr.length; i2++) {
    r2 += func(arr[i2]);
  }
  return r2;
}
function maxValueBy(arr, func) {
  var r2 = -Infinity;
  for (var i2 = 0; i2 < arr.length; i2++) {
    r2 = Math.max(func(arr[i2]), r2);
  }
  return r2;
}
function minValueBy(arr, func) {
  var r2 = Infinity;
  for (var i2 = 0; i2 < arr.length; i2++) {
    r2 = Math.min(func(arr[i2]), r2);
  }
  return r2;
}
function ascendingSourceBreadth(a2, b10) {
  return ascendingBreadth(a2.source, b10.source) || a2.index - b10.index;
}
function ascendingTargetBreadth(a2, b10) {
  return ascendingBreadth(a2.target, b10.target) || a2.index - b10.index;
}
function ascendingBreadth(a2, b10) {
  return a2.y0 - b10.y0;
}
function value(d2) {
  return d2.value;
}
function defaultId(d2) {
  return d2.index;
}
function defaultNodes(graph) {
  return graph.nodes;
}
function defaultLinks(graph) {
  return graph.links;
}
function find(nodeById, id2) {
  var node = nodeById.get(id2);
  if (!node)
    throw new Error("missing: " + id2);
  return node;
}
function computeLinkBreadths(_a2) {
  var nodes = _a2.nodes;
  for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {
    var node = nodes_1[_i];
    var y0 = node.y0;
    var y1 = y0;
    for (var _b = 0, _c = node.sourceLinks; _b < _c.length; _b++) {
      var link = _c[_b];
      link.y0 = y0 + link.width / 2;
      y0 += link.width;
    }
    for (var _d = 0, _e = node.targetLinks; _d < _e.length; _d++) {
      var link = _e[_d];
      link.y1 = y1 + link.width / 2;
      y1 += link.width;
    }
  }
}
function Sankey() {
  var x0 = 0, y0 = 0, x1 = 1, y1 = 1;
  var dx = 24;
  var dy = 8, py;
  var id2 = defaultId;
  var align = justify;
  var depth;
  var sort;
  var linkSort;
  var nodes = defaultNodes;
  var links = defaultLinks;
  var iterations = 6;
  function sankey(arg) {
    var graph = {
      nodes: nodes(arg),
      links: links(arg)
    };
    computeNodeLinks(graph);
    computeNodeValues(graph);
    computeNodeDepths(graph);
    computeNodeHeights(graph);
    computeNodeBreadths(graph);
    computeLinkBreadths(graph);
    return graph;
  }
  sankey.update = function(graph) {
    computeLinkBreadths(graph);
    return graph;
  };
  sankey.nodeId = function(_2) {
    return arguments.length ? (id2 = typeof _2 === "function" ? _2 : constant(_2), sankey) : id2;
  };
  sankey.nodeAlign = function(_2) {
    return arguments.length ? (align = typeof _2 === "function" ? _2 : constant(_2), sankey) : align;
  };
  sankey.nodeDepth = function(_2) {
    return arguments.length ? (depth = typeof _2 === "function" ? _2 : _2, sankey) : depth;
  };
  sankey.nodeSort = function(_2) {
    return arguments.length ? (sort = _2, sankey) : sort;
  };
  sankey.nodeWidth = function(_2) {
    return arguments.length ? (dx = +_2, sankey) : dx;
  };
  sankey.nodePadding = function(_2) {
    return arguments.length ? (dy = py = +_2, sankey) : dy;
  };
  sankey.nodes = function(_2) {
    return arguments.length ? (nodes = typeof _2 === "function" ? _2 : constant(_2), sankey) : nodes;
  };
  sankey.links = function(_2) {
    return arguments.length ? (links = typeof _2 === "function" ? _2 : constant(_2), sankey) : links;
  };
  sankey.linkSort = function(_2) {
    return arguments.length ? (linkSort = _2, sankey) : linkSort;
  };
  sankey.size = function(_2) {
    return arguments.length ? (x0 = y0 = 0, x1 = +_2[0], y1 = +_2[1], sankey) : [x1 - x0, y1 - y0];
  };
  sankey.extent = function(_2) {
    return arguments.length ? (x0 = +_2[0][0], x1 = +_2[1][0], y0 = +_2[0][1], y1 = +_2[1][1], sankey) : [
      [x0, y0],
      [x1, y1]
    ];
  };
  sankey.iterations = function(_2) {
    return arguments.length ? (iterations = +_2, sankey) : iterations;
  };
  function computeNodeLinks(_a2) {
    var nodes2 = _a2.nodes, links2 = _a2.links;
    nodes2.forEach(function(node, idx) {
      node.index = idx;
      node.sourceLinks = [];
      node.targetLinks = [];
    });
    var nodeById = new Map(nodes2.map(function(d2) {
      return [id2(d2), d2];
    }));
    links2.forEach(function(link, idx) {
      link.index = idx;
      var source = link.source, target = link.target;
      if (typeof source !== "object")
        source = link.source = find(nodeById, source);
      if (typeof target !== "object")
        target = link.target = find(nodeById, target);
      source.sourceLinks.push(link);
      target.targetLinks.push(link);
    });
    if (linkSort != null) {
      for (var _i = 0, nodes_2 = nodes2; _i < nodes_2.length; _i++) {
        var _b = nodes_2[_i], sourceLinks = _b.sourceLinks, targetLinks = _b.targetLinks;
        sourceLinks.sort(linkSort);
        targetLinks.sort(linkSort);
      }
    }
  }
  function computeNodeValues(_a2) {
    var nodes2 = _a2.nodes;
    for (var _i = 0, nodes_3 = nodes2; _i < nodes_3.length; _i++) {
      var node = nodes_3[_i];
      node.value = node.fixedValue === void 0 ? Math.max(sumBy(node.sourceLinks, value), sumBy(node.targetLinks, value)) : node.fixedValue;
    }
  }
  function computeNodeDepths(_a2) {
    var nodes2 = _a2.nodes;
    var n2 = nodes2.length;
    var current = new Set(nodes2);
    var next = /* @__PURE__ */ new Set();
    var x2 = 0;
    while (current.size) {
      current.forEach(function(node2) {
        node2.depth = x2;
        for (var _i = 0, _a3 = node2.sourceLinks; _i < _a3.length; _i++) {
          var target = _a3[_i].target;
          next.add(target);
        }
      });
      if (++x2 > n2)
        throw new Error("circular link");
      current = next;
      next = /* @__PURE__ */ new Set();
    }
    if (depth) {
      var maxDepth = Math.max(maxValueBy(nodes2, function(d2) {
        return d2.depth;
      }) + 1, 0);
      var node = void 0;
      for (var i2 = 0; i2 < nodes2.length; i2++) {
        node = nodes2[i2];
        node.depth = depth.call(null, node, maxDepth);
      }
    }
  }
  function computeNodeHeights(_a2) {
    var nodes2 = _a2.nodes;
    var n2 = nodes2.length;
    var current = new Set(nodes2);
    var next = /* @__PURE__ */ new Set();
    var x2 = 0;
    while (current.size) {
      current.forEach(function(node) {
        node.height = x2;
        for (var _i = 0, _a3 = node.targetLinks; _i < _a3.length; _i++) {
          var source = _a3[_i].source;
          next.add(source);
        }
      });
      if (++x2 > n2)
        throw new Error("circular link");
      current = next;
      next = /* @__PURE__ */ new Set();
    }
  }
  function computeNodeLayers(_a2) {
    var nodes2 = _a2.nodes;
    var x2 = Math.max(maxValueBy(nodes2, function(d2) {
      return d2.depth;
    }) + 1, 0);
    var kx = (x1 - x0 - dx) / (x2 - 1);
    var columns2 = new Array(x2).fill(0).map(function() {
      return [];
    });
    for (var _i = 0, nodes_4 = nodes2; _i < nodes_4.length; _i++) {
      var node = nodes_4[_i];
      var i2 = Math.max(0, Math.min(x2 - 1, Math.floor(align.call(null, node, x2))));
      node.layer = i2;
      node.x0 = x0 + i2 * kx;
      node.x1 = node.x0 + dx;
      if (columns2[i2])
        columns2[i2].push(node);
      else
        columns2[i2] = [node];
    }
    if (sort)
      for (var _b = 0, columns_1 = columns2; _b < columns_1.length; _b++) {
        var column = columns_1[_b];
        column.sort(sort);
      }
    return columns2;
  }
  function initializeNodeBreadths(columns2) {
    var ky = minValueBy(columns2, function(c2) {
      return (y1 - y0 - (c2.length - 1) * py) / sumBy(c2, value);
    });
    for (var _i = 0, columns_2 = columns2; _i < columns_2.length; _i++) {
      var nodes_6 = columns_2[_i];
      var y2 = y0;
      for (var _a2 = 0, nodes_5 = nodes_6; _a2 < nodes_5.length; _a2++) {
        var node = nodes_5[_a2];
        node.y0 = y2;
        node.y1 = y2 + node.value * ky;
        y2 = node.y1 + py;
        for (var _b = 0, _c = node.sourceLinks; _b < _c.length; _b++) {
          var link = _c[_b];
          link.width = link.value * ky;
        }
      }
      y2 = (y1 - y2 + py) / (nodes_6.length + 1);
      for (var i2 = 0; i2 < nodes_6.length; ++i2) {
        var node = nodes_6[i2];
        node.y0 += y2 * (i2 + 1);
        node.y1 += y2 * (i2 + 1);
      }
      reorderLinks(nodes_6);
    }
  }
  function computeNodeBreadths(graph) {
    var columns2 = computeNodeLayers(graph);
    py = Math.min(dy, (y1 - y0) / (maxValueBy(columns2, function(c2) {
      return c2.length;
    }) - 1));
    initializeNodeBreadths(columns2);
    for (var i2 = 0; i2 < iterations; ++i2) {
      var alpha = Math.pow(0.99, i2);
      var beta = Math.max(1 - alpha, (i2 + 1) / iterations);
      relaxRightToLeft(columns2, alpha, beta);
      relaxLeftToRight(columns2, alpha, beta);
    }
  }
  function relaxLeftToRight(columns2, alpha, beta) {
    for (var i2 = 1, n2 = columns2.length; i2 < n2; ++i2) {
      var column = columns2[i2];
      for (var _i = 0, column_1 = column; _i < column_1.length; _i++) {
        var target = column_1[_i];
        var y2 = 0;
        var w2 = 0;
        for (var _a2 = 0, _b = target.targetLinks; _a2 < _b.length; _a2++) {
          var _c = _b[_a2], source = _c.source, value_1 = _c.value;
          var v2 = value_1 * (target.layer - source.layer);
          y2 += targetTop(source, target) * v2;
          w2 += v2;
        }
        if (!(w2 > 0))
          continue;
        var dy_1 = (y2 / w2 - target.y0) * alpha;
        target.y0 += dy_1;
        target.y1 += dy_1;
        reorderNodeLinks(target);
      }
      if (sort === void 0)
        column.sort(ascendingBreadth);
      if (column.length)
        resolveCollisions(column, beta);
    }
  }
  function relaxRightToLeft(columns2, alpha, beta) {
    for (var n2 = columns2.length, i2 = n2 - 2; i2 >= 0; --i2) {
      var column = columns2[i2];
      for (var _i = 0, column_2 = column; _i < column_2.length; _i++) {
        var source = column_2[_i];
        var y2 = 0;
        var w2 = 0;
        for (var _a2 = 0, _b = source.sourceLinks; _a2 < _b.length; _a2++) {
          var _c = _b[_a2], target = _c.target, value_2 = _c.value;
          var v2 = value_2 * (target.layer - source.layer);
          y2 += sourceTop(source, target) * v2;
          w2 += v2;
        }
        if (!(w2 > 0))
          continue;
        var dy_2 = (y2 / w2 - source.y0) * alpha;
        source.y0 += dy_2;
        source.y1 += dy_2;
        reorderNodeLinks(source);
      }
      if (sort === void 0)
        column.sort(ascendingBreadth);
      if (column.length)
        resolveCollisions(column, beta);
    }
  }
  function resolveCollisions(nodes2, alpha) {
    var i2 = nodes2.length >> 1;
    var subject = nodes2[i2];
    resolveCollisionsBottomToTop(nodes2, subject.y0 - py, i2 - 1, alpha);
    resolveCollisionsTopToBottom(nodes2, subject.y1 + py, i2 + 1, alpha);
    resolveCollisionsBottomToTop(nodes2, y1, nodes2.length - 1, alpha);
    resolveCollisionsTopToBottom(nodes2, y0, 0, alpha);
  }
  function resolveCollisionsTopToBottom(nodes2, y2, i2, alpha) {
    for (; i2 < nodes2.length; ++i2) {
      var node = nodes2[i2];
      var dy_3 = (y2 - node.y0) * alpha;
      if (dy_3 > 1e-6)
        node.y0 += dy_3, node.y1 += dy_3;
      y2 = node.y1 + py;
    }
  }
  function resolveCollisionsBottomToTop(nodes2, y2, i2, alpha) {
    for (; i2 >= 0; --i2) {
      var node = nodes2[i2];
      var dy_4 = (node.y1 - y2) * alpha;
      if (dy_4 > 1e-6)
        node.y0 -= dy_4, node.y1 -= dy_4;
      y2 = node.y0 - py;
    }
  }
  function reorderNodeLinks(_a2) {
    var sourceLinks = _a2.sourceLinks, targetLinks = _a2.targetLinks;
    if (linkSort === void 0) {
      for (var _i = 0, targetLinks_1 = targetLinks; _i < targetLinks_1.length; _i++) {
        var sourceLinks_2 = targetLinks_1[_i].source.sourceLinks;
        sourceLinks_2.sort(ascendingTargetBreadth);
      }
      for (var _b = 0, sourceLinks_1 = sourceLinks; _b < sourceLinks_1.length; _b++) {
        var targetLinks_2 = sourceLinks_1[_b].target.targetLinks;
        targetLinks_2.sort(ascendingSourceBreadth);
      }
    }
  }
  function reorderLinks(nodes2) {
    if (linkSort === void 0) {
      for (var _i = 0, nodes_7 = nodes2; _i < nodes_7.length; _i++) {
        var _a2 = nodes_7[_i], sourceLinks = _a2.sourceLinks, targetLinks = _a2.targetLinks;
        sourceLinks.sort(ascendingTargetBreadth);
        targetLinks.sort(ascendingSourceBreadth);
      }
    }
  }
  function targetTop(source, target) {
    var y2 = source.y0 - (source.sourceLinks.length - 1) * py / 2;
    for (var _i = 0, _a2 = source.sourceLinks; _i < _a2.length; _i++) {
      var _b = _a2[_i], node = _b.target, width = _b.width;
      if (node === target)
        break;
      y2 += width + py;
    }
    for (var _c = 0, _d = target.targetLinks; _c < _d.length; _c++) {
      var _e = _d[_c], node = _e.source, width = _e.width;
      if (node === source)
        break;
      y2 -= width;
    }
    return y2;
  }
  function sourceTop(source, target) {
    var y2 = target.y0 - (target.targetLinks.length - 1) * py / 2;
    for (var _i = 0, _a2 = target.targetLinks; _i < _a2.length; _i++) {
      var _b = _a2[_i], node = _b.source, width = _b.width;
      if (node === source)
        break;
      y2 += width + py;
    }
    for (var _c = 0, _d = source.sourceLinks; _c < _d.length; _c++) {
      var _e = _d[_c], node = _e.target, width = _e.width;
      if (node === target)
        break;
      y2 -= width;
    }
    return y2;
  }
  return sankey;
}
var ALIGN_METHOD = {
  left,
  right,
  center,
  justify
};
var DEFAULT_OPTIONS$5 = {
  nodeId: function(node) {
    return node.index;
  },
  nodeAlign: "justify",
  nodeWidth: 8e-3,
  nodePadding: 0.03,
  nodeSort: void 0
};
function getNodeAlignFunction(nodeAlign) {
  var func = isString(nodeAlign) ? ALIGN_METHOD[nodeAlign] : isFunction(nodeAlign) ? nodeAlign : null;
  return func || justify;
}
function getDefaultOptions$1(sankeyLayoutOptions) {
  return mix({}, DEFAULT_OPTIONS$5, sankeyLayoutOptions);
}
function sankeyLayout(sankeyLayoutOptions, data2) {
  var options = getDefaultOptions$1(sankeyLayoutOptions);
  var nodeId = options.nodeId, nodeSort = options.nodeSort, nodeAlign = options.nodeAlign, nodeWidth = options.nodeWidth, nodePadding = options.nodePadding, nodeDepth = options.nodeDepth;
  var sankeyProcessor = Sankey().nodeSort(nodeSort).nodeWidth(nodeWidth).nodePadding(nodePadding).nodeDepth(nodeDepth).nodeAlign(getNodeAlignFunction(nodeAlign)).extent([
    [0, 0],
    [1, 1]
  ]).nodeId(nodeId);
  var layoutData = sankeyProcessor(data2);
  var nodes = layoutData.nodes.map(function(node) {
    var x0 = node.x0, x1 = node.x1, y0 = node.y0, y1 = node.y1;
    node.x = [x0, x1, x1, x0];
    node.y = [y0, y0, y1, y1];
    return node;
  }).filter(function(node) {
    return node.name !== null;
  });
  var links = layoutData.links.map(function(edge2) {
    var source = edge2.source, target = edge2.target;
    var sx = source.x1;
    var tx = target.x0;
    edge2.x = [sx, sx, tx, tx];
    var offset3 = edge2.width / 2;
    edge2.y = [edge2.y0 + offset3, edge2.y0 - offset3, edge2.y1 + offset3, edge2.y1 - offset3];
    return edge2;
  }).filter(function(edge2) {
    var source = edge2.source, target = edge2.target;
    return source.name !== null && target.name !== null;
  });
  return { nodes, links };
}
function getNodes(edges, sourceField, targetField) {
  var nodes = [];
  edges.forEach(function(e3) {
    var source = e3[sourceField];
    var target = e3[targetField];
    if (!nodes.includes(source)) {
      nodes.push(source);
    }
    if (!nodes.includes(target)) {
      nodes.push(target);
    }
  });
  return nodes;
}
function getMatrix(edges, nodes, sourceField, targetField) {
  var graphMatrix = {};
  nodes.forEach(function(pre) {
    graphMatrix[pre] = {};
    nodes.forEach(function(next) {
      graphMatrix[pre][next] = 0;
    });
  });
  edges.forEach(function(edge2) {
    graphMatrix[edge2[sourceField]][edge2[targetField]] = 1;
  });
  return graphMatrix;
}
function cutoffCircle(edges, sourceField, targetField) {
  if (!isArray$1(edges))
    return [];
  var removedData = [];
  var nodes = getNodes(edges, sourceField, targetField);
  var graphMatrix = getMatrix(edges, nodes, sourceField, targetField);
  var visited = {};
  nodes.forEach(function(node) {
    visited[node] = 0;
  });
  function DFS(dfsNode) {
    visited[dfsNode] = 1;
    nodes.forEach(function(node) {
      if (graphMatrix[dfsNode][node] != 0) {
        if (visited[node] == 1) {
          removedData.push(dfsNode + "_" + node);
        } else if (visited[node] == -1) {
          return;
        } else {
          DFS(node);
        }
      }
    });
    visited[dfsNode] = -1;
  }
  nodes.forEach(function(node) {
    if (visited[node] == -1) {
      return;
    }
    DFS(node);
  });
  if (removedData.length !== 0) {
    console.warn("sankey data contains circle, " + removedData.length + " records removed.", removedData);
  }
  return edges.filter(function(edge2) {
    return removedData.findIndex(function(i2) {
      return i2 === edge2[sourceField] + "_" + edge2[targetField];
    }) < 0;
  });
}
function isNodeLink(dataType) {
  return dataType === "node-link";
}
function getNodeWidthRatio(nodeWidth, nodeWidthRatio, width) {
  return isRealNumber(nodeWidth) ? nodeWidth / width : nodeWidthRatio;
}
function getNodePaddingRatio(nodePadding, nodePaddingRatio, height) {
  return isRealNumber(nodePadding) ? nodePadding / height : nodePaddingRatio;
}
function transformToViewsData(options, width, height) {
  var dataType = options.dataType, data2 = options.data, sourceField = options.sourceField, targetField = options.targetField, weightField = options.weightField, nodeAlign = options.nodeAlign, nodeSort = options.nodeSort, nodePadding = options.nodePadding, nodePaddingRatio = options.nodePaddingRatio, nodeWidth = options.nodeWidth, nodeWidthRatio = options.nodeWidthRatio, nodeDepth = options.nodeDepth, _a2 = options.rawFields, rawFields = _a2 === void 0 ? [] : _a2;
  var sankeyLayoutInputData;
  if (!isNodeLink(dataType)) {
    sankeyLayoutInputData = transformDataToNodeLinkData(cutoffCircle(data2, sourceField, targetField), sourceField, targetField, weightField, rawFields);
  } else {
    sankeyLayoutInputData = data2;
  }
  var _b = sankeyLayout({
    nodeAlign,
    nodePadding: getNodePaddingRatio(nodePadding, nodePaddingRatio, height),
    nodeWidth: getNodeWidthRatio(nodeWidth, nodeWidthRatio, width),
    nodeSort,
    nodeDepth
  }, sankeyLayoutInputData), nodes = _b.nodes, links = _b.links;
  return {
    nodes: nodes.map(function(node) {
      return __assign$4(__assign$4({}, pick(node, __spreadArrays(["x", "y", "name"], rawFields))), { isNode: true });
    }),
    edges: links.map(function(link) {
      return __assign$4(__assign$4({ source: link.source.name, target: link.target.name, name: link.source.name || link.target.name }, pick(link, __spreadArrays(["x", "y", "value"], rawFields))), { isNode: false });
    })
  };
}
var X_FIELD$1 = "x";
var Y_FIELD$1 = "y";
var COLOR_FIELD = "name";
var NODES_VIEW_ID = "nodes";
var EDGES_VIEW_ID = "edges";
function defaultOptions$1(params) {
  var options = params.options;
  var _a2 = options.rawFields, rawFields = _a2 === void 0 ? [] : _a2;
  return deepAssign({}, {
    options: {
      tooltip: {
        fields: uniq$2(__spreadArrays(["name", "source", "target", "value", "isNode"], rawFields))
      },
      label: {
        fields: uniq$2(__spreadArrays(["x", "name"], rawFields))
      }
    }
  }, params);
}
function geometry$1(params) {
  var chart = params.chart, options = params.options;
  var color2 = options.color, nodeStyle = options.nodeStyle, edgeStyle = options.edgeStyle, label2 = options.label, tooltip2 = options.tooltip, nodeState = options.nodeState, edgeState = options.edgeState;
  chart.legend(false);
  chart.tooltip(tooltip2);
  chart.axis(false);
  chart.coordinate().reflect("y");
  var _a2 = transformToViewsData(options, chart.width, chart.height), nodes = _a2.nodes, edges = _a2.edges;
  var edgeView = chart.createView({ id: EDGES_VIEW_ID });
  edgeView.data(edges);
  edge({
    chart: edgeView,
    options: {
      xField: X_FIELD$1,
      yField: Y_FIELD$1,
      seriesField: COLOR_FIELD,
      edge: {
        color: color2,
        style: edgeStyle,
        shape: "arc"
      },
      tooltip: tooltip2,
      state: edgeState
    }
  });
  var nodeView = chart.createView({ id: NODES_VIEW_ID });
  nodeView.data(nodes);
  polygon({
    chart: nodeView,
    options: {
      xField: X_FIELD$1,
      yField: Y_FIELD$1,
      seriesField: COLOR_FIELD,
      polygon: {
        color: color2,
        style: nodeStyle
      },
      label: label2,
      tooltip: tooltip2,
      state: nodeState
    }
  });
  chart.interaction("element-active");
  chart.scale({
    x: { sync: true, nice: true, min: 0, max: 1, minLimit: 0, maxLimit: 1 },
    y: { sync: true, nice: true, min: 0, max: 1, minLimit: 0, maxLimit: 1 },
    name: { sync: "color", type: "cat" }
  });
  return params;
}
function animation$1(params) {
  var chart = params.chart, options = params.options;
  var animation2 = options.animation;
  if (typeof animation2 === "boolean") {
    chart.animate(animation2);
  } else {
    chart.animate(true);
  }
  var geometries = __spreadArrays(chart.views[0].geometries, chart.views[1].geometries);
  geometries.forEach(function(g2) {
    g2.animate(animation2);
  });
  return params;
}
function nodeDraggable(params) {
  var chart = params.chart, options = params.options;
  var nodeDraggable2 = options.nodeDraggable;
  var DRAG_INTERACTION = "sankey-node-draggable";
  if (nodeDraggable2) {
    chart.interaction(DRAG_INTERACTION);
  } else {
    chart.removeInteraction(DRAG_INTERACTION);
  }
  return params;
}
function interaction$1(params) {
  var chart = params.chart, options = params.options;
  var _a2 = options.interactions, interactions = _a2 === void 0 ? [] : _a2;
  var nodeInteractions = [].concat(interactions, options.nodeInteractions || []);
  var edgeInteractions = [].concat(interactions, options.edgeInteractions || []);
  var nodeView = findViewById(chart, NODES_VIEW_ID);
  var edgeView = findViewById(chart, EDGES_VIEW_ID);
  nodeInteractions.forEach(function(i2) {
    if ((i2 === null || i2 === void 0 ? void 0 : i2.enable) === false) {
      nodeView.removeInteraction(i2.type);
    } else {
      nodeView.interaction(i2.type, i2.cfg || {});
    }
  });
  edgeInteractions.forEach(function(i2) {
    if ((i2 === null || i2 === void 0 ? void 0 : i2.enable) === false) {
      edgeView.removeInteraction(i2.type);
    } else {
      edgeView.interaction(i2.type, i2.cfg || {});
    }
  });
  return params;
}
function adaptor$4(params) {
  return flow(
    defaultOptions$1,
    geometry$1,
    interaction$1,
    nodeDraggable,
    animation$1,
    theme$2
  )(params);
}
var SankeyNodeDragAction = function(_super) {
  __extends$3(SankeyNodeDragAction2, _super);
  function SankeyNodeDragAction2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.isDragging = false;
    return _this;
  }
  SankeyNodeDragAction2.prototype.isNodeElement = function() {
    var shape = get(this.context, "event.target");
    if (shape) {
      var element = shape.get("element");
      return element && element.getModel().data.isNode;
    }
    return false;
  };
  SankeyNodeDragAction2.prototype.getNodeView = function() {
    return findViewById(this.context.view, NODES_VIEW_ID);
  };
  SankeyNodeDragAction2.prototype.getEdgeView = function() {
    return findViewById(this.context.view, EDGES_VIEW_ID);
  };
  SankeyNodeDragAction2.prototype.getCurrentDatumIdx = function(element) {
    return this.getNodeView().geometries[0].elements.indexOf(element);
  };
  SankeyNodeDragAction2.prototype.start = function() {
    if (this.isNodeElement()) {
      this.prevPoint = {
        x: get(this.context, "event.x"),
        y: get(this.context, "event.y")
      };
      var element = this.context.event.target.get("element");
      var idx = this.getCurrentDatumIdx(element);
      if (idx === -1) {
        return;
      }
      this.currentElementIdx = idx;
      this.context.isDragging = true;
      this.isDragging = true;
      this.prevNodeAnimateCfg = this.getNodeView().getOptions().animate;
      this.prevEdgeAnimateCfg = this.getEdgeView().getOptions().animate;
      this.getNodeView().animate(false);
      this.getEdgeView().animate(false);
    }
  };
  SankeyNodeDragAction2.prototype.translate = function() {
    if (this.isDragging) {
      var chart = this.context.view;
      var currentPoint = {
        x: get(this.context, "event.x"),
        y: get(this.context, "event.y")
      };
      var x2 = currentPoint.x - this.prevPoint.x;
      var y2 = currentPoint.y - this.prevPoint.y;
      var nodeView = this.getNodeView();
      var element = nodeView.geometries[0].elements[this.currentElementIdx];
      if (element && element.getModel()) {
        var prevDatum = element.getModel().data;
        var data2 = nodeView.getOptions().data;
        var coordinate2 = nodeView.getCoordinate();
        var datumGap_1 = {
          x: x2 / coordinate2.getWidth(),
          y: y2 / coordinate2.getHeight()
        };
        var nextDatum = __assign$4(__assign$4({}, prevDatum), { x: prevDatum.x.map(function(x3) {
          return x3 += datumGap_1.x;
        }), y: prevDatum.y.map(function(y3) {
          return y3 += datumGap_1.y;
        }) });
        var newData = __spreadArrays(data2);
        newData[this.currentElementIdx] = nextDatum;
        nodeView.data(newData);
        var name_1 = prevDatum.name;
        var edgeView = this.getEdgeView();
        var edgeData = edgeView.getOptions().data;
        edgeData.forEach(function(datum) {
          if (datum.source === name_1) {
            datum.x[0] += datumGap_1.x;
            datum.x[1] += datumGap_1.x;
            datum.y[0] += datumGap_1.y;
            datum.y[1] += datumGap_1.y;
          }
          if (datum.target === name_1) {
            datum.x[2] += datumGap_1.x;
            datum.x[3] += datumGap_1.x;
            datum.y[2] += datumGap_1.y;
            datum.y[3] += datumGap_1.y;
          }
        });
        edgeView.data(edgeData);
        this.prevPoint = currentPoint;
        chart.render(true);
      }
    }
  };
  SankeyNodeDragAction2.prototype.end = function() {
    this.isDragging = false;
    this.context.isDragging = false;
    this.prevPoint = null;
    this.currentElementIdx = null;
    this.getNodeView().animate(this.prevNodeAnimateCfg);
    this.getEdgeView().animate(this.prevEdgeAnimateCfg);
  };
  return SankeyNodeDragAction2;
}(Action);
registerAction("sankey-node-drag", SankeyNodeDragAction);
registerInteraction("sankey-node-draggable", {
  showEnable: [
    { trigger: "polygon:mouseenter", action: "cursor:pointer" },
    { trigger: "polygon:mouseleave", action: "cursor:default" }
  ],
  start: [{ trigger: "polygon:mousedown", action: "sankey-node-drag:start" }],
  processing: [
    { trigger: "plot:mousemove", action: "sankey-node-drag:translate" },
    { isEnable: function(context2) {
      return context2.isDragging;
    }, trigger: "plot:mousemove", action: "cursor:move" }
  ],
  end: [{ trigger: "plot:mouseup", action: "sankey-node-drag:end" }]
});
(function(_super) {
  __extends$3(Sankey2, _super);
  function Sankey2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "sankey";
    return _this;
  }
  Sankey2.getDefaultOptions = function() {
    return {
      appendPadding: 8,
      syncViewPadding: true,
      nodeStyle: {
        opacity: 1,
        fillOpacity: 1,
        lineWidth: 1
      },
      edgeStyle: {
        opacity: 0.3,
        lineWidth: 0
      },
      edgeState: {
        active: {
          style: {
            opacity: 0.8,
            lineWidth: 0
          }
        }
      },
      label: {
        formatter: function(_a2) {
          var name = _a2.name;
          return name;
        },
        callback: function(x2) {
          var isLast = x2[1] === 1;
          return {
            style: {
              fill: "#545454",
              textAlign: isLast ? "end" : "start"
            },
            offsetX: isLast ? -8 : 8
          };
        },
        layout: [
          {
            type: "hide-overlap"
          }
        ]
      },
      tooltip: {
        showTitle: false,
        showMarkers: false,
        shared: false,
        showContent: function(items) {
          return !get(items, [0, "data", "isNode"]);
        },
        formatter: function(datum) {
          var source = datum.source, target = datum.target, value2 = datum.value;
          return {
            name: source + " -> " + target,
            value: value2
          };
        }
      },
      nodeWidthRatio: 8e-3,
      nodePaddingRatio: 0.01,
      animation: {
        appear: {
          animation: "wave-in"
        },
        enter: {
          animation: "wave-in"
        }
      }
    };
  };
  Sankey2.prototype.changeData = function(data2) {
    this.updateOption({ data: data2 });
    var _a2 = transformToViewsData(this.options, this.chart.width, this.chart.height), nodes = _a2.nodes, edges = _a2.edges;
    var nodesView = findViewById(this.chart, NODES_VIEW_ID);
    var edgesView = findViewById(this.chart, EDGES_VIEW_ID);
    nodesView.changeData(nodes);
    edgesView.changeData(edges);
  };
  Sankey2.prototype.getSchemaAdaptor = function() {
    return adaptor$4;
  };
  Sankey2.prototype.getDefaultOptions = function() {
    return Sankey2.getDefaultOptions();
  };
  return Sankey2;
})(Plot);
var DEFAULT_OPTIONS$4 = {
  y: 0,
  nodeWidthRatio: 0.05,
  weight: false,
  nodePaddingRatio: 0.1,
  id: function(node) {
    return node.id;
  },
  source: function(edge2) {
    return edge2.source;
  },
  target: function(edge2) {
    return edge2.target;
  },
  sourceWeight: function(edge2) {
    return edge2.value || 1;
  },
  targetWeight: function(edge2) {
    return edge2.value || 1;
  },
  sortBy: null
};
function processGraph(nodeById, edges, options) {
  each$1(nodeById, function(node, id2) {
    node.inEdges = edges.filter(function(edge2) {
      return "" + options.target(edge2) === "" + id2;
    });
    node.outEdges = edges.filter(function(edge2) {
      return "" + options.source(edge2) === "" + id2;
    });
    node.edges = node.outEdges.concat(node.inEdges);
    node.frequency = node.edges.length;
    node.value = 0;
    node.inEdges.forEach(function(edge2) {
      node.value += options.targetWeight(edge2);
    });
    node.outEdges.forEach(function(edge2) {
      node.value += options.sourceWeight(edge2);
    });
  });
}
function sortNodes(nodes, options) {
  var sortMethods = {
    weight: function(a2, b10) {
      return b10.value - a2.value;
    },
    frequency: function(a2, b10) {
      return b10.frequency - a2.frequency;
    },
    id: function(a2, b10) {
      return ("" + options.id(a2)).localeCompare("" + options.id(b10));
    }
  };
  var method4 = sortMethods[options.sortBy];
  if (!method4 && isFunction(options.sortBy)) {
    method4 = options.sortBy;
  }
  if (method4) {
    nodes.sort(method4);
  }
}
function layoutNodes(nodes, options) {
  var len = nodes.length;
  if (!len) {
    throw new TypeError("Invalid nodes: it's empty!");
  }
  if (options.weight) {
    var nodePaddingRatio_1 = options.nodePaddingRatio;
    if (nodePaddingRatio_1 < 0 || nodePaddingRatio_1 >= 1) {
      throw new TypeError("Invalid nodePaddingRatio: it must be in range [0, 1)!");
    }
    var margin_1 = nodePaddingRatio_1 / (2 * len);
    var nodeWidthRatio_1 = options.nodeWidthRatio;
    if (nodeWidthRatio_1 <= 0 || nodeWidthRatio_1 >= 1) {
      throw new TypeError("Invalid nodeWidthRatio: it must be in range (0, 1)!");
    }
    var totalValue_1 = 0;
    nodes.forEach(function(node) {
      totalValue_1 += node.value;
    });
    nodes.forEach(function(node) {
      node.weight = node.value / totalValue_1;
      node.width = node.weight * (1 - nodePaddingRatio_1);
      node.height = nodeWidthRatio_1;
    });
    nodes.forEach(function(node, index2) {
      var deltaX = 0;
      for (var i2 = index2 - 1; i2 >= 0; i2--) {
        deltaX += nodes[i2].width + 2 * margin_1;
      }
      var minX = node.minX = margin_1 + deltaX;
      var maxX = node.maxX = node.minX + node.width;
      var minY = node.minY = options.y - nodeWidthRatio_1 / 2;
      var maxY2 = node.maxY = minY + nodeWidthRatio_1;
      node.x = [minX, maxX, maxX, minX];
      node.y = [minY, minY, maxY2, maxY2];
    });
  } else {
    var deltaX_1 = 1 / len;
    nodes.forEach(function(node, index2) {
      node.x = (index2 + 0.5) * deltaX_1;
      node.y = options.y;
    });
  }
  return nodes;
}
function locatingEdges(nodeById, edges, options) {
  if (options.weight) {
    var valueById_1 = {};
    each$1(nodeById, function(node, id2) {
      valueById_1[id2] = node.value;
    });
    edges.forEach(function(edge2) {
      var sId = options.source(edge2);
      var tId = options.target(edge2);
      var sNode = nodeById[sId];
      var tNode = nodeById[tId];
      if (sNode && tNode) {
        var sValue = valueById_1[sId];
        var currentSValue = options.sourceWeight(edge2);
        var sStart = sNode.minX + (sNode.value - sValue) / sNode.value * sNode.width;
        var sEnd = sStart + currentSValue / sNode.value * sNode.width;
        valueById_1[sId] -= currentSValue;
        var tValue = valueById_1[tId];
        var currentTValue = options.targetWeight(edge2);
        var tStart = tNode.minX + (tNode.value - tValue) / tNode.value * tNode.width;
        var tEnd = tStart + currentTValue / tNode.value * tNode.width;
        valueById_1[tId] -= currentTValue;
        var y2 = options.y;
        edge2.x = [sStart, sEnd, tStart, tEnd];
        edge2.y = [y2, y2, y2, y2];
        edge2.source = sNode;
        edge2.target = tNode;
      }
    });
  } else {
    edges.forEach(function(edge2) {
      var sNode = nodeById[options.source(edge2)];
      var tNode = nodeById[options.target(edge2)];
      if (sNode && tNode) {
        edge2.x = [sNode.x, tNode.x];
        edge2.y = [sNode.y, tNode.y];
        edge2.source = sNode;
        edge2.target = tNode;
      }
    });
  }
  return edges;
}
function getDefaultOptions(options) {
  return mix({}, DEFAULT_OPTIONS$4, options);
}
function chordLayout(chordLayoutOptions, chordLayoutInputData) {
  var options = getDefaultOptions(chordLayoutOptions);
  var nodeById = {};
  var nodes = chordLayoutInputData.nodes;
  var links = chordLayoutInputData.links;
  nodes.forEach(function(node) {
    var id2 = options.id(node);
    nodeById[id2] = node;
  });
  processGraph(nodeById, links, options);
  sortNodes(nodes, options);
  var outputNodes = layoutNodes(nodes, options);
  var outputLinks = locatingEdges(nodeById, links, options);
  return {
    nodes: outputNodes,
    links: outputLinks
  };
}
var X_FIELD = "x";
var Y_FIELD = "y";
var NODE_COLOR_FIELD = "name";
var EDGE_COLOR_FIELD = "source";
var DEFAULT_OPTIONS$3 = {
  nodeStyle: {
    opacity: 1,
    fillOpacity: 1,
    lineWidth: 1
  },
  edgeStyle: {
    opacity: 0.5,
    lineWidth: 2
  },
  label: {
    fields: ["x", "name"],
    callback: function(x2, name) {
      var centerX = (x2[0] + x2[1]) / 2;
      var offsetX = centerX > 0.5 ? -4 : 4;
      return {
        labelEmit: true,
        style: {
          fill: "#8c8c8c"
        },
        offsetX,
        content: name
      };
    }
  },
  tooltip: {
    showTitle: false,
    showMarkers: false,
    fields: ["source", "target", "value", "isNode"],
    showContent: function(items) {
      return !get(items, [0, "data", "isNode"]);
    },
    formatter: function(datum) {
      var source = datum.source, target = datum.target, value2 = datum.value;
      return {
        name: source + " -> " + target,
        value: value2
      };
    }
  },
  interactions: [
    {
      type: "element-active"
    }
  ],
  weight: true,
  nodePaddingRatio: 0.1,
  nodeWidthRatio: 0.05
};
function transformData$1(params) {
  var options = params.options;
  var data2 = options.data, sourceField = options.sourceField, targetField = options.targetField, weightField = options.weightField, nodePaddingRatio = options.nodePaddingRatio, nodeWidthRatio = options.nodeWidthRatio, _a2 = options.rawFields, rawFields = _a2 === void 0 ? [] : _a2;
  var chordLayoutInputData = transformDataToNodeLinkData(data2, sourceField, targetField, weightField);
  var _b = chordLayout({ weight: true, nodePaddingRatio, nodeWidthRatio }, chordLayoutInputData), nodes = _b.nodes, links = _b.links;
  var nodesData = nodes.map(function(node) {
    return __assign$4(__assign$4({}, pick(node, __spreadArrays(["id", "x", "y", "name"], rawFields))), { isNode: true });
  });
  var edgesData = links.map(function(link) {
    return __assign$4(__assign$4({ source: link.source.name, target: link.target.name, name: link.source.name || link.target.name }, pick(link, __spreadArrays(["x", "y", "value"], rawFields))), { isNode: false });
  });
  return __assign$4(__assign$4({}, params), { ext: __assign$4(__assign$4({}, params.ext), {
    chordData: { nodesData, edgesData }
  }) });
}
function scale(params) {
  var _a2;
  var chart = params.chart;
  chart.scale((_a2 = {
    x: { sync: true, nice: true },
    y: { sync: true, nice: true, max: 1 }
  }, _a2[NODE_COLOR_FIELD] = { sync: "color" }, _a2[EDGE_COLOR_FIELD] = { sync: "color" }, _a2));
  return params;
}
function axis$1(params) {
  var chart = params.chart;
  chart.axis(false);
  return params;
}
function legend(params) {
  var chart = params.chart;
  chart.legend(false);
  return params;
}
function tooltip$1(params) {
  var chart = params.chart, options = params.options;
  var tooltip2 = options.tooltip;
  chart.tooltip(tooltip2);
  return params;
}
function coordinate(params) {
  var chart = params.chart;
  chart.coordinate("polar").reflect("y");
  return params;
}
function nodeGeometry(params) {
  var chart = params.chart, options = params.options;
  var nodesData = params.ext.chordData.nodesData;
  var nodeStyle = options.nodeStyle, label2 = options.label, tooltip2 = options.tooltip;
  var nodeView = chart.createView();
  nodeView.data(nodesData);
  polygon({
    chart: nodeView,
    options: {
      xField: X_FIELD,
      yField: Y_FIELD,
      seriesField: NODE_COLOR_FIELD,
      polygon: {
        style: nodeStyle
      },
      label: label2,
      tooltip: tooltip2
    }
  });
  return params;
}
function edgeGeometry(params) {
  var chart = params.chart, options = params.options;
  var edgesData = params.ext.chordData.edgesData;
  var edgeStyle = options.edgeStyle, tooltip2 = options.tooltip;
  var edgeView = chart.createView();
  edgeView.data(edgesData);
  var edgeOptions = {
    xField: X_FIELD,
    yField: Y_FIELD,
    seriesField: EDGE_COLOR_FIELD,
    edge: {
      style: edgeStyle,
      shape: "arc"
    },
    tooltip: tooltip2
  };
  edge({
    chart: edgeView,
    options: edgeOptions
  });
  return params;
}
function animation(params) {
  var chart = params.chart, options = params.options;
  var animation2 = options.animation;
  if (typeof animation2 === "boolean") {
    chart.animate(animation2);
  } else {
    chart.animate(true);
  }
  each$1(getAllGeometriesRecursively(chart), function(g2) {
    g2.animate(animation2);
  });
  return params;
}
function adaptor$3(params) {
  return flow(theme$2, transformData$1, coordinate, scale, axis$1, legend, tooltip$1, edgeGeometry, nodeGeometry, interaction$7, state, animation)(params);
}
(function(_super) {
  __extends$3(Chord, _super);
  function Chord() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "chord";
    return _this;
  }
  Chord.getDefaultOptions = function() {
    return DEFAULT_OPTIONS$3;
  };
  Chord.prototype.getDefaultOptions = function() {
    return Chord.getDefaultOptions();
  };
  Chord.prototype.getSchemaAdaptor = function() {
    return adaptor$3;
  };
  return Chord;
})(Plot);
var DEFAULT_OPTIONS$2 = {
  field: "value",
  as: ["x", "y", "r"],
  sort: function(a2, b10) {
    return b10.value - a2.value;
  }
};
function pack(data2, options) {
  options = mix({}, DEFAULT_OPTIONS$2, options);
  var as = options.as;
  if (!isArray$1(as) || as.length !== 3) {
    throw new TypeError('Invalid as: it must be an array with 3 strings (e.g. [ "x", "y", "r" ])!');
  }
  var field2;
  try {
    field2 = getField(options);
  } catch (e3) {
    console.warn(e3);
  }
  var packLayout = function(data3) {
    return index$b().size(options.size).padding(options.padding)(hierarchy(data3).sum(function(d2) {
      return d2[field2];
    }).sort(options.sort));
  };
  var root2 = packLayout(data2);
  var x2 = as[0];
  var y2 = as[1];
  var r2 = as[2];
  root2.each(function(node) {
    node[x2] = node.x;
    node[y2] = node.y;
    node[r2] = node.r;
  });
  return getAllNodes(root2);
}
function transformData(options) {
  var data2 = options.data, hierarchyConfig = options.hierarchyConfig, _a2 = options.rawFields, rawFields = _a2 === void 0 ? [] : _a2, enableDrillDown = options.enableDrillDown;
  var nodes = pack(data2, __assign$4(__assign$4({}, hierarchyConfig), { field: "value", as: ["x", "y", "r"] }));
  var result = [];
  nodes.forEach(function(node) {
    var _a3;
    var path2 = node.data.name;
    var ancestorNode = __assign$4({}, node);
    while (ancestorNode.depth > 1) {
      path2 = ((_a3 = ancestorNode.parent.data) === null || _a3 === void 0 ? void 0 : _a3.name) + " / " + path2;
      ancestorNode = ancestorNode.parent;
    }
    if (enableDrillDown && node.depth > 2) {
      return null;
    }
    var nodeInfo = deepAssign({}, node.data, __assign$4(__assign$4(__assign$4({}, pick(node.data, rawFields)), { path: path2 }), node));
    nodeInfo.ext = hierarchyConfig;
    nodeInfo[HIERARCHY_DATA_TRANSFORM_PARAMS] = { hierarchyConfig, rawFields, enableDrillDown };
    result.push(nodeInfo);
  });
  return result;
}
function resolvePaddingForCircle(padding2, appendPadding, containerSize) {
  var tempPadding = resolveAllPadding([padding2, appendPadding]);
  var top = tempPadding[0], right2 = tempPadding[1], bottom = tempPadding[2], left2 = tempPadding[3];
  var width = containerSize.width, height = containerSize.height;
  var wSize = width - (left2 + right2);
  var hSize = height - (top + bottom);
  var minSize = Math.min(wSize, hSize);
  var restWidthPadding = (wSize - minSize) / 2;
  var restHeightPadding = (hSize - minSize) / 2;
  var finalTop = top + restHeightPadding;
  var finalRight = right2 + restWidthPadding;
  var finalBottom = bottom + restHeightPadding;
  var finalLeft = left2 + restWidthPadding;
  var finalPadding = [finalTop, finalRight, finalBottom, finalLeft];
  var finalSize = minSize < 0 ? 0 : minSize;
  return { finalPadding, finalSize };
}
var RAW_FIELDS = ["x", "y", "r", "name", "value", "path", "depth"];
var DEFAULT_OPTIONS$1 = {
  colorField: "name",
  autoFit: true,
  pointStyle: {
    lineWidth: 0,
    stroke: "#fff"
  },
  legend: false,
  hierarchyConfig: {
    size: [1, 1],
    padding: 0
  },
  label: {
    fields: ["name"],
    layout: {
      type: "limit-in-shape"
    }
  },
  tooltip: {
    showMarkers: false,
    showTitle: false
  },
  drilldown: { enabled: false }
};
function defaultOptions(params) {
  var chart = params.chart;
  var diameter = Math.min(chart.viewBBox.width, chart.viewBBox.height);
  return deepAssign({
    options: {
      size: function(_a2) {
        var r2 = _a2.r;
        return r2 * diameter;
      }
    }
  }, params);
}
function padding(params) {
  var options = params.options, chart = params.chart;
  var containerSize = chart.viewBBox;
  var padding2 = options.padding, appendPadding = options.appendPadding, drilldown = options.drilldown;
  var tempAppendPadding = appendPadding;
  if (drilldown === null || drilldown === void 0 ? void 0 : drilldown.enabled) {
    var appendPaddingByDrilldown = getAdjustAppendPadding(chart.appendPadding, get(drilldown, ["breadCrumb", "position"]));
    tempAppendPadding = resolveAllPadding([appendPaddingByDrilldown, appendPadding]);
  }
  var finalPadding = resolvePaddingForCircle(padding2, tempAppendPadding, containerSize).finalPadding;
  chart.padding = finalPadding;
  chart.appendPadding = 0;
  return params;
}
function geometry(params) {
  var chart = params.chart, options = params.options;
  var padding2 = chart.padding, appendPadding = chart.appendPadding;
  var color2 = options.color, colorField = options.colorField, pointStyle = options.pointStyle, hierarchyConfig = options.hierarchyConfig, sizeField = options.sizeField, _a2 = options.rawFields, rawFields = _a2 === void 0 ? [] : _a2, drilldown = options.drilldown;
  var data2 = transformData({
    data: options.data,
    hierarchyConfig,
    enableDrillDown: drilldown === null || drilldown === void 0 ? void 0 : drilldown.enabled,
    rawFields
  });
  chart.data(data2);
  var containerSize = chart.viewBBox;
  var finalSize = resolvePaddingForCircle(padding2, appendPadding, containerSize).finalSize;
  var circleSize = function(_a3) {
    var r2 = _a3.r;
    return r2 * finalSize;
  };
  if (sizeField) {
    circleSize = function(d2) {
      return d2[sizeField] * finalSize;
    };
  }
  point(deepAssign({}, params, {
    options: {
      xField: "x",
      yField: "y",
      seriesField: colorField,
      sizeField,
      rawFields: __spreadArrays(RAW_FIELDS, rawFields),
      point: {
        color: color2,
        style: pointStyle,
        shape: "circle",
        size: circleSize
      }
    }
  }));
  return params;
}
function meta(params) {
  return flow(scale$2({}, {
    x: { min: 0, max: 1, minLimit: 0, maxLimit: 1, nice: true },
    y: { min: 0, max: 1, minLimit: 0, maxLimit: 1, nice: true }
  }))(params);
}
function tooltip(params) {
  var chart = params.chart, options = params.options;
  var tooltip2 = options.tooltip;
  if (tooltip2 === false) {
    chart.tooltip(false);
  } else {
    var tooltipOptions = tooltip2;
    if (!get(tooltip2, "fields")) {
      tooltipOptions = deepAssign({}, {
        customItems: function(items) {
          return items.map(function(item) {
            var scales = get(chart.getOptions(), "scales");
            var nameFormatter = get(scales, ["name", "formatter"], function(v2) {
              return v2;
            });
            var valueFormatter = get(scales, ["value", "formatter"], function(v2) {
              return v2;
            });
            return __assign$4(__assign$4({}, item), { name: nameFormatter(item.data.name), value: valueFormatter(item.data.value) });
          });
        }
      }, tooltipOptions);
    }
    chart.tooltip(tooltipOptions);
  }
  return params;
}
function axis(params) {
  var chart = params.chart;
  chart.axis(false);
  return params;
}
function adaptorInteraction(options) {
  var drilldown = options.drilldown, _a2 = options.interactions, interactions = _a2 === void 0 ? [] : _a2;
  if (drilldown === null || drilldown === void 0 ? void 0 : drilldown.enabled) {
    return deepAssign({}, options, {
      interactions: __spreadArrays(interactions, [
        {
          type: "drill-down",
          cfg: { drillDownConfig: drilldown, transformData, enableDrillDown: true }
        }
      ])
    });
  }
  return options;
}
function interaction(params) {
  var chart = params.chart, options = params.options;
  interaction$7({
    chart,
    options: adaptorInteraction(options)
  });
  return params;
}
function adaptor$2(params) {
  return flow(pattern("pointStyle"), defaultOptions, padding, theme$2, meta, geometry, axis, legend$g, tooltip, interaction, animation$5, annotation$2())(params);
}
(function(_super) {
  __extends$3(CirclePacking, _super);
  function CirclePacking() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "circle-packing";
    return _this;
  }
  CirclePacking.getDefaultOptions = function() {
    return DEFAULT_OPTIONS$1;
  };
  CirclePacking.prototype.getDefaultOptions = function() {
    return CirclePacking.getDefaultOptions();
  };
  CirclePacking.prototype.getSchemaAdaptor = function() {
    return adaptor$2;
  };
  CirclePacking.prototype.triggerResize = function() {
    if (!this.chart.destroyed) {
      this.chart.forceFit();
      this.chart.clear();
      this.execAdaptor();
      this.chart.render(true);
    }
  };
  return CirclePacking;
})(Plot);
(function(_super) {
  __extends$3(P2, _super);
  function P2(container, options, adaptor2, defaultOptions2) {
    var _this = _super.call(this, container, deepAssign({}, defaultOptions2, options)) || this;
    _this.type = "g2-plot";
    _this.defaultOptions = defaultOptions2;
    _this.adaptor = adaptor2;
    return _this;
  }
  P2.prototype.getDefaultOptions = function() {
    return this.defaultOptions;
  };
  P2.prototype.getSchemaAdaptor = function() {
    return this.adaptor;
  };
  return P2;
})(Plot);
var PLOT_ADAPTORS = {
  line: adaptor$y,
  pie: adaptor$u,
  column: adaptor$w,
  bar: adaptor$v,
  area: adaptor$x,
  gauge: adaptor$9,
  "tiny-line": adaptor$n,
  "tiny-column": adaptor$m,
  "tiny-area": adaptor$o,
  "ring-progress": adaptor$j,
  progress: adaptor$k,
  scatter: adaptor$r,
  histogram: adaptor$l,
  funnel: adaptor$d,
  stock: adaptor$e
};
var PLOT_CONSTRUCTOR = {
  line: Line$1,
  pie: Pie,
  column: Column,
  bar: Bar,
  area: Area,
  gauge: Gauge,
  "tiny-line": TinyLine,
  "tiny-column": TinyColumn,
  "tiny-area": TinyArea,
  "ring-progress": RingProgress,
  progress: Progress,
  scatter: Scatter,
  histogram: Histogram,
  funnel: Funnel,
  stock: Stock
};
var DEFAULT_OPTIONS_MAP = {
  pie: { label: false },
  column: { tooltip: { showMarkers: false } },
  bar: { tooltip: { showMarkers: false } }
};
function execPlotAdaptor(plot, view, options) {
  var cls = PLOT_CONSTRUCTOR[plot];
  if (!cls) {
    console.error("could not find " + plot + " plot");
    return;
  }
  var module = PLOT_ADAPTORS[plot];
  module({
    chart: view,
    options: deepAssign({}, cls.getDefaultOptions(), get(DEFAULT_OPTIONS_MAP, plot, {}), options)
  });
}
function multiView(params) {
  var chart = params.chart, options = params.options;
  var views = options.views, legend2 = options.legend;
  each$1(views, function(v2) {
    var region = v2.region, data2 = v2.data, meta2 = v2.meta, axes = v2.axes, coordinate2 = v2.coordinate, interactions = v2.interactions, annotations = v2.annotations, tooltip2 = v2.tooltip, geometries = v2.geometries;
    var viewOfG2 = chart.createView({
      region
    });
    viewOfG2.data(data2);
    var scales = {};
    if (axes) {
      each$1(axes, function(axis2, field2) {
        scales[field2] = pick(axis2, AXIS_META_CONFIG_KEYS);
      });
    }
    scales = deepAssign({}, meta2, scales);
    viewOfG2.scale(scales);
    if (!axes) {
      viewOfG2.axis(false);
    } else {
      each$1(axes, function(axis2, field2) {
        viewOfG2.axis(field2, axis2);
      });
    }
    viewOfG2.coordinate(coordinate2);
    each$1(geometries, function(geometry2) {
      var ext = geometry$x({
        chart: viewOfG2,
        options: geometry2
      }).ext;
      var adjust2 = geometry2.adjust;
      if (adjust2) {
        ext.geometry.adjust(adjust2);
      }
    });
    each$1(interactions, function(interaction2) {
      if (interaction2.enable === false) {
        viewOfG2.removeInteraction(interaction2.type);
      } else {
        viewOfG2.interaction(interaction2.type, interaction2.cfg);
      }
    });
    each$1(annotations, function(annotation2) {
      viewOfG2.annotation()[annotation2.type](__assign$4({}, annotation2));
    });
    if (typeof v2.animation === "boolean") {
      viewOfG2.animate(false);
    } else {
      viewOfG2.animate(true);
      each$1(viewOfG2.geometries, function(g2) {
        g2.animate(v2.animation);
      });
    }
    if (tooltip2) {
      viewOfG2.interaction("tooltip");
      viewOfG2.tooltip(tooltip2);
    }
  });
  if (!legend2) {
    chart.legend(false);
  } else {
    each$1(legend2, function(l2, field2) {
      chart.legend(field2, l2);
    });
  }
  chart.tooltip(options.tooltip);
  return params;
}
function multiPlot(params) {
  var chart = params.chart, options = params.options;
  var plots = options.plots, _a2 = options.data, data2 = _a2 === void 0 ? [] : _a2;
  each$1(plots, function(plot) {
    var type4 = plot.type, region = plot.region, _a3 = plot.options, options2 = _a3 === void 0 ? {} : _a3, top = plot.top;
    var tooltip2 = options2.tooltip;
    if (top) {
      execPlotAdaptor(type4, chart, __assign$4(__assign$4({}, options2), { data: data2 }));
      return;
    }
    var viewOfG2 = chart.createView(__assign$4({ region }, pick(options2, PLOT_CONTAINER_OPTIONS)));
    if (tooltip2) {
      viewOfG2.interaction("tooltip");
    }
    execPlotAdaptor(type4, viewOfG2, __assign$4({ data: data2 }, options2));
  });
  return params;
}
function slider(params) {
  var chart = params.chart, options = params.options;
  chart.option("slider", options.slider);
  return params;
}
function adaptor$1(params) {
  return flow(
    animation$5,
    multiView,
    multiPlot,
    interaction$7,
    animation$5,
    theme$2,
    tooltip$9,
    slider,
    annotation$2()
  )(params);
}
function getElementValue(element, field2) {
  var model = element.getModel();
  var record = model.data;
  var value2;
  if (isArray$1(record)) {
    value2 = record[0][field2];
  } else {
    value2 = record[field2];
  }
  return value2;
}
function clearHighlight(view) {
  var elements = getAllElements(view);
  each$1(elements, function(el) {
    if (el.hasState("active")) {
      el.setState("active", false);
    }
    if (el.hasState("selected")) {
      el.setState("selected", false);
    }
    if (el.hasState("inactive")) {
      el.setState("inactive", false);
    }
  });
}
var Association = function(_super) {
  __extends$3(Association2, _super);
  function Association2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Association2.prototype.getAssociationItems = function(views, params) {
    var _a2;
    var event = this.context.event;
    var _b = params || {}, linkField = _b.linkField, dim = _b.dim;
    var items = [];
    if ((_a2 = event.data) === null || _a2 === void 0 ? void 0 : _a2.data) {
      var data_1 = event.data.data;
      each$1(views, function(v2) {
        var _a3, _b2;
        var field2 = linkField;
        if (dim === "x") {
          field2 = v2.getXScale().field;
        } else if (dim === "y") {
          field2 = (_a3 = v2.getYScales().find(function(s2) {
            return s2.field === field2;
          })) === null || _a3 === void 0 ? void 0 : _a3.field;
        } else if (!field2) {
          field2 = (_b2 = v2.getGroupScales()[0]) === null || _b2 === void 0 ? void 0 : _b2.field;
        }
        if (!field2) {
          return;
        }
        var elements = map$2(getAllElements(v2), function(ele) {
          var active = false;
          var inactive = false;
          var dataValue = isArray$1(data_1) ? get(data_1[0], field2) : get(data_1, field2);
          if (getElementValue(ele, field2) === dataValue) {
            active = true;
          } else {
            inactive = true;
          }
          return { element: ele, view: v2, active, inactive };
        });
        items.push.apply(items, elements);
      });
    }
    return items;
  };
  Association2.prototype.showTooltip = function(params) {
    var siblings2 = getSiblingViews(this.context.view);
    var elements = this.getAssociationItems(siblings2, params);
    each$1(elements, function(ele) {
      if (ele.active) {
        var box2 = ele.element.shape.getCanvasBBox();
        ele.view.showTooltip({ x: box2.minX + box2.width / 2, y: box2.minY + box2.height / 2 });
      }
    });
  };
  Association2.prototype.hideTooltip = function() {
    var siblings2 = getSiblingViews(this.context.view);
    each$1(siblings2, function(sibling) {
      sibling.hideTooltip();
    });
  };
  Association2.prototype.active = function(params) {
    var views = getViews(this.context.view);
    var items = this.getAssociationItems(views, params);
    each$1(items, function(item) {
      var active = item.active, element = item.element;
      if (active) {
        element.setState("active", true);
      }
    });
  };
  Association2.prototype.selected = function(params) {
    var views = getViews(this.context.view);
    var items = this.getAssociationItems(views, params);
    each$1(items, function(item) {
      var active = item.active, element = item.element;
      if (active) {
        element.setState("selected", true);
      }
    });
  };
  Association2.prototype.highlight = function(params) {
    var views = getViews(this.context.view);
    var items = this.getAssociationItems(views, params);
    each$1(items, function(item) {
      var inactive = item.inactive, element = item.element;
      if (inactive) {
        element.setState("inactive", true);
      }
    });
  };
  Association2.prototype.reset = function() {
    var views = getViews(this.context.view);
    each$1(views, function(v2) {
      clearHighlight(v2);
    });
  };
  return Association2;
}(Action);
registerAction("association", Association);
registerInteraction("association-active", {
  start: [{ trigger: "element:mouseenter", action: "association:active" }],
  end: [{ trigger: "element:mouseleave", action: "association:reset" }]
});
registerInteraction("association-selected", {
  start: [{ trigger: "element:mouseenter", action: "association:selected" }],
  end: [{ trigger: "element:mouseleave", action: "association:reset" }]
});
registerInteraction("association-highlight", {
  start: [{ trigger: "element:mouseenter", action: "association:highlight" }],
  end: [{ trigger: "element:mouseleave", action: "association:reset" }]
});
registerInteraction("association-tooltip", {
  start: [{ trigger: "element:mousemove", action: "association:showTooltip" }],
  end: [{ trigger: "element:mouseleave", action: "association:hideTooltip" }]
});
(function(_super) {
  __extends$3(Mix, _super);
  function Mix() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "mix";
    return _this;
  }
  Mix.prototype.getSchemaAdaptor = function() {
    return adaptor$1;
  };
  return Mix;
})(Plot);
function execViewAdaptor(viewOfG2, options) {
  var data2 = options.data, coordinate2 = options.coordinate, interactions = options.interactions, annotations = options.annotations, animation2 = options.animation, tooltip2 = options.tooltip, axes = options.axes, meta2 = options.meta, geometries = options.geometries;
  if (data2) {
    viewOfG2.data(data2);
  }
  var scales = {};
  if (axes) {
    each$1(axes, function(axis2, field2) {
      scales[field2] = pick(axis2, AXIS_META_CONFIG_KEYS);
    });
  }
  scales = deepAssign({}, meta2, scales);
  viewOfG2.scale(scales);
  if (coordinate2) {
    viewOfG2.coordinate(coordinate2);
  }
  if (axes === false) {
    viewOfG2.axis(false);
  } else {
    each$1(axes, function(axis2, field2) {
      viewOfG2.axis(field2, axis2);
    });
  }
  each$1(geometries, function(geometry2) {
    var ext = geometry$x({
      chart: viewOfG2,
      options: geometry2
    }).ext;
    var adjust2 = geometry2.adjust;
    if (adjust2) {
      ext.geometry.adjust(adjust2);
    }
  });
  each$1(interactions, function(interaction2) {
    if (interaction2.enable === false) {
      viewOfG2.removeInteraction(interaction2.type);
    } else {
      viewOfG2.interaction(interaction2.type, interaction2.cfg);
    }
  });
  each$1(annotations, function(annotation2) {
    viewOfG2.annotation()[annotation2.type](__assign$4({}, annotation2));
  });
  if (typeof animation2 === "boolean") {
    viewOfG2.animate(false);
  } else {
    viewOfG2.animate(true);
    each$1(viewOfG2.geometries, function(g2) {
      g2.animate(animation2);
    });
  }
  if (tooltip2) {
    viewOfG2.interaction("tooltip");
    viewOfG2.tooltip(tooltip2);
  } else if (tooltip2 === false) {
    viewOfG2.removeInteraction("tooltip");
  }
}
function facetAdaptor(params) {
  var chart = params.chart, options = params.options;
  var facetType = options.type, data2 = options.data, fields = options.fields, eachView = options.eachView;
  var restFacetCfg = omit$1(options, [
    "type",
    "data",
    "fields",
    "eachView",
    "axes",
    "meta",
    "tooltip",
    "coordinate",
    "theme",
    "legend",
    "interactions",
    "annotations"
  ]);
  chart.data(data2);
  chart.facet(facetType, __assign$4(__assign$4({}, restFacetCfg), { fields, eachView: function(viewOfG2, facet) {
    var viewOptions = eachView(viewOfG2, facet);
    if (viewOptions.geometries) {
      execViewAdaptor(viewOfG2, viewOptions);
    } else {
      var plot = viewOptions;
      var plotOptions = plot.options;
      if (plotOptions.tooltip) {
        viewOfG2.interaction("tooltip");
      }
      execPlotAdaptor(plot.type, viewOfG2, plotOptions);
    }
  } }));
  return params;
}
function component(params) {
  var chart = params.chart, options = params.options;
  var axes = options.axes, meta2 = options.meta, tooltip2 = options.tooltip, coordinate2 = options.coordinate, theme2 = options.theme, legend2 = options.legend, interactions = options.interactions, annotations = options.annotations;
  var scales = {};
  if (axes) {
    each$1(axes, function(axis2, field2) {
      scales[field2] = pick(axis2, AXIS_META_CONFIG_KEYS);
    });
  }
  scales = deepAssign({}, meta2, scales);
  chart.scale(scales);
  chart.coordinate(coordinate2);
  if (!axes) {
    chart.axis(false);
  } else {
    each$1(axes, function(axis2, field2) {
      chart.axis(field2, axis2);
    });
  }
  if (tooltip2) {
    chart.interaction("tooltip");
    chart.tooltip(tooltip2);
  } else if (tooltip2 === false) {
    chart.removeInteraction("tooltip");
  }
  chart.legend(legend2);
  if (theme2) {
    chart.theme(theme2);
  }
  each$1(interactions, function(interaction2) {
    if (interaction2.enable === false) {
      chart.removeInteraction(interaction2.type);
    } else {
      chart.interaction(interaction2.type, interaction2.cfg);
    }
  });
  each$1(annotations, function(annotation2) {
    chart.annotation()[annotation2.type](__assign$4({}, annotation2));
  });
  return params;
}
function adaptor(params) {
  return flow(theme$2, facetAdaptor, component)(params);
}
var DEFAULT_OPTIONS = {
  title: {
    style: {
      fontSize: 12,
      fill: "rgba(0,0,0,0.65)"
    }
  },
  rowTitle: {
    style: {
      fontSize: 12,
      fill: "rgba(0,0,0,0.65)"
    }
  },
  columnTitle: {
    style: {
      fontSize: 12,
      fill: "rgba(0,0,0,0.65)"
    }
  }
};
(function(_super) {
  __extends$3(Facet2, _super);
  function Facet2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "area";
    return _this;
  }
  Facet2.getDefaultOptions = function() {
    return DEFAULT_OPTIONS;
  };
  Facet2.prototype.getDefaultOptions = function() {
    return Facet2.getDefaultOptions();
  };
  Facet2.prototype.getSchemaAdaptor = function() {
    return adaptor;
  };
  return Facet2;
})(Plot);
var Stage;
(function(Stage2) {
  Stage2["DEV"] = "DEV";
  Stage2["BETA"] = "BETA";
  Stage2["STABLE"] = "STABLE";
})(Stage || (Stage = {}));
registerLocale("en-US", EN_US_LOCALE);
registerLocale("zh-CN", ZH_CN_LOCALE);
var __assign$2 = globalThis && globalThis.__assign || function() {
  __assign$2 = Object.assign || function(t2) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign$2.apply(this, arguments);
};
globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value2) {
    return value2 instanceof P2 ? value2 : new P2(function(resolve) {
      resolve(value2);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value2) {
      try {
        step(generator.next(value2));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value2) {
      try {
        step(generator["throw"](value2));
      } catch (e3) {
        reject(e3);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
globalThis && globalThis.__generator || function(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t2[0] & 1)
      throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f2, y2, t2, g2;
  return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v2) {
      return step([n2, v2]);
    };
  }
  function step(op) {
    if (f2)
      throw new TypeError("Generator is already executing.");
    while (_2)
      try {
        if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
          return t2;
        if (y2 = 0, t2)
          op = [op[0] & 2, t2.value];
        switch (op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            _2.label++;
            return { value: op[1], done: false };
          case 5:
            _2.label++;
            y2 = op[1];
            op = [0];
            continue;
          case 7:
            op = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _2.label = op[1];
              break;
            }
            if (op[0] === 6 && _2.label < t2[1]) {
              _2.label = t2[1];
              t2 = op;
              break;
            }
            if (t2 && _2.label < t2[2]) {
              _2.label = t2[2];
              _2.ops.push(op);
              break;
            }
            if (t2[2])
              _2.ops.pop();
            _2.trys.pop();
            continue;
        }
        op = body.call(thisArg, _2);
      } catch (e3) {
        op = [6, e3];
        y2 = 0;
      } finally {
        f2 = t2 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var fullClone = __assign$2({}, ReactDOM$1);
var version = fullClone.version, reactRender = fullClone.render;
fullClone.unmountComponentAtNode;
var createRoot;
try {
  var mainVersion = Number((version || "").split(".")[0]);
  if (mainVersion >= 18) {
    createRoot = fullClone.createRoot;
  }
} catch (e3) {
}
function toggleWarning(skip) {
  var __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = fullClone.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
  if (__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED && typeof __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED === "object") {
    __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.usingClientEntryPoint = skip;
  }
}
var MARK = "__rc_react_root__";
function modernRender(node, container) {
  toggleWarning(true);
  var root2 = container[MARK] || createRoot(container);
  toggleWarning(false);
  root2.render(node);
  container[MARK] = root2;
}
function legacyRender(node, container) {
  reactRender(node, container);
}
function render(node, container) {
  if (createRoot) {
    modernRender(node, container);
    return;
  }
  legacyRender(node, container);
}
var createNode = function(children, type4) {
  var mountPoint = document.createElement("div");
  if (type4 === "tooltip") {
    mountPoint.className = "g2-tooltip";
  }
  render(children, mountPoint);
  return mountPoint;
};
var createNode$1 = createNode;
var isType = function(value2, type4) {
  var toString3 = {}.toString;
  return toString3.call(value2) === "[object ".concat(type4, "]");
};
var clone = function(source) {
  if (!source) {
    return source;
  }
  var target = {};
  for (var k2 in source) {
    target[k2] = source[k2];
  }
  return target;
};
var deepClone = function(source) {
  if (!source || typeof source !== "object") {
    return source;
  }
  var target;
  if (Array.isArray(source)) {
    target = source.map(function(item) {
      return deepClone(item);
    });
  } else {
    target = {};
    Object.keys(source).forEach(function(key2) {
      return target[key2] = deepClone(source[key2]);
    });
  }
  return target;
};
var hasPath = function(source, path2) {
  var current = source;
  for (var i2 = 0; i2 < path2.length; i2 += 1) {
    if (current === null || current === void 0 ? void 0 : current[path2[i2]]) {
      current = current[path2[i2]];
    } else {
      current = void 0;
      break;
    }
  }
  return current;
};
var setPath = function(source, path2, value2) {
  if (!source) {
    return source;
  }
  var o2 = source;
  path2.forEach(function(key2, idx) {
    if (idx < path2.length - 1) {
      o2 = o2[key2];
    } else {
      o2[key2] = value2;
    }
  });
  return source;
};
var getChart = function(chartRef, chart) {
  if (!chartRef) {
    return;
  }
  if (isFunction(chartRef)) {
    chartRef(chart);
  } else {
    chartRef.current = chart;
  }
};
var __assign$1 = globalThis && globalThis.__assign || function() {
  __assign$1 = Object.assign || function(t2) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign$1.apply(this, arguments);
};
var __rest$2 = globalThis && globalThis.__rest || function(s2, e3) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e3.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
function useInit(ChartClass, config) {
  var chart = react.exports.useRef();
  var chartOptions = react.exports.useRef();
  var container = react.exports.useRef(null);
  var onReady = config.onReady, onEvent = config.onEvent;
  var toDataURL = function(type4, encoderOptions) {
    var _a2;
    if (type4 === void 0) {
      type4 = "image/png";
    }
    return (_a2 = chart.current) === null || _a2 === void 0 ? void 0 : _a2.chart.canvas.cfg.el.toDataURL(type4, encoderOptions);
  };
  var downloadImage = function(name, type4, encoderOptions) {
    var _a2;
    if (name === void 0) {
      name = "download";
    }
    if (type4 === void 0) {
      type4 = "image/png";
    }
    var imageName = name;
    if (name.indexOf(".") === -1) {
      imageName = "".concat(name, ".").concat(type4.split("/")[1]);
    }
    var base64 = (_a2 = chart.current) === null || _a2 === void 0 ? void 0 : _a2.chart.canvas.cfg.el.toDataURL(type4, encoderOptions);
    var a2 = document.createElement("a");
    a2.href = base64;
    a2.download = imageName;
    document.body.appendChild(a2);
    a2.click();
    document.body.removeChild(a2);
    a2 = null;
    return imageName;
  };
  var reactDomToString = function(source, path2, type4) {
    var statisticCustomHtml = hasPath(source, path2);
    setPath(source, path2, function() {
      var arg = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        arg[_i] = arguments[_i];
      }
      var statisticDom = isType(statisticCustomHtml, "Function") ? statisticCustomHtml.apply(void 0, arg) : statisticCustomHtml;
      if (isType(statisticDom, "String") || isType(statisticDom, "Number") || isType(statisticDom, "HTMLDivElement")) {
        return statisticDom;
      }
      return createNode$1(statisticDom, type4);
    });
  };
  var processConfig = function() {
    if (hasPath(config, ["statistic", "content", "customHtml"])) {
      reactDomToString(config, ["statistic", "content", "customHtml"]);
    }
    if (hasPath(config, ["statistic", "title", "customHtml"])) {
      reactDomToString(config, ["statistic", "title", "customHtml"]);
    }
    if (typeof config.tooltip === "object") {
      if (hasPath(config, ["tooltip", "container"])) {
        reactDomToString(config, ["tooltip", "container"], "tooltip");
      }
      if (hasPath(config, ["tooltip", "customContent"])) {
        reactDomToString(config, ["tooltip", "customContent"], "tooltip");
      }
    }
  };
  react.exports.useEffect(function() {
    if (chart.current && !isEqual$1(chartOptions.current, config)) {
      var changeData = false;
      if (chartOptions.current) {
        var _a2 = chartOptions.current;
        _a2.data;
        _a2.value;
        _a2.percent;
        var currentConfig = __rest$2(_a2, ["data", "value", "percent"]);
        config.data;
        config.value;
        config.percent;
        var inputConfig = __rest$2(config, ["data", "value", "percent"]);
        changeData = isEqual$1(currentConfig, inputConfig);
      }
      chartOptions.current = deepClone(config);
      if (changeData && get(config, "chartType") !== "Mix") {
        var changeType_1 = "data";
        var typeMaps = ["percent"];
        var currentKeys_1 = Object.keys(config);
        typeMaps.forEach(function(type4) {
          if (currentKeys_1.includes(type4)) {
            changeType_1 = type4;
          }
        });
        chart.current.changeData((config === null || config === void 0 ? void 0 : config[changeType_1]) || []);
      } else {
        processConfig();
        chart.current.update(config);
      }
    }
  }, [config]);
  react.exports.useEffect(function() {
    if (!container.current) {
      return function() {
        return null;
      };
    }
    if (!chartOptions.current) {
      chartOptions.current = deepClone(config);
    }
    processConfig();
    var chartInstance = new ChartClass(container.current, __assign$1({}, config));
    chartInstance.toDataURL = function(type4, encoderOptions) {
      return toDataURL(type4, encoderOptions);
    };
    chartInstance.downloadImage = function(name, type4, encoderOptions) {
      return downloadImage(name, type4, encoderOptions);
    };
    chartInstance.render();
    chart.current = clone(chartInstance);
    if (onReady) {
      onReady(chartInstance);
    }
    var handler = function(event) {
      if (onEvent) {
        onEvent(chartInstance, event);
      }
    };
    chartInstance.on("*", handler);
    return function() {
      if (chart.current) {
        chart.current.destroy();
        chart.current.off("*", handler);
        chart.current = void 0;
      }
    };
  }, []);
  return {
    chart,
    container
  };
}
var __extends = globalThis && globalThis.__extends || function() {
  var extendStatics2 = function(d2, b10) {
    extendStatics2 = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d3, b11) {
      d3.__proto__ = b11;
    } || function(d3, b11) {
      for (var p2 in b11)
        if (Object.prototype.hasOwnProperty.call(b11, p2))
          d3[p2] = b11[p2];
    };
    return extendStatics2(d2, b10);
  };
  return function(d2, b10) {
    if (typeof b10 !== "function" && b10 !== null)
      throw new TypeError("Class extends value " + String(b10) + " is not a constructor or null");
    extendStatics2(d2, b10);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b10 === null ? Object.create(b10) : (__.prototype = b10.prototype, new __());
  };
}();
var ErrorBoundary = function(_super) {
  __extends(ErrorBoundary2, _super);
  function ErrorBoundary2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.state = {
      hasError: false
    };
    _this.renderError = function(e3) {
      var errorTemplate = _this.props.errorTemplate;
      switch (e3) {
        default:
          return errorTemplate && typeof errorTemplate === "function" ? errorTemplate(e3) : /* @__PURE__ */ jsxs("h5", {
            children: ["\u7EC4\u4EF6\u51FA\u9519\u4E86\uFF0C\u8BF7\u6838\u67E5\u540E\u91CD\u8BD5\uFF1A ", e3.message]
          });
      }
    };
    return _this;
  }
  ErrorBoundary2.getDerivedStateFromError = function(error) {
    return {
      hasError: true,
      error
    };
  };
  ErrorBoundary2.getDerivedStateFromProps = function(nextProps, state2) {
    if (state2.children !== nextProps.children) {
      return {
        children: nextProps.children,
        hasError: false,
        error: void 0
      };
    }
    return null;
  };
  ErrorBoundary2.prototype.render = function() {
    if (this.state.hasError) {
      return this.renderError(this.state.error);
    }
    return /* @__PURE__ */ jsx(Fragment, {
      children: this.props.children
    });
  };
  return ErrorBoundary2;
}(React.Component);
var ErrorBoundary$1 = ErrorBoundary;
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var __assign = function() {
  __assign = Object.assign || function __assign2(t2) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign.apply(this, arguments);
};
function __rest$1(s2, e3) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e3.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
}
var uid = function() {
  return Math.random().toString(36).substring(6);
};
var SVG = function(_a2) {
  var animate = _a2.animate, backgroundColor = _a2.backgroundColor, backgroundOpacity = _a2.backgroundOpacity, baseUrl = _a2.baseUrl, children = _a2.children, foregroundColor = _a2.foregroundColor, foregroundOpacity = _a2.foregroundOpacity, gradientRatio = _a2.gradientRatio, uniqueKey = _a2.uniqueKey, interval2 = _a2.interval, rtl2 = _a2.rtl, speed = _a2.speed, style2 = _a2.style, title = _a2.title, props = __rest$1(_a2, ["animate", "backgroundColor", "backgroundOpacity", "baseUrl", "children", "foregroundColor", "foregroundOpacity", "gradientRatio", "uniqueKey", "interval", "rtl", "speed", "style", "title"]);
  var fixedId = uniqueKey || uid();
  var idClip = fixedId + "-diff";
  var idGradient = fixedId + "-animated-diff";
  var idAria = fixedId + "-aria";
  var rtlStyle = rtl2 ? { transform: "scaleX(-1)" } : null;
  var keyTimes = "0; " + interval2 + "; 1";
  var dur = speed + "s";
  return react.exports.createElement(
    "svg",
    __assign({ "aria-labelledby": idAria, role: "img", style: __assign(__assign({}, style2), rtlStyle) }, props),
    title ? react.exports.createElement("title", { id: idAria }, title) : null,
    react.exports.createElement("rect", { role: "presentation", x: "0", y: "0", width: "100%", height: "100%", clipPath: "url(" + baseUrl + "#" + idClip + ")", style: { fill: "url(" + baseUrl + "#" + idGradient + ")" } }),
    react.exports.createElement(
      "defs",
      { role: "presentation" },
      react.exports.createElement("clipPath", { id: idClip }, children),
      react.exports.createElement(
        "linearGradient",
        { id: idGradient },
        react.exports.createElement("stop", { offset: "0%", stopColor: backgroundColor, stopOpacity: backgroundOpacity }, animate && react.exports.createElement("animate", { attributeName: "offset", values: -gradientRatio + "; " + -gradientRatio + "; 1", keyTimes, dur, repeatCount: "indefinite" })),
        react.exports.createElement("stop", { offset: "50%", stopColor: foregroundColor, stopOpacity: foregroundOpacity }, animate && react.exports.createElement("animate", { attributeName: "offset", values: -gradientRatio / 2 + "; " + -gradientRatio / 2 + "; " + (1 + gradientRatio / 2), keyTimes, dur, repeatCount: "indefinite" })),
        react.exports.createElement("stop", { offset: "100%", stopColor: backgroundColor, stopOpacity: backgroundOpacity }, animate && react.exports.createElement("animate", { attributeName: "offset", values: "0; 0; " + (1 + gradientRatio), keyTimes, dur, repeatCount: "indefinite" }))
      )
    )
  );
};
SVG.defaultProps = {
  animate: true,
  backgroundColor: "#f5f6f7",
  backgroundOpacity: 1,
  baseUrl: "",
  foregroundColor: "#eee",
  foregroundOpacity: 1,
  gradientRatio: 2,
  id: null,
  interval: 0.25,
  rtl: false,
  speed: 1.2,
  style: {},
  title: "Loading..."
};
var ContentLoader = function(props) {
  return props.children ? react.exports.createElement(SVG, __assign({}, props)) : react.exports.createElement(ReactContentLoaderFacebook, __assign({}, props));
};
var ReactContentLoaderFacebook = function(props) {
  return react.exports.createElement(
    ContentLoader,
    __assign({ viewBox: "0 0 476 124" }, props),
    react.exports.createElement("rect", { x: "48", y: "8", width: "88", height: "6", rx: "3" }),
    react.exports.createElement("rect", { x: "48", y: "26", width: "52", height: "6", rx: "3" }),
    react.exports.createElement("rect", { x: "0", y: "56", width: "410", height: "6", rx: "3" }),
    react.exports.createElement("rect", { x: "0", y: "72", width: "380", height: "6", rx: "3" }),
    react.exports.createElement("rect", { x: "0", y: "88", width: "178", height: "6", rx: "3" }),
    react.exports.createElement("circle", { cx: "20", cy: "20", r: "20" })
  );
};
var ContentLoader$1 = ContentLoader;
var ChartLoading = function(_a2) {
  var loadingTemplate = _a2.loadingTemplate, _b = _a2.theme, theme2 = _b === void 0 ? "light" : _b;
  var renderLoading = function() {
    if (loadingTemplate) {
      return loadingTemplate;
    }
    return React.createElement(
      ContentLoader$1,
      { viewBox: "0 0 400 180", width: 200, height: 90, speed: 1, backgroundColor: theme2 === "dark" ? "#262626" : "#D9D9D9" },
      React.createElement("rect", { x: "20", y: "5", rx: "0", ry: "0", width: "1", height: "170" }),
      React.createElement("rect", { x: "20", y: "175", rx: "0", ry: "0", width: "360", height: "1" }),
      React.createElement("rect", { x: "40", y: "75", rx: "0", ry: "0", width: "35", height: "100" }),
      React.createElement("rect", { x: "80", y: "125", rx: "0", ry: "0", width: "35", height: "50" }),
      React.createElement("rect", { x: "120", y: "105", rx: "0", ry: "0", width: "35", height: "70" }),
      React.createElement("rect", { x: "160", y: "35", rx: "0", ry: "0", width: "35", height: "140" }),
      React.createElement("rect", { x: "200", y: "55", rx: "0", ry: "0", width: "35", height: "120" }),
      React.createElement("rect", { x: "240", y: "15", rx: "0", ry: "0", width: "35", height: "160" }),
      React.createElement("rect", { x: "280", y: "135", rx: "0", ry: "0", width: "35", height: "40" }),
      React.createElement("rect", { x: "320", y: "85", rx: "0", ry: "0", width: "35", height: "90" })
    );
  };
  return React.createElement("div", { className: "charts-loading-container", style: {
    position: "absolute",
    width: "100%",
    height: "100%",
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    left: 0,
    top: 0,
    zIndex: 99,
    backgroundColor: theme2 === "dark" ? "rgb(20, 20, 20)" : "rgb(255, 255, 255)"
  } }, renderLoading());
};
var ChartLoading$1 = ChartLoading;
var __rest = globalThis && globalThis.__rest || function(s2, e3) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e3.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
var LineChart = react.exports.forwardRef(function(props, ref) {
  var chartRef = props.chartRef, _a2 = props.style, style2 = _a2 === void 0 ? {
    height: "inherit"
  } : _a2, className = props.className, loading = props.loading, loadingTemplate = props.loadingTemplate, errorTemplate = props.errorTemplate, rest = __rest(props, ["chartRef", "style", "className", "loading", "loadingTemplate", "errorTemplate"]);
  var _b = useInit(Line$1, rest), chart = _b.chart, container = _b.container;
  react.exports.useEffect(function() {
    getChart(chartRef, chart.current);
  }, [chart.current]);
  react.exports.useImperativeHandle(ref, function() {
    return {
      getChart: function() {
        return chart.current;
      }
    };
  });
  return /* @__PURE__ */ jsxs(ErrorBoundary$1, {
    errorTemplate,
    children: [loading && /* @__PURE__ */ jsx(ChartLoading$1, {
      loadingTemplate,
      theme: props.theme
    }), /* @__PURE__ */ jsx("div", {
      className,
      style: style2,
      ref: container
    })]
  });
});
var Line = LineChart;
var index$9 = "";
const GUTTER$1 = 16;
const SPAN = 6;
function Overview(props) {
  const {
    detail = {}
  } = props;
  const {
    recentTransactionsMap = []
  } = detail;
  const [data2, setData] = react.exports.useState([]);
  react.exports.useEffect(() => {
    setData(recentTransactionsMap);
  }, [recentTransactionsMap.length]);
  const config = {
    data: data2,
    xField: "date",
    yField: "count",
    height: 116,
    xAxis: {
      tickCount: 5
    }
  };
  return /* @__PURE__ */ jsxs("div", {
    className: "overview",
    children: [/* @__PURE__ */ jsx("h2", {
      children: "\u603B\u89C8"
    }), /* @__PURE__ */ jsxs(Row$1, {
      gutter: GUTTER$1,
      children: [/* @__PURE__ */ jsxs(Col$1, {
        span: 16,
        className: "left-info",
        children: [/* @__PURE__ */ jsxs(Row$1, {
          gutter: GUTTER$1,
          children: [/* @__PURE__ */ jsxs(Col$1, {
            span: SPAN,
            children: [/* @__PURE__ */ jsx("p", {
              className: "title",
              children: "\u4EA4\u6613\u6BD4\u6570"
            }), /* @__PURE__ */ jsx("p", {
              className: "introduc-content",
              children: detail.txnCount
            })]
          }), /* @__PURE__ */ jsxs(Col$1, {
            span: SPAN,
            children: [/* @__PURE__ */ jsx("p", {
              className: "title",
              children: "\u533A\u5757\u9AD8\u5EA6"
            }), /* @__PURE__ */ jsx("p", {
              className: "introduc-content",
              children: detail.blockHeight
            })]
          }), /* @__PURE__ */ jsxs(Col$1, {
            span: SPAN,
            children: [/* @__PURE__ */ jsx("p", {
              className: "title",
              children: "\u5E73\u5747\u6BCF\u79D2\u4EA4\u6613"
            }), /* @__PURE__ */ jsx("p", {
              className: "introduc-content",
              children: detail.avgTxnCount
            })]
          }), /* @__PURE__ */ jsxs(Col$1, {
            span: SPAN,
            children: [/* @__PURE__ */ jsx("p", {
              className: "title",
              children: "\u94B1\u5305\u5730\u5740\u603B\u91CF"
            }), /* @__PURE__ */ jsx("p", {
              className: "introduc-content",
              children: detail.addressCount
            })]
          })]
        }), /* @__PURE__ */ jsxs(Row$1, {
          gutter: GUTTER$1,
          children: [/* @__PURE__ */ jsxs(Col$1, {
            span: SPAN,
            children: [/* @__PURE__ */ jsx("p", {
              className: "title",
              children: "\u6700\u8FD124H\u4EA4\u6613\u6BD4\u6570"
            }), /* @__PURE__ */ jsx("p", {
              className: "introduc-content",
              children: detail.recentTxnCount
            })]
          }), /* @__PURE__ */ jsxs(Col$1, {
            span: SPAN,
            children: [/* @__PURE__ */ jsx("p", {
              className: "title",
              children: "\u8FD124H\u51FA\u5757\u91CF"
            }), /* @__PURE__ */ jsx("p", {
              className: "introduc-content",
              children: detail.recentBlockCount
            })]
          }), /* @__PURE__ */ jsxs(Col$1, {
            span: SPAN,
            children: [/* @__PURE__ */ jsx("p", {
              className: "title",
              children: "\u5E73\u5747\u51FA\u5757\u65F6\u95F4"
            }), /* @__PURE__ */ jsx("p", {
              className: "introduc-content",
              children: detail.avgBlockTime
            })]
          }), /* @__PURE__ */ jsxs(Col$1, {
            span: SPAN,
            children: [/* @__PURE__ */ jsx("p", {
              className: "title",
              children: "\u667A\u80FD\u5408\u7EA6\u91CF"
            }), /* @__PURE__ */ jsx("p", {
              className: "introduc-content",
              children: detail.contractCount
            })]
          })]
        })]
      }), /* @__PURE__ */ jsx(Col$1, {
        span: 8,
        children: /* @__PURE__ */ jsx(Line, {
          ...config
        })
      })]
    })]
  });
}
const scendsTakenTo = (times) => {
  const SCENDS = 1e3;
  return Number.parseInt((new Date().getTime() - times) / SCENDS);
};
var index$8 = "";
function InfoList(props) {
  const {
    lastBlock = [],
    lastTransactions = []
  } = props;
  useNavigate();
  const BLOCK_TYPE2 = "recentBlock";
  const TRANS_TYPE2 = "recentTrans";
  const overLenText = react.exports.useCallback(overLenTextShow, []);
  return /* @__PURE__ */ jsxs("div", {
    className: "info-list",
    children: [/* @__PURE__ */ jsx(List$1, {
      className: "list",
      bordered: true,
      header: /* @__PURE__ */ jsxs("div", {
        className: "list-head",
        children: [/* @__PURE__ */ jsx("span", {
          children: "\u6700\u65B0\u51FA\u5757"
        }), /* @__PURE__ */ jsx(Link, {
          to: `recentInfo/${BLOCK_TYPE2}`,
          children: "\u66F4\u591A"
        })]
      }),
      dataSource: lastBlock,
      renderItem: (item) => {
        var _a2;
        return /* @__PURE__ */ jsxs(List$1.Item, {
          children: [/* @__PURE__ */ jsx(List$1.Item.Meta, {
            title: /* @__PURE__ */ jsx(Popover$1, {
              content: item.blockHeight,
              children: /* @__PURE__ */ jsx(Link, {
                to: `/blockHeight/${item.blockHeight}`,
                children: `# ${overLenText(item.blockHeight)}`
              })
            }),
            description: `${scendsTakenTo(new Date(item.createTime).getTime())} scends ago`
          }), /* @__PURE__ */ jsx("span", {
            children: `${(_a2 = item == null ? void 0 : item.transactionsList) == null ? void 0 : _a2.length} \u6BD4\u4EA4\u6613`
          })]
        }, item.hash);
      }
    }), /* @__PURE__ */ jsx(List$1, {
      className: "list",
      bordered: true,
      header: /* @__PURE__ */ jsxs("div", {
        className: "list-head",
        children: [/* @__PURE__ */ jsx("span", {
          children: "\u6700\u65B0\u4EA4\u6613"
        }), /* @__PURE__ */ jsx(Link, {
          to: `recentInfo/${TRANS_TYPE2}`,
          children: "\u66F4\u591A"
        })]
      }),
      dataSource: lastTransactions,
      renderItem: (item) => /* @__PURE__ */ jsxs(List$1.Item, {
        children: [/* @__PURE__ */ jsx(List$1.Item.Meta, {
          title: /* @__PURE__ */ jsx(Popover$1, {
            content: item.txnHash,
            children: /* @__PURE__ */ jsx(Link, {
              to: `/transaction/${item.txnHash}`,
              children: `# ${overLenText(item.txnHash)}`
            })
          }),
          description: `${scendsTakenTo(new Date(item.createTime).getTime())} scends ago`
        }), /* @__PURE__ */ jsxs("div", {
          className: "briefly-wrap",
          children: [/* @__PURE__ */ jsxs("div", {
            className: "briefly",
            children: [/* @__PURE__ */ jsx("span", {
              children: "From"
            }), /* @__PURE__ */ jsx(Popover$1, {
              content: item.fromAddress,
              children: /* @__PURE__ */ jsx(Link, {
                to: `/walletDetail/${item.fromAddress}`,
                children: `${overLenText(item.fromAddress)}`
              })
            })]
          }), /* @__PURE__ */ jsxs("div", {
            className: "briefly",
            children: [/* @__PURE__ */ jsx("span", {
              children: "To"
            }), /* @__PURE__ */ jsx(Popover$1, {
              content: item.toAddress,
              children: /* @__PURE__ */ jsx(NavigateAddress, {
                address: item.toAddress
              })
            })]
          })]
        })]
      }, item.txnHash)
    })]
  });
}
const isEmptyObj = (obj = {}) => {
  return Object.keys(obj).length === 0;
};
var index$7 = "";
function Home() {
  const {
    countDetail,
    lastBlock,
    lastTransactions
  } = useSelector((state2) => state2.home);
  const dispatch2 = useDispatch();
  react.exports.useEffect(() => {
    if (isEmptyObj(countDetail)) {
      dispatch2(asyncGetCountDetail());
      dispatch2(asyncGetLastBlock());
      dispatch2(asyncGetLastTransactions());
    }
    return () => {
      dispatch2(getInitState$6());
    };
  }, []);
  return /* @__PURE__ */ jsxs("div", {
    children: [/* @__PURE__ */ jsxs("div", {
      className: "search-content",
      children: [/* @__PURE__ */ jsxs("div", {
        className: "search-content-left",
        children: [/* @__PURE__ */ jsxs("div", {
          className: "title",
          children: [/* @__PURE__ */ jsx(Image$4, {
            width: 50,
            height: 50,
            preview: false,
            src: "cc.jpeg"
          }), /* @__PURE__ */ jsx("span", {
            className: "title-text",
            children: "Free Blockchain Explorer"
          })]
        }), /* @__PURE__ */ jsx("div", {
          className: "search-wrap",
          children: /* @__PURE__ */ jsx(CommonSearch, {})
        })]
      }), /* @__PURE__ */ jsxs("div", {
        className: "search-content-right",
        children: [/* @__PURE__ */ jsx("p", {
          children: "\u514D\u8D39\u53D1\u578B\u6570\u5B57\u85CF\u54C1"
        }), /* @__PURE__ */ jsx("p", {
          children: "\u53EF\u514D\u8D39\u4F7F\u7528\u798F\u745E\u94FE,\u7531\u56FD\u5185\u9886\u5148\u3001\u81EA\u4E3B\u7814\u53D1\u7684\u798F\u745E\u94FE\u4F5C\u4E3A\u5E95\u5C42\u533A\u5757\u94FE\u6280\u672F\u652F\u6491\uFF0C\u5728\u4FDD\u8BC1\u5B89\u5168\u548C\u6027\u80FD\u7684\u540C\u65F6\uFF0C\u80FD\u6EE1\u8DB3\u5404\u7C7B\u590D\u6742\u7684\u4E1A\u52A1\u573A\u666F\u3002\u57280\u6210\u672C\u7684\u521B\u4F5C\u548C\u4EA4\u6613\u4E2D\u4F53\u9A8CNFR\u751F\u6001\u3002"
        }), /* @__PURE__ */ jsx(Button$2, {
          ghost: true,
          className: "experience-btn",
          type: "primary",
          children: "\u7ACB\u5373\u4F53\u9A8C"
        })]
      })]
    }), /* @__PURE__ */ jsx(Overview, {
      detail: countDetail
    }), /* @__PURE__ */ jsx(InfoList, {
      lastBlock,
      lastTransactions
    })]
  });
}
Home.getInitialProps = () => {
  return [asyncGetCountDetail(), asyncGetLastBlock(), asyncGetLastTransactions()];
};
const columns$3 = [{
  title: "\u65F6\u95F4",
  dataIndex: "createTime"
}, {
  title: "\u4EA4\u6613\u54C8\u5E0C",
  dataIndex: "txnHash",
  render: (txnHash) => /* @__PURE__ */ jsx(Popover$1, {
    content: txnHash,
    children: /* @__PURE__ */ jsx(Link, {
      to: `/transaction/${txnHash}`,
      children: overLenTextShow(txnHash)
    })
  })
}, {
  title: "\u53D1\u9001\u65B9",
  dataIndex: "fromAddress",
  render: (fromAddress) => /* @__PURE__ */ jsx(Popover$1, {
    content: fromAddress,
    children: /* @__PURE__ */ jsx(Link, {
      to: `/walletDetail/${fromAddress}`,
      children: overLenTextShow(fromAddress)
    })
  })
}, {
  title: "\u63A5\u6536\u65B9",
  dataIndex: "toAddress",
  render: (toAddress) => /* @__PURE__ */ jsx(Popover$1, {
    content: toAddress,
    children: /* @__PURE__ */ jsx(NavigateAddress, {
      address: toAddress
    })
  })
}, {
  title: "\u7C7B\u578B",
  dataIndex: "methodName"
}, {
  title: "NFR",
  dataIndex: "nfrList",
  render(nfrList = []) {
    if (nfrList.length === 1) {
      const nfr = nfrList[0];
      return /* @__PURE__ */ jsx(Link, {
        to: `/nfrDetail/${nfr.id}`,
        children: nfr.name
      });
    }
    return "--";
  }
}, {
  title: "NFRID",
  dataIndex: "nfrList",
  render(nfrList = []) {
    if (nfrList.length === 1) {
      const nfr = nfrList[0];
      return /* @__PURE__ */ jsx(Link, {
        to: `/nfrDetail/${nfr.id}`,
        children: nfr.id
      });
    }
    return "--";
  }
}];
var index$6 = "";
function BlockHeight() {
  const {
    params
  } = useMatch("/blockHeight/:type");
  const dispatch2 = useDispatch();
  const {
    list = [],
    pageInfo,
    info = {}
  } = useSelector((state2) => state2.blockHeight);
  const pageType = params.type || "";
  const {
    address = "",
    searchData = {}
  } = info;
  console.log(searchData, list);
  react.exports.useEffect(() => {
    if (isEmptyObj(info)) {
      dispatch2(asyncGetPageList$3(pageType));
      dispatch2(asyncGetDetail$1(pageType));
    }
    return () => {
      dispatch2(getInitState$4());
    };
  }, []);
  const pageChange = react.exports.useCallback((page, pageSize) => {
    dispatch2(changTable$3(page, pageSize, pageType));
  }, []);
  return /* @__PURE__ */ jsxs("div", {
    className: "block-height",
    children: [/* @__PURE__ */ jsx("div", {
      className: "common-search",
      children: /* @__PURE__ */ jsx(CommonSearch, {
        borderd: true
      })
    }), /* @__PURE__ */ jsxs("div", {
      className: "title-wrap",
      children: [/* @__PURE__ */ jsxs("div", {
        className: "head-title",
        children: [/* @__PURE__ */ jsx("span", {
          className: "address",
          children: `# ${address}`
        }), /* @__PURE__ */ jsx(ClockCircleOutlined$1, {}), /* @__PURE__ */ jsx("span", {
          className: "time",
          children: searchData.createTime
        })]
      }), /* @__PURE__ */ jsx("p", {
        children: searchData.hash
      })]
    }), /* @__PURE__ */ jsx("h3", {
      className: "title",
      children: "\u8BE5\u9AD8\u5EA6\u4E0B\u4EA4\u6613"
    }), /* @__PURE__ */ jsx(Table$1, {
      dataSource: list,
      pagination: {
        total: pageInfo.totalElements,
        current: pageInfo.pageStart,
        pageSize: pageInfo.pageSize,
        onChange: pageChange
      },
      columns: columns$3
    })]
  });
}
BlockHeight.getInitialProps = () => {
  return [asyncGetPageList$3(), asyncGetDetail$1()];
};
const columns$2 = [{
  title: "\u65F6\u95F4",
  dataIndex: "createTime"
}, {
  title: "\u4EA4\u6613\u54C8\u5E0C",
  dataIndex: "txnHash",
  render: (text2) => /* @__PURE__ */ jsx(Popover$1, {
    content: text2,
    children: /* @__PURE__ */ jsx(Link, {
      to: `/transaction/${text2}`,
      children: overLenTextShow(text2)
    })
  })
}, {
  title: "\u53D1\u9001\u65B9",
  dataIndex: "fromAddress",
  render: (fromAddress) => /* @__PURE__ */ jsx(Popover$1, {
    content: fromAddress,
    children: /* @__PURE__ */ jsx(Link, {
      to: `/walletDetail/${fromAddress}`,
      children: overLenTextShow(fromAddress)
    })
  })
}, {
  title: "\u63A5\u6536\u65B9",
  dataIndex: "toAddress",
  render: (toAddress) => /* @__PURE__ */ jsx(Popover$1, {
    content: toAddress,
    children: /* @__PURE__ */ jsx(Link, {
      to: `/walletDetail/${toAddress}`,
      children: overLenTextShow(toAddress)
    })
  })
}, {
  title: "\u7C7B\u578B",
  dataIndex: "methodName"
}];
var index$5 = "";
function NfrDetail() {
  const {
    params
  } = useMatch("nfrDetail/:type");
  const dispatch2 = useDispatch();
  const {
    list = [],
    pageInfo,
    detail = {}
  } = useSelector((state2) => state2.nfrDetail);
  console.log(detail, list);
  const id2 = params.type;
  react.exports.useEffect(() => {
    if (isEmptyObj(detail)) {
      dispatch2(asyncGetPageList(id2));
      dispatch2(asyncGetNfrDetail(id2));
    }
    return () => {
      dispatch2(getInitState$1());
    };
  }, []);
  const pageChange = react.exports.useCallback((page, pageSize) => {
    dispatch2(changTable(page, pageSize, id2));
  }, []);
  return /* @__PURE__ */ jsxs("div", {
    className: "nfr-detail",
    children: [/* @__PURE__ */ jsx("h3", {
      className: "title",
      children: "NFR\u8BE6\u60C5"
    }), /* @__PURE__ */ jsxs("div", {
      className: "detail-header",
      children: [/* @__PURE__ */ jsx("span", {
        className: "name",
        children: detail.name
      }), /* @__PURE__ */ jsx(Link, {
        to: "",
        children: detail.contractAddress
      }), /* @__PURE__ */ jsx("span", {
        className: "contrat",
        children: `# ${detail.nfrId}`
      })]
    }), /* @__PURE__ */ jsxs("div", {
      className: "detail-info",
      children: [/* @__PURE__ */ jsxs(Row$1, {
        gutter: 24,
        children: [/* @__PURE__ */ jsx(Col$1, {
          className: "label",
          span: 2,
          children: /* @__PURE__ */ jsx("span", {
            children: "NFR\u96C6\u5408"
          })
        }), /* @__PURE__ */ jsx(Col$1, {
          span: 22,
          children: /* @__PURE__ */ jsx(Link, {
            to: `/contractDetail/${detail.contractAddress}`,
            children: detail.contractAddress
          })
        })]
      }), /* @__PURE__ */ jsxs(Row$1, {
        gutter: 24,
        children: [/* @__PURE__ */ jsx(Col$1, {
          className: "label",
          span: 2,
          children: /* @__PURE__ */ jsx("span", {
            children: "NFRID"
          })
        }), /* @__PURE__ */ jsx(Col$1, {
          children: /* @__PURE__ */ jsx(Link, {
            to: "",
            children: detail.nfrId
          })
        })]
      }), /* @__PURE__ */ jsxs(Row$1, {
        gutter: 24,
        children: [/* @__PURE__ */ jsx(Col$1, {
          className: "label",
          span: 2,
          children: /* @__PURE__ */ jsx("span", {
            children: "\u6301\u6709\u8005"
          })
        }), /* @__PURE__ */ jsx(Col$1, {
          children: /* @__PURE__ */ jsx(Link, {
            to: `/walletDetail/${detail.ownerAddress}`,
            children: detail.ownerAddress
          })
        })]
      }), /* @__PURE__ */ jsxs(Row$1, {
        gutter: 24,
        children: [/* @__PURE__ */ jsx(Col$1, {
          className: "label",
          span: 2,
          children: /* @__PURE__ */ jsx("span", {
            children: "\u751F\u6210\u8005"
          })
        }), /* @__PURE__ */ jsx(Col$1, {
          children: /* @__PURE__ */ jsx(Link, {
            to: "",
            children: detail.creatorAddress
          })
        })]
      }), /* @__PURE__ */ jsxs(Row$1, {
        gutter: 24,
        children: [/* @__PURE__ */ jsx(Col$1, {
          className: "label",
          span: 2,
          children: /* @__PURE__ */ jsx("span", {
            children: "\u7C7B\u578B"
          })
        }), /* @__PURE__ */ jsx(Col$1, {
          children: /* @__PURE__ */ jsx(Link, {
            to: "",
            children: detail.nfrProtocol
          })
        })]
      })]
    }), /* @__PURE__ */ jsx(Table$1, {
      dataSource: list,
      pagination: {
        total: pageInfo.totalElements,
        current: pageInfo.pageStart,
        pageSize: pageInfo.pageSize,
        onChange: pageChange
      },
      columns: columns$2
    })]
  });
}
NfrDetail.getInitialProps = () => {
  return [asyncGetPageList(), asyncGetNfrDetail()];
};
const columns$1 = [{
  title: "\u65F6\u95F4",
  dataIndex: "createTime"
}, {
  title: "\u4EA4\u6613\u54C8\u5E0C",
  dataIndex: "txnHash",
  render: (txnHash) => /* @__PURE__ */ jsx(Popover$1, {
    content: txnHash,
    children: /* @__PURE__ */ jsx(Link, {
      to: `/transaction/${txnHash}`,
      children: overLenTextShow(txnHash)
    })
  })
}, {
  title: "\u53D1\u9001\u65B9",
  dataIndex: "fromAddress",
  render: (fromAddress) => /* @__PURE__ */ jsx(Popover$1, {
    content: fromAddress,
    children: /* @__PURE__ */ jsx(Link, {
      to: `/walletDetail/${fromAddress}`,
      children: overLenTextShow(fromAddress)
    })
  })
}, {
  title: "\u63A5\u6536\u65B9",
  dataIndex: "toAddress",
  render: (toAddress) => /* @__PURE__ */ jsx(Popover$1, {
    content: toAddress,
    children: /* @__PURE__ */ jsx(Link, {
      to: `/walletDetail/${toAddress}`,
      children: overLenTextShow(toAddress)
    })
  })
}, {
  title: "\u7C7B\u578B",
  dataIndex: "methodName"
}, {
  title: "NFR",
  dataIndex: "nfrList",
  render(nfrList = []) {
    if (nfrList.length === 1) {
      const nfr = nfrList[0];
      return /* @__PURE__ */ jsx(Link, {
        to: `/nfrDetail/${nfr.id}`,
        children: nfr.name
      });
    }
    return "--";
  }
}, {
  title: "NFRID",
  dataIndex: "nfrList",
  render(nfrList = []) {
    if (nfrList.length === 1) {
      const nfr = nfrList[0];
      return /* @__PURE__ */ jsx(Link, {
        to: `/nfrDetail/${nfr.id}`,
        children: nfr.id
      });
    }
    return "--";
  }
}];
var index$4 = "";
function ContractDetail() {
  const {
    params
  } = useMatch("contractDetail/:type");
  const dispatch2 = useDispatch();
  const {
    list = [],
    pageInfo,
    detail = {},
    info = {}
  } = useSelector((state2) => state2.contractDetail);
  const {
    tokenCount,
    walletCount,
    transactionCount
  } = info.searchData || {};
  const id2 = params.type;
  react.exports.useEffect(() => {
    if (isEmptyObj(info)) {
      dispatch2(asyncGetPageList$2(id2));
      dispatch2(asyncGetNfrDetail$2(id2));
    }
    return () => {
      dispatch2(getInitState$3());
    };
  }, []);
  const pageChange = react.exports.useCallback((page, pageSize) => {
    dispatch2(changTable$2(page, pageSize, id2));
  }, []);
  return /* @__PURE__ */ jsxs("div", {
    className: "contract-detail",
    children: [/* @__PURE__ */ jsxs("div", {
      className: "contract-title",
      children: [/* @__PURE__ */ jsx("h3", {
        className: "title",
        children: detail.name
      }), /* @__PURE__ */ jsx(Link, {
        to: "",
        children: `\u5408\u7EA6\uFF1A${info.address}`
      })]
    }), /* @__PURE__ */ jsxs("div", {
      className: "detail-info",
      children: [/* @__PURE__ */ jsxs(Row$1, {
        gutter: 24,
        children: [/* @__PURE__ */ jsx(Col$1, {
          className: "label",
          span: 2,
          children: "\u603B\u91CF"
        }), /* @__PURE__ */ jsx(Col$1, {
          span: 22,
          children: tokenCount
        })]
      }), /* @__PURE__ */ jsxs(Row$1, {
        gutter: 24,
        children: [/* @__PURE__ */ jsx(Col$1, {
          className: "label",
          span: 2,
          children: /* @__PURE__ */ jsx("span", {
            children: "\u6301\u6709\u94B1\u5305"
          })
        }), /* @__PURE__ */ jsx(Col$1, {
          children: walletCount
        })]
      }), /* @__PURE__ */ jsxs(Row$1, {
        gutter: 24,
        children: [/* @__PURE__ */ jsx(Col$1, {
          className: "label",
          span: 2,
          children: /* @__PURE__ */ jsx("span", {
            children: "\u4EA4\u6613\u7B14\u6570"
          })
        }), /* @__PURE__ */ jsx(Col$1, {
          children: transactionCount
        })]
      }), /* @__PURE__ */ jsxs(Row$1, {
        gutter: 24,
        children: [/* @__PURE__ */ jsx(Col$1, {
          className: "label",
          span: 2,
          children: /* @__PURE__ */ jsx("span", {
            children: "\u5408\u7EA6"
          })
        }), /* @__PURE__ */ jsx(Col$1, {
          children: /* @__PURE__ */ jsx(Link, {
            to: "",
            children: info.address
          })
        })]
      })]
    }), /* @__PURE__ */ jsx(Table$1, {
      dataSource: list,
      pagination: {
        total: pageInfo.totalElements,
        current: pageInfo.pageStart,
        pageSize: pageInfo.pageSize,
        onChange: pageChange
      },
      columns: columns$1
    })]
  });
}
ContractDetail.getInitialProps = () => {
  return [asyncGetPageList$2(), asyncGetNfrDetail$2()];
};
const columns = [{
  title: "\u65F6\u95F4",
  dataIndex: "createTime",
  key: "createTime"
}, {
  title: "\u4EA4\u6613\u54C8\u5E0C",
  dataIndex: "txnHash",
  key: "txnHash",
  render: (text2) => /* @__PURE__ */ jsx(Popover$1, {
    content: text2,
    children: /* @__PURE__ */ jsx(Link, {
      to: `/transaction/${text2}`,
      children: overLenTextShow(text2)
    })
  })
}, {
  title: "\u53D1\u9001\u65B9",
  dataIndex: "fromAddress",
  key: "fromAddress",
  render: (text2) => /* @__PURE__ */ jsx(Popover$1, {
    content: text2,
    children: /* @__PURE__ */ jsx(Link, {
      to: `/walletDetail/${text2}`,
      children: overLenTextShow(text2)
    })
  })
}, {
  title: "\u63A5\u6536\u65B9",
  dataIndex: "toAddress",
  key: "toAddress",
  render: (text2) => /* @__PURE__ */ jsx(Popover$1, {
    content: text2,
    children: /* @__PURE__ */ jsx(NavigateAddress, {
      address: text2
    })
  })
}, {
  title: "\u7C7B\u578B",
  dataIndex: "methodName",
  key: "methodName"
}, {
  title: "NFR",
  dataIndex: "nfrIds",
  key: "nfrIds",
  render(nfrIds = []) {
    if (nfrIds.length === 1) {
      const nfr = nfrIds[0];
      return /* @__PURE__ */ jsx(Link, {
        to: `/nfrDetail/${nfr.id}`,
        children: nfr.name
      });
    }
    return "--";
  }
}, {
  title: "NFRID",
  dataIndex: "nfrIds",
  key: "nfrId",
  render(nfrIds = []) {
    if (nfrIds.length === 1) {
      const nfr = nfrIds[0];
      return /* @__PURE__ */ jsx(Link, {
        to: `/nfrDetail/${nfr.id}`,
        children: nfr.id
      });
    }
    return "--";
  }
}];
var index$3 = "";
function WalletDetail() {
  const {
    params
  } = useMatch("walletDetail/:type");
  const dispatch2 = useDispatch();
  const {
    list = [],
    pageInfo,
    info = {}
  } = useSelector((state2) => state2.walletDetail);
  const id2 = params.type;
  react.exports.useEffect(() => {
    if (isEmptyObj(info)) {
      dispatch2(asyncGetPageList$1(id2));
      dispatch2(asyncGetNfrDetail$1(id2));
    }
    return () => {
      dispatch2(getInitState$2());
    };
  }, []);
  const {
    nfrCount,
    nfrUriList
  } = info.searchData || {};
  const pageChange = react.exports.useCallback((page, pageSize) => {
    dispatch2(changTable$1(page, pageSize, id2));
  }, []);
  return /* @__PURE__ */ jsxs("div", {
    className: "wallet-detail",
    children: [/* @__PURE__ */ jsx("h3", {
      className: "title",
      children: "\u94B1\u5305\u5730\u5740"
    }), /* @__PURE__ */ jsx("p", {
      className: "address",
      children: info.address
    }), /* @__PURE__ */ jsxs("div", {
      className: "detail-info",
      children: [/* @__PURE__ */ jsx("h3", {
        className: "title",
        children: "\u7528\u6237\u603B\u89C8"
      }), /* @__PURE__ */ jsxs("p", {
        children: ["\u5171\u6301\u6709NFR\uFF1A ", nfrCount]
      }), /* @__PURE__ */ jsx("h3", {
        className: "title",
        children: "\u4EA4\u6613\u8BB0\u5F55"
      }), /* @__PURE__ */ jsx(Table$1, {
        dataSource: list,
        pagination: {
          total: pageInfo.totalElements,
          current: pageInfo.pageStart,
          pageSize: pageInfo.pageSize,
          onChange: pageChange
        },
        columns
      })]
    })]
  });
}
WalletDetail.getInitialProps = () => {
  return [asyncGetPageList$1(), asyncGetNfrDetail$1()];
};
const MINT = "mint";
const MINT_BATCH = "mintBatch";
const TRANSFER = "transfer";
const TRANSFER_BATCH = "transferBatch";
const BURN = "burn";
const BURN_BATCH = "burnBatch";
const transactionEnum = {
  [MINT]: {
    title: "\u94F8\u9020"
  },
  [MINT_BATCH]: {
    title: "\u6279\u91CF\u94F8\u9020"
  },
  [TRANSFER]: {
    title: "\u8F6C\u8D26",
    label: "\u53D1\u9001\u81F3"
  },
  [TRANSFER_BATCH]: {
    title: "\u6279\u91CF\u53D1\u9001",
    label: "\u53D1\u9001\u81F3"
  },
  [BURN]: {
    title: "\u9500\u6BC1",
    label: "\u9500\u6BC1\u5408\u7EA6"
  },
  [BURN_BATCH]: {
    title: "\u6279\u91CF\u9500\u6BC1",
    label: "\u9500\u6BC1\u5408\u7EA6"
  }
};
const MAX_SHOW = 5;
function TransResult(props) {
  var _a2;
  console.log("props:::", props);
  const {
    toAddress,
    method: method4,
    nfrList = []
  } = props;
  const [showAll, setShowAll] = react.exports.useState(nfrList <= MAX_SHOW);
  function toggleShow() {
    setShowAll(!showAll);
  }
  return /* @__PURE__ */ jsxs("div", {
    children: [/* @__PURE__ */ jsx(Link, {
      to: `walletDetail/${toAddress}`,
      children: toAddress
    }), /* @__PURE__ */ jsxs("div", {
      className: "direct-title",
      children: [/* @__PURE__ */ jsx(ArrowDownOutlined$1, {}), /* @__PURE__ */ jsx("span", {
        children: `${(_a2 = transactionEnum[method4]) == null ? void 0 : _a2.title} ${nfrList.length}\u4E2ANFT`
      })]
    }), /* @__PURE__ */ jsxs("div", {
      children: [nfrList.map((item, index2) => {
        if (!showAll && index2 > MAX_SHOW - 1) {
          return null;
        }
        return /* @__PURE__ */ jsxs("div", {
          className: "flow-wrap",
          children: [/* @__PURE__ */ jsx(Link, {
            to: `/nfrDetail/${item.id}`,
            children: `[${item.name || item.id}]`
          }), method4 !== MINT || method4 !== MINT_BATCH ? /* @__PURE__ */ jsxs(Fragment, {
            children: [/* @__PURE__ */ jsx(SwapRightOutlined$1, {
              className: "direct-icon"
            }), /* @__PURE__ */ jsx("span", {
              children: transactionEnum[method4].label
            }), /* @__PURE__ */ jsx(Popover$1, {
              content: item.to,
              children: /* @__PURE__ */ jsx(NavigateAddress, {
                address: item.to
              })
            })]
          }) : ""]
        }, item.id);
      }), nfrList.length > MAX_SHOW ? /* @__PURE__ */ jsxs("div", {
        children: [/* @__PURE__ */ jsx("span", {
          children: `...\u7B49${nfrList.length - MAX_SHOW}\u4E2A`
        }), /* @__PURE__ */ jsx(Button$2, {
          type: "link",
          onClick: toggleShow,
          children: showAll ? "\u6536\u8D77" : "\u5C55\u5F00"
        })]
      }) : null]
    })]
  });
}
var index$2 = "";
const GUTTER = 24;
const LABEL_SPAN = 2;
const CONTENT_SPAN = 22;
function Transaction() {
  const {
    params
  } = useMatch("/transaction/:type");
  const {
    type: type4
  } = params;
  const dispatch2 = useDispatch();
  const {
    detail = {}
  } = useSelector((state2) => state2.transaction);
  react.exports.useEffect(() => {
    if (isEmptyObj(detail)) {
      dispatch2(asyncGetDetail(type4));
    }
    return () => {
      dispatch2(getInitState());
    };
  }, []);
  return /* @__PURE__ */ jsxs("div", {
    className: "transaction-detail",
    children: [/* @__PURE__ */ jsxs("div", {
      className: "title-wrap",
      children: [/* @__PURE__ */ jsx("h3", {
        children: "\u4EA4\u6613\u54C8\u5E0C"
      }), /* @__PURE__ */ jsx("span", {
        children: detail.txnHash
      })]
    }), /* @__PURE__ */ jsxs("div", {
      className: "detail-wrap",
      children: [/* @__PURE__ */ jsx("h3", {
        className: "title",
        children: "\u4EA4\u6613\u8BE6\u60C5"
      }), /* @__PURE__ */ jsxs(Row$1, {
        gutter: GUTTER,
        children: [/* @__PURE__ */ jsx(Col$1, {
          className: "label",
          span: LABEL_SPAN,
          children: "\u53D1\u9001\u65B9"
        }), /* @__PURE__ */ jsx(Col$1, {
          span: CONTENT_SPAN,
          children: /* @__PURE__ */ jsx(CopyText, {
            text: `${detail.fromAddress}`,
            children: /* @__PURE__ */ jsx(Link, {
              to: `/walletDetail/${detail.fromAddress}`,
              children: detail.fromAddress
            })
          })
        })]
      }), /* @__PURE__ */ jsxs(Row$1, {
        gutter: GUTTER,
        children: [/* @__PURE__ */ jsx(Col$1, {
          className: "label",
          span: LABEL_SPAN,
          children: "\u63A5\u6536/\u4EA4\u4E92\u65B9"
        }), /* @__PURE__ */ jsx(Col$1, {
          span: CONTENT_SPAN,
          children: /* @__PURE__ */ jsx(CopyText, {
            text: `${detail.toAddress}`,
            children: /* @__PURE__ */ jsx(Link, {
              to: `/contract/${detail.toAddress}`,
              children: detail.toAddress
            })
          })
        })]
      }), /* @__PURE__ */ jsxs(Row$1, {
        gutter: GUTTER,
        children: [/* @__PURE__ */ jsx(Col$1, {
          className: "label",
          span: LABEL_SPAN,
          children: "\u533A\u5757\u9AD8\u5EA6"
        }), /* @__PURE__ */ jsx(Col$1, {
          span: CONTENT_SPAN,
          children: /* @__PURE__ */ jsx(Link, {
            to: `/blockHeight/${detail.blockHeight}`,
            children: `# ${detail.blockHeight}`
          })
        })]
      }), /* @__PURE__ */ jsxs(Row$1, {
        gutter: GUTTER,
        children: [/* @__PURE__ */ jsx(Col$1, {
          className: "label",
          span: LABEL_SPAN,
          children: "\u4EA4\u6613\u7ED3\u679C"
        }), /* @__PURE__ */ jsx(Col$1, {
          span: CONTENT_SPAN,
          children: /* @__PURE__ */ jsx(TransResult, {
            toAddress: detail.toAddress,
            method: detail.method,
            nfrList: detail == null ? void 0 : detail.nfrList
          })
        })]
      }), /* @__PURE__ */ jsxs(Row$1, {
        gutter: GUTTER,
        children: [/* @__PURE__ */ jsx(Col$1, {
          className: "label",
          span: LABEL_SPAN,
          children: "\u7C7B\u578B"
        }), /* @__PURE__ */ jsx(Col$1, {
          span: CONTENT_SPAN,
          children: detail.type
        })]
      }), /* @__PURE__ */ jsxs(Row$1, {
        gutter: GUTTER,
        children: [/* @__PURE__ */ jsx(Col$1, {
          className: "label",
          span: LABEL_SPAN,
          children: "\u4EA4\u6613\u624B\u7EED\u8D39"
        }), /* @__PURE__ */ jsx(Col$1, {
          span: CONTENT_SPAN,
          children: detail.transFee
        })]
      })]
    })]
  });
}
Transaction.getInitialProps = () => {
  return [asyncGetDetail()];
};
const BLOCK_TYPE = "recentBlock";
const TRANS_TYPE = "recentTrans";
const PAGE_CONFIG = {
  [BLOCK_TYPE]: {
    title: "\u6700\u8FD1\u51FA\u5757",
    tableColumns: [{
      title: "\u533A\u5757\u9AD8\u5EA6",
      dataIndex: "blockHeight",
      render: (text2) => {
        return /* @__PURE__ */ jsx(Link, {
          to: `/blockHeight/${text2}`,
          children: text2
        });
      }
    }, {
      title: "\u65F6\u95F4",
      dataIndex: "createTime"
    }, {
      title: "\u51FA\u5757\u8282\u70B9",
      dataIndex: "miner",
      render: (text2) => /* @__PURE__ */ jsx(Popover$1, {
        content: text2,
        children: /* @__PURE__ */ jsx(Link, {
          to: `/walletDetail/${text2}`,
          children: overLenTextShow(text2)
        })
      })
    }, {
      title: "\u4EA4\u6613\u6BD4\u6570",
      dataIndex: "transactions",
      render: (transactions) => (transactions || []).length
    }]
  },
  [TRANS_TYPE]: {
    title: "\u6700\u8FD1\u4EA4\u6613",
    tableColumns: [{
      title: "\u533A\u5757\u9AD8\u5EA6",
      dataIndex: "blockHeight",
      render: (text2) => {
        return /* @__PURE__ */ jsx(Link, {
          to: `/blockHeight/${text2}`,
          children: text2
        });
      }
    }, {
      title: "\u65F6\u95F4",
      dataIndex: "createTime"
    }, {
      title: "\u4EA4\u6613\u54C8\u5E0C",
      dataIndex: "txnHash",
      render: (text2) => /* @__PURE__ */ jsx(Popover$1, {
        content: text2,
        children: /* @__PURE__ */ jsx(Link, {
          to: `/transaction/${text2}`,
          children: overLenTextShow(text2)
        })
      })
    }, {
      title: "\u53D1\u9001\u65B9",
      dataIndex: "fromAddress",
      render: (text2) => /* @__PURE__ */ jsx(Popover$1, {
        content: text2,
        children: /* @__PURE__ */ jsx(Link, {
          to: `/walletDetail/${text2}`,
          children: overLenTextShow(text2)
        })
      })
    }, {
      title: "\u63A5\u6536\u65B9",
      dataIndex: "toAddress",
      render: (text2) => /* @__PURE__ */ jsx(Popover$1, {
        content: text2,
        children: /* @__PURE__ */ jsx(NavigateAddress, {
          address: text2
        })
      })
    }, {
      title: "\u7C7B\u578B",
      dataIndex: "methodName"
    }, {
      title: "NFR",
      dataIndex: "nfrList",
      render(nfrList = []) {
        if (nfrList.length === 1) {
          const nfr = nfrList[0];
          return /* @__PURE__ */ jsx(Link, {
            to: `/nfrDetail/${nfr.id}`,
            children: nfr.name
          });
        }
        return "--";
      }
    }, {
      title: "NFRID",
      dataIndex: "nfrList",
      render(nfrList = []) {
        if (nfrList.length === 1) {
          const nfr = nfrList[0];
          return /* @__PURE__ */ jsx(Link, {
            to: `/nfrDetail/${nfr.id}`,
            children: nfr.id
          });
        }
        return "--";
      }
    }]
  }
};
var index$1 = "";
function RecentInfo() {
  const {
    params
  } = useMatch("/recentInfo/:type");
  const dispatch2 = useDispatch();
  const {
    list = [],
    pageInfo
  } = useSelector((state2) => state2.recentInfo);
  const pageType = params.type || BLOCK_TYPE;
  react.exports.useEffect(() => {
    console.log(list);
    if (list.length) {
      dispatch2(asyncGetPageList$4(pageType));
    }
    return () => {
      dispatch2(getInitState$5());
    };
  }, []);
  const pageChange = react.exports.useCallback((page, pageSize) => {
    dispatch2(changTable$4(page, pageSize, pageType));
  }, []);
  return /* @__PURE__ */ jsxs("div", {
    className: "recent-info",
    children: [/* @__PURE__ */ jsx("div", {
      className: "common-search",
      children: /* @__PURE__ */ jsx(CommonSearch, {
        borderd: true
      })
    }), /* @__PURE__ */ jsx("h3", {
      className: "title",
      children: PAGE_CONFIG[pageType].title
    }), /* @__PURE__ */ jsx(Table$1, {
      dataSource: list,
      pagination: {
        total: pageInfo.totalElements,
        current: pageInfo.pageStart,
        pageSize: pageInfo.pageSize,
        onChange: pageChange
      },
      columns: PAGE_CONFIG[pageType].tableColumns,
      rowClassName: "editable-row"
    })]
  });
}
RecentInfo.getInitialProps = () => {
  return [asyncGetPageList$4()];
};
var routeConfig = [
  { path: "home", PageComponent: Home },
  { path: "recentInfo/:type", PageComponent: RecentInfo },
  { path: "blockHeight/:type", PageComponent: BlockHeight },
  { path: "nfrDetail/:type", PageComponent: NfrDetail },
  { path: "contractDetail/:type", PageComponent: ContractDetail },
  { path: "walletDetail/:type", PageComponent: WalletDetail },
  { path: "transaction/:type", PageComponent: Transaction },
  { path: "*", PageComponent: Home }
];
var index = "";
const store = getClientStore();
reactDom.exports.hydrate(/* @__PURE__ */ jsx(BrowserRouter, {
  children: /* @__PURE__ */ jsx(Provider$1, {
    store,
    children: /* @__PURE__ */ jsx(Layout, {
      routes: routeConfig
    })
  })
}), document.getElementById("root"));
